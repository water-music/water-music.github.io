<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><link rel="canonical" href="http://example.com/2022/10/05/computer-systems-a-programmer's-perspective-3e-chpt-2/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/10/05/computer-systems-a-programmer's-perspective-3e-chpt-2/","path":"2022/10/05/computer-systems-a-programmer's-perspective-3e-chpt-2/","title":"《深入理解计算机系统 第3版》第2章 信息的表示与处理"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《深入理解计算机系统 第3版》第2章 信息的表示与处理 |</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8"><span class="nav-text">2.1 信息存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6"><span class="nav-text">2.1.1 数据长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80%E5%92%8C%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F"><span class="nav-text">2.1.2 寻址和字节顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E7%AE%80%E4%BB%8B"><span class="nav-text">2.1.3 布尔代数简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3%E6%94%AF%E6%8C%81"><span class="nav-text">2.1.4 C语言相关支持</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E8%A1%A8%E7%A4%BA"><span class="nav-text">2.2 整数表示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">2.2.1 整型数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A0%81"><span class="nav-text">2.2.2 编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">2.2.3 有符号数和无符号数的转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E6%95%B0%E7%9A%84%E4%BD%8D%E8%A1%A8%E7%A4%BA"><span class="nav-text">2.2.4 扩展数的位表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%AA%E6%96%AD%E6%95%B0%E5%80%BC"><span class="nav-text">2.2.5 截断数值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97"><span class="nav-text">2.3 整数运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E8%BF%90%E7%AE%97"><span class="nav-text">2.3.1 无符号运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E8%BF%90%E7%AE%97"><span class="nav-text">2.3.2 有符号运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%A4%E4%BB%A52%E7%9A%84%E5%B9%82"><span class="nav-text">2.3.3 除以2的幂</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%99%A4%E4%BB%A52%E7%9A%84%E5%B9%82"><span class="nav-text">2.3.3.1 无符号数除以2的幂</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%99%A4%E4%BB%A52%E7%9A%84%E5%B9%82"><span class="nav-text">2.3.3.2 有符号数除以2的幂</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="nav-text">2.4 浮点数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B0%8F%E6%95%B0"><span class="nav-text">2.4.1 二进制小数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ieee%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA"><span class="nav-text">2.4.2 IEEE浮点表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97"><span class="nav-text">2.4.3 浮点运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3%E6%94%AF%E6%8C%81-1"><span class="nav-text">2.4.4 C语言相关支持</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/10/05/computer-systems-a-programmer's-perspective-3e-chpt-2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《深入理解计算机系统 第3版》第2章 信息的表示与处理 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《深入理解计算机系统 第3版》第2章 信息的表示与处理</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-10-05 00:00:00" itemprop="dateCreated datePublished" datetime="2022-10-05T00:00:00+08:00">2022-10-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-03-31 00:00:00" itemprop="dateModified" datetime="2023-03-31T00:00:00+08:00">2023-03-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/computer-system/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>22k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　使用了1000多年的十进制源自印度，12世纪被阿拉伯数学家改进并在13世纪被意大利数学家Leonardo Pisano (即Fibonacci) 带到西方。对于10个手指头的人类而言，十进制很自然。但是，现代计算机存储和处理的信息都是用二进制 (称为<strong>位</strong>) 表示，因为二进制更容易被表示、存储和传输，例如，高电压和低电压。</p><p>　　单个位并不是很有用，当把位组合在一起并附加上<strong>解释</strong>来给不同的位模式赋予意义时，可以表示任何有限集合中的元素。</p><p>　　<strong>无符号</strong>编码基于传统的二进制表示法，表示大于等于0的数字。<strong>补码</strong>编码是表示有符号整数 (有正负) 的最常见的方式。<strong>浮点</strong>编码是以2为基数的科学计数法版本，用于表示实数。</p><p>　　计算机的表示法使用有限数量的位来编码，所以当结果太大时以至于不能表示时，某些运算可能<strong>溢出</strong>。溢出可能会导致奇怪的结果，例如，对于<code>int</code>是32位的计算机，C语言有<span class="math inline">\(200\times300\times400\times500=-884901888\)</span>。</p><p>　　计算机的整数运算满足数学中整数运算的许多属性，例如，乘法的结合律和交换律。计算机的浮点运算具有完全不同的数学属性。正数之间的乘积始终为正，尽管溢出时会产生特殊值<span class="math inline">\(+\infty\)</span>。由于表示的精度有限，浮点运算不是不可结合的，例如，大多数计算机上，C语言有<span class="math inline">\((3.14+10^{20})-10^{20}=0.0\)</span>。整数与浮点算术的不同数学属性源于其CPU表示的有限性的方式不同，整数是精确的，但表示的值范围较小；浮点是近似的，但表示的值范围较大。</p><p>　　在20世纪80年代前，计算机制造商都会设计自己的浮点数表示规则以及相关运算细节，它们都更注重实现的速度和简便而非精确。在1985年，这些随着IEEE 754的出现而发生了变化，IEEE 754是精心设计的标准，用于表示浮点数以及其执行的操作。这些工作始于1976年，开始由Intel赞助，与8087 (为8086 CPU提供浮点支持的芯片) 的设计同时进行。Intel聘请加州大学伯克利分校的教授William Kahan作为顾问，帮助其为未来的CPU设计浮点标准。Intel允许Kahan与委员会合作，在IEEE的主持下制定行业标准。委员会最终采用的标准很接近Kahan为Intel设计的标准。</p><p>　　ASCII字符集适合对英语文档进行编码，但不支持特殊字符 (希腊语、俄语和中文等)。多年来，出现了很多对不同语言进行编码的方法。Unicode联盟设计了最全面和最广泛的文本编码标准，7.0版本的Unicode标准的拥有超过100000个字符，支持多种语言，包括古埃及语和巴比伦语。Unicode技术委员会否决了为克林贡语编写语言标准的提议。</p><p>　　基本编码称为Unicode的通用字符集使用32位表示字符，这似乎要求文本中的每个字符占用4B，另一种编码方案是常见字符仅需1B或2B，而不太常见的字符需要更多字节。例如，UTF-8的表示形式将每个字符编码为字节序列，所有ASCII字节序列用ASCII表示和UTF-8表示相同。Java使用Unicode表示字符串，C语言也有支持Unicode的库。</p><p>　　由于二进制是计算机编码、存储和操作信息的核心，所以围绕0和1的研究已演化出了丰富的数学知识体系，这源自1850年左右的George Boole (1815-1864) 的工作，所以称为<strong>布尔代数</strong>。Boole观察到，将逻辑值TRUE和FALSE编码为二进制值0和1，可以制定1种包含逻辑推理基本原理的代数。</p><p>　　ISO C99在头文件<code>stdint.h</code>中加入了固定长度的整数类型，其声明类似<code>intN_t</code>和<code>uintN_t</code>，其中<code>N</code>表示<span class="math inline">\(N\)</span>位的有符号和无符号整数，<code>N</code>的具体值与实现有关，但大多数编译器允许的值为8、16、32和64。这些整数类型有一组对应的宏，即<code>INTN_MIN</code>、<code>INTN_MAX</code>和<code>UINTN_MAX</code>。</p><span id="more"></span><h3 id="信息存储">2.1 信息存储</h3><p>　　大多数计算机将<span style="background-color:#ff0">字节</span>作为最小的可寻址内存单元。应用程序将内存视为很大的字节数组，称为<strong>虚拟内存</strong>。内存的每个字节都由唯一的数字标识，称为<strong>地址</strong>，所有可能的地址集称为<strong>虚拟地址空间</strong>。</p><p>　　相比二进制和十进制，<span style="background-color:#ff0">十六进制</span>更适合描述位模式，因为它比较精简且无需转换。</p><table><thead><tr><th>二进制</th><th>十进制</th><th>十六进制</th></tr></thead><tbody><tr><td>0000</td><td>0</td><td>0</td></tr><tr><td>0001</td><td>1</td><td>1</td></tr><tr><td>0010</td><td>2</td><td>2</td></tr><tr><td>0011</td><td>3</td><td>3</td></tr><tr><td>0100</td><td>4</td><td>4</td></tr><tr><td>0101</td><td>5</td><td>5</td></tr><tr><td>0110</td><td>6</td><td>6</td></tr><tr><td>0111</td><td>7</td><td>7</td></tr><tr><td>1000</td><td>8</td><td>8</td></tr><tr><td>1001</td><td>9</td><td>9</td></tr><tr><td>1010</td><td>10</td><td>A</td></tr><tr><td>1011</td><td>11</td><td>B</td></tr><tr><td>1100</td><td>12</td><td>C</td></tr><tr><td>1101</td><td>13</td><td>D</td></tr><tr><td>1110</td><td>14</td><td>E</td></tr><tr><td>1111</td><td>15</td><td>F</td></tr></tbody></table><p>　　在C语言中，十六进制以<code>0x</code>和<code>0X</code>开头，字符<code>A</code>~<code>F</code>大小写不限。</p><h4 id="数据长度">2.1.1 数据长度</h4><p>　　每个计算机都有<strong>字长</strong>，表示指针的标称大小。虚拟地址以这样的字来编码，所以字长决定虚拟地址空间的范围。对于字长为<span class="math inline">\(w\)</span>位的计算机，虚拟地址的范围是<span class="math inline">\(0\sim2^w-1\)</span>。32位虚拟地址空间为4GB，64位虚拟地址空间为16EB。</p><p>　　32位程序和64位程序的区别是编译过程。大多数64位计算机可以兼容32位程序。</p><p>　　计算机和编译器支持多种不同方法编码的数据格式，例如，不同长度的整数和浮点数。C语言中某些数据类型字节数取决于程序的编译方式。整数可以是<strong>有符号</strong> (有正负) 或<strong>无符号</strong> (非负)，关键字分别是<code>signed</code>和<code>unsigned</code>。大多数计算机支持单精度和双精度浮点数，长度分别是4B和8B。</p><table><thead><tr><th>有符号 (C语言)</th><th>无符号 (C语言)</th><th>字节数 (32位)</th><th>字节数 (64位)</th></tr></thead><tbody><tr><td><code>[signed] char</code></td><td><code>unsigned char</code></td><td>1</td><td>1</td></tr><tr><td><code>short</code></td><td><code>unsigned short</code></td><td>2</td><td>2</td></tr><tr><td><code>int</code></td><td><code>unsigned</code></td><td>4</td><td>4</td></tr><tr><td><code>long</code></td><td><code>unsigned long</code></td><td>4</td><td>8</td></tr><tr><td><code>int32_t</code></td><td><code>uint32_t</code></td><td>4</td><td>4</td></tr><tr><td><code>int64_t</code></td><td><code>uint64_t</code></td><td>8</td><td>8</td></tr><tr><td><code>T *</code></td><td></td><td>4</td><td>8</td></tr><tr><td><code>float</code></td><td></td><td>4</td><td>4</td></tr><tr><td><code>double</code></td><td></td><td>8</td><td>8</td></tr></tbody></table><p>　　大多数数据类型都会编码为有符号，除非使用关键字<code>unsigned</code>或固定大小数据类型的特定无符号声明。但是，<code>char</code>是例外，大多数计算机和编译器都将<code>char</code>编码为有符号，但C语言标准不保证这一点。当使用<code>char</code>存储长度是1B的数据时，应使用关键字<code>signed</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> l1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> l2;</span><br><span class="line"><span class="type">long</span> <span class="type">unsigned</span> l3;</span><br><span class="line"><span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span> l4;</span><br></pre></td></tr></table></figure><p>　　C语言允许多种方式来对关键字进行排序以及省略可选关键字，这里<code>l1</code>、<code>l2</code>、<code>l3</code>和<code>l4</code>意义相同。</p><p>　　对不同数据类型的确切大小不敏感是程序的可移植性的方面之一。C语言标准对不同数据类型的范围设置了下限但没有设置上限。当32位程序迁移到64位程序时，很多隐藏的字长依赖项会作为错误出现，例如，32位程序中<code>int</code>类型的对象可用于存储指针，但这并不适用于64位程序。</p><h4 id="寻址和字节顺序">2.1.2 寻址和字节顺序</h4><p>　　对于包含多个字节的程序对象，必须确定对象的地址以及字节在内存中的顺序。在几乎所有计算机中，多字节对象都存储为连续的字节序列，对象的地址是所使用字节中的最小地址。若<code>int</code>类型 (32位) 的变量<code>x</code>的地址为<code>0x100</code>，即地址表达式<code>&amp;x</code>的值是<code>0x100</code>，则<code>x</code>的4个字节存储在内存位置<code>0x100</code>、<code>0x101</code>、<code>0x102</code>和<code>0x103</code>。</p><img src="/2022/10/05/computer-systems-a-programmer's-perspective-3e-chpt-2/big_endian_and_little_endian.svg" title="big_endian_and_little_endian"><p>　　以<code>w</code>位的整数为例，其位表示为<span class="math inline">\([x_{w-1},x_{w-2},\cdots,x_1,x_0]\)</span>，其中<span class="math inline">\(x_{w-1}\)</span>是最高有效位，<span class="math inline">\(x_0\)</span>是最低有效位。若<span class="math inline">\(w\)</span>是8的倍数，则这些位可以分组为字节，其中最高有效字节包含位<span class="math inline">\([x_{w-1},x_{w-2},\cdots ,x_{w-8}]\)</span>，而最低有效字节包含位<span class="math inline">\([x_7,x_6,\cdots ,x_0]\)</span>，其他字节包含中间的位。某些计算机按从低 (有效) 字节到高 (有效) 字节的顺序存储对象，其他计算机从高 (有效) 字节到低 (有效) 字节的顺序存储对象。前者称为<strong>小端</strong>，后者称为<strong>大端</strong>。大多数与Intel兼容的计算机仅支持小端模式，IBM和Oracle的大多数计算机仅支持大端模式。部分CPU是<strong>双端</strong>，即支持这2种模式。实际中，一旦选择了操作系统，字节顺序就会固定，例如，许多手机使用的ARM CPU是双端，但Android和IOS仅支持小端模式。</p><p>　　对于大多数应用程序程序员，计算机使用的字节顺序是完全不可见的。无论为哪种类型的计算机所编译的程序，都会得到相同的结果，但有时字节顺序会成为问题。</p><p>　　● 当二进制数据通过网络在不同计算机之间通信时，若计算机的字节顺序不同，接收端和发送端的字节相反。为了避免此类问题，TCP/IP定义了<strong>网络字节顺序</strong>，即通过网络传输的数据必须是大端。</p><p>　　● 阅读表示整数数据的字节序列时字节顺序很重要。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4004d3:	01 05 43 0b 20 00	add	%eax,0x200b43(%rip)</span><br></pre></td></tr></table></figure><p>　　这是Intel x86-64 CPU的机器级代码的文本表示，由反汇编器生成，<strong>反汇编器</strong>是确定可执行文件对应的指令序列的工具。十六进制字节序列<code>01 05 43 0b 20 00</code>是一条指令的字节级表示形式，该指令会将单字长的数据加到某个值上，该值的存储地址由<code>0x200b43</code>加上当前PC的值 (待执行的下一指令的地址) 得到。若将序列的最后4个字节<code>43 0b 20 00</code>转换为小端，则得到<code>00 20 0b 43</code>，去掉开头作为填充的0，得到值<code>0x200b43</code>。</p><p>　　● 在编写绕过数据类型系统的程序时字节排序很重要。C语言中，可以通过使用<strong>强制类型转换</strong>和<strong>联合</strong>来允许一种数据类型引用一个对象，但该数据类型与创建该对象时定义的数据类型不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印对象的字节表示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param start 对象指针</span></span><br><span class="line"><span class="comment"> * @param len 对象长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_bytes</span><span class="params">(byte_pointer start, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %.2x&quot;</span>, start[i]); <span class="comment">/* 至少用2个数字的十六进制格式输出 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印int的字节表示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_int</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印float的字节表示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_float</span><span class="params">(<span class="type">float</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印指针的字节表示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_pointer</span><span class="params">(<span class="type">void</span> *x)</span></span><br><span class="line">&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 测试函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param val</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_show_bytes</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ival = val;</span><br><span class="line">    <span class="type">float</span> fval = (<span class="type">float</span>)ival;</span><br><span class="line">    <span class="type">int</span> *pval = &amp;ival;</span><br><span class="line">    show_int(ival);</span><br><span class="line">    show_float(fval);</span><br><span class="line">    show_pointer(pval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　若参数为<code>12345</code>，对应的十六进制是<code>0x00003039</code>，Linux和Windows都是小端，Windows 64的输出是<code>39 30 00 00</code>、<code>00 e4 40 46</code>以及<code>4c fb 9f e4 9f 00 00 00</code>。<code>int</code>和<code>float</code>的字节模式看似不同，将其转换为二进制后会发现会有13个匹配的位序列。指针值根据不同的计算机或操作系统配置的存储分配规则分配。</p><p>　　C语言中的字符串以<code>null</code>字符 (值为0) 结尾的字符数组编码。以ASCII为例，若以参数<code>"12345"</code>和<code>6</code>来运行函数<code>show_bytes()</code>，则可以得到结果<code>31 32 33 34 35 00</code>。十进制数字<code>n</code>的ASCII码值是<code>0x0n</code>，<code>null</code>的ASCII码值为<code>0x00</code>。ASCII在任何系统上都可以获得相同的结果，与字节顺序和字长无关。因此，文本数据比二进制数据更具有平台独立性。</p><h4 id="布尔代数简介">2.1.3 布尔代数简介</h4><img src="/2022/10/05/computer-systems-a-programmer's-perspective-3e-chpt-2/operations_of_boolean_algebra.svg" title="operations_of_boolean_algebra"><p>　　最简单的布尔代数是在双元集合<span class="math inline">\(\{0,1\}\)</span>上定义。布尔运算~表示逻辑运算非，用<span class="math inline">\(\lnot\)</span>表示。布尔运算&amp;表示逻辑运算与，用<span class="math inline">\(\land\)</span>表示。布尔运算|表示逻辑运算或，用<span class="math inline">\(\lor\)</span>表示。布尔运算^表示逻辑运算异或，用<span class="math inline">\(\oplus\)</span>表示。</p><p>　　布尔运算也适用于<strong>位向量</strong> (长度为<span class="math inline">\(w\)</span>，由0和1组成的序列)。若<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>分别表示位向量<span class="math inline">\([a_{w-1},a_{w-2},\cdots ,a_0]\)</span>和<span class="math inline">\([b_{w-1},b_{w-2},\cdots ,b_0]\)</span>，则<span class="math inline">\(a\)</span>&amp;<span class="math inline">\(b\)</span>可以定义为长度为<span class="math inline">\(w\)</span>的位向量，其中第<span class="math inline">\(i\)</span>个元素等于<span class="math inline">\(a_i\)</span>&amp;<span class="math inline">\(b_i\)</span>，类似的方法可以扩展到|、~和^上。</p><p>　　对于长度为<span class="math inline">\(2^w\)</span>的位向量，布尔代数和整数算术有很多相似之处。类似乘法对加法的分配律，&amp;和|相互都有分配律，即<span class="math inline">\(a\)</span>&amp;<span class="math inline">\((b\)</span>|<span class="math inline">\(c)=(a\)</span>&amp;<span class="math inline">\(b)|(a\)</span>&amp;<span class="math inline">\(c)\)</span>和<span class="math inline">\(a\)</span>|<span class="math inline">\((b\)</span>&amp;<span class="math inline">\(c)=(a\)</span>|<span class="math inline">\(b)\)</span>&amp;<span class="math inline">\((a\)</span>|<span class="math inline">\(c)\)</span>。</p><p>　　对位向量进行布尔运算会得到<strong>布尔环</strong>。布尔环由<strong>幂等元</strong>组成 (所有元素都满足<span class="math inline">\(x^2=x\)</span>)，布尔环与整数算术有很多相似之处，例如，整数算术的属性之一是是每个值<span class="math inline">\(n\)</span>都有1个<strong>加法逆元</strong><span class="math inline">\(-n\)</span>，使得<span class="math inline">\(n+-n=0\)</span>。</p><p>　　位向量可用于表示有限集合，即用位向量<span class="math inline">\([a_{w-1},a_{w-2},\cdots ,a_0]\)</span>对任何子集<span class="math inline">\(A\subseteq\{0,1,\cdots ,w-1\}\)</span>编码，当<span class="math inline">\(i\in A\)</span>时，<span class="math inline">\(a_i=1\)</span>。若<span class="math inline">\(a_{w-1}\)</span>在左边，<span class="math inline">\(a_0\)</span>在右边，则位向量<span class="math inline">\(a=[01101001]\)</span>表示集合<span class="math inline">\(A=\{0,3,5,6\}\)</span>，而<span class="math inline">\(b=[01010101]\)</span>表示集合<span class="math inline">\(B=\{0,2,4,6\}\)</span>。使用这种编码集合的方式时，布尔运算|、&amp;和~分别表示交集、并集和补集。若<span class="math inline">\(a\)</span>&amp;<span class="math inline">\(b\)</span>得到位向量<span class="math inline">\([0100001]\)</span>，则<span class="math inline">\(A\cap B=\{0,6\}\)</span>。</p><h4 id="c语言相关支持">2.1.4 C语言相关支持</h4><p>　　C语言支持布尔运算，其符号也是<code>~</code>、<code>&amp;</code>、<code>|</code>和<code>^</code>，能用于所有整型数。</p><p>　　位级运算可用于<strong>掩码</strong>运算，掩码属于位模式，表示字中部分位的位模式，例如，掩码<code>0xFF</code>表示字中的低位字节。<code>n &amp; 0xFF</code>会得到低位字节是<code>n</code>的低位字节，其他值全为0的结果。<code>~0</code>会得到值全为1的掩码。</p><p>　　C语言也提供了逻辑运算符<code>||</code>、<code>&amp;&amp;</code>和<code>!</code>，分别对应逻辑或、与和非运算。</p><p>　　C语言还支持<strong>移位</strong>运算，用于向左和向右移动位模式。对于位模式为<span class="math inline">\([x_{w-1},x_{w-2},\cdots ,x_0]\)</span>的操作数<code>x</code>，<code>x &lt;&lt; k</code>的结果的位模式是<span class="math inline">\([x_{w-k-1},x_{w-k-w},\cdots ,x_0,0,\cdots ,0]\)</span>，即<code>x</code>向左移动<span class="math inline">\(k\)</span>位，丢弃最高<span class="math inline">\(k\)</span>位并在右端补<span class="math inline">\(k\)</span>个0。显然，偏移量应该介于0和<span class="math inline">\(w-1\)</span>之间。移位操作从左到右执行，故<code>x &lt;&lt; j &lt;&lt; k</code>等效于<code>(x &lt;&lt; j) &lt;&lt; k</code>。</p><p>　　计算机通常支持<strong>逻辑右移</strong>和<strong>算术右移</strong>。对于<code>x &gt;&gt; k</code>，逻辑右移类似于右移，会直接在左端补<span class="math inline">\(k\)</span>个0。算术右移会在左端补<span class="math inline">\(k\)</span>个最高有效位的值，即<span class="math inline">\([x_{w-1},\cdots ,x_{w-1},x_{w-1},x_{w-2},\cdots x_k]\)</span>，主要用于有符号数。</p><table><thead><tr><th>操作</th><th>值1</th><th>值2</th></tr></thead><tbody><tr><td><code>x</code></td><td>[01100011]</td><td>[10010101]</td></tr><tr><td><code>x &lt;&lt; 4</code></td><td>[0011<strong>0000</strong>]</td><td>[0101<strong>0000</strong>]</td></tr><tr><td><code>x &gt;&gt; 4</code> (逻辑右移)</td><td>[<strong>0000</strong>0011]</td><td>[<strong>0000</strong>1001]</td></tr><tr><td><code>x &gt;&gt; 4</code> (算术右移)</td><td>[<strong>0000</strong>0011]</td><td>[<strong>1111</strong>1001]</td></tr></tbody></table><p>　　C语言标准并未定义有符号数应使用的右移类型。实际中，几乎所有编译器和计算机会对有符号数使用算术右移，对无符号数使用逻辑右移。对于<span class="math inline">\(w\)</span>位的数据类型，移动<span class="math inline">\(k(k\geqslant w)\)</span>位，实际位移量为<span class="math inline">\(k\bmod w\)</span>。</p><h3 id="整数表示">2.2 整数表示</h3><p>　　数学术语<strong>双射</strong>指函数<span class="math inline">\(f\)</span>有2种映射方式，可以将数字<span class="math inline">\(x\)</span>映射为数值<span class="math inline">\(y\)</span>，即<span class="math inline">\(y=f(x)\)</span>，也可以反向操作，因为对于每个<span class="math inline">\(y\)</span>都有唯一的<span class="math inline">\(x\)</span>满足<span class="math inline">\(f(x)=y\)</span>，这通过<strong>反函数</strong><span class="math inline">\(f^{-1}\)</span>来表示，即<span class="math inline">\(x=f^{-1}(y)\)</span>。</p><table><thead><tr><th>符号</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td><span class="math inline">\(B2T_w\)</span></td><td>函数</td><td>二进制转补码</td></tr><tr><td><span class="math inline">\(B2U_w\)</span></td><td>函数</td><td>二进制转无符号数</td></tr><tr><td><span class="math inline">\(U2B_w\)</span></td><td>函数</td><td>无符号数转二进制</td></tr><tr><td><span class="math inline">\(U2T_w\)</span></td><td>函数</td><td>无符号数转补码</td></tr><tr><td><span class="math inline">\(T2B_w\)</span></td><td>函数</td><td>补码转二进制</td></tr><tr><td><span class="math inline">\(T2U_w\)</span></td><td>函数</td><td>补码转无符号数</td></tr><tr><td><span class="math inline">\(TMin_w\)</span></td><td>常数</td><td>最小补码值</td></tr><tr><td><span class="math inline">\(TMax_w\)</span></td><td>常数</td><td>最大补码值</td></tr><tr><td><span class="math inline">\(UMax_w\)</span></td><td>常数</td><td>最大无符号数</td></tr><tr><td><span class="math inline">\(+^t_w\)</span></td><td>操作符</td><td>补码加法</td></tr><tr><td><span class="math inline">\(+^u_w\)</span></td><td>操作符</td><td>无符号数加法</td></tr><tr><td><span class="math inline">\(*^t_w\)</span></td><td>操作符</td><td>补码乘法</td></tr><tr><td><span class="math inline">\(*^u_w\)</span></td><td>操作符</td><td>无符号数乘法</td></tr><tr><td><span class="math inline">\(-^t_w\)</span></td><td>操作符</td><td>补码取反</td></tr><tr><td><span class="math inline">\(-^u_w\)</span></td><td>操作符</td><td>无符号数取反</td></tr></tbody></table><p>　　有符号数和无符号数之间转换可能导致错误或漏洞，解决方法之一是尽量不使用无符号数。但是，无符号数并非一无是处，在表示布尔类型时很有用，ISO C99在<code>&lt;stdbool.h&gt;</code>中加入的<code>bool</code>本质是<code>unsigned char</code>。</p><h4 id="整型数据类型">2.2.1 整型数据类型</h4><p>　　C语言支持多种整型数据类型，每种数据类型用<code>char</code>、<code>short</code>和<code>long</code>等关键字来指定大小，<span style="background-color:#ff0">默认</span>有符号数。</p><table><thead><tr><th style="text-align:left">C语言整型数据类型</th><th style="text-align:left">32位程序的取值范围</th><th style="text-align:left">64位程序的取值范围</th></tr></thead><tbody><tr><td style="text-align:left"><code>[signed] char</code></td><td style="text-align:left"><span class="math inline">\(-2^7\sim2^7-1\)</span></td><td style="text-align:left"><span class="math inline">\(-2^7\sim2^7-1\)</span></td></tr><tr><td style="text-align:left"><code>unsigned char</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^8-1\)</span></td><td style="text-align:left"><span class="math inline">\(0\sim2^8-1\)</span></td></tr><tr><td style="text-align:left"><code>short</code></td><td style="text-align:left"><span class="math inline">\(-2^{15}\sim2^{15}-1\)</span></td><td style="text-align:left"><span class="math inline">\(-2^{15}\sim2^{15}-1\)</span></td></tr><tr><td style="text-align:left"><code>unsigned short</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^{16}-1\)</span></td><td style="text-align:left"><span class="math inline">\(0\sim2^{16}-1\)</span></td></tr><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left"><span class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td><td style="text-align:left"><span class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td></tr><tr><td style="text-align:left"><code>unsigned</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^{32}-1\)</span></td><td style="text-align:left"><span class="math inline">\(0\sim2^{32}-1\)</span></td></tr><tr><td style="text-align:left"><code>long</code></td><td style="text-align:left"><span class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td><td style="text-align:left"><span class="math inline">\(-2^{63}\sim2^{63}-1\)</span></td></tr><tr><td style="text-align:left"><code>unsigned long</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^{32}-1\)</span></td><td style="text-align:left"><span class="math inline">\(0\sim2^{64}-1\)</span></td></tr><tr><td style="text-align:left"><code>int32_t</code></td><td style="text-align:left"><span class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td><td style="text-align:left"><span class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td></tr><tr><td style="text-align:left"><code>uint32_t</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^{32}-1\)</span></td><td style="text-align:left"><span class="math inline">\(0\sim2^{32}-1\)</span></td></tr><tr><td style="text-align:left"><code>int64_t</code></td><td style="text-align:left"><span class="math inline">\(-2^{63}\sim2^{63}-1\)</span></td><td style="text-align:left"><span class="math inline">\(-2^{63}\sim2^{63}-1\)</span></td></tr><tr><td style="text-align:left"><code>uint64_t</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^{64}-1\)</span></td><td style="text-align:left"><span class="math inline">\(0\sim2^{64}-1\)</span></td></tr></tbody></table><p>　　C语言标准定义了每种整型数据类型的最小取值范围，其中有符号正数和负数的取值范围是对称的。对于有符号整型数，负数的取值范围比正数的大1。<code>int</code>的长度可以是2B，<code>long</code>的长度可以是4B。</p><table><thead><tr><th style="text-align:left">C语言整型数据类型</th><th style="text-align:left">C语言标准定义的最小取值范围</th></tr></thead><tbody><tr><td style="text-align:left"><code>[signed] char</code></td><td style="text-align:left"><span class="math inline">\(-2^7+1\sim2^7-1\)</span></td></tr><tr><td style="text-align:left"><code>unsigned char</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^8-1\)</span></td></tr><tr><td style="text-align:left"><code>short</code></td><td style="text-align:left"><span class="math inline">\(-2^{15}+1\sim2^{15}-1\)</span></td></tr><tr><td style="text-align:left"><code>unsigned short</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^{16}-1\)</span></td></tr><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left"><span class="math inline">\(-2^{15}+1\sim2^{15}-1\)</span></td></tr><tr><td style="text-align:left"><code>unsigned</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^{16}-1\)</span></td></tr><tr><td style="text-align:left"><code>long</code></td><td style="text-align:left"><span class="math inline">\(-2^{31}+1\sim2^{31}-1\)</span></td></tr><tr><td style="text-align:left"><code>unsigned long</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^{32}-1\)</span></td></tr><tr><td style="text-align:left"><code>int32_t</code></td><td style="text-align:left"><span class="math inline">\(-2^{31}+1\sim2^{31}-1\)</span></td></tr><tr><td style="text-align:left"><code>uint32_t</code></td><td style="text-align:left"><span class="math inline">\(0\sim 2^{32}-1\)</span></td></tr><tr><td style="text-align:left"><code>int64_t</code></td><td style="text-align:left"><span class="math inline">\(-2^{63}+1\sim2^{63}-1\)</span></td></tr><tr><td style="text-align:left"><code>uint64_t</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^{64}-1\)</span></td></tr></tbody></table><p>　　C语言处理包含有符号数和无符号数组合的表达式时会将有符号数隐式转换为无符号数，例如，比较式<code>-1 &lt; 0U</code>，若两者都是32位，则<code>-1</code>将转换为<code>4294967295U</code>并返回<code>false</code>。</p><p>　　C语言中将位模式较短的有符号数转换为位模度较长的无符号数时，需要先进行符号扩展，再完成有符号到无符号的转换。</p><h4 id="编码">2.2.2 编码</h4><p>　　对于<span class="math inline">\(w\)</span>位的整数<span class="math inline">\(x\)</span>，其位向量表示为<span class="math inline">\(\vec{x}\)</span>。</p><p>　　将<span class="math inline">\(\vec{x}\)</span>视为二进制表示的数就可以得到<span class="math inline">\(\vec{x}\)</span>的无符号表示。在此编码中，每个位<span class="math inline">\(x_i\)</span>的值都为0或1，值为1表示<span class="math inline">\(2^i\)</span>应为数字值的一部分。 <span class="math display">\[ B2U_w(\vec{x})=\sum_{i=0}^{w-1}x_i2^i \]</span> 　　对于无符号数，<span class="math inline">\(\vec{x}\)</span>的最小值是位向量<span class="math inline">\([00\cdots 0]\)</span>，最大值是位向量<span class="math inline">\([11\cdots 1]\)</span>，其整数值<span class="math inline">\(UMax_w=2^w-1\)</span>，所以函数<span class="math inline">\(B2U_w\)</span>能定义为映射<span class="math inline">\(B2U_w:\{0,1\}^w\rightarrow\{0,\cdots ,UMax_w\}\)</span>。<span class="math inline">\(B2U_w\)</span>是双射，它能将每个长度为<span class="math inline">\(w\)</span>的位向量都映射到<span class="math inline">\(0\sim2^w-1\)</span>之间的1个唯一值，也能将<span class="math inline">\(0\sim2^w-1\)</span>之间的每个整数都可以映射到1个唯一的长度为<span class="math inline">\(w\)</span>的位模式 (即<span class="math inline">\(U2B_w\)</span>)。</p><p>　　在补码中，最高有效位解释为<strong>负权</strong>，也称为<strong>符号位</strong>，其权重为<span class="math inline">\(-2^{w-1}\)</span>。 <span class="math display">\[ B2T_w(\vec{x})=-x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i \]</span> 　　对于补码，<span class="math inline">\(\vec{x}\)</span>的最小值是位向量<span class="math inline">\([10\cdots 0]\)</span>，其整数值<span class="math inline">\(TMin_w=-2^{w-1}\)</span>，最大值是位向量<span class="math inline">\([01\cdots 1]\)</span>，其整数值<span class="math inline">\(TMax=2^{w-1}-1\)</span>，所以函数<span class="math inline">\(B2T_w\)</span>能定义为映射<span class="math inline">\(B2T_w:\{0,1\}^w\rightarrow\{TMin_w,\cdots ,TMax_w\}\)</span>。<span class="math inline">\(B2T_w\)</span>同样也是双射。</p><p>　　C语言标准并未要求有符号数以补码形式表示，但几乎所有计算机都是如此，但考虑到可移植性等因素，有符号数都默认补码。C语言库文件<code>&lt;limits.h&gt;</code>定义了一组常量来限定编译器运行的计算机的不同整数数据类型的取值范围，常量<code>INT_MAX</code>、<code>INT_MIN</code>和<code>UINT_MAX</code>来定义有 (有符号和无符号) <code>int</code>的取值范围。</p><p>　　有符号数的也能表示为<strong>反码</strong>，除了其最高有效位的权重是<span class="math inline">\(1-2^{w-1}\)</span>，其他与补码相同。 <span class="math display">\[ B2O_w(\vec{x})=-x_{w-1}(1-2^{w-1})+\sum_{i=0}^{w-2}x_i2^i \]</span> 　　有符号数的还能表示为<strong>原码</strong>，其最高有效位是符号位，用于确定其他位是负权或正权。 <span class="math display">\[ B2S_w(\vec{x})=(-1)^{x_{w-1}} \cdot(\sum_{i=0}^{w-2}x_i2^i) \]</span> 　　原码和反码都有一个奇怪的特性，即数字0有两种不同的编码，两者都将<span class="math inline">\([00\cdots 0]\)</span>解释为+0，前者将<span class="math inline">\([10\cdots 0]\)</span>解释为-0，后者将<span class="math inline">\([11\cdots 1]\)</span>解释为-0。</p><p>　　补码 (two's complement) 源于情况：对于非负<span class="math inline">\(x\)</span>，用<span class="math inline">\(2^w-x\)</span>计算<span class="math inline">\(-x\)</span>的<span class="math inline">\(w\)</span>位表示 (单个2)。反码 (ones' complement) 源于属性：用<span class="math inline">\([111\cdots 1]-x\)</span>计算<span class="math inline">\(-x\)</span>的反码表示 (多个1)。</p><h4 id="有符号数和无符号数的转换">2.2.3 有符号数和无符号数的转换</h4><p>　　C语言允许在不同的表示数字的数据类型之间转换，例如，从有符号数转换到无符号数，这种转换通常基于位而非数字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> v = <span class="number">-12345</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> uv = (<span class="type">unsigned</span> <span class="type">short</span>)v;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;v = %d, uv = %u\n&quot;</span>, v, uv); <span class="comment">/* v = -12345, uv = 53191 */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">-1</span>;</span><br><span class="line"><span class="type">unsigned</span> ui = (<span class="type">unsigned</span>)i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d, ui = %u\n&quot;</span>, i, ui); <span class="comment">/* i = -1, ui = 4294967295 */</span></span><br></pre></td></tr></table></figure><p>　　-12345的16位补码与53191的16位无符号表示相同，-1的32位补码也与4294967295的32位无符号表示相同。这是大多数C语言中相同字长的有符号数和无符号数之间转换的规则，即数值可能改变，但位模式不会变。给定一个整数<span class="math inline">\(x\)</span>，当<span class="math inline">\(x\)</span>满足<span class="math inline">\(0\leqslant x\leqslant UMax_w\)</span>时，函数<span class="math inline">\(U2B_w(x)\)</span>会得到<span class="math inline">\(x\)</span>的唯一<span class="math inline">\(w\)</span>位无符号表示形式。同样，当<span class="math inline">\(x\)</span>满足<span class="math inline">\(TMin_w\leqslant x\leqslant TMax_w\)</span>时，函数<span class="math inline">\(T2B_w(x)\)</span>会得到<span class="math inline">\(x\)</span>的唯一<span class="math inline">\(w\)</span>位补码表示形式。 <span class="math display">\[ \begin{aligned} T2U_w(x)&amp;= B2U_w(T2B_w(x))\\[3px] U2T_w(x)&amp;= B2T_w(U2B_w(x)) \end{aligned} \]</span> 　　<code>0xCFC7</code>的16位位模式既是-12345的补码表示，也是53191的无符号表示，而<span class="math inline">\(12345+53191=2^{16}\)</span>，该属性也适用于给定位模式表示的两个数值 (补码和无符号数) 之间的关系，无符号表示中<span class="math inline">\(UMax\)</span>和-1的补码具有相同的位模式，所以<span class="math inline">\(1+UMax_w=2^w\)</span>。</p><p>　　对于位模式<span class="math inline">\(\vec{x}\)</span>，若计算<span class="math inline">\(B2U(\vec{x})-B2T(\vec{x})\)</span>，则0到<span class="math inline">\(w-2\)</span>位的加权和将相互抵消，得到<span class="math inline">\(x_{w-1}2^w\)</span>。 <span class="math display">\[ B2U_w(T2B_w(x))=T2U_w(x)=x+x_{w-1}2^w \]</span> 　　在<span class="math inline">\(x\)</span>的补码表示中，位<span class="math inline">\(x_{w-1}\)</span>决定了<span class="math inline">\(x\)</span>的正负。 <span class="math display">\[ T2U_w(x)= \begin{cases} x+2^w&amp;&amp;{TMin_x\leqslant x&lt;0}\\ x&amp;&amp;{0\leqslant x\leqslant TMax_w} \end{cases} \]</span> 　　设<span class="math inline">\(\vec{u}=U2B_w(u)\)</span>，即<span class="math inline">\(U2T_w(u)\)</span>的补码表示。 <span class="math display">\[ U2T_w(u)=-u_{w-1}2^w+u \]</span> 　　在<span class="math inline">\(u\)</span>的无符号表示中，位<span class="math inline">\(u_{w-1}\)</span>决定了<span class="math inline">\(u\)</span>是否大于<span class="math inline">\(TMax_w=2^{w-1}-1\)</span>。 <span class="math display">\[ U2T_w(u)= \begin{cases} u&amp;&amp;{0\leqslant u\leqslant TMax_w}\\ u-2^w&amp;&amp;{TMax_w&lt;u\leqslant UMax_w} \end{cases} \]</span> 　　当整数<span class="math inline">\(x\)</span>满足<span class="math inline">\(0\leqslant x\leqslant TMax_w\)</span>时，<span class="math inline">\(T2U_w(x)=U2T_w(x)=x\)</span>，在此范围外转换需要增加或减去<span class="math inline">\(2^w\)</span>。</p><h4 id="扩展数的位表示">2.2.4 扩展数的位表示</h4><p>　　<strong>零扩展</strong> (在位模式的开头填充0) 可用于将无符号数转换为位模式更长的无符号数。</p><p>　　若<span class="math inline">\(w\)</span>位位向量<span class="math inline">\(\vec{u}=[u_{w-1},u_{w-2},\cdots ,u_0]\)</span>和<span class="math inline">\(w&#39;\)</span>位位向量<span class="math inline">\(\vec{u}&#39;=[0,\cdots ,0,u_{w-1},u_{w-2},\cdots ,u_0]\)</span>，当<span class="math inline">\(w&#39;&gt;w\)</span>时，<span class="math inline">\(B2U_w(\vec{u})=B2T_{w&#39;}(\vec{u}&#39;)\)</span>。</p><p>　　<strong>符号扩展</strong> (在位模式的开头填充最高有效位的值) 可用于将有符号数转换为位模式更长的有符号数。</p><p>　　若<span class="math inline">\(w\)</span>位位向量<span class="math inline">\(\vec{x}=[x_{w-1},x_{w-2},\cdots ,x_0]\)</span>和<span class="math inline">\(w&#39;\)</span>位位向量<span class="math inline">\(\vec{x}&#39;=[x_{w-1},\cdots ,x_{w-1},x_{w-1},x_{w-2},\cdots ,x_0]\)</span>，当<span class="math inline">\(w&#39;&gt;w\)</span>时，<span class="math inline">\(B2U_w(\vec{u})=B2U_{w&#39;}(\vec{u}&#39;)\)</span>。若<span class="math inline">\(w&#39;=w+k\)</span>，则需证明 <span class="math display">\[ B2T_{w+k}([x_{w-1},...,x_{w-1},x_{w-1},x_{w-2},...,x_0])=B2T_w([x_{w-1},x_{w-2},...,x_0]) \]</span> 　　根据数学归纳法，若能证明符号扩展1位时数值不变，则符号扩展到任意位时数值也不变。 <span class="math display">\[ \begin{aligned} B2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},...,x_0])&amp;=-x_{w-1}2^w+\sum^{w-1}_{i=0}x_i2^i\\[3px] &amp;=-x_{w-1}2^w+x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i\\[3px] &amp;=-x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i\\[3px] &amp;=B2T_w([x_{w-1},x_{w-2},...,x_0]) \end{aligned} \]</span></p><h4 id="截断数值">2.2.5 截断数值</h4><p>　　将<span class="math inline">\(w\)</span>位位向量截断为<span class="math inline">\(k\)</span>位时，将丢弃高<span class="math inline">\(w-k\)</span>位，这可能会改变其值。这种情况也属于溢出。</p><p>　　若<span class="math inline">\(w\)</span>位位向量<span class="math inline">\(\vec{x}=[x_{w-1},w_{w-2},\cdots ,x_0]\)</span>，则截断为<span class="math inline">\(k\)</span>位后的结果<span class="math inline">\(\vec{x}&#39;=[x_{k-1},w_{k-2},\cdots ,x_0]\)</span>。令<span class="math inline">\(x=B2U_w(\vec{x})\)</span>，<span class="math inline">\(x&#39;=B2U_w(\vec{x}&#39;)\)</span>，则<span class="math inline">\(x&#39;=x\bmod 2^k\)</span>。若<span class="math inline">\(x’=B2T(\vec{x}&#39;)\)</span>，则<span class="math inline">\(x&#39;=U2T_k(x\bmod 2^k)\)</span>，<span class="math inline">\(U2T_k\)</span>将最高有效位<span class="math inline">\(x_{k-1}\)</span>的权重从<span class="math inline">\(2^{k-1}\)</span>转换为<span class="math inline">\(-2^{k-1}\)</span>。 <span class="math display">\[ \begin{aligned} B2U([x_{w-1},x_{w-2},...,x_0])\bmod 2^k&amp;=[\sum_{i=0}^{w-1}x_i2^i]\bmod 2^k\\[3px] &amp;=[\sum_{i=0}^{k-1}x_i2^i]\bmod 2^k\\[3px] &amp;=\sum^{k-1}_{i=0}x_i2^i\\[3px] &amp;=B2U_k([x_{k-1},x_{k-2},...,x_0]) \end{aligned} \]</span> 　　对于无符号数，所有截断的位都具有形如<span class="math inline">\(2^i(i\geqslant k)\)</span>的权重，这些权重都在模运算时会得到0。</p><h3 id="整数运算">2.3 整数运算</h3><h4 id="无符号运算">2.3.1 无符号运算</h4><p>　　对于位模式为<span class="math inline">\(w\)</span>位的无符号数<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>，两者的运算<span class="math inline">\(+^u_w\)</span>就是把和<span class="math inline">\(x+y\)</span>的位模式截断为<span class="math inline">\(w\)</span>位后的结果再转换为无符号数。当<span class="math inline">\(x+y\geqslant 2^w\)</span>时，会发生溢出，溢出后的结果小于<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>。当执行C程序时，溢出不会导致错误。 <span class="math display">\[ x+^u_wy= \begin{cases} x+y&amp;&amp;{0\leqslant x+y&lt;2^w}\\ x+y-2^w&amp;&amp;{2^w\leqslant x+y&lt;2^{w+1}} \end{cases} \]</span> 　　模加法会形成<strong>阿贝尔群</strong>。阿贝尔群以挪威数学家Niels Henrik Abel (1802~1829) 命名，它是可交换的和可结合的。阿贝尔群有1个单元0，并且每个元素都有1个加法逆元。对于位模式为<span class="math inline">\(w\)</span>位的无符号数<span class="math inline">\(x\)</span>，必有1个值<span class="math inline">\(-^u_wx\)</span>满足<span class="math inline">\(-^u_wx+^u_wx=0\)</span>。 <span class="math display">\[ -^u_wx= \begin{cases} x&amp;&amp;{x=0}\\ 2^w-x&amp;&amp;{0&lt;x\leqslant 2^w-1} \end{cases} \]</span></p><p>　　<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>的运算<span class="math inline">\(*^u_w\)</span>也是将乘积<span class="math inline">\(x\cdot y\)</span>的位模式 (<span class="math inline">\(2w\)</span>位) 截断为<span class="math inline">\(w\)</span>位后的结果再转换为无符号数。 <span class="math display">\[ x*^u_wy=(x\cdot y)\bmod 2^w \]</span></p><h4 id="有符号运算">2.3.2 有符号运算</h4><p>　　对于位模式为<span class="math inline">\(w\)</span>位的有符号数<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>，两者的运算<span class="math inline">\(+^t_w\)</span>就是把和<span class="math inline">\(x+y\)</span>的位模式截断为<span class="math inline">\(w\)</span>位后的结果再转换为有符号数。</p><p>　　<span class="math inline">\(+^t_w\)</span>与<span class="math inline">\(+^u_w\)</span>有相同的位级表示，所以<span class="math inline">\(+^t_w\)</span>等同于先将参数转换为无符号数进行<span class="math inline">\(+^u_w\)</span>再转换为有符号数。 <span class="math display">\[ \begin{aligned} x+^t_wy&amp;=U2T_w(T2U_w(x)+^u_wT2U(y))\\[3px] &amp;=U2T_w[(x_{w-1}2^w+x+y_{w-1}2^w+y)\bmod2^w]\\[3px] &amp;=U2T_w[(x+y)\bmod 2^w] \end{aligned} \]</span> 　　假设<span class="math inline">\(z=x+y\)</span>，<span class="math inline">\(z&#39;= z\bmod2^w\)</span>，<span class="math inline">\(z&#39;&#39;= U2T(z&#39;)=x+^t_wy\)</span>。</p><p>　　● 当<span class="math inline">\(-2^w\leqslant z&lt;-2^{w-1}\)</span>时，<span class="math inline">\(z&#39;=z+2^w\)</span>，所以<span class="math inline">\(0\leqslant z&#39;&lt;-2^{w-1}\)</span>，<span class="math inline">\(z&#39;&#39;=z&#39;\)</span>，此时，两个负数相加得到正数，称为<strong>负溢出</strong>。</p><p>　　● 当<span class="math inline">\(-2^{w-1}\leqslant z&lt;0\)</span>时，<span class="math inline">\(z&#39;=z+2^w\)</span>，所以<span class="math inline">\(2^{2-1}\leqslant z&#39;&lt;2^w\)</span>，<span class="math inline">\(z&#39;&#39;=z\)</span>。</p><p>　　● 当<span class="math inline">\(0\leqslant z&lt;2^{w-1}\)</span>时，<span class="math inline">\(z&#39;=z\)</span>，所以<span class="math inline">\(0\leqslant z&#39;&lt;2^{w-1}\)</span>，<span class="math inline">\(z&#39;&#39;=z\)</span>。</p><p>　　● 当<span class="math inline">\(2^{w-1}\leqslant z&lt;2^w\)</span>时，<span class="math inline">\(z&#39;=z\)</span>，所以<span class="math inline">\(2^{w-1}\leqslant z&#39;&lt;2^w\)</span>，<span class="math inline">\(z&#39;&#39;=z-2^w\)</span>，此时，两个正数相加得到负数，称为<strong>正溢出</strong>。 <span class="math display">\[ x+^t_wy= \begin{cases} x+y+2^w&amp;&amp;{-2^w\leqslant x+y&lt;-2^{w-1}}\\ x+y&amp;&amp;{-2^{w-1}\leqslant x+y&lt;2^{w-1}}\\ x+y-2^w&amp;&amp;{2^{w-1}\leqslant x+y&lt;2^w} \end{cases} \]</span> 　　<span class="math inline">\(TMin_w+TMin_w=-2^w\)</span>会导致负溢出，所以<span class="math inline">\(TMin_w+^t_wTMin_w=0\)</span>。若<span class="math inline">\(x&gt;Tmin_w\)</span>且<span class="math inline">\(-x\)</span>可以表示为<span class="math inline">\(w\)</span>位的补码，则<span class="math inline">\(-x+x=0\)</span>。 <span class="math display">\[ -^t_wx= \begin{cases} TMin_w&amp;&amp;{x=-2^{w-1}}\\ -x&amp;&amp;{-2^{w-1}&lt;x\leqslant 2^{w-1}-1} \end{cases} \]</span> 　　获取<span class="math inline">\(-^t_wx\)</span>的有2种方法。第1种方法是将<span class="math inline">\(x\)</span>的位模式中的所有位取反并将结果加1。第2种方法是先找到<span class="math inline">\(x\)</span>的位模式中的最右边的1并假设其位置为<span class="math inline">\(k\)</span>，然后将<span class="math inline">\(k\)</span>左边的位所有位取反。</p><p>　　对于<span class="math inline">\(w\)</span>位位向量<span class="math inline">\(\vec{x}\)</span>和<span class="math inline">\(\vec{y}\)</span>，<span class="math inline">\(x=B2T_w(\vec{x})\)</span>，<span class="math inline">\(y=B2T_w(\vec{y})\)</span>，<span class="math inline">\(x&#39;=B2U_w(\vec{x})\)</span>，<span class="math inline">\(y&#39;=B2U_w(\vec{y})\)</span>。 <span class="math display">\[ \begin{aligned} (x&#39;\cdot y&#39;)\bmod 2^w&amp;=[(x+x_{w-1}2^w)\cdot(y+y_{w-1}2^w)]\bmod 2^w\\[3px] &amp;=[x\cdot y+(x_{w-1}y+y_{w-1}x)2^w+x_{w-1}y_{w-1}2^{2w}]\bmod 2^w\\[3px] &amp;=(x\cdot y)\bmod 2^w \end{aligned} \]</span> 　　因此，无符号数和有符号数乘法运算的位级表示相同。</p><p>　　<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>的运算<span class="math inline">\(*^t_w\)</span>也是将乘积<span class="math inline">\(x\cdot y\)</span>的位模式 (<span class="math inline">\(2w\)</span>位) 截断为<span class="math inline">\(w\)</span>位后的结果再转换为有符号数。 <span class="math display">\[ x*^t_wy=U2T_w((x\cdot y)\bmod 2^w) \]</span></p><h4 id="除以2的幂">2.3.3 除以2的幂</h4><p>　　除以2的幂可以用右移操作来实现，逻辑右移和算术右移分别对应无符号数和有符号数。因此，大多数计算机都支持这2种右移，但这种方法并不适用于所有整数。</p><p>　　对于实数<span class="math inline">\(a\)</span>，<span class="math inline">\(\lfloor a \rfloor\)</span>表示满足<span class="math inline">\(a&#39;\leqslant a\leqslant a&#39;+1\)</span>的唯一整数<span class="math inline">\(a&#39;\)</span>，<span class="math inline">\(\lceil a \rceil\)</span>表示满足<span class="math inline">\(a&#39;-1 \leqslant a\leqslant a&#39;\)</span>的唯一整数<span class="math inline">\(a&#39;\)</span>。</p><p>　　整数除法通常向零舍入，即当结果为正时，向下舍入；当结果为负时，向上舍入。因此，当<span class="math inline">\(x\geqslant 0\)</span>和<span class="math inline">\(y&gt;0\)</span>，会得到<span class="math inline">\(\lfloor \frac{x}{y} \rfloor\)</span>；当<span class="math inline">\(x&lt;0\)</span>和<span class="math inline">\(y&gt;0\)</span>时，会得到<span class="math inline">\(\lceil \frac{x}{y} \rceil\)</span>。</p><h5 id="无符号数除以2的幂">2.3.3.1 无符号数除以2的幂</h5><p>　　若C变量<code>x</code>和<code>k</code>都是无符号数，值分别为<span class="math inline">\(x\)</span>和<span class="math inline">\(k\)</span>，<span class="math inline">\(x\)</span>的位模式是<span class="math inline">\([x_{w-1},x_{w-2},...,x_0]\)</span>且<span class="math inline">\(0\leqslant k&lt;w\)</span>，则<code>x &gt;&gt; k</code>会执行逻辑右移并向下舍入。</p><p>　　假设<span class="math inline">\(x&#39;\)</span>表示<span class="math inline">\(x\)</span>的高<span class="math inline">\(w-k\)</span>位的位模式，即<span class="math inline">\([x_{w-1},x_{w-2},...,x_k]\)</span>，<span class="math inline">\(x&#39;&#39;\)</span>表示<span class="math inline">\(x\)</span>的低<span class="math inline">\(k\)</span>位的位模式，即<span class="math inline">\([x_{k-1},...,x_0]\)</span>，则<span class="math inline">\(x=2^kx&#39;+x&#39;&#39;\)</span>，其中<span class="math inline">\(0\leqslant x&#39;&#39;&lt;2^k\)</span>。因此，<span class="math inline">\(\lfloor \frac{x}{2^k} \rfloor=x&#39;\)</span>。</p><table><thead><tr><th><code>k</code></th><th><code>&gt;&gt; k</code> (二进制)</th><th>十进制</th><th><code>12340 / (2 ^ k)</code></th></tr></thead><tbody><tr><td>0</td><td>0011000000110100</td><td>12340</td><td>12340.0</td></tr><tr><td>1</td><td><strong>0</strong>001100000011010</td><td>6170</td><td>6170.0</td></tr><tr><td>4</td><td><strong>0000</strong>001100000011</td><td>771</td><td>771.25</td></tr><tr><td>8</td><td><strong>00000000</strong>00110000</td><td>48</td><td>48.203125</td></tr></tbody></table><p>　　这是对12340的16位表示进行逻辑右移后的结果，粗体表示从左边移入的0。</p><h5 id="有符号数除以2的幂">2.3.3.2 有符号数除以2的幂</h5><p>　　若C变量<code>x</code>和<code>k</code>分别是有符号数和无符号数，值分别为<span class="math inline">\(x\)</span>和<span class="math inline">\(k\)</span>，<span class="math inline">\(x\)</span>的位模式是<span class="math inline">\([x_{w-1},x_{w-2},...,x_0]\)</span>且<span class="math inline">\(0\leqslant k&lt;w\)</span>，则<code>x &gt;&gt; k</code>会执行算术右移并向下舍入。</p><p>　　当<span class="math inline">\(x\geqslant 0\)</span>时，<span class="math inline">\(x\)</span>的最高位是0，此时，算术右移与逻辑右移相同；当<span class="math inline">\(x&lt;0\)</span>时，算术右移<span class="math inline">\(k\)</span>位后，高<span class="math inline">\(k\)</span>位都会变为1，刚好是<span class="math inline">\(\lfloor \frac{x}{2^k} \rfloor\)</span>的补码表示。</p><table><thead><tr><th><code>k</code></th><th><code>&gt;&gt; k</code> (二进制)</th><th>十进制</th><th><code>-12340 / (2 ^ k)</code></th></tr></thead><tbody><tr><td>0</td><td>1100111111001100</td><td>-12340</td><td>-12340.0</td></tr><tr><td>1</td><td><strong>1</strong>110011111100110</td><td>-6170</td><td>-6170.0</td></tr><tr><td>4</td><td><strong>1111</strong>110011111100</td><td>-772</td><td>-771.25</td></tr><tr><td>8</td><td><strong>11111111</strong>11001111</td><td>-49</td><td>−48.203125</td></tr></tbody></table><p>　　这是对-12340的16位表示进行逻辑右移后的结果。对于不需要舍入的情况 (<span class="math inline">\(k=1\)</span>)，结果会是<span class="math inline">\(\frac{x}{2^k}\)</span>。对于需要舍入的情况，算术右移会导致向下舍入。</p><p>　　为了保证整数除法向零舍入，算术右移前需要加上<span style="background-color:#ff0">偏置</span><span class="math inline">\(2^k-1\)</span>，即<code>(x + (1 &lt;&lt; k) - 1) &gt;&gt; k</code>。</p><table><colgroup><col style="width:5%"><col style="width:5%"><col style="width:29%"><col style="width:27%"><col style="width:8%"><col style="width:24%"></colgroup><thead><tr><th><code>k</code></th><th>偏置</th><th>-12340 + 偏置 (二进制)</th><th><code>&gt;&gt; k</code> (二进制)</th><th>十进制</th><th><code>-12340 / (2 ^ k)</code></th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1100111111001100</td><td>1100111111001100</td><td>-12340</td><td>-12340.0</td></tr><tr><td>1</td><td>1</td><td>110011111100110<strong>1</strong></td><td><strong>1</strong>110011111100110</td><td>-6170</td><td>-6170.0</td></tr><tr><td>4</td><td>15</td><td>110011111101<strong>1011</strong></td><td><strong>1111</strong>110011111101</td><td>-771</td><td>-771.25</td></tr><tr><td>8</td><td>255</td><td>11010000<strong>11001011</strong></td><td><strong>11111111</strong>11010000</td><td>-48</td><td>−48.203125</td></tr></tbody></table><p>　　这是如何在算术右移前加上合适的偏置来保证向零舍入。在第3列中，展示了-12340与偏置相加的结果，其中粗体表示低<span class="math inline">\(k\)</span>位，它们左边的位可能会增加，也可能不会增加。对于不需要舍入的情况 (<span class="math inline">\(k=1\)</span>)，偏置只会影响那些会移动的位。对于需要舍入的情况，偏置会导致较高的位增加，即结果将向零舍入。</p><p>　　若<span class="math inline">\(x=qy+r\)</span>，其中<span class="math inline">\(0\leqslant x&lt;y\)</span>，则<span class="math inline">\(\frac{x+y-1}{y}=q+\frac{r+y-1}{y}\)</span>，所以<span class="math inline">\(\lfloor\frac{x+y-1}{y}\rfloor=q+\lfloor\frac{r+y-1}{y}\rfloor\)</span>。当<span class="math inline">\(r=0\)</span>时，<span class="math inline">\(\lfloor\frac{r+y-1}{y}\rfloor\)</span>会得到0；当<span class="math inline">\(r&gt;0\)</span>时，<span class="math inline">\(\lfloor\frac{r+y-1}{y}\rfloor\)</span>会得到1。因此，对于整数<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span> (<span class="math inline">\(y&gt;0\)</span>)，<span class="math inline">\(\lceil\frac{x}{y}\rceil=\lfloor \frac{x+y-1}{y} \rfloor\)</span>，偏置技术充分使用了这一点。当<span class="math inline">\(y=2^k\)</span>时，<code>(x + (1 &lt;&lt; k) - 1) &gt;&gt; k</code>会先得到<span class="math inline">\(x+2^k-1\)</span>，然后右移<span class="math inline">\(k\)</span>位，最后得到<span class="math inline">\(\lceil\frac{x}{2^k}\rceil\)</span>。</p><h3 id="浮点数">2.4 浮点数</h3><p>　　浮点数表示用于对形如<span class="math inline">\(V=x\times 2^y\)</span>的有理数进行编码。对于涉及非常大的数 (<span class="math inline">\(|V|&gt;&gt;1\)</span>)、非常接近于0的数 (<span class="math inline">\(0&lt;|V|&lt;&lt;1\)</span>) 以及更普遍的作为实数运算的近似值的计算，它很实用。</p><h4 id="二进制小数">2.4.1 二进制小数</h4><p>　　小数的十进制表示为<span class="math inline">\(d_md_{m-1}\cdots d_1d_0.d_{-1}d_{-2}\cdots d_{-n+1}d_{-n}\)</span>。数字的权是相对小数点符号定义，左边的数的权是10的正幂，得到整数值，而右边的数的权是10的负幂，得到小数值。 <span class="math display">\[ d=\sum^m_{i=-n}10^i\times d_i \]</span> 　　类似十进制，小数的二进制也能表示为<span class="math inline">\(b_mb_{m-1}\cdots b_1b_0.b_{-1}b_{-2}\cdots b_{-n+1}b_{-n}\)</span>。小数点左边的数的权是2的正幂，右边的数的权是2的负幂。小数点左移<span class="math inline">\(n\)</span>位相当于除以<span class="math inline">\(2^n\)</span>，右移<span class="math inline">\(n\)</span>位相当于乘<span class="math inline">\(2^n\)</span>。 <span class="math display">\[ b=\sum^m_{i=-n}2^i\times b_i \]</span> 　　对于有些小数，并不能确切地用二进制表示，只能近似地表示，但增加二进制表示的长度可以提高其精度。</p><h4 id="ieee浮点表示">2.4.2 IEEE浮点表示</h4><p>　　IEEE浮点标准用<span class="math inline">\(V=(-1)^s\times M\times 2^E\)</span>表示数字。</p><p>　　● <span class="math inline">\(s\)</span>表示<strong>符号</strong>，<span class="math inline">\(s=1\)</span>表示负数，<span class="math inline">\(s=0\)</span>表示正数，其中数值0的符号位解释作为特殊情况处理。</p><p>　　● <span class="math inline">\(M\)</span>表示<strong>尾数</strong>，它是二进制小数，其范围是<span class="math inline">\(1\sim 2-\epsilon\)</span>或<span class="math inline">\(0\sim 1-\epsilon\)</span>。</p><p>　　● <span class="math inline">\(E\)</span>表示<strong>阶码</strong>，其作用是对浮点数加权，该权是<span class="math inline">\(2^E\)</span>。</p><img src="/2022/10/05/computer-systems-a-programmer's-perspective-3e-chpt-2/standard_floating_pointer_format.svg" title="standard_floating_pointer_format"><p>　　在C语言中，单精度浮点数是32位，其中有1位符号、8位阶码和23位尾数。双精度浮点数是64位，其中有1位符号、11位阶码和52位尾数。</p><img src="/2022/10/05/computer-systems-a-programmer's-perspective-3e-chpt-2/categories_of_single_precision_floating_point_values.svg" title="categories_of_single_precision_floating_point_values"><p>　　对于C语言的单精度浮点数，阶码的值决定了其类别。此外，用<span class="math inline">\(k\)</span>和<span class="math inline">\(n\)</span>分别表示阶码和尾数的位模式长度。</p><p>　　● 最常见的情况是<strong>规格化</strong>数，其阶码的位模式不全为0或1。在这种情况下，阶码被解释为<strong>偏置</strong>形式表示的有符号整数，即阶码值<span class="math inline">\(E=e-Bias\)</span>，其中<span class="math inline">\(e\)</span>是无符号数，其位模式是<span class="math inline">\(e_{k-1}\cdots e_1e_0\)</span>，<span class="math inline">\(Bias\)</span>是偏置值<span class="math inline">\(2^{k-1}-1\)</span>。因此，单精度浮点数的指数的取值范围是<span class="math inline">\(-126\sim +127\)</span>，双精度浮点数的指数范围是<span class="math inline">\(-1022\sim +1023\)</span>。尾数被解释为小数<span class="math inline">\(f\)</span> (<span class="math inline">\(0\leqslant f&lt;1\)</span>)，其二进制表示为<span class="math inline">\(0.f_{n-1}\cdots f_1f_0\)</span>。尾数定义为<span class="math inline">\(M=1+f\)</span>，这种方式也称为<strong>隐含前导1</strong>表示，因为<span class="math inline">\(M\)</span>的二进制表示为<span class="math inline">\(1.f_{n-1}\cdots f_1f_0\)</span>，这种表示方法可以获得额外精度。由于可以调整阶码<span class="math inline">\(E\)</span>来保证尾数<span class="math inline">\(M\)</span>在<span class="math inline">\(1\leqslant M&lt;2\)</span>范围内，所以无需显示地表示前导位。</p><p>　　● 当阶码位模式全为0时，表示<strong>非规格化</strong>数。在这种情况下，阶码值<span class="math inline">\(E=1-Bias\)</span>，尾数值<span class="math inline">\(M=f\)</span>。它有2个用途，第1个用途是表示数值0，因为规格化数的尾数<span class="math inline">\(M\geqslant1\)</span>，不能表示0。实际上，+0.0的位模式全为0，但位模式的符号位为1，其他位全为0时表示-0.0。对于IEEE浮点格式，+0.0和-0.0在某些方面不同，其他方面相同。第2个用途是表示很接近0的数，提供了一个称为<strong>渐进下溢</strong>的属性，即可能的数值均匀分布在0.0附近。</p><p>　　● 当阶码位模式全为1时，表示特殊值。当尾数位模式全为0时，表示无穷大，符号位是0时表示<span class="math inline">\(+\infty\)</span>，符号位为1时表示<span class="math inline">\(-\infty\)</span>。当两个很大的数相乘或除以0时，无穷大表示<span style="background-color:#ff0">溢出</span>。当尾数位模式不全为0时，表示<strong>非数字</strong>，某些运算结果不为实数或无穷大时，返回非数字。在某些应用程序中，它们可用于表示未初始化的数据。</p><table><colgroup><col style="width:21%"><col style="width:19%"><col style="width:17%"><col style="width:41%"></colgroup><thead><tr><th></th><th>阶码</th><th>尾数</th><th>数值</th></tr></thead><tbody><tr><td>最小的正非规格化数</td><td><span class="math inline">\(M=f=2^{-n}\)</span></td><td><span class="math inline">\(E=-2^{k-1}+2\)</span></td><td><span class="math inline">\(V=2^{-n-2^{k-1}+2}\)</span></td></tr><tr><td>最大的正非规格化数</td><td><span class="math inline">\(M=f=1-2^{-n}\)</span></td><td><span class="math inline">\(E=-2^{k-1}+2\)</span></td><td><span class="math inline">\(V=(1-2^{-n})\cdot 2^{-2^{k-1}+2}\)</span></td></tr><tr><td>最小的正规格化数</td><td><span class="math inline">\(M=1+f=1\)</span></td><td><span class="math inline">\(E=-2^{k-1}+2\)</span></td><td><span class="math inline">\(V=2^{-2^{k-1}+2}\)</span></td></tr><tr><td>最大的正规格化数</td><td><span class="math inline">\(M=1+f=2-2^{-n}\)</span></td><td><span class="math inline">\(E=2^{k-1}-1\)</span></td><td><span class="math inline">\(V=(1-2^{-n-1})\cdot 2^{2^{k-1}}\)</span></td></tr></tbody></table><p>　　以基于IEEE浮点格式的6位浮点表示为例，其中有3位阶码和2位尾数，所以偏置值<span class="math inline">\(Bias=2^{3-1}-1=3\)</span>。对于规格化数，阶码值的取值范围是<span class="math inline">\(-2\sim3\)</span>，尾数值的取值范围是<span class="math inline">\(1\sim \frac{7}{4}\)</span>，最大值是<span class="math inline">\(\pm14\)</span>，最小值是<span class="math inline">\(\pm\frac{1}{4}\)</span>。对于非规格化数，阶码值是<span class="math inline">\(-2\)</span>，尾数值的取值范围是<span class="math inline">\(0\sim \frac{3}{4}\)</span>，最大值是<span class="math inline">\(\pm \frac{3}{16}\)</span>，最小值是<span class="math inline">\(\pm 0\)</span>。非规格数聚集在0附近，它们并不是均匀分布，而是越靠近原点越密集。对比规格数的最小值和非规格数的最大值，可以发现两者之间的<span style="background-color:#ff0">平滑过渡</span>，因为非规格化数的阶码值<span class="math inline">\(E\)</span>定义为<span class="math inline">\(1-Bias\)</span>，这样弥补了非规格化数的尾数没有隐含前导1。</p><img src="/2022/10/05/computer-systems-a-programmer's-perspective-3e-chpt-2/simple_example_of_converting_a_signed_number_to_a_floating_point_number.svg" title="simple_example_of_converting_a_signed_number_to_a_floating_point_number"><p>　　将整数转换为浮点形式对理解浮点表示很有用。以数值12345为例，其二进制表示为<span class="math inline">\([11000000111001]\)</span>，对应的规格化表示为<span class="math inline">\(1.1000000111001_2\cdot 2^{13}\)</span>。为了用IEEE单精度浮点表示，将二进制小数点左移13位，丢弃开头的1并在结尾增加10个0，然后计算尾数<span class="math inline">\(e=E+Bias=13+127=140\)</span>并转换为二进制，最后加上符号位。</p><h4 id="浮点运算">2.4.3 浮点运算</h4><p>　　浮点运算只能近似于实数运算，因为表示的范围和精度有限。因此，对于值<span class="math inline">\(x\)</span>，需要系统的方法来查找浮点格式能表示的最近接的值<span class="math inline">\(x&#39;\)</span>，这是<strong>舍入</strong>的任务。</p><p>　　IEEE浮点格式定义了4种舍入模式。向最近值舍入也称为向偶数舍入，是默认方式，它向上或向下舍入来尽量保证结果的最低有效位为偶数。当有2个可能的舍入值时，选择最低有效位为偶数的舍入值。以保留整数为例，1.40会舍入到1，1.50和2.50都会舍入到2，因为2是偶数。其他3种方式会在实际值上产生<span style="background-color:#ff0">确界</span>，分别是向上舍入、向零舍入和向下舍入。</p><p>　　向偶数舍入也能运用在二进制小数上 (0是偶数)。通常位模式形如<span class="math inline">\(XX\cdots X.YY\cdots Y100\cdots\)</span>的数 (最右边的<span class="math inline">\(Y\)</span>是待舍入的位置) 才可能会有2个舍入值。以保留2位小数为例，<span class="math inline">\(10.00011_2(2\frac{3}{32})\)</span>会舍入到<span class="math inline">\(10.00_2(2)\)</span>，<span class="math inline">\(10.00110_2(2\frac{3}{16})\)</span>会舍入到<span class="math inline">\(10.01_2(2\frac{1}{4})\)</span>，<span class="math inline">\(10.11100_2(2\frac{7}{8})\)</span>会舍入到<span class="math inline">\(11.00_2(3)\)</span>，<span class="math inline">\(10.10100_2(2\frac{5}{8})\)</span>会舍入到<span class="math inline">\(10.10(2\frac{1}{2})\)</span>。</p><p>　　将一组数据舍入后进行平均值计算时会引入统计偏差，无论向上舍入、向零舍入还是向下舍入，都会增大统计偏差，而向偶数舍入可以减小甚至消除统计偏差，因为大约一半的数据向上舍入，大约一半数据向下舍入。</p><p>　　IEEE规定了用于确定算术运算结果的规则，即若将浮点数<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>视为实数，则算术运算<span class="math inline">\(\odot\)</span>的结果应该是实际值的舍入结果<span class="math inline">\(Round(x\odot y)\)</span>。</p><p>　　整数 (包括无符号和补码) 加法会形成阿贝尔群，实数加法也会形成阿贝尔群，但需要考虑舍入。将<span class="math inline">\(x+^fy\)</span>定义为<span class="math inline">\(Round(x+y)\)</span>，该运算会根据<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>的所有取值定义，虽然<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>都是实数，但由于溢出可能得到无穷大。对于所有<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>的值，该运算是可交换的，<span class="math inline">\(x+^fy=y+^fx\)</span>。但是，该运算是不可结合的，例如，对于单精度浮点数，有<span class="math inline">\((3.14+10^{10})-10^{10}=0.0\)</span>，舍入会导致3.14会丢失，而<span class="math inline">\(3.14+(10^{10}-10^{10})=3.14\)</span>。大多数在浮点加法时有逆元，<span class="math inline">\(x+^f-x=0\)</span>，无穷大和非数字是例外，因为<span class="math inline">\(+\infty-\infty=NaN\)</span>，<span class="math inline">\(NaN+^fx=NaN\)</span>。</p><p>　　浮点加法满足单调性，即若<span class="math inline">\(a\geqslant b\)</span>，则<span class="math inline">\(x+^fa\geqslant x+^fb(x\neq NaN)\)</span>。</p><p>　　由于浮点加法不具有结合性，<code>x = a + b + c</code>可能会被编译器替换为<code>t = b + c</code>和<code>x = a + t</code>。在大多数情况下，这种差异无关紧要。编译器无法得知如何取舍效率和保留原始程序的确切行为，所以编译器通常很保守，避免任何可能对功能产生影响的优化。</p><p>　　浮点乘法也有常规乘数的很多属性。将<span class="math inline">\(x\cdot^fy\)</span>定义为<span class="math inline">\(Round(x\cdot y)\)</span>，该运算会在乘法下闭合 (虽然可能产生无穷大或非数字)，它是可交换的并且有1.0作为乘法恒等式。由于溢出或舍入而导致精度丢失，该运算是不可结合和不可分配的。该运算满足单调性，对于不为非数字的<span class="math inline">\(a\)</span>、<span class="math inline">\(b\)</span>和<span class="math inline">\(c\)</span>，其中<span class="math inline">\(a\geqslant b\)</span>，若<span class="math inline">\(c\geqslant 0\)</span>，则<span class="math inline">\(a\cdot^fc \geqslant b \cdot^f c\)</span>；若<span class="math inline">\(c\leqslant0\)</span>，则<span class="math inline">\(a\cdot^f c\leqslant b\cdot^f c\)</span>。</p><h4 id="c语言相关支持-1">2.4.4 C语言相关支持</h4><p>　　C语言提供了<code>float</code>和<code>double</code>来支持浮点数，其舍入模式是向偶数舍入。C语言并不要求计算机使用IEEE浮点格式，所以没有标准方法来更改舍入方式和获取特殊值，但大多数系统提供了头文件引入和过程库的结合来提供这些支持，具体实现因系统而异。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>　　这段代码会让GCC定义常数<code>INFINTY</code>和<code>NAN</code>。</p><p>　　<code>int</code>转换为<code>float</code>时，可能会舍入。<code>int</code>或<code>float</code>转换为<code>double</code>时，不会有精度损失。<code>double</code>转换为<code>float</code>时，可能会溢出为<span class="math inline">\(\pm\infty\)</span>或者舍入。<code>float</code>或<code>double</code>转换为<code>int</code>时，可能会向零舍入，也可能会溢出，C语言没有为这种情况指定固定结果。Intel兼容的CPU会指定位模式<span class="math inline">\([10\cdots00]\)</span>为<strong>整数不定值</strong>，若从浮点数转换为整数时，没有合理的整数近似值，则会产生该值。因此，<code>(int)+1e10</code>会得到-21483648，即从正数变成负数。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2022/09/17/computer-systems-a-programmer's-perspective-3e-chpt-1/" rel="prev" title="《深入理解计算机系统 第3版》 第1章 计算机系统概览"><i class="fa fa-angle-left"></i> 《深入理解计算机系统 第3版》 第1章 计算机系统概览</a></div><div class="post-nav-item"><a href="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/" rel="next" title="《深入理解计算机系统 第3版》第3章 程序的机器级表示">《深入理解计算机系统 第3版》第3章 程序的机器级表示 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script></body></html>