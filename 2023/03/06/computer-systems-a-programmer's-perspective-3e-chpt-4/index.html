<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><link rel="canonical" href="http://example.com/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/","path":"2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/","title":"《深入理解计算机系统 第3版》第4章 处理器体系架构"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《深入理解计算机系统 第3版》第4章 处理器体系架构 |</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#y86-64%E6%8C%87%E4%BB%A4%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">4.1 Y86-64指令级体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#y86-64%E6%8C%87%E4%BB%A4"><span class="nav-text">4.1.1 Y86-64指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#y86-64%E7%A8%8B%E5%BA%8F"><span class="nav-text">4.1.2 Y86-64程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80"><span class="nav-text">4.2 逻辑设计和硬件控制语言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E7%BA%A7%E7%9A%84%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF"><span class="nav-text">4.2.1 位级的组合电路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%BA%A7%E7%9A%84%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF"><span class="nav-text">4.2.2 字级的组合电路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%92%8C%E6%97%B6%E9%92%9F"><span class="nav-text">4.2.3 存储器和时钟</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#y86-64%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="nav-text">4.3 Y86-64的顺序实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E5%A4%84%E7%90%86%E7%BB%84%E7%BB%87%E6%88%90%E9%98%B6%E6%AE%B5"><span class="nav-text">4.3.1 将处理组织成阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#seq"><span class="nav-text">4.3.2 SEQ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#seq%E6%97%B6%E5%BA%8F"><span class="nav-text">4.3.3 SEQ时序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#seq%E5%90%84%E9%98%B6%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">4.3.4 SEQ各阶段的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%96%E6%8C%87%E9%98%B6%E6%AE%B5"><span class="nav-text">4.3.4.1 取指阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%91%E7%A0%81%E5%92%8C%E5%86%99%E5%9B%9E%E9%98%B6%E6%AE%B5"><span class="nav-text">4.3.4.2 译码和写回阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5"><span class="nav-text">4.3.4.3 执行阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BF%E5%AD%98%E9%98%B6%E6%AE%B5"><span class="nav-text">4.3.4.4 访存阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pc%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5"><span class="nav-text">4.3.4.5 PC更新阶段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E9%80%9A%E7%94%A8%E5%8E%9F%E7%90%86"><span class="nav-text">4.4 流水线的通用原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-text">4.4.1 计算流水线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-text">4.4.2 流水线的限制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#y86-64%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AE%9E%E7%8E%B0"><span class="nav-text">4.5 Y86-64的流水线实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#seq-1"><span class="nav-text">4.5.1 SEQ+</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pipe-"><span class="nav-text">4.5.2 PIPE-</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%9A%90%E6%82%A3"><span class="nav-text">4.5.3 流水线隐患</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E9%9A%90%E6%82%A3"><span class="nav-text">4.5.3.1 避免数据隐患</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%8E%A7%E5%88%B6%E9%9A%90%E6%82%A3"><span class="nav-text">4.5.3.2 避免控制隐患</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pipe%E5%90%84%E9%98%B6%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">4.5.4 PIPE各阶段的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%96%E6%8C%87%E9%98%B6%E6%AE%B5-1"><span class="nav-text">4.5.4.1 取指阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%91%E7%A0%81%E5%92%8C%E5%86%99%E5%9B%9E%E9%98%B6%E6%AE%B5-1"><span class="nav-text">4.5.4.2 译码和写回阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5-1"><span class="nav-text">4.5.4.3 执行阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BF%E5%AD%98%E9%98%B6%E6%AE%B5-1"><span class="nav-text">4.5.4.4 访存阶段</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">4.5.5 异常处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91"><span class="nav-text">4.5.6 流水线控制逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="nav-text">4.5.6.1 流水线控制机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%9D%A1%E4%BB%B6%E7%9A%84%E7%BB%84%E5%90%88"><span class="nav-text">4.5.6.2 控制条件的组合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0"><span class="nav-text">4.5.6.3 控制逻辑实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%92%8C%E9%AA%8C%E8%AF%81"><span class="nav-text">4.5.6.4 测试和验证</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-text">4.5.7 性能分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="nav-text">4.5.8 未完成的工作</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《深入理解计算机系统 第3版》第4章 处理器体系架构 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《深入理解计算机系统 第3版》第4章 处理器体系架构</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-03-06 00:00:00" itemprop="dateCreated datePublished" datetime="2023-03-06T00:00:00+08:00">2023-03-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-07-30 00:00:00" itemprop="dateModified" datetime="2023-07-30T00:00:00+08:00">2023-07-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/computer-system/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>32k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　CPU支持的指令及其字节级编码称为该CPU的<strong>指令集体系结构</strong>。定义指令集体系结构包括定义各种状态单元、指令集、指令集编码、编码规范和异常事件处理。</p><p>　　x86-64也称为<span style="background-color:#ff0">复杂指令集计算机</span>，与<span style="background-color:#ff0">精简指令集计算机</span>相对。从历史角度，先出现了CISC (发音为sisk)，它从最早的计算机演化而来。到20世纪80年代早期，随着计算机设计者加入了很多新指令来支持高级任务 (例如，处理循环缓存、执行十进制数计算和多项式求值)，计算机的指令集已经变得很庞大。最早的CPU出现在20世纪70年代早期，因为当时的集成电路技术极大地限制了芯片的功能，其指令集很有限。CPU发展得很快，到20世纪80年代早期，计算机的指令集复杂度一直都在增加。x86家族沿着这条道路发展到IA32，然后是x86-64。即使是x86系列也仍在不断地变化，基于新出现的应用的需求，增加新的指令类。</p><p>　　RISC (发音为risk) 的设计理念发展于20世纪80年代早期，作为上述发展趋势的代替方案。IBM的一些硬件和编译器专家深受IBM研究员John Cocke的影响，认为可以为更简单的指令集形式生成高效的代码。实际上，很多加到指令集中的高级指令很难被编译器生成，所以很少被用到。较简单的指令集可以用更少的硬件实现，能以高效的流水线结构组织起来。直到多年后，IBM才将这个理念商品化，开发了Power和PowerPC ISA。加州大学伯克利分校的David Patterson和斯坦福大学的John Hennessy进一步发展了RISC的概念。Patterson将这种新的机器类型命名为RISC，而将之前的那种机器命名为CISC，因为以前没有必要为1种几乎通用的指令集命名。</p><table><colgroup><col style="width:50%"><col style="width:50%"></colgroup><thead><tr><th>CISC</th><th>早期RISC</th></tr></thead><tbody><tr><td>指令数量很多。</td><td>指令数量很少，通常少于100个。</td></tr><tr><td>有些指令的执行时间很长，包括将整个块从内存的某个部分复制到其他部分的指令以及将多个寄存器的值复制到内存或从内存复制到多个寄存器的指令。</td><td>没有执行时间较长的指令。部分早期的RISC甚至没有整数乘法指令，要求编译器通过加法来实现。</td></tr><tr><td>编码长度可变，x86-64的指令长度可以是1~15B。</td><td>编码长度固定，通常所有的指令都编码为4B。</td></tr><tr><td>指定操作数的形式多样，x86-64中的内存引用可以包括偏移量、基址寄存器、变址寄存器和伸缩因子。</td><td>寻址方式简单，通常只有基址和偏移量寻址。</td></tr><tr><td>可以对内存引用和寄存器操作数进行算术和逻辑运算。</td><td>只能对寄存器操作数进行算术和逻辑运算。允许使用内存引用操作数的指令只有<code>load</code>和<code>store</code>，<code>load</code>是从内存读数据到寄存器，<code>store</code>是从寄存器写数据到内存，这种方法称为load/store体系结构。</td></tr><tr><td>实现细节对机器级程序不可见。ISA提供了程序和执行细节之间的清晰的抽象。</td><td>实现细节对机器级程序可见。有些RSIC机器禁止某些特殊的指令序列，而有些跳转指令要到下一条指令执行完后才会生效。编译器必须在这些约束条件下进行性能优化。</td></tr><tr><td>有条件码。作为指令执行的副产品，设置了一些特殊的标志位，用于条件跳转判断。</td><td>没有条件码。对于条件判断，要用明确的判断指令，这些指令会将判断结果存储1个普通寄存器中。</td></tr><tr><td>栈密集的过程链接。栈用于存取过程参数和返回地址。</td><td>寄存器密集的过程链接。寄存器用于存取过程参数和返回地址，所以有些过程无需内存引用。CPU通常有更多的寄存器 (最多32个)。</td></tr></tbody></table><p>　　20世纪80年代，计算机体系结构领域里关于RISC指令集和CISC指令集优缺点的争论十分激烈。RISC的支持者声称在给定硬件数量的情况下，通过结合简化的指令集设计、高级编译器技术和流水线化的CPU实现，RISC能获得更强的计算性能。CISC的拥趸反驳称完成给定任务需要的RISC指令更少，所以RISC有更强的总体性能。20世纪90年代早期，争论逐渐平息，因为事实很清楚，单独的RISC或CISC都不如结合两者的精华。CISC后来的发展中加入了很多的指令 (包括需要多个执行周期的指令) 和高性能流水线结构。现在的RISC指令集中有数百条指令，几乎与其名称不相匹配，而那种将实现细节暴露给机器级程序的思想已经被证明是目光短浅的。</p><p>　　大多数公司都推出了RISC CPU系列产品，包括Sun Microsystem (SPARC)、IBM和Motorola (PowerPC) 以及Digital Equipment Corporation (Alpha)。英国公司Acorn Computer Ltd.推出了自己的体系结构Acorn RISC Machine (ARM)，广泛应用于嵌入式系统中。</p><p>　　Y86-64指令集兼具CISC和RISC指令集的特点。和CISC一样，它有条件码和长度可变的指令，并且用栈来保存返回地址。和RISC一样的是，它使用load/store体系结构和常规指令编码，并且通过寄存器来传递过程参数。Y86-64指令集可以视为根据某些RISC原理简化后CISC指令集 (x86)。</p><p>　　从头到尾执行1条指令所需的时间称为<strong>延迟</strong>。在现代逻辑设计中，电路延迟以微微秒或皮秒 (<span class="math inline">\(10^{-12}\)</span>s) 为单位来计算。</p><p>　　会导致异常的指令称为<strong>异常指令</strong>。</p><span id="more"></span><h3 id="y86-64指令级体系结构">4.1 Y86-64指令级体系结构</h3><p>　　Y86-64程序中的每条指令都会读取或修改CPU状态的某些部分，这些部分称为<strong>程序员可见状态</strong> (这里的程序员包括用汇编代码编写程序的人和生成机器级代码的编译器)。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/y86-64_programmer_visible_state.svg" title="y86-64_programmer_visible_state"><p>　　Y86-64的状态类似于x86-64，有15个程序寄存器、3个1位的CC、PC、程序状态和内存。相比x86-64，Y86-64省略了寄存器<code>%r15</code>，每个寄存器存储64位的字。CC存储最近的算术或逻辑指令所造成影响的相关信息。PC存储当前正在执行指令的地址。程序状态表明程序执行的总体状态，指示程序是正常运行还是出现了异常。从概念角度，内存是很大的字节数组，保存着程序和数据。Y86-64程序用<strong>虚拟地址</strong>来引用内存。硬件和操作系统软件协同工作来将虚拟地址转换成实际/物理地址，指明数据实际存储位置。</p><table><thead><tr><th>十六进制数</th><th>寄存器名称</th></tr></thead><tbody><tr><td><code>0x0</code></td><td><code>%rax</code></td></tr><tr><td><code>0x1</code></td><td><code>%rcx</code></td></tr><tr><td><code>0x2</code></td><td><code>%rdx</code></td></tr><tr><td><code>0x3</code></td><td><code>%rbx</code></td></tr><tr><td><code>0x4</code></td><td><code>%rsp</code></td></tr><tr><td><code>0x5</code></td><td><code>%rbp</code></td></tr><tr><td><code>0x6</code></td><td><code>%rsi</code></td></tr><tr><td><code>0x7</code></td><td><code>%rdi</code></td></tr><tr><td><code>0x8</code></td><td><code>%r8</code></td></tr><tr><td><code>0x9</code></td><td><code>%r9</code></td></tr><tr><td><code>0xA</code></td><td><code>%r10</code></td></tr><tr><td><code>0xB</code></td><td><code>%r11</code></td></tr><tr><td><code>0xC</code></td><td><code>%r12</code></td></tr><tr><td><code>0xD</code></td><td><code>%r13</code></td></tr><tr><td><code>0xE</code></td><td><code>%r14</code></td></tr><tr><td><code>0xF</code></td><td>无寄存器</td></tr></tbody></table><p>　　Y86-64的15个程序寄存器都有对应的<strong>寄存器ID</strong> (范围在<code>0x0</code>~<code>0xE</code>之间)。程序寄存器存在CPU中的寄存器文件中，寄存器文件是以寄存器ID作为地址的存储器。当不需要存取寄存器时，用ID值<code>0XF</code>表示。</p><h4 id="y86-64指令">4.1.1 Y86-64指令</h4><p>　　Y86-64指令集可以视为是x86-64指令集的子集，它只包括8B整数操作，并且寻址方式和操作更少。由于仅使用8B的数据，所以把<span style="background-color:#ff0">8B的数据称为字</span>也不会有任何歧义。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/y86-64_instruction_set.svg" title="y86-64_instruction_set"><p>　　对于Y86-64，有些指令只有1B，而其他指令更长。首先，可能有额外的<strong>寄存器指示符字节</strong>，用于指定1或2个寄存器，即<code>rA</code>和<code>rB</code>。对于只有1个寄存器的指令，另一个寄存器ID为<code>0xF</code>。其次，可能有额外的8B<strong>常数字</strong>，可作为立即数、指令<code>rmmovq</code>和<code>mrmovq</code>的地址指示符的偏移量以及跳转指令和调用指令的目的地址。</p><p>　　Y86-64的跳转指令和调用指令的目的地址是<span style="background-color:#ff0">绝对地址</span>，而非像IA32中那样使用PC相对寻址。CPU使用PC相对寻址时，跳转指令的编码会更简洁，同时能允许代码从内存的某部分复制到其他部分而无需更新所有的分支目标地址。</p><p>　　Y86-64中的所有整数都是小端编码。例如，用十六进制编码<code>rmmovq %rsp, 0x123456789abcd(%rdx)</code>时，第1个字节是<code>0x40</code>，栈指针在字段<code>rA</code>中，<code>%rdx</code>在字段<code>rB</code>中，需要偏移量在前面填上<code>0x0</code>使之变成8B，最后结果为<code>0x4042cdab896745230100</code>。</p><p>　　Y86-64的数据移动指令<code>movq</code>包括<code>irmovq</code>、<code>rrmovq</code>、<code>mrmovq</code>和<code>rmmovq</code>，其名称中的前2个字母分别表示源和目的操作数的格式，<code>i</code>表示立即数，<code>r</code>表示寄存器，<code>m</code>表示内存引用。内存引用是简单的基址和偏移量形式，<span style="background-color:#ff0">不支持</span>第2变址寄存器和寄存器值的伸缩。同x86-64一样，不允许将立即数移动到内存和直接将数据从某个内存位置移动到其他内存位置。</p><p>　　Y86-64的整数操作指令<code>OPq</code>包括<code>adq</code>、<code>subq</code>、<code>andq</code>和<code>xorq</code>，它们<span style="background-color:#ff0">只对寄存器数据进行操作</span>，会设置CC中的零标志ZF、符号标志SF和溢出标志OF。x86-64的同类指令还可以对内存数据进行操作。</p><p>　　Y86-64的跳转指令<code>jXX</code>包括<code>jmp</code>、<code>jle</code>、<code>jl</code>、<code>je</code>、<code>jne</code>、<code>jge</code>和<code>jg</code>，根据分支指令的类型和CC的值来选择分支，分支条件和x86-64相同。</p><p>　　Y86-64的条件移动指令<code>cmovXX</code>包括<code>cmovle</code>、<code>cmovl</code>、<code>cmove</code>、<code>cmovne</code>、<code>comvge</code>和<code>cmovg</code>，这些指令的操作数格式同指令<code>rrmovq</code>相同，但只有当CC满足条件时才更新目的寄存器的值。</p><p>　　Y86-64的指令<code>call</code>会将返回地址压入栈，然后跳转到目的地址，指令<code>ret</code>会从这样的调用中返回。指令<code>pushq</code>和<code>popq</code>同x86-64中相同。指令<code>halt</code>会停止指令的执行，对应x86-64中的指令<code>hlt</code>，但x86-64应用程序不允许使用该指令，因为它会导致整个系统暂停。对于Y86-64，指令<code>halt</code>会导致CPU停止并将状态码置为<code>HLT</code>。</p><p>　　大多数Y86-64指令以简单明了的方式修改程序状态，但有2条指令是例外，即<code>pushq</code>和<code>popq</code>。<code>pushq</code>会把栈指针减8并将寄存器值写入内存中。因此，当执行<code>pushq %rsp</code>时，CPU的行为是不确定的，可能有2种情况，即压入栈指针的原始值和压入减8后栈指针的值，Y86-64采用了和x86-64一样的做法，<span style="background-color:#ff0">压入的是原始值</span>。同样，对于<code>popq %rsp</code>，<span style="background-color:#ff0">弹出的是栈顶的值</span>。对于IA32，从Intel 286开始，<code>PUSH ESP</code>会将寄存器的原始值压入栈 (IA32体系结构的实地址模式和虚8086模式以及Intel 64位体系结构也是如此)，而Intel 8086压入的则是减后的值。然而，<code>POP ESP</code>不存分歧。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/function_codes_for_y86-64_instruction_set.svg" title="function_codes_for_y86-64_instruction_set"><p>　　Y86-64指令的字节级编码中的第1个字节表示指令的类型，其中高4位表示<span style="background-color:#ff0">代码</span>部分，低4位表示<span style="background-color:#ff0">功能</span>部分。代码部分的值为<code>0x0</code>~<code>0xB</code>，功能部分只有在代码部分相同时才有用。</p><p>　　Y86-64状态码Stat用于描述程序程序的总体状态。</p><table><thead><tr><th>Stat值</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>AOK</td><td>正常操作</td></tr><tr><td>2</td><td>HLT</td><td>执行<code>halt</code>指令</td></tr><tr><td>3</td><td>ADR</td><td>非法地址</td></tr><tr><td>4</td><td>INS</td><td>非法指令</td></tr></tbody></table><p>　　当Stat的值不为1时，表示发生了某种类型的<span style="background-color:#ff0">异常</span>，CPU会停止执行指令。在更完整的设计中，CPU通常会调用<strong>异常处理程序</strong>，该过程可以配置为不同的结果，例如，中止程序或调用用户自定义的<strong>信号处理程序</strong>。</p><h4 id="y86-64程序">4.1.2 Y86-64程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> *start, <span class="type">long</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += *start;</span><br><span class="line">        start++;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 从地址0开始执行</span><br><span class="line">0x000:                          .pos 0</span><br><span class="line">0x000: 30f40002000000000000     irmovq stack, %rsp  # 设置栈指针</span><br><span class="line">0x00a: 803800000000000000       call main           # 执行主程序</span><br><span class="line">0x013: 00                       halt                # 结束程序</span><br><span class="line"></span><br><span class="line"># 包括4个元素的数组</span><br><span class="line">0x018:                          .align 8</span><br><span class="line">0x018:                      array: </span><br><span class="line">0x018: 0d000d000d000000         .quad 0x000d000d000d</span><br><span class="line">0x020: c000c000c0000000         .quad 0x00c000c000c0</span><br><span class="line">0x028: 000b000b000b0000         .quad 0x0b000b000b00</span><br><span class="line">0x030: 00a000a000a00000         .quad 0xa000a000a000</span><br><span class="line"></span><br><span class="line">0x038:                      main:</span><br><span class="line">0x038: 30f71800000000000000     irmovq  array, %rdi</span><br><span class="line">0x042: 30f60400000000000000     irmovq  $4, %rsi</span><br><span class="line">0x04c: 805600000000000000       call sum</span><br><span class="line">0x055: 90                       ret</span><br><span class="line"></span><br><span class="line"># long sum(long *start, long count)</span><br><span class="line"># start在寄存器%rdi, count在寄存器%rsi</span><br><span class="line">0x056:                      sum:</span><br><span class="line">0x056: 30f80800000000000000     irmovq  $8, %r8</span><br><span class="line">0x060: 30f90100000000000000     irmovq  $1, %r9</span><br><span class="line">0x06a: 6300                     xorq    %rax, %rax</span><br><span class="line">0x06c: 6266                     andq    %rsi, %rsi</span><br><span class="line">0x06e: 708700000000000000       jmp test</span><br><span class="line">0x077:                      loop:</span><br><span class="line">0x077: 50a70000000000000000     mrmovq  (%rdi), %r10</span><br><span class="line">0x081: 60a0                     addq    %r10, %rax</span><br><span class="line">0x083: 6087                     addq    %r8, %rdi</span><br><span class="line">0x085: 6196                     subq    %r9, %rsi</span><br><span class="line">0x087:                      test:</span><br><span class="line">0x087: 747700000000000000       jne loop;</span><br><span class="line">0x090: 90                       ret</span><br><span class="line"></span><br><span class="line"># 栈的起始地址</span><br><span class="line">0x200:                          .pos 0x200</span><br><span class="line">0x200:                      stack:</span><br></pre></td></tr></table></figure><p>　　<code>.pos</code> (第2行) 表示应该从地址0处开始生成代码，该地址是所有Y86-64程序的起始地址。接下来的指令 (第3行) 会初始化栈指针。在程序的结尾 (第40行) 声明了标签<code>stack</code>并用<code>.pos</code>表示地址<code>0x200</code> (第39行)，所以栈会从该地址开始并向低地址增长。第8~13行会声明1个4字的数组，标签<code>array</code>表示数组的起始地址，标签<code>.align</code>表示按8B对齐。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 停在34步，PC = 0x13, status &#x27;HLT&#x27;, CC: Z = 1 O = 0</span><br><span class="line"># 寄存器的变化</span><br><span class="line">%rax:   0x0000000000000000  0x0000abcdabcdabcd</span><br><span class="line">%rsp:   0x0000000000000000  0x0000000000000200</span><br><span class="line">%rdi:   0x0000000000000000  0x0000000000000038</span><br><span class="line">%r8:    0x0000000000000000  0x0000000000000008</span><br><span class="line">%r9:    0x0000000000000000  0x0000000000000001</span><br><span class="line">%r10:   0x0000000000000000  0x0000a000a000a000</span><br><span class="line"></span><br><span class="line"># 内存的变化</span><br><span class="line">0x01f0: 0x0000000000000000  0x0000000000000055</span><br><span class="line">0x01f8: 0x0000000000000000  0x0000000000000013</span><br></pre></td></tr></table></figure><p>　　这是在通过Y86-64指令集模拟器执行函数<code>sum()</code>的Y86-64代码的输出。第1行表示执行情况以及PC和程序状态的值。之后的输出中左侧是原始值，右侧是改变后的值。栈指针的从<code>0x200</code>开始向低地址增长，栈的使用导致内存地址<code>0x01f0</code>~<code>0x0f18</code>中的值发生了变化。可执行代码的最大地址为<code>0x090</code>，所以出入栈不会损坏可执行代码。</p><h3 id="逻辑设计和硬件控制语言">4.2 逻辑设计和硬件控制语言</h3><p>　　在硬件设计中，电子电路用于计算位运算的函数以及在各种存储单元中存储位。大多数现代电路技术用信号线上的高电压或低电压来表示不同的位，例如，用1.0V左右的高电压表示逻辑1，用0.0V左右的低电压表示逻辑0。要实现数字系统需要<span style="background-color:#ff0">计算位操作函数的组合逻辑</span>、<span style="background-color:#ff0">存储位的存储器单元</span>和<span style="background-color:#ff0">控制存储器单元更新的时钟信号</span>。</p><p>　　过去，硬件设计者通过描绘示意性的逻辑电路图来进行电路设计 (最早是用纸和笔，后来用计算机图像终端)。现在，大多数设计都是用<strong>硬件描述语言</strong>。HDL属于文本表示，看上去类似汇编，但用于描述硬件结构而非程序行为。最常用的HDL是Verilog和VHDL，Verilog的语法类似于C语言，VHDL的语法类似于Ada语言。这些语言用于表示数字电路的模拟模型。20世纪80年代中期，出现了<strong>逻辑合成</strong>程序，它可以根据HDL的描述生成有效的电路设计。现在有很多商用的合成程序，已成为生成数字电路的主要技术。从手工设计电路到合成生成的转变类似从写汇编程序到写高级语言程序，再用编译器来生成机器代码的转变。</p><p>　　之后的内容使用的是<strong>硬件控制语言</strong>。HCL仅描述硬件设计的控制部分，支持的操作很有限，并且没有模块化。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/logic_gate_types.svg" title="logic_gate_types"><p>　　<strong>逻辑门</strong>是数字电路的基本计算单元。逻辑门总是活动的，一旦其输入发生了变化，在很短的时间内，输出就会相应地变化。</p><p>　　将很多个逻辑门组合在一起就能构成计算块，称为<strong>组合电路</strong>。</p><p>　　● 每个逻辑门要么连接到系统输入 (称为<span style="background-color:#ff0">主输入</span>)，要么是某个存储器单元或逻辑门的输出。</p><p>　　● 2个及以上的逻辑门的输出不能连接在一起，否则，可能会导致信号冲突。</p><p>　　● 组合电路必须是无环的，否则，可能会导致计算的函数有歧义。</p><h4 id="位级的组合电路">4.2.1 位级的组合电路</h4><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/combinational_circuit_to_test_for_bit_equality.svg" title="combinational_circuit_to_test_for_bit_equality"><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool eq = (a &amp;&amp; b) || (!a &amp;&amp; !b);</span><br></pre></td></tr></table></figure><p>　　这是判断位相等的组合电路的的电路图和HCL函数。从HCL代码中可以看出，数据类型<code>bool</code>表示输出<code>eq</code>是位信号，输入是<code>a</code>和<code>b</code>。<code>!eq</code>是异或，即在输出前加上1个非门。HCL使用了C语言风格，但其并非将执行结果存储内存中，只是为表达式命名。C语言的逻辑表达式可能部分求值，对于<code>a &amp;&amp; fun(b)</code>，当<code>a</code>为0时，<code>fun(b)</code>就不会执行，但HCL不会这样，它只是响应输入的变化。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/single-bit_multiplexor_circuit.svg" title="single-bit_multiplexor_circuit"><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool <span class="keyword">out</span> = (s &amp;&amp; a) || (!s &amp;&amp; b);</span><br></pre></td></tr></table></figure><p>　　这是位<strong>多路复用器</strong>的组合电路和HCL函数。2个数据信号是输入位<code>a</code>和<code>b</code>，控制信号是输入位<code>s</code>。当<code>s</code>为1时，输出是<code>a</code>；当<code>s</code>为0时，输出是<code>b</code>。</p><h4 id="字级的组合电路">4.2.2 字级的组合电路</h4><p>　　执行字运算的组合电路由逻辑门构成，根据输入字的每个位来计算输出字的每个位。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/combinational_circuit_to_test_for_word_equality.svg" title="combinational_circuit_to_test_for_word_equality"><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool Eq = (A == B);</span><br></pre></td></tr></table></figure><p>　　这是判断字相等的组合电路和HCL函数，当且仅当2个字中的所有位都相等时，输出才为1，该电路将64个判断位相等的组合电路的输出和与门连接。此外，也可以通过将64个位异或的组合电路的输出和与门连接，最后在与门后连接1个非门来实现。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/word-level_multiplexor_circuit.svg" title="word-level_multiplexor_circuit"><p>　　这是字多路复用器的组合电路和HCL函数，根据输入控制位<code>s</code>，生成64位的字<code>Out</code>，等于<code>A</code>或<code>B</code>中的1个。该电路由64个位多路复用器组成，但这里仅使用了1个非门。</p><p>　　CPU中会使用很多种多路复用器，能够根据某些控制条件，从许多源中选出1个字。在HCL中，多路复用函数用<strong>情况表达式</strong>表示。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    select_1 : expr_1;</span><br><span class="line">    select_2 : expr_2;</span><br><span class="line">    ...</span><br><span class="line">    select_k : expr_k;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>　　情况表达式包含了多种情况，每种情况<code>i</code>都有布尔表达式<code>select_i</code>和整数表达式<code>expr_i</code>，前者表示选择该情况的条件，后者表示得到的值。与C语言中的<code>case</code>语句不同的时，情况表达式的布尔表达式之间不必互斥。从逻辑角度，这些选择表达式是按顺序计算的，第1个值为1的情况会被选择。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/four-way_multplexor.svg" title="four-way_multplexor"><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">word Out4 = </span><br><span class="line">[</span><br><span class="line">    !s1 &amp;&amp; !s0  : A; # <span class="number">00</span></span><br><span class="line">    !s1         : B; # <span class="number">01</span></span><br><span class="line">    !s0         : C; # <span class="number">10</span></span><br><span class="line">    <span class="number">1</span>           : D; # <span class="number">11</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>　　这是四路复用器的HCL，其中<code>#</code>开头的注释表示选择该情况时<code>s1</code>和<code>s0</code>的值。选择表达式有时可以简化，例如，第2个表达式简写为<code>!s1</code>而非<code>!s1 &amp;&amp; s0</code>，因为当<code>s0</code>为0的情况已经出现在第1个表达式中，同样，第3个表达式简写为<code>!s0</code>，第4个表达式简写为<code>1</code>。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/alu.svg" title="alu"><p>　　<strong>算术逻辑单元</strong>有2个数据输入 (A和B) 和1个控制输入，电路对数据输入执行的算术或逻辑操作根据控制输入决定。ALU的4个操作对应Y86-64指令集的4种整数操作指令。</p><h4 id="存储器和时钟">4.2.3 存储器和时钟</h4><p>　　实际上，组合电路不存储任何信息，相反，它们只是简单地响应输入信号，生成对应的输出。为了生成<strong>时序电路</strong> (具有状态并对该状态进行计算的系统)，必须加入按位存储信息的设备。存储设备都是由同一<strong>时钟</strong>控制，时钟是周期性信号，决定何时把新值加载到设备中。</p><p>　　● <strong>时钟寄存器</strong> (简称寄存器) 存储单个位或字。时钟信号控制寄存器输入值的加载。</p><p>　　● <strong>存储器</strong>存储多个字，用地址来决定待读写的字。例如，CPU的虚拟内存系统和寄存器文件。</p><p>　　寄存器在硬件和机器级编程的含义略有不同。在硬件中，寄存器直接将其输入和输出线连接到电路的其他部分。在机器级编程中，寄存器表示CPU中为数不多的可寻址的字，地址是寄存器ID，这些字通常存储在寄存器文件中，虽然硬件有时可以直接将字从某个指令移动到其他指令，以避免先写寄存器文件再读的延迟。为了避免歧义，这2类寄存器称为<span style="background-color:#ff0">硬件寄存器</span>和<span style="background-color:#ff0">程序寄存器</span>。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/register_operation.svg" title="register_operation"><p>　　硬件寄存器通常都保持在稳定状态<code>x</code>，其输出为其当前状态。信号会沿寄存器前面的组合逻辑传播，生成新的寄存器输入<code>y</code>，但只要时钟保持低电位，寄存器的输出不变。当时钟变为高电位时，输入信号加载到寄存器，寄存器变为下一个状态<code>y</code>，在下一个时钟上升沿前，寄存器的输出不变。寄存器作为电路不同部分中的组合逻辑之间的屏障。每当时钟上升沿时，值才会从寄存器的输入移动到输出。Y86-64会用时钟寄存器保存PC、CC和程序状态。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/register_file.svg" title="register_file"><p>　　寄存器文件有2个读端口 (A和B) 和1个写端口 (W)，这样的多端口存储器允许同时进行多个读或写操作。它可以读2个程序寄存器的值，同时更新第3个寄存器的状态。每个端口都有1个地址输入 (表示程序寄存器) 和1个数据输入/输出 (表示程序寄存器的值)。地址输入是寄存器ID。2个读端口都有地址输入 (<code>srcA</code>和<code>srcB</code>) 和数据输出 (<code>valA</code>和<code>valB</code>)。写端口有地址输入 (<code>dstW</code>) 和数据输入 (<code>valW</code>)。</p><p>　　寄存器文件不是组合电路，因为它有内部存储。不过，在这里的实现中，从寄存器文件读数据就好像它是以地址为输入、数据为输出的组合逻辑块。当<code>srcA</code>或<code>srcB</code>为某个寄存器ID时，在一段时间后，存储在对应程序寄存器的值就会出现在<code>valA</code>或<code>valB</code>。例如，将<code>srcA</code>置为<code>0x3</code>，就会读程序寄存器<code>%rbx</code>的值，这个值会出现在输出<code>valA</code>。</p><p>　　写寄存器文件由时钟信号控制，控制方式类似将值加载到时钟寄存器。每次时钟上升时，输入<code>valW</code>的值会写入到输入<code>dstW</code>的寄存器ID对应的程序寄存器。当<code>dstW</code>为<code>0xF</code>时，不会写任何寄存器。若更新某个寄存器的同时在读端口上用该寄存器ID，则会出现从旧值到新值的变化。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/data_memory.svg" title="data_memory"><p>　　CPU有1个存储器用于存储程序数据，该存储器有1个地址输入、1个数据输入和1个数据输出。同寄存器文件一样，该存储器的操作方式类似于组合逻辑，在地址输入中输入地址并将写控制信号置0，经过一段时间后，存储在该地址上的值会出现在数据输出。若地址超出范围 (这里的边界检查就是地址输入的函数，不涉及保存任何状态)，异常信号会置1；否则，置0。写该存储器是时钟控制的，在地址输入输入地址、数据输入输入数据和将写控制信号置1后，只要地址是合法的，就会更新对应的值。CPU还包括1个只读存储器，用于读指令。在大多数实际系统中，这2个存储器合并为1个具有双端口的存储器，分别用于读指令和读写数据。</p><h3 id="y86-64的顺序实现">4.3 Y86-64的顺序实现</h3><p>　　这里的实现以SEQ为例，每个时钟周期内，SEQ会执行处理1条指令所需的所有步骤，但这需要很长的时钟周期时间，所以时钟周期频率会很低。处理1条指令通常需要<strong>取指</strong>、<strong>译码</strong>、<strong>执行</strong>、<strong>访存</strong>、<strong>写回</strong>、<strong>更新PC</strong>。CPU会一直循环这几个阶段，这里简化了实现，当出现异常时 (执行指令<code>halt</code>/非法指令和读写非法地址)，CPU就会停止，在更完整的设计中，CPU会进入异常处理模式，开始执行异常类型决定的特殊代码。</p><p>　　● 在取指阶段，会以PC为内存地址来读取指令，再从指令中提取出指令指示符的2个4位的字段 (<strong>指令代码</strong>和<strong>指令功能</strong>)。这里可能会取出1B的寄存器ID字段，表示1或2个寄存器操作数指示符<code>rA</code>和<code>rB</code>。这里还可能取出8B的常数字段<code>valC</code>，用于计算下一条指令的地址<code>valP</code> (<code>valP</code>的值为PC的值加上取出指令的长度)。</p><p>　　● 在译码阶段，会从寄存器文件读取最多2个操作数，得到值<code>val</code>和/或<code>valB</code>。通常，这里读指令中<code>rA</code>和<code>rB</code>字段指明的寄存器，不过有些指令读栈指针。</p><p>　　● 在执行阶段，ALU要么执行指令指明的操作数 (根据<code>ifun</code>)，计算内存引用的有效地址，加/减栈指针，得到值<code>valE</code>，这里可能会设置CC。对于条件移动指令，该阶段会检查CC和移动条件 (由<code>ifun</code>给出)，若条件成立，则更新目标寄存器。同样，条件跳转指令也会进行条件判断。</p><p>　　● 在访存阶段，可能会读写内存，这里将读取的值表示为<code>valM</code>。</p><p>　　● 在写回阶段，会写最多2个结果到寄存器文件。</p><p>　　● 在更新PC阶段，会将PC设置为下一条指令的地址。</p><p>　　SEQ并不能充分利用硬件单元，因为每个单元仅在整个时钟周期中的一部分时间才被使用。</p><h4 id="将处理组织成阶段">4.3.1 将处理组织成阶段</h4><table><colgroup><col style="width:3%"><col style="width:32%"><col style="width:32%"><col style="width:32%"></colgroup><thead><tr><th>阶段</th><th style="text-align:left"><code>Opq rA, rB</code></th><th><code>rrmovq rA, rB</code></th><th style="text-align:left"><code>irmovq V, rB</code></th></tr></thead><tbody><tr><td>取指</td><td style="text-align:left"><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>rA:rB</code> ← <code>M1[PC + 1]</code>; <code>valP</code> ← <code>PC + 2</code></td><td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>ra:rB</code> ← <code>M1[PC + 1]</code>; <code>valP</code> ← <code>PC + 2</code></td><td style="text-align:left"><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>rA:rB</code> ← <code>M1[PC + 1]</code>; <code>valC</code> ← <code>M8[PC + 2]</code>; <code>valP</code> ← <code>PC + 10</code></td></tr><tr><td>译码</td><td style="text-align:left"><code>valA</code> ← <code>R[rA]</code>; <code>valB</code> ← <code>R[rB]</code></td><td><code>valA</code> ← <code>R[rA]</code></td><td style="text-align:left"></td></tr><tr><td>执行</td><td style="text-align:left"><code>valE</code> ← <code>valB OP valA</code>; <code>Set CC</code></td><td><code>valE</code> ← <code>valA</code></td><td style="text-align:left"><code>valE</code> ← <code>valC</code></td></tr><tr><td>访存</td><td style="text-align:left"></td><td></td><td style="text-align:left"></td></tr><tr><td>写回</td><td style="text-align:left"><code>R[rB]</code> ← <code>valE</code></td><td><code>R[rB]</code> ← <code>valE</code></td><td style="text-align:left"><code>R[rB]</code> ← <code>valE</code></td></tr><tr><td>更新PC</td><td style="text-align:left">PC ← <code>valP</code></td><td>PC ← <code>valP</code></td><td style="text-align:left">PC ← <code>valP</code></td></tr></tbody></table><p>　　这些指令都是计算1个值并将结果存储在寄存器中。<code>icode:ifun</code>表示指令代码和指令功能，<code>rA:rB</code>表示寄存器指示符字节中的<code>ra</code>和<code>rB</code>。<code>M1[x]</code>表示访存位置<code>x</code>处的1B，同理，<code>M8[x]</code>表示访问该位置的8B。</p><p>　　对于整数操作指令，其编码长度为2B，所以取指阶段中<code>valP</code>为<code>PC + 2</code>。在译码阶段，会读取2个操作数。在执行阶段，会将操作数和<code>ifun</code>一起提供给ALU，其中具体的整数操作由<code>ifun</code>指定，得到<code>valE</code>，这里会设置CC。整数操作指令不涉及内存访问，所以访存阶段什么也不做。在写回阶段，会将<code>valE</code>写回寄存器<code>rB</code>。在更新PC阶段，会将<code>PC</code>设置为<code>valP</code>。指令<code>rrmovq</code>和<code>irmivq</code>与之类似。</p><table style="width:100%"><colgroup><col style="width:4%"><col style="width:47%"><col style="width:47%"></colgroup><thead><tr><th>阶段</th><th><code>rmmovq rA, D(rB)</code></th><th><code>mrmovq D(rB), rA</code></th></tr></thead><tbody><tr><td>取指</td><td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>rA:rB</code> ← <code>M1[PC + 1]</code>; <code>valC</code> ← <code>M8[PC + 2]</code>; <code>valP</code> ← <code>PC + 10</code></td><td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>rA:rB</code> ← <code>M1[PC + 1]</code>; <code>valC</code> ← <code>M8[PC + 2]</code>; <code>valP</code> ← <code>PC + 10</code></td></tr><tr><td>译码</td><td><code>valA</code> ← <code>R[rA]</code>; <code>valB</code> ← <code>R[rB]</code></td><td><code>valB</code> ← <code>R[rB]</code></td></tr><tr><td>执行</td><td><code>valE</code> ← <code>valB + valC</code></td><td><code>valE</code> ← <code>valB + valC</code></td></tr><tr><td>访存</td><td><code>M8[valE]</code> ← <code>valA</code></td><td><code>valM</code> ← <code>M8[valE]</code></td></tr><tr><td>写回</td><td></td><td><code>R[rA]</code> ← <code>valM</code></td></tr><tr><td>更新PC</td><td>PC ← <code>valP</code></td><td>PC ← <code>valP</code></td></tr></tbody></table><p>　　指令<code>rmmovq</code>和<code>mrmovq</code>的流程和整数操作指令的类似，不过会用ALU来加<code>valC</code>和<code>valB</code>得到内存操作的有效地址。在访存阶段，会将寄存器值<code>valA</code>写到内存或从内存读到<code>valM</code>。</p><table style="width:100%"><colgroup><col style="width:4%"><col style="width:47%"><col style="width:47%"></colgroup><thead><tr><th>阶段</th><th><code>pushq rA</code></th><th><code>popq rA</code></th></tr></thead><tbody><tr><td>取指</td><td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>rA:rB</code> ← <code>M1[PC + 1]</code>; <code>valP</code> ← <code>PC + 2</code></td><td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>rA:rB</code> ← <code>M1[PC + 1]</code>; <code>valP</code> ← <code>PC + 2</code></td></tr><tr><td>译码</td><td><code>valA</code> ← <code>R[rA]</code>; <code>valB</code> ← <code>R[%rsp]</code></td><td><code>valA</code> ← <code>R[%rsp]</code>; <code>valB</code> ← <code>R[%rsp]</code></td></tr><tr><td>执行</td><td><code>valE</code> ← <code>valB - 8</code></td><td><code>valE</code> ← <code>valB + 8</code></td></tr><tr><td>访存</td><td><code>M8[valE]</code> ← <code>valA</code></td><td><code>valM</code> ← <code>M8[valA]</code></td></tr><tr><td>写回</td><td><code>R[%rsp]</code> ← <code>valE</code></td><td><code>R[%rsp]</code> ← <code>valE</code>; <code>R[rA]</code> ← <code>valM</code></td></tr><tr><td>更新PC</td><td>PC ← <code>valP</code></td><td>PC ← <code>valP</code></td></tr></tbody></table><p>　　对于指令<code>pushq</code>，在译码阶段，会用栈指针作为第2个操作数并赋值给<code>valB</code>。在执行阶段，会将栈指针减8，得到的值作为访存阶段中的内存地址。</p><p>　　指令<code>popq</code>的流程与指令<code>pushq</code>的类似，不同的是译码阶段会读取<span style="background-color:#ff0">2次</span>栈指针分别赋值给<code>valA</code>和<code>valB</code>。在执行阶段，会将栈指针加8，得到的值用于写回阶段中写回给栈指针。在访存阶段，会读取栈指针，得到的值用于写回阶段中写回寄存器<code>rA</code>。</p><table><colgroup><col style="width:3%"><col style="width:35%"><col style="width:35%"><col style="width:25%"></colgroup><thead><tr><th>阶段</th><th><code>jxx Dest</code></th><th><code>call Dest</code></th><th><code>ret</code></th></tr></thead><tbody><tr><td>取指</td><td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>valC</code> ← <code>M8[PC + 1]</code>; <code>valP</code> ← <code>PC + 9</code></td><td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>valC</code> ← <code>M8[PC + 1]</code>; <code>valP</code> ← <code>PC + 9</code></td><td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>valP</code> ← <code>PC + 1</code></td></tr><tr><td>译码</td><td></td><td><code>valB</code> ← <code>R[%rsp]</code></td><td><code>valA</code> ← <code>R[%rsp]</code>; <code>valB</code> ← <code>R[%rsp]</code></td></tr><tr><td>执行</td><td><code>Cnd</code> ← <code>Cond(CC, ifun)</code></td><td><code>valE</code> ← <code>valB - 8</code></td><td><code>valE</code> ← <code>valB + 8</code></td></tr><tr><td>访存</td><td></td><td><code>M8[valE]</code> ← <code>valP</code></td><td><code>valM</code> ← <code>M8[valA]</code></td></tr><tr><td>写回</td><td></td><td><code>R[%rsp]</code> ← <code>valE</code></td><td><code>R[%rsp]</code> ← <code>valE</code></td></tr><tr><td>更新PC</td><td>PC ← <code>Cnd ? valC : valP</code></td><td>PC ← <code>valC</code></td><td>PC ← <code>valM</code></td></tr></tbody></table><p>　　条件跳转指令的流程与整数操作指令的类似。在执行阶段，会检查CC和跳转条件来确定分支选择 (生成1位的信号<code>Cnd</code>)。在更新PC阶段，会根据<code>Cnd</code>来设置PC，若<code>Cnd</code>为1，则将PC设置为<code>valC</code> (跳转目标)；若<code>Cnd</code>为0，则将PC设置为<code>valP</code>。</p><p>　　指令<code>call</code>和<code>ret</code>的流程与指令<code>pushq</code>和<code>popq</code>的类似，除了将栈指针压入和弹出栈。对于<code>call</code>指令，会将<code>valP</code>压入栈。在更新PC阶段，会将PC设置为<code>valC</code>。对于指令<code>ret</code>，在更新PC阶段，会PC设置为从栈中取出的值<code>valM</code>。</p><h4 id="seq">4.3.2 SEQ</h4><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/seq_hardware_structure.svg" title="seq_hardware_structure"><p>　　在SEQ中，<span style="background-color:#ff0">白色矩形表示时钟寄存器</span>，PC是这里唯一的时钟寄存器。<span style="background-color:#ff0">浅蓝色框表示硬件单元</span>，包括存储器和ALU，这里会使用黑盒 (忽视其细节设计) 来实现。<span style="background-color:#ff0">灰色圆角矩形表示控制逻辑块</span>，这些块用于从一组信号源中进行选择或计算布尔函数。<span style="background-color:#ff0">粗线表示字级别的数据</span>，每条这样的线实际表示1簇64根线，并列地连在一起，将1个字从硬件的某部分移动到其他部分。<span style="background-color:#ff0">细线表示字节级别或更小的数据</span>，根据具体待移动的值，每条这样的线实际表示1簇4或8根线。<span style="background-color:#ff0">虚线表示单个位</span>，表示单元与块之间移动的控制值。</p><h4 id="seq时序">4.3.3 SEQ时序</h4><p>　　SEQ的实现包括组合逻辑和2种存储器，即时钟寄存器 (PC和CC寄存器) 和<span style="background-color:#ff0">随机存取存储器</span> (寄存器文件、指令存储器和数据存储器)。组合逻辑不需要任何时序或控制，只要输入变化，值就通过组合电路传播。读存储器可以视为和组合逻辑一样的操作，根据地址输入生成输出，对于寄存器文件等较小的存储器，这是合理的假设，但对于较大的电路，可以用特殊的时钟电路来模拟。由于指令存储器仅用于读指令，该硬件单元可以视为组合逻辑。</p><p>　　这里还有4个硬件单元需要进行时序控制，即PC寄存器、CC寄存器、数据存储器和寄存器文件。这些单元通过同一时钟信号控制，该信号会触发将新值加载到寄存器和将值写入RAM。PC在每个时钟周期加载新指令的地址。仅当执行整数操作指令时，才会加载CC寄存器。只有执行指令<code>rmmovq</code>、<code>pushq</code>和<code>call</code>时，才会写数据存储器。寄存器文件的2个写端口允许每个时钟周期更新2个程序寄存器。</p><p>　　要控制CPU中活动的时序，只需控制寄存器和存储器的时钟。SEQ硬件实现了与指令执行顺序相同的效果，即使所有状态更新实际上同时发生且仅在时钟上升沿 (即下一个时钟周期的开始)。这种等价性得益于Y86-64指令集的本质——<span style="background-color:#ff0">从不回读</span>，即<span style="background-color:#ff0">CPU永远不需要读指令更新后的状态即可完成指令的处理</span>。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/tracing_two_cycles_of_execution_by_seq.svg" title="tracing_two_cycles_of_execution_by_seq"><p>　　标签1~4分别给出了第3~4行代码的开始和结束时的一些信息，包括4个状态单元以及组合逻辑和状态单元之间的连接。组合逻辑将CC寄存器包围，因为一些组合逻辑 (例如，ALU) 生成CC寄存器的输入，而其他部分 (例如，条件判断和PC选择逻辑) 将CC寄存器作为输入。寄存器文件和数据存储器有独立的读连接和写连接，因为读沿着这些单元传播，就好像它们是组合逻辑，而写操作由时钟控制。</p><p>　　这里假设处理从CC开始，CC的顺序是ZF、SF和OF，设置为100。在时钟周期3开始时 (标签1)，状态单元保持的是周期2中指令<code>irmovq</code>更新后的状态，该指令用浅灰色表示。组合逻辑用白色表示，表示还未对变化后的状态做出反应。时钟周期以地址<code>0x014</code>载入到PC开始，这样会取出并执行指令<code>addq</code>。值会沿着组合逻辑，包括RAM的读。在该周期结束时 (标签2)，组合逻辑会为CC生成了新值000、寄存器<code>%rbx</code>更新后的值和PC的新值<code>0x016</code>。此时，组合逻辑已经根据指令<code>addq</code>更新，但状态还保持着周期2中指令<code>irmovq</code>设置的值。</p><p>　　在时钟周期4开始时 (标签3)，会更新PC、寄存器文件和CC寄存器，所以用蓝色表示，但组合逻辑还未对这些变化做出反应，所以用白色表示。在该周期内，会取出并执行指令<code>je</code>，用深灰色表示。ZF为0，所以不会进行分支选择。在该周期结束时 (标签4)，PC的新值<code>0x01f</code>已经生成，组合逻辑已完成更新，但直到下个周期开始前，状态会保持指令<code>addq</code>设置的值。</p><h4 id="seq各阶段的实现">4.3.4 SEQ各阶段的实现</h4><table><thead><tr><th>名称</th><th>十六进制值</th><th>描述</th></tr></thead><tbody><tr><td><code>IHALT</code></td><td><code>0x0</code></td><td>指令<code>halt</code>的代码</td></tr><tr><td><code>INOP</code></td><td><code>0x1</code></td><td>指令<code>nop</code>的代码</td></tr><tr><td><code>IRRMOVQ</code></td><td><code>0x2</code></td><td>指令<code>rrmovq</code>的代码</td></tr><tr><td><code>IIRMOVQ</code></td><td><code>0x3</code></td><td>指令<code>irmovq</code>的代码</td></tr><tr><td><code>IRMMOVQ</code></td><td><code>0x4</code></td><td>指令<code>rmmovq</code>的代码</td></tr><tr><td><code>IMRMOVQ</code></td><td><code>0x5</code></td><td>指令<code>irmovq</code>的代码</td></tr><tr><td><code>IOPL</code></td><td><code>0x6</code></td><td>整数运算指令的代码</td></tr><tr><td><code>IJXX</code></td><td><code>0x7</code></td><td>跳转指令的代码</td></tr><tr><td><code>ICALL</code></td><td><code>0x8</code></td><td>指令<code>call</code>的代码</td></tr><tr><td><code>IRET</code></td><td><code>0x9</code></td><td>指令<code>ret</code>的代码</td></tr><tr><td><code>IPUSHQ</code></td><td><code>0xA</code></td><td>指令<code>pushq</code>的代码</td></tr><tr><td><code>IPOPQ</code></td><td><code>0xB</code></td><td>指令<code>popq</code>的代码</td></tr><tr><td><code>FNONE</code></td><td><code>0x0</code></td><td>默认功能码</td></tr><tr><td><code>RRSP</code></td><td><code>0x4</code></td><td>寄存器<code>%rsp</code>的ID</td></tr><tr><td><code>RNONE</code></td><td><code>0xF</code></td><td>不访问寄存器</td></tr><tr><td><code>ALUADD</code></td><td><code>0x0</code></td><td>加法运算</td></tr><tr><td><code>SAOK</code></td><td><code>0x1</code></td><td>正常操作状态码</td></tr><tr><td><code>SADR</code></td><td><code>0x2</code></td><td>地址异常状态码</td></tr><tr><td><code>SINS</code></td><td><code>0x3</code></td><td>非法指令异常状态码</td></tr><tr><td><code>SHLT</code></td><td><code>0x4</code></td><td><code>halt</code>状态码</td></tr></tbody></table><p>　　这是一些整数和布尔信号的定义，可以作为HCL操作的参数。它们都是必须显式引用的常数，按照惯例，常数值都是大写。</p><h5 id="取指阶段">4.3.4.1 取指阶段</h5><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/seq_fetch_stage.svg" title="seq_fetch_stage"><p>　　对于取指阶段，指令存储器会以PC作为第1个字节 (字节0) 的地址从存储器<span style="background-color:#ff0">读取10B</span>。第1个字节会解释为指令字节 (标签Split)，分为2个4位的数。然后，标签为icode和ifun的控制逻辑块会计算指令和功能代码，使之等于从指令存储器读取的值，或者指令地址越界时 (信号<code>imem_error</code>表示)，使之等于对应指令<code>nop</code>的值。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool need_regids =</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool need_valC =</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL &#125;;</span><br></pre></td></tr></table></figure><p>　　根据<code>icode</code>计算可以3个1位的信号 (虚线表示)，即<code>instr_valid</code>、<code>need_regids</code>和<code>need_valC</code>。第1个信号表示指令字节是否合法，第2个信号表示指令是否包含1个寄存器ID，第3个信号表示指令是否包含常数。</p><p>　　信号<code>instr_valid</code>和<code>imem_error</code>在访存阶段用于生成CC。</p><p>　　从指令存储器读出的剩余字节是寄存器ID和常数的组合编码 (标签Align)。若<code>need_regids</code>为1，则字节1会拆开并赋值给<code>rA</code>和<code>rB</code>，字节2~9用于生成<code>valC</code>；否则，<code>rA</code>和<code>rB</code>会设置为<code>0xF</code>，字节1~8用于生成<code>valC</code>。</p><p>　　若PC的当前值为<span class="math inline">\(p\)</span>，<code>need_regids</code>的值为<span class="math inline">\(r\)</span>，<code>need_valC</code>的值为<span class="math inline">\(i\)</span>，则PC增加后的值为<span class="math inline">\(p+1+r+8i\)</span>。</p><h5 id="译码和写回阶段">4.3.4.2 译码和写回阶段</h5><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/seq_decode_and_write-back_stage.svg" title="seq_decode_and_write-back_stage"><p>　　寄存器文件有4个端口，支持同时进行2个读操作 (端口A和B) 和2个写操作 (端口E和M)。每个端口都有1个地址连接和数据连接，地址连接是1个寄存器ID，数据连接是1簇64根线，既可以作为寄存器文件的输出字 (对读端口)，也可以作为输入字 (对写端口)。2个读端口的地址输入为<code>srcA</code>和<code>srcB</code>，而2个写端口的地址输入为<code>dstE</code>和<code>dstM</code>。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word srcA = </span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ &#125; : rA;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IPOPQ, IRET &#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word srcB = </span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IOPQ, IRMMOVQ, IMRMOVQ &#125; : rB;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 不考虑条件移动指令</span><br><span class="line">word dstE = </span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRRMOVQ, IIRMOVQ, IOPQ &#125; : rB;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 不考虑条件移动指令</span><br><span class="line">word dstM = </span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IMRMOVQ, IPOPQ &#125; : rA;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>　　<code>srcA</code>和<code>srcB</code>分别表示应该读取哪个寄存器来获取<code>valA</code>和<code>valB</code>。<code>desE</code>和<code>destM</code>分别是端口E和M的目的寄存器ID。</p><p>　　根据<code>icode</code>、<code>rA</code>和<code>rB</code>，可能还会在执行阶段计算<code>Cnd</code>。</p><h5 id="执行阶段">4.3.4.3 执行阶段</h5><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/seq_execute_stage.svg" title="seq_execute_stage"><p>　　对于执行阶段，ALU会根据<code>alufun</code>，对输入<code>aluA</code>和<code>aluB</code>进行加、减、与和异或运算，输出是<code>valE</code>。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">word aluA =</span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRRMOVQ, IOPQ &#125; : valA;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ &#125; : valC;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; ICALL, IPUSHQ &#125; : -<span class="number">8</span>;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRET, IPOPQ &#125; : <span class="number">8</span>;</span><br><span class="line">    # 其他指令无需ALU</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word aluB =</span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRMMOVQ, IMRMOVQ, IOPQ, ICALL, IPUSHQ, IRET, IPOPQ &#125; : valB;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRRMOVQ, IIRMOVQ &#125; : <span class="number">0</span>;</span><br><span class="line">    # 其他指令无需ALU</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>　　执行阶段的第1步是ALU计算，列出的操作数中<code>aluB</code>在前面，<code>aluA</code>在后面，这样可以保证指令<code>subq</code>的执行。根据指令的类型，<code>aluA</code>的值可以是<code>valA</code>、<code>valC</code>和$$8。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word alufun =</span><br><span class="line">[</span><br><span class="line">    icode == IOPQ : ifun;</span><br><span class="line">    i : ALUADD;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool set_cc = icode <span class="keyword">in</span> &#123; IOPQ &#125;;</span><br></pre></td></tr></table></figure><p>　　在执行阶段中，ALU通常作为加法器使用，但对于整数操作指令，它还是会使用<code>ifun</code>编码的操作。CC只会在执行整数操作指令时才会设置。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">word dstE = </span><br><span class="line">[</span><br><span class="line">    # 用IRRMOVQ实现条件移动指令</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRRMOVQ &#125; &amp;&amp; Cnd : rB;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IIRMOVQ, IOPQ &#125; : rB;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>　　标签为cond的硬件单元会根据CC和功能码来确定是否进行条件分支选择或条件数据移动。它还会生成<code>Cnd</code>，用于设置条件移动的<code>dstE</code>和条件分支中下一个PC的逻辑。对于其他指令，<code>Cnd</code>可以设置为0或1，这取决于指令的功能码和CC，但ALU会忽略它。</p><h5 id="访存阶段">4.3.4.4 访存阶段</h5><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/seq_memory_stage.svg" title="seq_memory_stage"><p>　　访存阶段的任务是读写程序数据。2个控制块用于生成存储器地址和存储器写入数据的值。另外2个块用于生成控制读写操作的控制信号。当执行读操作时，数据存储器会生成<code>valM</code>。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word mem_addr = </span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ &#125; : valE;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IPOPQ, IRET &#125; : valA;</span><br><span class="line">    # 其他指令无需地址</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">word mem_data = </span><br><span class="line">[</span><br><span class="line">    # 寄存器的值</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRMMOVQ, IPUSHQ &#125; : valA;</span><br><span class="line">    # 返回PC</span><br><span class="line">    icode == ICALL : valP;</span><br><span class="line">    # 默认不写数据</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool mem_read = icode <span class="keyword">in</span> &#123; IMRMOVQ, IPOPQ, IRET &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool mem_write = icode <span class="keyword">in</span> &#123; IRMMOVQ, IPUSHQ, ICALL &#125;</span><br></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">word Stat = </span><br><span class="line">[</span><br><span class="line">    imem_error || dmem_error : SADR;</span><br><span class="line">    !instr_valid : SINS;</span><br><span class="line">    icode == IHAT : SHLT;</span><br><span class="line">    <span class="number">1</span> : SAOK;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>　　访存阶段会根据取指阶段生成的<code>icode</code>、<code>imem_error</code>、<code>instr_valid</code>和数据存储器生成的<code>dmem_error</code>来计算<code>Stat</code>。</p><h5 id="pc更新阶段">4.3.4.5 PC更新阶段</h5><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/seq_pc_update_stage.svg" title="seq_pc_update_stage"><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">word new_pc = </span><br><span class="line">[</span><br><span class="line">    # Call指令：指令常数</span><br><span class="line">    icode == ICALL : valC;</span><br><span class="line">    # 条件跳转指令：指令常数</span><br><span class="line">    icode == IJXX &amp;&amp; Cnd : valC;</span><br><span class="line">    # 返回指令：使用栈值</span><br><span class="line">    icode == IRET : valM;</span><br><span class="line">    # 默认：PC增加</span><br><span class="line">    <span class="number">1</span> : valP;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>　　PC更新阶段会生成新PC。根据指令类型和是否执行条件跳转，新PC可能是<code>valC</code>、<code>valM</code>或<code>valP</code>。</p><h3 id="流水线的通用原理">4.4 流水线的通用原理</h3><p>　　流水线化设计的目的是保证<span style="background-color:#ff0">每个时钟周期都发出1条新指令</span>，即每个时钟周期都有1条新指令进入执行阶段并完成。要实现这一点需要吞吐量为每个时钟周期1条指令，也就是在取出当前指令后立即确定下一条指令的位置。若取出的指令是条件分支指令，则需要指令通过执行阶段后，才能知道是否选择分支。同样，若取出的指令是<code>ret</code>，则需要指令通过访存阶段后，才能确定返回地址。</p><p>　　通过预测PC的下一个值，在大多数情况下，能够达到流水线化设计的目的。对<span style="background-color:#ff0">大多数</span>类型的指令，这种预测是可靠的。</p><p>　　猜测分支方向并根据猜测开始取值的技术称为<strong>分支预测</strong>，实际上所有的CPU都采用某种形式的分支预测。这里只会使用简单的策略——<strong>总是选择</strong>条件分支，所以预测的PC值为<code>valC</code>，该策略的成功率大约是60%。相反，<strong>从不选择</strong>策略的成功率大约为40%。更复杂的<strong>反向选择、正向不选择</strong>策略的成功率大约为65%，这种策略源于事实：循环是由后向分支结束的，而循环通常会多次执行，前向分支用于条件操作，而这种选择的可能性较小。第3章提到过，分支预测错误会极大地降低程序性能，所以尽可能使用条件数据移动而非条件控制移动。</p><p>　　不同于条件移动指令，指令<code>ret</code>的PC新可能值几乎是无穷的，因为返回地址是位于栈顶的字，其内容不定。</p><p>　　对于大多数程序，预测返回值很容易，因为过程调用和返回是成对出现的。高性能CPU充分利用了该属性，在取指单元中加入<span style="background-color:#ff0">硬件栈</span> (不属于程序员可见状态)，保存指令<code>call</code>生成的返回地址。每次执行指令<code>call</code>时，都会将其返回值压入栈中。当取出指令<code>ret</code>时，就从这个栈中弹出顶部的值，作为预测的返回值。同分支预测一样，预测错误时需要恢复机制，因为有时调用和返回不匹配。</p><h4 id="计算流水线">4.4.1 计算流水线</h4><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/unpipelined_computaion_hardware.svg" title="unpipelined_computaion_hardware"><p>　　假设未流水线化的计算硬件中组合逻辑和寄存器的处理时间分别是300ps和20ps，所以每条指令的延迟为320ps。这种实现中下一条指令只能在前一条指令执行完成后才能执行，指令执行周期为320ps，所以时钟周期为320ps。这里用<span style="background-color:#ff0">每秒千兆条指令</span>为单位来描述该系统的吞吐量。 <span class="math display">\[ \begin{align} T_{unpipelined}&amp;=\frac{1条指令}{1条指令的时延}\times\frac{1000ps}{1ns}\\[3px] &amp;=\frac{1}{320ps}\times\frac{1000ps}{1ns}\\[3px] &amp;\approx3.12GIPS \end{align} \]</span></p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/three-stage_pipelining_timing.svg" title="three-stage_pipelining_timing"><p>　　在之前的基础上，若<span style="background-color:#ff0">将指令按延迟平均划分3个阶段</span> (A、B和C)，每个阶段中组合逻辑的处理时间为100ps，而寄存器的处理时间为20ps，所以时钟周期为120ps，这样1条指令需要3个时钟周期来执行，延迟为360ps。从宏观角度，每个时钟周期可以执行1个阶段A、B和C，可视为每个时钟周期执行1条指令。 <span class="math display">\[ \begin{align} T_{three}&amp;=\frac{1条指令}{1条指令的时延}\times\frac{1000ps}{1ns}\\[3px] &amp;=\frac{1}{120ps}\times\frac{1000ps}{1ns}\\[3px] &amp;\approx8.33GIPS \end{align} \]</span> 　　相比未流水线化设计，3阶段流水线设计的吞吐量大大增加，代价是增加了一些硬件和少量延迟。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/one_clock_cycle_of_pipeline_operation.svg" title="one_clock_cycle_of_pipeline_operation"><p>　　在时段240ps~360ps内，指令I1经过阶段C，I2经过阶段B，I3经过阶段A。在时刻239ps，阶段A中计算的指令I2的值已经到达第1个流水线寄存器的输入，但该寄存器的状态和输出还保持为指令I1的阶段A中计算的值。同样，指令I1在阶段B中计算的值已经到达第2个流水线寄存器的输入。在时刻241ps，流水线寄存器的输入载入其中，成为其输出。阶段A的输入设置为发起指令I3的计算。在时刻300ps，信号传播到各个阶段的组合逻辑，这里使用的是曲线化的波阵面，表示信号<span style="background-color:#ff0">可能以不同的速率</span>通过各个部分。在时刻359ps，结果值到达流水线寄存器的输入。</p><p>　　这里的流水线化设计是理想情况，实际中会出现一些降低流水线效率的因素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">irmovq	$50, %rax</span><br><span class="line">addq	%rax, %rbx</span><br><span class="line">mrmovq	100(%rbx), %rdx</span><br></pre></td></tr></table></figure><p>　　在这个示例中，每条相邻的指令之间都有<strong>数据依赖</strong>。指令<code>irmovq</code>会将结果存储在寄存器<code>%rax</code>中。指令<code>addq</code>会读寄存器<code>%rax</code>再将结果存储到寄存器<code>%rbx</code>。最后，指令<code>irmovq</code>会读寄存器<code>%rbx</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">	subq    %rdx, %rbx</span><br><span class="line">	jne     targ</span><br><span class="line">	irmovq  $10, %rdx</span><br><span class="line">	jmp     loop</span><br><span class="line">targ:</span><br><span class="line">	halt</span><br></pre></td></tr></table></figure><p>　　在这个示例中，指令<code>jne</code> (第3行) 有<strong>控制依赖</strong>。条件判断的结果会决定执行的下一条指令是<code>irmovq</code> (第4行) 还是<code>halt</code> (第7行)。</p><p>　　在SEQ设计中，数据和控制依赖都是通过<span style="background-color:#ff0">反馈路径</span>解决。</p><h4 id="流水线的限制">4.4.2 流水线的限制</h4><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/limitations_of_pipelining_due_to_nonuniform_stages_daleys.svg" title="limitations_of_pipelining_due_to_nonuniform_stages_daleys"><p>　　这个示例与之前的流水线系统大致相同，但在阶段划分时<span style="background-color:#ff0">阶段的时间不等</span>。时钟周期为最长的阶段延迟，即阶段B的延迟170ps。对于时钟周期，阶段A和C会分别空闲 (表示为白色框) 100ps和50ps，根据这些可以计算出吞吐量为5.88GIPS。此外，单条指令的周期时间增加到了510ps。</p><p>　　对于硬件设计者，将系统计算设计划分为时间相等的多个阶段是个严峻的挑战。此外，CPU中的某些硬件单元 (例如，ALU和内存) 无法进一步划分，这使得划分时间相等的阶段更困难。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/limitations_of_pipelineing_due_to_overhead.svg" title="limitations_of_pipelineing_due_to_overhead"><p>　　这个示例与之前的流水线系统大致相同，但在阶段划分时<span style="background-color:#ff0">平均划分为6个阶段</span>。时钟周期为70ps，根据这些可以计算出吞吐量为14.29GIPS。相比3阶段流水线系统，时钟周期减半，但吞吐量并未加倍。</p><p>　　为了提高时钟频率，现代CPU采用了阶段很多 (15及更多阶段) 的流水线。CPU架构师将指令的执行划分为很多很简单的步骤，这样是为了保证每个阶段的延迟很小。电路设计师需要尽可能保证流水线寄存器的延迟足够小。芯片设计师需要小心地设计时钟传播网络以保证时钟在整个芯片上同时改变。所有这些因素都会增加CPU设计的难度。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/limitations_of_pipelining_due_to_logical_dependencies.svg" title="limitations_of_pipelining_due_to_logical_dependencies"><p>　　将反馈机制加入流水线后，在未流水线化的系统中，每条指令的结果都可以反馈给下一条指令。将该系统转化为3阶段流水线系统时 (每条指令的结果只能反馈给其后的第3条指令)，程序的行为将发生改变，所以必须以某种方式处理指令之间的数据和控制依赖来保证得到的行为符合ISA定义的模型。</p><h3 id="y86-64的流水线实现">4.5 Y86-64的流水线实现</h3><p>　　为了实现流水线化的Y86-64，首先，需要调整顺序SEQ中阶段的顺序，使得更新PC阶段在周期的开始执行，得到<span style="background-color:#ff0">SEQ+</span>。然后，在各个阶段之间加上流水线寄存器，得到<span style="background-color:#ff0">PIPE-</span> (-表示性能比SEQ+更差)。最后，还需要一些修改来保证正确地处理各种数据和控制依赖。</p><h4 id="seq-1">4.5.1 SEQ+</h4><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/seq+_hardware_structure.svg" title="seq+_hardware_structure"><p>　　在SEQ+中，PC更新阶段会使用一组时钟寄存器来保存前一条指令执行过程中计算出来的信号，根据这些信号可以计算出PC值。这种模式是一个小小的例证——可以用不同于ISA隐含的概念模型的方式来实现CPU，只要CPU能正确执行机器语言程序。这种模式中无需将状态编码为程序员可见的状态指示形式，只要CPU能够为程序员可见状态生成正确的值。</p><p>　　SEQ到SEQ+中对状态单元的改变是一种很通用的改进方法的示例，这种改进称为<strong>电路重定时</strong>，重定时会改变系统的状态表示，但并不改变其逻辑行为，通常用于平衡流水线系统里各个阶段之间的延迟。</p><h4 id="pipe-">4.5.2 PIPE-</h4><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/pipe-_hardware_structure.svg" title="pipe-_hardware_structure"><p>　　在PIPE-中，<span style="background-color:#ff0">蓝色方框表示流水线寄存器</span>，每个寄存器包括不同的字段，用白色方框表示。同顺序处理CPU的硬件结构图不同，这些<span style="background-color:#ff0">白色方框表示实际的硬件组成</span>。大写的前缀表示流水线寄存器，所以<code>M_stat</code>表示流水线寄存器<code>M</code>的状态码字段。小写的前缀表示流水线的阶段，所以<code>m_stat</code>表示访存阶段中控制逻辑块生成的状态信号。</p><p>　　流水线寄存器<code>F</code>用于保存PC的预测值。流水线寄存器<code>D</code>用于保存最近取出的指令的信息。流水线寄存器<code>E</code>用于保存最近译码的指令和从寄存器文件中读出的值的信息。流水线寄存器<code>M</code>用于保存最近执行的指令的结果和处理条件判断和分支目标的信息。流水线寄存器<code>W</code>用于将反馈路径计算出来的值提供给寄存器文件和指令<code>ret</code>完成后向PC提供返回地址。</p><p>　　PIPE-取指阶段负责预测PC的下一个值和取指阶段实际的PC值。标签为Predict PC的块会在PC增加后的值<code>valP</code>和根据取出的指令得到的值<code>valC</code>中进行选择，选择的值会作为PC的预测值并存储到流水线寄存器<code>F</code>中。标签为Select PC的块类似于SEQ+中PC更新阶段中标签为PC的块，它会从预测的PC值、存储在流水线寄存器<code>M_valA</code>中的<code>valP</code> (对于达到流水线寄存器<code>M</code>的不选择分支的指令) 和存储在流水线寄存器<code>W_valM</code>中的返回地址的值 (对于达到流水线寄存器<code>W</code>的指令<code>ret</code>) 中进行选择，得到PC值。</p><p>　　标签为Select A的块会从流水线寄存器<code>D</code>中的<code>valP</code>和寄存器文件A端口中读出的值来中选择，得到值<code>valA</code>。这个块是为了减少要携带给寄存器<code>E</code>和<code>M</code>的状态数量。在所有指令中，只有<code>call</code>的访存阶段和跳转指令的执行阶段 (不需要执行跳转) 会需要值<code>valP</code>，而这2个指令都不从寄存器文件中读取值，所以将它们合并为值<code>valA</code>，这样就不需要标签为Data的块 (功能类似)。</p><p>　　SEQ+和PIPE-在译码阶段都生成了值<code>dstE</code>和<code>dstM</code>。SEQ+可以将这些值直接连接到寄存器文件写端口的地址输入。PIPE-会一直携带这些值，直到写回阶段才将其传递给寄存器文件，这样做是为了保证写端口的地址和数据输入来自同一条指令。</p><p>　　在SEQ和SEQ+中，同一时刻只能处理1条指令，所以<code>valC</code>、<code>srcA</code>和<code>valE</code>等值有唯一值。在PIPE-中，与各个指令相关联的这些值有多个版本，会随着指令一起流过系统，需要确保使用的是正确的值。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/simple_example_of_instruction_flow_through_pipeline.svg" title="simple_example_of_instruction_flow_through_pipeline"><p>　　这个示例描述了每条指令通过流水线各个阶段的行进过程，时间从左到右递增。周期1取出指令I1，然后该指令开始通过流水线各个阶段，到周期5结束后，其结果写入到寄存器文件，依此类推。下方是周期5的流水线的扩展，取指阶段在底部，写回阶段在顶部，同PIPE-一样，因为正常的程序是从上到下执行。</p><h4 id="流水线隐患">4.5.3 流水线隐患</h4><p>　　数据和控制依赖可能会导致流水线生成错误的计算，称为<strong>隐患</strong>。与依赖类似，隐患可以分为<strong>数据隐患</strong>和<strong>控制隐患</strong>。</p><p>　　● 程序寄存器出现数据隐患是因为寄存器文件的读写是在不同阶段进行的，导致不同指令之间可能出现意料之外的相互作用。</p><p>　　● 更新和读取PC之间的冲突会导致控制隐患。当取指阶段的逻辑在取下一条指令前正确地预测PC的新值，就不会导致控制隐患。</p><p>　　● 数据存储器的读写发生在访存阶段，在读存储器的指令到达这个阶段前，前面所有写存储器的指令都已完成该阶段。在访存阶段中的写数据的指令和在取指阶段中的读数据的指令之间会发生冲突，因为指令和数据存储器引用的是同一地址空间，只有包含自我修改代码的程序才会出现这种情况，在这样的程序中，指令写存储器的某部分，然后再从同一存储器中取出指令。有些系统有复杂的机制来检验和避免此类隐患，而有些系统只能简单强制要求程序不能使用自我修改代码。为了简便，这里<span style="background-color:#ff0">假设程序不能自我修改</span>。</p><p>　　● 整数操作指令会在执行阶段写CC寄存器。条件移动指令会在执行阶段读CC寄存器。条件跳转指令会在访存阶段读CC寄存器。在条件移动指令和条件跳转指令到达执行阶段前，前面所有的整数操作指令都已完成该阶段，所以CC寄存器不会有隐患。</p><p>　　● 指令通过流水线时，会影响程序状态。这里采用流水线中每条指令都与状态码相关联的机制，使得异常发生时，CPU能够有条理地停止。</p><h5 id="避免数据隐患">4.5.3.1 避免数据隐患</h5><p>　　<strong>暂停</strong>是避免隐患的常用技术之一，CPU会让部分指令暂停在它们所处的阶段，而允许其他指令继续通过流水线，直到构成的隐患条件不再满足。让指令暂停在译码阶段，直到生成其操作数的指令通过写回阶段，这样就能避免数据隐患。实现暂停的方式就是在执行阶段插入1个<strong>气泡</strong>，气泡就像自动生成的<code>nop</code>指令，代价是性能损失。</p><p>　　另一种避免数据隐患的技术是<strong>数据转发</strong>，也称为<strong>转发</strong>或<strong>旁路</strong>，即将值直接从当前阶段转发到更早阶段。数据转发需要在基本的硬件结构中增加一些额外的数据连接和控制逻辑。在PIPE-中加入数据转发会得到<span style="background-color:#ff0">PIPE</span>。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/pipe_hardware_structure.svg" title="pipe_hardware_structure"><p>　　相比PIPE-，PIPE在译码阶段中加入了标签为Sel+Fwd A和Fwd B的2个块，标签为Sel+Fwd A的块是PIPE-中标签为Select A的块和转发逻辑的结合，它会在PC增加后的值<code>valP</code>、寄存器文件A端口读出的值和某个转发过来的值中进行选择，得到流水线寄存器<code>E</code>中的<code>valA</code>。标签为Fwd B的块是源操作数<code>valB</code>的转发逻辑。PIPE中有5个转发源 (<code>e_valE</code>、<code>M_valE</code>、<code>m_valE</code>、<code>W_valM</code>和<code>W_valE</code>) 和2个转发目的地 (<code>valA</code>和<code>valB</code>)。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/simple_example_of_load_or_use_hazard.svg" title="simple_example_of_load_or_use_hazard"><p>　　有1类数据隐患不能简单地用转发来避免，即<strong>加载/使用隐患</strong>，因为访存阶段是流水线中较晚的阶段。例如，这个示例中第5行的指令<code>irmovq</code>需要在周期8才能将值加载到寄存器<code>%rax</code>，而第6行的指令<code>addq</code>在周期7就需要使用寄存器<code>%rax</code>。用暂停来避免加载/使用隐患的方法称为<strong>加载互锁</strong>，加载互锁与转发结合起来可以避免所有的数据隐患，这个示例可以在第6行插入气泡来避免隐患。</p><h5 id="避免控制隐患">4.5.3.2 避免控制隐患</h5><p>　　控制隐患只会出现在指令<code>ret</code>和跳转指令，后者只有在条件跳转分支预测错误时才会导致问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x000:      irmovq  stack, %rsp</span><br><span class="line">0x00a:      call    proc</span><br><span class="line">0x013:      irmovq  $10, %rdx</span><br><span class="line">0x01d:      halt</span><br><span class="line">0x020:  .pos 0x20</span><br><span class="line">0x020:  proc:</span><br><span class="line">0x020:      ret</span><br><span class="line">0x021:      rrmovq  %rdx, %rbx</span><br><span class="line">0x030:  .pos 0x30</span><br><span class="line">0x030:  stack:</span><br></pre></td></tr></table></figure><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/processing_instruction_ret.svg" title="processing_instruction_ret"><p>　　在这个示例中，周期3取出指令<code>ret</code>并沿着流水线继续执行，在周期7进入写回阶段。在其进行译码、执行和访存阶段时，流水线不能执行任何有用的活动，即在这3个周期插入气泡。由于<span style="background-color:#ff0">无法在取指阶段插入气泡</span>，只能在译码阶段插入气泡，PC的新值会预测为<code>0x021</code> (第8行)，这个地址是错误的。一旦指令<code>ret</code>到达写回阶段，PC选择逻辑会将PC值设为返回地址，然后取指阶段就会取出位于返回点处 (地址<code>0x013</code>) 的指令<code>irmovq</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x000:      xorq    %rax, %rax</span><br><span class="line">0x002:      jne     target </span><br><span class="line">0x00b:      irmovq  $1, %rax</span><br><span class="line">0x015:      halt</span><br><span class="line">0x016:  target:</span><br><span class="line">0x016:      irmovq  $2, %rdx</span><br><span class="line">0x020:      irmovq  $3, %rbx</span><br><span class="line">0x02a:      halt</span><br></pre></td></tr></table></figure><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/processing_mispredicted_branch_instruction.svg" title="processing_mispredicted_branch_instruction"><p>　　在这个示例中，指令<code>jne</code> (第2行) 并不会执行跳转，但由于预测跳转指令会跳转，所以周期3会取出位于跳转目标处的指令 (第6行)，周期4会取出跳转目标处指令的下一条指令 (第7行)。指令只有到了执行阶段才能改变程序员可见状态，所以通过在下一周期的译码阶段和执行阶段插入气泡并取出指令<code>jne</code>的下一条指令 (第3行) 来<strong>取消</strong> (也称为<strong>指令排除</strong>) 这2条预测错误的指令。</p><h4 id="pipe各阶段的实现">4.5.4 PIPE各阶段的实现</h4><p>　　PIPE的HCL代码类似于SEQ，不同的是给信号加上了类似PIPE中的前缀。例如，<code>D_</code>表示该信号来自流水线寄存器<code>D</code>，<code>d_</code>表示该信号在译码阶段生成。</p><h5 id="取指阶段-1">4.5.4.1 取指阶段</h5><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/pipe_fetch_stage.svg" title="pipe_fetch_stage"><p>　　PIPE取指阶段会选择PC的当前值并预测下一个PC值。从存储器中读指令和提取不同指令字段的硬件单元与SEQ的相同。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">word f_pc =</span><br><span class="line">[</span><br><span class="line">    # 预测错误的分支</span><br><span class="line">    M_icode == IJXX &amp;&amp; !M_Cnd : M_valA;</span><br><span class="line">    # 完成ret指令</span><br><span class="line">    W_icode == IRET : W_valM;</span><br><span class="line">    # 默认使用PC预测值</span><br><span class="line">    <span class="number">1</span> : F_predPC;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>　　PC选择逻辑会从3个PC源中进行选择。当预测错误的分支进入访存阶段时，会从在流水线寄存器<code>M</code>中读取该指令的<code>valP</code> (存储在<code>M_valA</code>，表示下一条指令的地址)。当指令<code>ret</code>进入写回阶段时，会从流水线寄存器<code>W</code>中读取返回地址 (存储在<code>W_valM</code>)。其他情况使用存储在寄存器<code>F</code>中的PC预测值 (存储在<code>F_predPC</code>)。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word f_predPC =</span><br><span class="line">[</span><br><span class="line">    f_icode <span class="keyword">in</span> &#123; IJXX, ICALL &#125; : f_valC;</span><br><span class="line">    <span class="number">1</span> : f_valP;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>　　当取出的指令为跳转指令或指令<code>call</code>时，PC预测逻辑会选择<code>valC</code>；否则，选择<code>valP</code>。</p><p>　　标签为Instr valid、Need regids和Need valC的块与SEQ中的相同。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">word f_stat =</span><br><span class="line">[</span><br><span class="line">    imeme_error : SADR;</span><br><span class="line">    !instr_valid : SINS;</span><br><span class="line">    f_icode == IHALT : SHLT;</span><br><span class="line">    <span class="number">1</span> : SAOK;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>　　同SEQ不同，PIPE将指令状态的计算分为2部分。在取指阶段，可以检测非法指令、指令<code>halt</code>和指令地址越界导致的内存异常，但非法数据地址的检测必须推迟到访存阶段。</p><h5 id="译码和写回阶段-1">4.5.4.2 译码和写回阶段</h5><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/pipe_decode_and_write-back_stage.svg" title="pipe_decode_and_write-back_stage"><p>　　标签为dstE、dstM、srcA和srcB的块与SEQ中的相似。此外，提供给寄存器文件写端口的寄存器ID (信号<code>W_dstE</code>和<code>W_dstM</code>) 来自写回阶段而非译码阶段，因为对目的寄存器的写操作由写回阶段中的指令指定。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">word d_valA =</span><br><span class="line">[</span><br><span class="line">    D_icode <span class="keyword">in</span> &#123; ICALL, IJXX &#125; : D_valP;    # 选择增加后的PC</span><br><span class="line">    d_srcA == e_dstE : e_valE;              # 选择执行阶段的valE</span><br><span class="line">    d_srcA == M_dstM : m_valM;              # 选择访存阶段的valM</span><br><span class="line">    d_srcA == M_dstE : M_valE;              # 选择访存阶段的valE</span><br><span class="line">    d_srcA == W_dstM : W_valM;              # 选择写回阶段的valM</span><br><span class="line">    d_srcA == W_dstE : W_valE;              # 选择写回阶段的valE</span><br><span class="line">    <span class="number">1</span> : d_rvalA;                            # 选择寄存器文件A端口的值</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">word d_valB =</span><br><span class="line">[</span><br><span class="line">    d_srcB == e_dstE : e_valE;              # 选择执行阶段的valE</span><br><span class="line">    d_srcB == M_dstM : m_valM;              # 选择访存阶段的valM</span><br><span class="line">    d_srcB == M_dstE : M_valE;              # 选择访存阶段的valE</span><br><span class="line">    d_srcB == W_dstM : W_valM;              # 选择写回阶段的valM</span><br><span class="line">    d_srcB == W_dstE : W_valE;              # 选择写回阶段的valE</span><br><span class="line">    <span class="number">1</span> : d_rvalB;                            # 选择寄存器文件B端口的值</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>　　PIPE译码阶段的复杂之处在于转发逻辑，之前提到过有5个不同的转发源，每个转发源都有1个数据字和1个目的寄存器ID。标签为Sel+Fwd A的块除了负责源操作数<code>valA</code>的转发，还会将<code>valP</code>合并到<code>valA</code>。合并<code>valA</code>和<code>valP</code>的依据是只有指令<code>call</code>和跳转指令在后面的阶段需要<code>valP</code>，而且这两者都不需要从寄存器文件A端口读取值。</p><table><thead><tr><th>数据字</th><th>寄存器ID</th><th>源描述</th></tr></thead><tbody><tr><td><code>e_valE</code></td><td><code>e_dstE</code></td><td>ALU输出</td></tr><tr><td><code>m_valN</code></td><td><code>M_dstM</code></td><td>数据存储器输出</td></tr><tr><td><code>M_valE</code></td><td><code>M_dstE</code></td><td>访存阶段中对端口E即将进行的写</td></tr><tr><td><code>W_valM</code></td><td><code>W_dstM</code></td><td>写回阶段中对端口M即将进行的写</td></tr><tr><td><code>W_valE</code></td><td><code>W_dstE</code></td><td>写回阶段中对端口E即将进行的写</td></tr></tbody></table><p>　　源操作数<code>valA</code>的转发逻辑中的<span style="background-color:#ff0">5个转发源的优先级很重要</span>，该优先级由HCL代码中检测5个目的寄存器ID的顺序来决定。若选择了其他顺序，则可能会导致某些程序的流水线出错。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/simple_example_of_forwarding_priority.svg" title="simple_example_of_forwarding_priority"><p>　　在这个示例中，前2条指令会写寄存器<code>%rdx</code>，第3条指令会将寄存器<code>%rdx</code>作为源操作数。当第3条指令到达译码阶段 (周期4) 时，转发逻辑必须在2个都以寄存器<code>%rdx</code>为目的地的值中选择一个。按照机器语言程序的行为，第3条指令应该从寄存器<code>%rdx</code>中读出3，所以流水线化的实现应该<span style="background-color:#ff0">保证流水线阶段最早的转发源有最高的优先级</span>。按照这一点，转发逻辑会先在执行阶段检测转发源，然后在访存阶段检测转发源，最后在写回阶段检测转发源。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word Stat =</span><br><span class="line">[</span><br><span class="line">    W_stat == SBUB : SAOK;</span><br><span class="line">    <span class="number">1</span> : W_stat;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>　　PIPE写回阶段正如图中所示，整个流水线的状态<code>Stat</code>根据流水线寄存器<code>W</code>中的状态值计算而来。之前提到过，状态码应该指明是正常操作或3种异常之一。流水线寄存器<code>W</code>保存着最近完成指令的状态，所以该值很适合用于表示整个流水线的状态。唯一要考虑的特殊情况是写回阶段出现气泡，但这也属于正常操作。</p><h5 id="执行阶段-1">4.5.4.3 执行阶段</h5><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/pipe_execute_stage.svg" title="pipe_execute_stage"><p>　　PIPE执行阶段中的块同SEQ中的相似，使用的信号也进行了适当的重命名。<code>e_valE</code>和<code>e_dstE</code>作为转发源，转发到译码阶段。与SEQ执行阶段不同的是标签为Set CC的块以<code>W_stat</code>和<code>m_stat</code>作为输入，决定是否要更新CC，用于检测异常指令正在通过后续流水线阶段的情况。</p><h5 id="访存阶段-1">4.5.4.4 访存阶段</h5><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/pipe_memory_stage.svg" title="pipe_memory_stage"><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word m_stat =</span><br><span class="line">[</span><br><span class="line">    dmem_error : SADR;</span><br><span class="line">    <span class="number">1</span> : M_stat;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>　　PIPE访存阶段与SEQ访存阶段相似，但没有标签为Data的块 (用于数据源<code>valP</code>和<code>valA</code>中进行选择)，因为其功能由译码阶段中标签为Sel+Fwd A的块负责。该阶段中的其他块同SEQ中的相似，使用的信号进行了适当的重命名。之前提到过，访存阶段仅能检测非法数据地址。</p><h4 id="异常处理">4.5.5 异常处理</h4><p>　　在流水线系统中，异常处理包括一些细节问题。</p><p>　　1) 有时可能同时有多个异常指令，例如，<span style="background-color:#ff0">同一流水线周期</span>中取指阶段有<code>halt</code>指令和访存阶段出现指令数据地址越界。在这种情况下，基本原则是<span style="background-color:#ff0">异常指令所处流水线阶段越靠后，优先级越高</span>，所以应该反馈地址越界。</p><p>　　2) 当指令被取出并开始执行时导致了异常，但后来由于分支预测错误，取消了该指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x000:  6300                    |       xorq    %rax,%rax</span><br><span class="line">0x002:  741600000000000000      |       jne     target</span><br><span class="line">0x00b:  30f00100000000000000    |       irmovq  $1, %rax</span><br><span class="line">0x015:  00                      |       halt</span><br><span class="line">0x016:                          |   target:</span><br><span class="line">0x016:  ff                      |       .byte 0xFF</span><br></pre></td></tr></table></figure><p>　　在这个示例中，分支预测会取出第6行代码，所以译码阶段会出现非法指令异常。之后，流水线发现不应该选择分支，就会取消该指令。</p><p>　　3) 某条指令导致了异常，它后面的指令在异常指令完成前改变了部分状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">irmovq  $1, %rax</span><br><span class="line">xorq    %rsp, %rsp</span><br><span class="line">pushq   %rax</span><br><span class="line">addq    %rax, %rax</span><br></pre></td></tr></table></figure><p>　　在这个示例中，指令<code>xorq</code>会将栈指针和CC分别设置为<code>0x00</code>和100，指令<code>pushq</code>会减少栈指针进而导致地址异常，访存阶段会发现这个异常。在同一周期内，指令<code>addq</code>处于执行阶段，而它会将CC设置成新值。</p><p>　　处理异常的简单而可靠的机制是<span style="background-color:#ff0">携带指令的异常状态和其他信息一起通过流水线</span>。每个流水线寄存器中都有状态码<code>stat</code>，其功能是处理异常。若出现了异常，则<code>stat</code>会设置为表示异常的值并继续执行取指、译码和执行。当异常指令达到访存或写回阶段时，会采取措施禁止修改程序员可见状态，包括<span style="background-color:#ff0">禁止执行阶段中的指令设置CC</span>、<span style="background-color:#ff0">在访存阶段插入气泡以禁止写数据存储器</span>和<span style="background-color:#ff0">在写回阶段有异常指令时暂停写回阶段</span>。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/processing_invalid_memory_reference_exception.svg" title="processing_invalid_memory_reference_exception"><p>　　在这个示例的周期6中，指令<code>pushq</code>到达访存阶段并引起了内存异常，指令<code>addq</code>到达执行阶段并生成了新的CC。当访存或写回阶段中有异常指令时 (检测信号<code>m_stat</code>和<code>W_stat</code>)，会禁止设置CC (将信号<code>set_cc</code>置0)。从整体角度，处理过程还包括在访存阶段插入气泡和暂停写回阶段。</p><h4 id="流水线控制逻辑">4.5.6 流水线控制逻辑</h4><p>　　流水线控制逻辑必须处理加载/使用隐患、指令<code>ret</code>、预测错误的分支和异常。</p><table><colgroup><col style="width:17%"><col style="width:82%"></colgroup><thead><tr><th>特殊情况</th><th>触发条件</th></tr></thead><tbody><tr><td>处理指令<code>ret</code></td><td><code>IRET in &#123; D_icode, E_icode, M_icode &#125;</code></td></tr><tr><td>加载/使用隐患</td><td><code>E_icode in &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp; E_dstM in &#123; d_srcA, d_srcB &#125;</code></td></tr><tr><td>预测错误分支</td><td><code>E_icode = IJXX &amp;&amp; !e_Cnd</code></td></tr><tr><td>异常</td><td><code>m_stat in &#123; SADR, SINS, SHLT &#125; || W_stat in &#123; SADR, SINS, SHLT &#125;</code></td></tr></tbody></table><h5 id="流水线控制机制">4.5.6.1 流水线控制机制</h5><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/additional_pipeline_register_operations.svg" title="additional_pipeline_register_operations"><p>　　相比非流水线寄存器，流水线寄存器加入了<span style="background-color:#ff0">暂停</span>和<span style="background-color:#ff0">气泡</span>这2个控制信号。在正常情况下，这2个控制信号都为0，寄存器会加载输入作为状态。当暂停为1时，寄存器不会更新状态。当气泡为1时，寄存器状态会设置为某个固定的<strong>复位配置</strong> (等效于<code>nop</code>指令的状态)，复位配置的0/1模式由流水线寄存器中的字段的集合决定。若需要在流水线寄存器<code>D</code>中插入气泡，只需将<code>icode</code>设置为<code>INOP</code>。若需要在流水线寄存器<code>E</code>中插入气泡，需要将<code>icode</code>设置为<code>INOP</code>并将<code>dstE</code>、<code>dstM</code>、<code>srcA</code>和<code>srcB</code>设置为<code>RNONE</code>。此外，这里<span style="background-color:#ff0">将气泡和暂停都置为1视为出错</span>。</p><table style="width:100%"><colgroup><col style="width:15%"><col style="width:16%"><col style="width:16%"><col style="width:16%"><col style="width:16%"><col style="width:16%"></colgroup><thead><tr><th>特殊情况</th><th>流水线寄存器<code>F</code></th><th>流水线寄存器<code>D</code></th><th>流水线寄存器<code>E</code></th><th>流水线寄存器<code>M</code></th><th>流水线寄存器<code>W</code></th></tr></thead><tbody><tr><td>处理指令<code>ret</code></td><td>暂停</td><td>气泡</td><td>正常</td><td>正常</td><td>正常</td></tr><tr><td>加载/使用隐患</td><td>暂停</td><td>暂停</td><td>气泡</td><td>正常</td><td>正常</td></tr><tr><td>预测错误的分支</td><td>正常</td><td>气泡</td><td>气泡</td><td>正常</td><td>正常</td></tr></tbody></table><p>　　这是在3种特殊情况下各个流水线寄存器应采取的行动。在时序方面，流水线寄存器的暂停和气泡控制输入都是由组合逻辑块生成，所以这些值必须是合法的，保证下个时钟周期开始时，每个流水线寄存器要么加载，要么暂停，要么气泡。</p><h5 id="控制条件的组合">4.5.6.2 控制条件的组合</h5><p>　　在之前的设计中都是假设单个时钟周期内最多只会出现1种特殊情况，这是常见的缺陷之一。</p><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/pipeline_states_for_special_control_conditions.svg" title="pipeline_states_for_special_control_conditions"><p>　　单个时钟周期可能出现2种特殊情况，因为大多数控制条件都是<span style="background-color:#ff0">互斥</span>的。例如，加载/使用隐患不能和预测错误的分支同时出现，因为加载/使用隐患要求执行阶段是加载指令 (<code>mrmovq</code>和<code>popq</code>)，而预测错误的分支要求执行阶段是跳转指令。同样，处于执行或访存阶段的指令<code>ret</code>也不能与加载/使用隐患或预测错误的分支同时出现。只有箭头标明的2种组合可能同时出现。</p><p>　　组合A中执行阶段是预测错误的跳转指令，而译码阶段是指令<code>ret</code>，流水线控制逻辑会发现分支预测错误，所以取消指令<code>ret</code>。</p><table style="width:100%"><colgroup><col style="width:15%"><col style="width:16%"><col style="width:16%"><col style="width:16%"><col style="width:16%"><col style="width:16%"></colgroup><thead><tr><th>特殊情况</th><th>流水线寄存器<code>F</code></th><th>流水线寄存器<code>D</code></th><th>流水线寄存器<code>E</code></th><th>流水线寄存器<code>M</code></th><th>流水线寄存器<code>W</code></th></tr></thead><tbody><tr><td>处理指令<code>ret</code></td><td>暂停</td><td>气泡</td><td>正常</td><td>正常</td><td>正常</td></tr><tr><td>预测错误的分支</td><td>正常</td><td>气泡</td><td>气泡</td><td>正常</td><td>正常</td></tr><tr><td>组合A</td><td>暂停</td><td>气泡</td><td>气泡</td><td>正常</td><td>正常</td></tr></tbody></table><p>　　这是出现组合A时的流水线应采取的行动 (假设气泡或暂停会覆盖正常)。组合A的处理与预测错误的分支处理相似，区别是取指阶段是暂停。同样，在下一周期，PC选择逻辑会选择正确的地址而非预测值，所以流水线寄存器F的行动不重要。</p><p>　　组合B包括加载/使用隐患，其中加载指令设置栈指针，然后指令<code>ret</code>将栈指针作为源操作数，因为它必须从栈中弹出返回地址。流水线控制逻辑应将指令<code>ret</code>暂停在译码阶段。</p><table style="width:100%"><colgroup><col style="width:14%"><col style="width:17%"><col style="width:17%"><col style="width:17%"><col style="width:17%"><col style="width:17%"></colgroup><thead><tr><th>特殊情况</th><th>流水线寄存器<code>F</code></th><th>流水线寄存器<code>D</code></th><th>流水线寄存器<code>E</code></th><th>流水线寄存器<code>M</code></th><th>流水线寄存器<code>W</code></th></tr></thead><tbody><tr><td>处理指令<code>ret</code></td><td>暂停</td><td>气泡</td><td>正常</td><td>正常</td><td>正常</td></tr><tr><td>加载/使用隐患</td><td>暂停</td><td>暂停</td><td>气泡</td><td>正常</td><td>正常</td></tr><tr><td>组合B</td><td>暂停</td><td>气泡+暂停</td><td>气泡</td><td>正常</td><td>正常</td></tr><tr><td>实际情况</td><td>暂停</td><td>暂停</td><td>气泡</td><td>正常</td><td>正常</td></tr></tbody></table><p>　　这是出现组合B时的流水线应采取的行动，流水线控制逻辑会暂停指令<code>ret</code>来避免加载/使用隐患，同时又因为指令<code>ret</code>而在译码阶段插入气泡。PIPE控制逻辑原本的实现并不能正确处理组合B，因为流水线控制逻辑会将流水线寄存器<code>D</code>的气泡和暂停信号都置1。之前提到过，气泡和暂停信号不能都为1，所以译码阶段只采取针对加载/使用隐患的行动并将处理指令<code>ret</code>的行动推迟1个周期。</p><h5 id="控制逻辑实现">4.5.6.3 控制逻辑实现</h5><img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/pipe_pipeline_control_logic.svg" title="pipe_pipeline_control_logic"><p>　　根据来自流水线寄存器和流水线阶段的信号，控制逻辑生成流水线寄存器的暂停和气泡信号，同时也决定是否要更新CC寄存器。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool F_stall = </span><br><span class="line">    # 加载/使用隐患</span><br><span class="line">    E_icode <span class="keyword">in</span> &#123; IMRMOVQ, IPOPQ&#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123; d_srcA, d_srcB &#125; ||</span><br><span class="line">    # ret指令通过流水线</span><br><span class="line">    IRET <span class="keyword">in</span> &#123; D_icode, E_icode, M_icode &#125;;</span><br></pre></td></tr></table></figure><p>　　遇到加载/使用隐患或指令<code>ret</code>时，流水线寄存器<code>F</code>会暂停。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool D_stall = </span><br><span class="line">    # 加载/使用隐患</span><br><span class="line">    E_icode <span class="keyword">in</span> &#123; IMRMOVQ, IPOPQ&#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123; d_srcA, d_srcB &#125;;</span><br></pre></td></tr></table></figure><p>　　遇到加载/使用隐患时，流水线寄存器<code>D</code>会暂停。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool D_bubble = </span><br><span class="line">    # 预测错误的分支</span><br><span class="line">    (E_icode == IJXX &amp;&amp; !e_Cnd) ||</span><br><span class="line">    # 不能出现加载/使用隐患和ret指令组合</span><br><span class="line">    !(E_icode <span class="keyword">in</span> &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123; d_srcA, d_srcB &#125;) &amp;&amp; IRET <span class="keyword">in</span> &#123; D_icode, E_icode, M_icode &#125;;</span><br></pre></td></tr></table></figure><p>　　遇到预测错误的分支时，流水线寄存器<code>D</code>会插入气泡。不过，遇到加载/使用隐患和指令<code>ret</code>组合时，不会插入气泡。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool E_bubble = </span><br><span class="line">    # 预测错误的分支</span><br><span class="line">    (E_icode == IJXX &amp;&amp; !e_Cnd) ||</span><br><span class="line">    # 加载/使用隐患</span><br><span class="line">    E_icode <span class="keyword">in</span> &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123; d_srcA, d_srcB &#125;;</span><br></pre></td></tr></table></figure><p>　　遇到加载/使用隐患或预测错误的分支时，流水线寄存器<code>E</code>会插入气泡。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool set_cc = </span><br><span class="line">    E_icode == IOPQ &amp;&amp;</span><br><span class="line">    # 正常操作</span><br><span class="line">    !m_stat <span class="keyword">in</span> &#123; SADR, SINS, SHLT &#125; &amp;&amp; !W_stat <span class="keyword">in</span> &#123; SADR, SINS, SHLT &#125;;</span><br></pre></td></tr></table></figure><p>　　只有整数操作指令正常执行时才设置CC。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool M_bubble = </span><br><span class="line">    # 异常指令</span><br><span class="line">    m_stat <span class="keyword">in</span> &#123; SADR, SINS, SHLT &#125; || W_stat <span class="keyword">in</span> &#123; SADR, SINS, SHLT &#125;;</span><br></pre></td></tr></table></figure><p>　　遇到异常指令时，流水线寄存器<code>M</code>会插入气泡。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool W_stall = W_stat <span class="keyword">in</span> &#123; SADR, SINS, SHLT &#125;;</span><br></pre></td></tr></table></figure><p>　　遇到异常指令时，流水线寄存器<code>W</code>会暂停。若某个指令在访存阶段暂停过，则该指令不会达到写回阶段。</p><h5 id="测试和验证">4.5.6.4 测试和验证</h5><p>　　简单地模拟设计和运行一些典型的程序并不足以用于测试系统。相反，全面的测试需要一些方法来系统地生成很多测试，这些测试将尽可能多地使用不同指令和指令组合。在设计Y86-64时，还设计了很多测试脚本，每个脚本都会生成很多不同的测试，运行CPU模拟并比较得到的寄存器/存储器值和YIS指令集模拟器生成的值。</p><p>　　● <strong>optest</strong>：运行49个不同的Y86-64指令的测试，包括不同的源和目的寄存器。</p><p>　　● <strong>jtest</strong>：运行64个不同的跳转指令和指令<code>call</code>的测试，包括不同的分支组合。</p><p>　　● <strong>cmtest</strong>：运行28个不同的条件移动指令的测试，包括不同的控制组合。</p><p>　　● <strong>htest</strong>：运行600个不同的数据隐患可能性的测试，包括不同的源和目的指令的组合，在这些指令之间有不同的数量的<code>nop</code>指令。</p><p>　　● <strong>ctest</strong>：测试22个不同的控制组合。</p><p>　　● <strong>etest</strong>：测试12种不同的异常指令和跟在其后可能改变程序员可见状态的指令组合。</p><p>　　即使设计通过了大量的测试，也不能保证它能正确运行所有程序。即使只考虑由较短的代码组成的测试，待测试的可能的程序的数量也很庞大。不过，<strong>形式化验证</strong>能够保证有工具能够严格地考虑到系统所有可能的行为并确定是否有设计错误。例如，形式化验证Y86-64的早期版本之一，建立框架来比较PIPE和SEQ，该框架能够证明对于任意的Y86-64程序，两者对程序员可见状态的影响完全相同，该过程使用归纳法。进行这种分析要求用<strong>符号方法</strong>来推导硬件。在符号方法中，所有的程序值都是任意整数，ALU抽象为黑盒并根据其参数计算某个未指定的函数。形式化验证还处于发展的早期阶段，并不能完全验证。</p><h4 id="性能分析">4.5.7 性能分析</h4><p>　　所有需要流水线控制逻辑进行特殊处理的条件，都会导致流水线不能实现每个时钟周期发出1条新指令，这通过确定往流水线中插入气泡的频率来衡量，因为插入1个气泡会导致1个流水线周期不被使用。返回指令会生成3个气泡，加载/使用隐患会生成1个气泡，预测错误的分支会生成2个气泡。异常的定义表明其出现频率很低，所以可以忽略。可以通过计算流水线执行1条指令所需的平均时钟周期的估计值来量化这些处罚的性能影响，这种衡量方法称为<strong>每指令周期数</strong>。</p><p>　　假设在某个CPU上运行某个基准程序并观察执行阶段的运行。每个周期中，执行阶段要么处理1条指令并继续剩下的阶段直到完成；要么处理3种特殊情况之一并插入气泡。若这个阶段一共处理了<span class="math inline">\(C_i\)</span>条指令和<span class="math inline">\(C_b\)</span>个气泡，则CPU共需要大约<span class="math inline">\(C_i+C_b\)</span>个时钟周期来执行<span class="math inline">\(C_i\)</span>条指令 (忽略了启动指令通过流水线的周期)。 <span class="math display">\[ CPI=\frac{C_i+C_b}{C_i}=1.0+\frac{C_b}{C_i} \]</span> 　　CPI等于1.0加处罚项<span class="math inline">\(\frac{C_b}{C_i}\)</span>，这个项表示执行1条指令需要插入的气泡的平均值。 <span class="math display">\[ CPI=1.0+lp+mp+rp \]</span> 　　处罚项<span class="math inline">\(\frac{C_b}{C_i}\)</span>可以分为3部分，<span style="background-color:#ff0">加载处罚<span class="math inline">\(lp\)</span></span>表示由于加载/使用隐患造成暂停而插入的气泡的平均值，<span style="background-color:#ff0">预测错误的分支处罚<span class="math inline">\(mp\)</span></span>表示由于预测错误的分支造成取消指令而插入的气泡的平均值，<span style="background-color:#ff0">返回处罚<span class="math inline">\(rp\)</span></span>表示由于指令<code>ret</code>造成暂停而插入的气泡的平均值。</p><table><thead><tr><th></th><th>处罚</th><th>指令出现机率</th><th>造成特殊情况的机率</th><th>气泡数</th><th>乘积</th></tr></thead><tbody><tr><td>加载指令</td><td><span class="math inline">\(lp\)</span></td><td>0.25</td><td>0.20</td><td>1</td><td>0.05</td></tr><tr><td>跳转指令</td><td><span class="math inline">\(mp\)</span></td><td>0.20</td><td>0.40</td><td>2</td><td>0.16</td></tr><tr><td>指令<code>ret</code></td><td><span class="math inline">\(rp\)</span></td><td>0.02</td><td>1.00</td><td>3</td><td>0.06</td></tr><tr><td>总和</td><td></td><td></td><td></td><td></td><td>0.27</td></tr></tbody></table><p>　　3种处罚的总和是0.27，得到CPI为1.27。若想要进一步降低CPI，则应该优化预测错误的分支。若使用成功率为65%的分支预测策略，则<span class="math inline">\(mp=0.35\cdot0.20\cdot2=0.14\)</span>，这个提升并不大，但如果分支预测策略的成本不高，则这个提升还算值得。</p><h4 id="未完成的工作">4.5.8 未完成的工作</h4><p>　　PIPE还缺乏<span style="background-color:#ff0">多指令周期</span>和<span style="background-color:#ff0">存储系统接口</span>这些CPU设计中必须的关键特性。</p><p>　　Y86-64指令集的所有指令都包括一些整数加法等简单的操作。这些操作可以在执行阶段的单周期内处理完成。在一个更完整的指令集中，还将实现一些整数乘除和浮点运算等更复杂的指令。像PIPE这种性能中等的CPU中，这些操作的典型执行时间从浮点加法的3或4个周期到整数除法的64个周期。为了实现这些指令，还需要额外的硬件和协调这些指令的处理和流水线其他部分的机制。</p><p>　　实现多指令周期的方法之一是直接用整数和浮点运算单元扩展执行阶段逻辑的功能，但是这种方法需要指令在执行阶段停留多个周期，进而导致取指和译码阶段暂停，所以这种方法的性能并不好。</p><p>　　另一种实现多指令周期的方法是使用独立于主流水线的特殊硬件功能单元来处理较复杂的操作，这种方法的性能更好。通常，有1个功能单元来执行整数乘除，还有1个功能单元来执行浮点操作。当指令进入译码阶段时，可以将其发送给特殊单元。在特殊单元处理时，流水线会继续执行其他指令。通常，浮点单元本身也是流水线化的，所以多条指令可以在主流水线和各个单元中并发执行。不同单元的操作必须同步以避免出错，这可以通过暂停、气泡、转发和取消等机制来实现。</p><p>　　PIPE会假设取指单元和数据存储器都可以在单时钟周期内读写内存中的任意位置，并且忽略了自我修改代码可能造成的隐患。之前介绍过，CPU的存储系统由多个硬件存储器和管理内存的操作系统共同组成。存储系统被组织成层次结构，典型的CPU有2个L1缓存，分别用于读写指令和数据。另一种缓存是<strong>页表缓存</strong>，用于将虚拟地址快速转换为物理地址。将两者结合起来，在大多数情况下，可以在单周期内读指令并读写数据。</p><p>　　缓存总保存最常引用的存储器位置，但还是会出现<strong>未命中</strong> (引用的位置不在缓存内)。在最好的情况下 (在更高级的缓存或内存中找到未命中的数据)，处理缓存未命中需要3~20个时钟周期。同时，流水线会将指令暂停在取指或访存阶段，直到缓存能够执行读写。</p><p>　　在部分情况下，被引用的存储器位置实际上是位于磁盘。此时，硬件会生成<strong>缺页</strong>异常信号。同其他异常一样，该异常会导致CPU调用操作系统的异常处理程序并发起1个磁盘到内存的移动操作。一旦完成，操作系统会返回到原来的程序并重新执行缺页的程序。因为磁盘存取需要数百万个周期，缺页中断处理程序执行所需的几百个时钟周期可以忽略不记。</p><p>　　在CPU角度，将暂停 (处理短时间的缓存未命中) 和异常 (处理长时间的缺页) 结合起来，能够解决访问存储器时由于存储器层次结构引起的所有不可预测性而导致的问题。</p><p>　　PIPE等5阶段流水线代表了20世纪80年代中期的CPU设计水平。伯克利的Patternson研究组开发的RISC CPU原型是Sun Microsystem在1987年开发的第一个SPARC CPU的基础。斯坦福的Hennessy研究组开发的CPU由MIPS Technologies (Hennessy成立的公司) 在1986年商业化。这两者都使用的是5阶段流水线。i486也是5阶段流水线，只不过阶段之间的职责划分不太相同，它有2个译码阶段和1个合并的执行/访存阶段。这些流水线化设计的CPI也大于1.0。</p><p>　　较新的CPU支持<strong>超标量</strong> (并行地取指、译码和执行多条指令)，可以实现小于1.0的CPI。当超标量CPU已经广泛使用时，性能测量标准变为了CPI的倒数——每周期执行指令数。最新的设计使用称为<strong>乱序</strong>的技术来并行地执行多条指令，顾名思义，执行的顺序可能完全不同于它们在程序中出现的顺序，但保留了顺序ISA模型的整体行为。在芯片上集成许多简单的CPU而非少量更复杂的CPU来提高整体计算能力的策略称为<strong>多核</strong>。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/" rel="prev" title="《深入理解计算机系统 第3版》第3章 程序的机器级表示"><i class="fa fa-angle-left"></i> 《深入理解计算机系统 第3版》第3章 程序的机器级表示</a></div><div class="post-nav-item"><a href="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/" rel="next" title="《深入理解计算机系统 第3版》第5章 优化程序性能">《深入理解计算机系统 第3版》第5章 优化程序性能 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script></body></html>