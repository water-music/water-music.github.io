<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><link rel="canonical" href="http://example.com/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/","path":"2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/","title":"《深入理解计算机系统 第3版》第8章 异常控制流"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《深入理解计算机系统 第3版》第8章 异常控制流 |</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-text">8.1 异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">8.1.1 异常处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%88%AB"><span class="nav-text">8.1.2 异常类别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-text">8.1.2.1 中断</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%B7%E9%98%B1"><span class="nav-text">8.1.2.2 陷阱</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%85%E9%9A%9C"><span class="nav-text">8.1.2.3 故障</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E6%AD%A2"><span class="nav-text">8.1.2.4 中止</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#linuxx86-84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="nav-text">8.1.3 Linux&#x2F;x86-84系统中的异常</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-text">8.2 进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-text">8.3 系统调用错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">8.4 进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-text">8.4.1 回收子进程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="nav-text">8.4.1.1 修改默认行为</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%B7%B2%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81"><span class="nav-text">8.4.1.2 检查已回收子进程的退出状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%A4%BA%E4%BE%8B"><span class="nav-text">8.4.1.3 相关示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%B9%B6%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="nav-text">8.4.2 加载并执行程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8fork%E5%92%8Cexecve%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="nav-text">8.4.3 用fork()和execve()运行程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-text">8.5 信号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="nav-text">8.5.1 发送信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E4%BF%A1%E5%8F%B7"><span class="nav-text">8.5.2 接收信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E8%A7%A3%E9%99%A4%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7"><span class="nav-text">8.5.3 阻塞和解除阻塞信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-text">8.5.4 编写信号处理程序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="nav-text">8.5.4.1 安全的信号处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="nav-text">8.4.5.2 正确的信号处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="nav-text">8.4.5.3 可移植的信号处理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%B5%81%E4%BB%A5%E9%81%BF%E5%85%8D%E5%B9%B6%E5%8F%91%E6%BC%8F%E6%B4%9E"><span class="nav-text">8.5.5 同步流以避免并发漏洞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E5%9C%B0%E7%AD%89%E5%BE%85%E4%BF%A1%E5%8F%B7"><span class="nav-text">8.5.6 显式地等待信号</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E6%9C%AC%E5%9C%B0%E8%B7%B3%E8%BD%AC"><span class="nav-text">8.6 非本地跳转</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《深入理解计算机系统 第3版》第8章 异常控制流 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《深入理解计算机系统 第3版》第8章 异常控制流</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-06-17 00:00:00" itemprop="dateCreated datePublished" datetime="2023-06-17T00:00:00+08:00">2023-06-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-11-06 00:00:00" itemprop="dateModified" datetime="2023-11-06T00:00:00+08:00">2023-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/computer-system/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>29k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　从CPU通电到断电，假设PC的值序列为<span class="math inline">\(a_0,a_1,..,a_{n-1}\)</span>，其中<span class="math inline">\(a_k\)</span>是对应的指令<span class="math inline">\(I_k\)</span>的地址。那么，从<span class="math inline">\(a_k\)</span>到<span class="math inline">\(a_{k+1}\)</span>的过渡称为<strong>控制转移</strong>，这样的控制转移序列称为CPU的<strong>控制流</strong>。最简单的控制流就是平滑的序列，即<span class="math inline">\(I_k\)</span>和<span class="math inline">\(I_{k+1}\)</span>在内存中是相邻的。这种平滑流的突然变化通常由跳转、调用和返回等指令造成。</p><p>　　操作系统必须能够响应内部程序没有捕获的系统状态变化和不一定与程序执行相关的系统状态变化。例如，硬件定时器会定期产生信号，该事件必须得到处理。分组到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到收到数据已就绪的通知。当子进程终止时，其父进程必须收到通知。</p><p>　　现代系统通过让控制流发生突然变化来应对这些情况，这些突然变化称为<strong>异常控制流</strong>。ECF发生计算机系统的各个层级。例如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过切换上下文来在用户进程之间进行控制转移。在应用层，进程可以发送信号到其他进程，接收者会将控制突然转移到它的信号处理程序。单个程序可以通过回避通常的栈规则并执行到其他函数中任意位置的<strong>非本地</strong>跳转 (即违反常规的调用/返回栈规则的跳转) 来对响应错误。</p><p>　　<strong>异常</strong>是ECF的一种形式，由硬件和操作系统共同实现。</p><p>　　软件异常允许程序进行非本地跳转来响应。C++和Java等语言通过<code>try</code>、<code>catch</code>和<code>throw</code>语句来提供软件异常机制，C语言通过函数<code>setjmp()</code>和<code>longjmp()</code>来提供软件异常机制，前者的异常机制相对后者更结构化。<code>catch</code>语句可类比为函数<code>setjmp()</code>，<code>throw</code>语句可类比为函数<code>longjmp()</code>。</p><p>　　在CPU中，状态编码为不同的位和信号，状态变化称为<strong>事件</strong>。事件可能和当前执行的指令直接相关。</p><p>　　CPU通常通过控制寄存器的<strong>模式位</strong>来限制应用可执行的指令和可访问的地址空间范围。当设置了模式位后，进程就运行在<strong>内核模式</strong> (也称为<strong>超级用户模式</strong>)，这样该进程可以访问指令集中的任何指令和系统中的任何内存位置。没有设置模式位时，进程运行在用户模式，该模式下不能执行<strong>特权指令</strong>，例如，停止CPU、改变模式位和发起I/O操作。此外，用户模式中的进程不能直接引用地址空间中内核区的代码和数据。</p><p>　　Linux提供了很多监控和控制进程的工具。</p><p>　　● STRACE：打印正在运行的程序 (及其子进程) 调用的每个系统调用的轨迹。</p><p>　　● PS：列出当前系统中的进程 (包括僵尸进程)。</p><p>　　● TOP：打印关于当前进程资源使用的信息。</p><p>　　● PMAP：显示进程的内存映射。</p><p>　　● <code>proc/</code>：虚拟文件系统，以ASCII文本格式输出大量内核数据结构的信息，用户程序可以读取这些内容。</p><p>　　● <code>/sys</code>：Linux 2.6版本内核加入的文件系统，它能输出关于系统总线和设备的额外底层信息。</p><span id="more"></span><h3 id="异常">8.1 异常</h3><img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/anatomy_of_an_exception.svg" title="anatomy_of_an_exception"><p>　　当CPU检测到事件发生时，会通过称为<strong>异常表</strong>的跳转表来进行间接过程调用 (异常)，到专门设计来处理此类事件的称为<strong>异常处理程序</strong>的操作系统子程序。当异常处理程序完成处理后，根据引起异常的事件的类型，出现以下情况之一：</p><p>　　● 异常处理程序将控制权转移给<span class="math inline">\(I_{curr}\)</span>，即异常发生时正在执行的指令。</p><p>　　● 异常处理程序将控制权转移给<span class="math inline">\(I_{next}\)</span>，即异常发生时正在执行的指令的下一条指令。</p><p>　　● 异常处理程序中止被中断的程序。</p><h4 id="异常处理">8.1.1 异常处理</h4><p>　　系统中的每种异常都有唯一的非负整数<strong>异常号</strong>。部分异常号由CPU的设计者分配 (例如，除以0、缺页、内存访问越界、断点和算术运算溢出)，其他异常号由操作系统内核的设计者分配 (例如，系统调用和外部I/O设备的信号)。</p><p>　　当计算机启动或重启时，操作系统会分配和初始化异常表，使得条目<code>k</code>包含异常<code>k</code>对应的异常处理程序的地址。当CPU检测到事件并确定对应的异常号后，会触发异常，方法是通过异常表的条目来执行到对应异常处理程序的间接过程调用。</p><img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/generating_the_address_of_an_exception_handler.svg" title="generating_the_address_of_an_exception_handler"><p>　　对于异常表，索引就是异常号，其起始地址存放在<strong>异常表基址寄存器</strong>中。</p><p>　　一旦硬件触发了异常，剩下的工作都由异常处理程序在软件中完成。异常处理程序运行在<span style="background-color:#ff0">内核模式</span>下，所以它们对所有的系统资源都有完全的访问权限。异常处理程序完成处理后，通过特殊的中断返回指令，可选地返回到中断的程序，该指令将适当的状态弹回到CPU的控制和数据寄存器中。若异常中断的是用户程序，则将状态恢复到<span style="background-color:#ff0">用户模式</span>并将控制权转移给中断的程序。</p><h4 id="异常类别">8.1.2 异常类别</h4><p>　　异常按类型可以分为<span style="background-color:#ff0">中断</span>、<span style="background-color:#ff0">陷阱</span>、<span style="background-color:#ff0">故障</span>和<span style="background-color:#ff0">中止</span>，按同步和异步可以分为<span style="background-color:#ff0">同步异常</span> (陷阱、故障和中止) 和<span style="background-color:#ff0">异步异常</span> (中断)。</p><table><thead><tr><th>异常类别</th><th>原因</th><th>异步/同步</th><th>返回行为</th></tr></thead><tbody><tr><td>中断</td><td>来自I/O设备的信号</td><td>异步</td><td>总是返回到下一条指令</td></tr><tr><td>陷阱</td><td>有意的异常</td><td>同步</td><td>总是返回到下一条指令</td></tr><tr><td>故障</td><td>可能修复的错误</td><td>同步</td><td>可能返回到当前指令</td></tr><tr><td>中止</td><td>不可修复的错误</td><td>同步</td><td>不会返回</td></tr></tbody></table><p>　　陷阱、故障和中止是同步发生的，即执行当前指令的结果，而这类指令称为<strong>故障指令</strong>。</p><p>　　运行应用程序代码的进程初始默认用户模式，若需要变为内核模式，则需要通过中断、故障或陷阱这样的异常。</p><h5 id="中断">8.1.2.1 中断</h5><p>　　硬件中断不是由执行任何一条指令造成，所以它是异步的。硬件中断的异常处理程序称为<strong>中断处理程序</strong>。</p><img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/interrupt_handling.svg" title="interrupt_handling"><p>　　I/O设备向CPU芯片上的中断引脚发送信号并将异常号放到系统总线上来触发中断，该异常号标识了引起中断的设备。在当前指令完成后，CPU检测到中断引脚的电压变高，从系统总线读取异常号并调用对应的中断处理程序。当中断处理程序返回后，将控制权转移给下一条指令，然后程序像没有出现中断一样继续执行。</p><h5 id="陷阱">8.1.2.2 陷阱</h5><p>　　陷阱是执行某条指令的结果，最重要的用途是在用户程序和内核之间提供像过程一样的接口，称为<strong>系统调用</strong>。用户程序经常会向内核请求服务，例如，读文件<code>read()</code>、创建新进程<code>fork()</code>、加载新程序<code>execve()</code>和中止当前进程<code>exit()</code>，为了允许对此类服务的受控访问，CPU提供了特殊<code>syscall n</code>指令，当用户程序想要请求服务<code>n</code>时，可以执行该指令。</p><img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/trap_handling.svg" title="trap_handling"><p>　　执行<code>syscall</code>指令会导致陷阱，陷阱处理程序会解析参数并调用对应的内核程序。</p><p>　　从程序员角度，系统调用和普通的函数调用是一样的，但它们的实现不同。普通的函数运行在用户模式，用户模式限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的栈。系统调用运行在内核模式，内核模式允许系统执行特权指令，而且能访问定义在内核中的栈。</p><h5 id="故障">8.1.2.3 故障</h5><p>　　故障由错误情况引起，它可能能被故障处理程序修复。</p><img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/fault_handling.svg" title="fault_handling"><p>　　当故障发生时，CPU会将控制权转移给故障处理程序。若故障处理程序能够修复，则它会将控制权转移给导致故障的指令，然后重新执行该指令；否则，从故障处理程序返回到<code>abort</code>例程，该例程会中止导致故障的应用程序。</p><p>　　缺页异常就是典型的故障，当指令引用某个虚拟地址，但该虚拟地址对应的物理地址不在内存中，所以必须从磁盘中取出，此时就会发生故障。缺页处理程序会从磁盘加载对应的页面，然后将控制权转移给引起故障的指令。当指令再次执行时，对应的物理页面已驻留在内存中，指令就可以没有故障地完成了。</p><h5 id="中止">8.1.2.4 中止</h5><img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/abort_handling.svg" title="abort_handling"><p>　　中止是不可修复的故障导致的结果，通常是硬件故障，例如，DRAM/SRAM位被损坏时发生的奇偶错误。中止处理程序不会将控制权转移给应用程序。</p><h4 id="linuxx86-84系统中的异常">8.1.3 Linux/x86-84系统中的异常</h4><p>　　x86-64中有256种异常类型。异常号0~31是Intel架构师定义的异常，所以对所有x86-64系统都相同。异常号32~255是OS定义的中断和陷阱。</p><table><thead><tr><th>异常号</th><th>描述</th><th>异常类别</th></tr></thead><tbody><tr><td>0</td><td>除法错误</td><td>故障</td></tr><tr><td>13</td><td>一般保护故障</td><td>故障</td></tr><tr><td>14</td><td>缺页</td><td>故障</td></tr><tr><td>18</td><td>机器检查</td><td>中止</td></tr><tr><td>32~255</td><td>OS定义的异常</td><td>中断或陷阱</td></tr></tbody></table><p>　　当除以0或除法指令的结果比目标操作数大很多时，就会发生除法错误，Unix会直接中止程序而非试图修复此类故障。shell通常把除法错误称为<strong>浮点异常</strong>。</p><p>　　很多原因都会导致一般保护故障，例如，引用未定义的虚拟内存区域和写只读的文件。Linux不会试图修复此类故障。shell通常把一般保护故障称为<strong>段故障</strong>。</p><p>　　执行会导致故障的指令时，若遇到硬件故障，则会发生机器检查。机器检查处理程序不会将控制权转移给应用程序。</p><p>　　Linux提供数百种系统调用。每种系统调用都有唯一的整数编号，每个编号都对应内核中跳转表的偏移。</p><table><thead><tr><th>(系统调用) 编号</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td><code>read</code></td><td>读文件</td></tr><tr><td>1</td><td><code>write</code></td><td>写文件</td></tr><tr><td>2</td><td><code>open</code></td><td>打开文件</td></tr><tr><td>3</td><td><code>close</code></td><td>关闭文件</td></tr><tr><td>4</td><td><code>stat</code></td><td>获取文件信息</td></tr><tr><td>9</td><td><code>mmap</code></td><td>将内存页映射到文件</td></tr><tr><td>12</td><td><code>brk</code></td><td>重置栈顶</td></tr><tr><td>32</td><td><code>dup2</code></td><td>复制文件描述符</td></tr><tr><td>33</td><td><code>pause</code></td><td>挂起进程直到信号到达</td></tr><tr><td>37</td><td><code>alarm</code></td><td>调度报警信号的发送</td></tr><tr><td>39</td><td><code>getpid</code></td><td>获取进程ID</td></tr><tr><td>57</td><td><code>fork</code></td><td>创建进程</td></tr><tr><td>59</td><td><code>execve</code></td><td>执行程序</td></tr><tr><td>60</td><td><code>_exit</code></td><td>终止程序</td></tr><tr><td>61</td><td><code>wait4</code></td><td>等待进程终止</td></tr><tr><td>62</td><td><code>kill</code></td><td>发送信号到进程</td></tr></tbody></table><p>　　对于大多数系统调用，标准C语言库都提供了一组便利的包装函数。这些包装函数将参数打包到一起，以适当的系统调用指令陷入内核，然后将系统调用的返回传递给调用程序。系统调用及其对应的包装函数都称为<strong>系统级函数</strong>。</p><p>　　Linux的系统调用的参数都是通过寄存器传递，寄存器<code>%rax</code>存放系统调用号，最多可以有6个参数，按序分别存放在<code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%r10</code>、<code>%r9</code>和<code>%r8</code>中。从系统调用返回时，寄存器<code>%rcx</code>和<code>%r11</code>都会被清空，<code>%rax</code>存放返回值。-4095到-1的负数返回值表示出现错误，对应负的的<code>errno</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;hello, world\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.section .data</span><br><span class="line">string:</span><br><span class="line">  .ascii &quot;hello, world\n&quot;</span><br><span class="line">string_end:</span><br><span class="line">  .equ len, string_end - string</span><br><span class="line">.section .text</span><br><span class="line">.globl main</span><br><span class="line">main:</span><br><span class="line">  # 调用write</span><br><span class="line">  movq  $1, %rax  # write的系统调用号是1</span><br><span class="line">  movq  $1, %rdi  # 参数1，stdout的描述符是1</span><br><span class="line">  movq  $string, %rsi # 参数2</span><br><span class="line">  movq  $len, %rdx  # 参数3</span><br><span class="line">  syscall # 执行系统调用</span><br><span class="line">  # 调用_exit</span><br><span class="line">  movq  $60, %rax # _exit的系统调用号是60</span><br><span class="line">  movq  $0, %rdi  # 参数1</span><br><span class="line">  syscall # 执行系统调用</span><br></pre></td></tr></table></figure><p>　　这是使用了系统级函数的<code>hello</code>程序及其对应的汇编代码。函数<code>write()</code>的第1个参数将传递到<code>stdout</code>，第2个参数是待写的字节序列，第3个参数是待写的字节数。</p><h3 id="进程">8.2 进程</h3><p>　　进程的经典定义是正在执行的程序的<strong>实例</strong>。</p><p>　　即使系统中通常有很多其他程序在运行，进程也可以提供<span style="background-color:#ff0">看似独占地使用CPU</span>的假象。若使用调试器单步执行程序，会看到一系列的PC值，这些值唯一地对应程序的可执行文件或共享库中的指令。这个PC值的序列称为<strong>逻辑控制流</strong>，简称<strong>逻辑流</strong>。</p><p>　　进程为每个程序提供的另一个假象是<span style="background-color:#ff0">看似独占地使用系统地址空间</span>。在<span class="math inline">\(n\)</span>位地址的计算机上，地址空间是<span class="math inline">\(2^n\)</span>个可能地址的集合，即<span class="math inline">\(0\)</span>到<span class="math inline">\(2^n-1\)</span>。进程为每个程序提供其<strong>私有地址空间</strong>。一般情况下，和私有地址空间中的某个地址相关联的内存字节不能被其他进程访问。</p><img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/logical_control_flow.svg" title="logical_control_flow"><p>　　这里以运行3个进程的系统为例，CPU的物理控制流分为了3个逻辑流。每个竖直的流表示逻辑流的一部分，这里3个逻辑流是交错的。每个进程执行它的流一部分，然后被<strong>抢占</strong> (暂挂) 并轮到其他进程。</p><p>　　内核为每个进程维护对应的上下文，<strong>上下文</strong>就是内核重新启动暂挂进程所需的状态，由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、PC、用户栈、状态寄存器和各种内核数据结构，例如，描述地址空间的<span style="background-color:#ff0">页表</span>、包含当前进程相关信息的<span style="background-color:#ff0">进程表</span>和包含当前进程已打开文件的信息的<span style="background-color:#ff0">文件表</span>。</p><p>　　对于流X和Y，当前仅当X在Y开始之后和Y结束之前开始或Y在X开始之后和X结束之前开始，它们才能称为相互<strong>并发</strong>执行，这2个流称为<strong>并发流</strong>。例如，进程A和B是并发执行，A和C也是并发执行，但B和C不是并发执行。</p><p>　　<strong>并发</strong>指多个流并发执行。<strong>多任务</strong>指多个进程轮流运行。进程执行其控制流的一部分的时间段称为<strong>时间片</strong>，所以多任务也称为<strong>时间分片</strong>。例如，进程A由2个时间片组成。操作系统内核通过<strong>上下文切换</strong>来实现多任务。</p><p>　　若多个流运行在CPU<span style="background-color:#ff0">不同核</span>上，则它们称为<strong>并行流</strong>，它们<strong>并行运行</strong>且<strong>并行执行</strong>。</p><p>　　在进程执行时，内核可以抢占当前进程并重新开始某个暂挂的进程，该过程称为<strong>调度</strong>，由内核中的调度器执行。当内核调度时，会使用上下文切换来将控制权转移给暂挂的进程，即先保存当前进程的上下文，恢复暂挂的进程之前保存的上下文并将控制权转移给该进程。</p><p>　　当内核代表用户执行系统调度时，可能会发生上下文切换。若系统调用因等待某个事件而阻塞，则内核可以让当前进程休眠，切换到其他进程。例如，若<code>read()</code>系统调用需要访问磁盘，内核就可以选择执行上下文切换来运行其他进程而非等待数据到达。<code>sleep()</code>系统调用可以显示地请求调用进程休眠。一般情况下，即使系统调用没有阻塞，内核也可以决定执行上下文切换而非将控制权转移给调用进程。</p><p>　　中断可能导致上下文切换。例如，所有系统都有产生周期性定时器中断的机制，间隔通常是1ms到10ms。每次发生定时器中断时，内核就能判断当前进程已经运行了足够长的时间，并切换到新进程。</p><h3 id="系统调用错误处理">8.3 系统调用错误处理</h3><p>　　当Unix系统级函数出错时，通常返回-1并设置全局整数变量<code>errno</code>来表示错误类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数<code>strerror()</code>会返回与<code>errno</code>对应的错误的文本串。通过定义以下的<strong>错误报告函数</strong>，能简化这段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    unix_error(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　通过错误处理包装函数，可以进一步简化代码。对于给定的基本函数<code>foo()</code>，定义具有相同参数的包装函数<code>Foo()</code> (首字母大写)，包装函数会调用基本函数，检查错误，若出错，则终止。以下是函数<code>fork()</code>的错误处理包装函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进程控制">8.4 进程控制</h3><p>　　从程序员角度，进程总是处于以下3种状态之一：</p><p>　　● <strong>运行</strong>。进程要么在CPU上执行，要么在等待被执行并最终被内核调度。</p><p>　　● <strong>停止</strong>。进程的执行被<span style="background-color:#ff0">挂起</span>且不会被调度。当收到信号SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU时，进程会停止并一直持续到收到信号SIGCONT，此时，进程再次开始运行。</p><p>　　● <strong>终止</strong>。进程永远停止。只有当收到默认行为是终止进程的信号、从主程序返回或调用函数<code>exit()</code>时，进程才会终止。</p><p>　　Unix提供了C语言控制进程的系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure><p>　　函数<code>exit()</code>会以退出状态<code>status</code>来终止进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程PID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的父进程PID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 子进程返回0，父进程返回子进程PID，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　每个进程都有唯一的正整数进程ID (PID)。在Linux中，<code>types.h</code>把<code>pid_t</code>定义为<code>int</code>。</p><p>　　<strong>父进程</strong>通过调用函数<code>fork()</code>来创建新的正在运行的<strong>子进程</strong>。子进程得到与父进程用户级虚拟地址空间相同但<span style="background-color:#ff0">独立</span>的副本，包括代码段、数据段、堆、共享库和用户栈。子进程还获得与父进程所有文件描述符相同的副本，这表示子进程可以读写父进程调用函数<code>fork()</code>时打开的所有文件。父进程和子进程之间最大的区别是PID。</p><p>　　函数<code>fork()</code>只会被调用1次，但父进程和子进程都会返回， 父进程中返回子进程PID，子进程中返回0。因为子进程PID总是非0，返回值可以分辨程序是在父进程还是在子进程中执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    pid = Fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child: x=%d\n&quot;</span>, ++x);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: x=%d\n&quot;</span>, --x);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/process_graph_for_the_example_program.svg" title="process_graph_for_the_example_program"><p>　　这个示例会使用函数<code>fork()</code>创建子进程。当函数<code>fork()</code>返回时 (第6行)，父进程和子进程中的<code>x</code>的值都为1，然后父子进程在自己的私有地址空间并发执行。子进程在第8行加1并输出其<code>x</code>的副本 (值为0)，父进程在第13行减1并输出其<code>x</code>的副本 (值为2)。</p><p>　　对于运行在单核CPU上的程序，进程图中所有顶点的<strong>拓扑排序</strong>都表示程序中对应的语句的可行总排序。当且仅当画出的每条边的方向都是从左到右时，该排列是拓扑排序。这里，父子进程的<code>printf()</code>语句可以以任意顺序执行，因为每种顺序都对应图顶点的某种拓扑排序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    Fork();</span><br><span class="line">    Fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/process_graph_for_a_nested_fork.svg" title="process_graph_for_a_nested_fork"><p>　　这个示例的源码中调用了2次函数<code>fork()</code>，而进程图中实际运行了4个进程，每个都调用了1次函数<code>printf()</code>，这样函数<code>printf()</code>可以以任意顺序执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>; <span class="comment">/* 返回剩余待休眠秒数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 总是返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>sleep()</code>会将进程挂起指定时间，若已达到指定挂起时间，则返回0；若提前返回 (被信号中断)，则返回剩余待挂起时间 (单位为秒)。函数<code>pause()</code>也会让函数休眠直到进程收到信号。</p><h4 id="回收子进程">8.4.1 回收子进程</h4><p>　　当进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程一直保持终止状态直到被其父进程<strong>回收</strong>。当父进程回收终止的子进程时，内核会将子进程的退出状态传递给父进程，然后清除终止的子进程，此时，该子进程将不复存在。终止但未被回收的进程称为<strong>僵尸</strong>进程。</p><p>　　若父进程终止，则其子进程会成为<strong>孤儿</strong>进程，内核会让<code>init</code>进程领养孤儿进程。<code>init</code>进程PID为1，是系统启动时由内核创建，它不会终止，是所有进程的祖先。若孤儿进程是僵尸进程，则<code>init</code>进程会进行回收。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statusp, <span class="type">int</span> options)</span>; <span class="comment">/* 若成功则返回子进程PID，若WNOHANG则返回0，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statusp)</span>; <span class="comment">/* 若成功则返回子进程PID，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　进程可以通过调用函数<code>waitpid()</code>来等待其子进程终止。默认情况下 (参数<code>options</code>为0时)，函数<code>waitpid()</code>会挂起调用进程，直到其<strong>等待集合</strong>中的某个子进程终止。若等待集合中的某个进程在调用时就已终止，则函数<code>waitpid()</code>会立即返回。在这2种情况下，函数<code>waitpid()</code>会返回导致自身返回的已终止子进程PID。此时，已终止的子进程已被回收，内核会从系统中删除其所有痕迹。</p><p>　　等待集合的成员由参数<code>pid</code>确定：</p><p>　　● 若<code>pid</code>大于0，则等待集合就是1个单独的子进程，其PID等于<code>pid</code>。</p><p>　　● 若<code>pid</code>为-1，则等待集合就是父进程所有的子进程。</p><p>　　函数<code>waitpid()</code>还支持其他类型的等待集合，包括Unix进程组。</p><p>　　若调用进程没有子进程，则函数<code>waitpid()</code>会返回-1并将<code>errno</code>设置为<code>ECHILD</code>。若函数<code>waitpid()</code>被信号中断，则返回-1并将<code>errno</code>设置为<code>EINTR</code>。头文件<code>errno.h</code>中定义了<code>errno</code>相关的宏。</p><p>　　调用<code>wait(&amp;status)</code>等价于调用<code>waitpid(-1, &amp;status, 0)</code>。</p><h5 id="修改默认行为">8.4.1.1 修改默认行为</h5><p>　　可以将参数<code>options</code>设置为常量<code>WNOHANG</code>、<code>WUNTRACED</code>和<code>WCONTINUED</code>的各种组合修改来默认行为。</p><p>　　● <code>WNOHANG</code>：若等待集合中的所有子进程都还没终止，则立即返回0。默认的行为是挂起调用进程，直到子进程终止。在等待子进程终止时还想进行其他工作，可以使用该选项。</p><p>　　● <code>WUNTRACED</code>：挂起调用进程直到等待集合中的1个进程变为终止或停止。返回PID为导致返回的已终止或已停止的子进程PID。默认行为是只返回已终止的子进程。当需要检查已终止或已停止的子进程时，该选项会有用。</p><p>　　● <code>WCONTINUED</code>：挂起调用进程直到等待集合中的1个正在运行的进程终止或等待集合中1个停止的进程收到信号SIGCONT重新开始执行。</p><p>　　这3个常量可以用或运算来组合。例如，<code>WNOHANG | WUNTRACED</code>：立即返回，若等待集合中的子进程都没有终止或停止，则返回0；若有1个进程终止或停止，则返回该子进程PID。</p><h5 id="检查已回收子进程的退出状态">8.4.1.2 检查已回收子进程的退出状态</h5><p>　　若参数<code>statusp</code>是非空，则函数<code>waitpid()</code>会设置<code>status</code>来表示导致返回的子进程的状态信息，这里<code>status</code>是<code>statusp</code>指向的值。头文件<code>wait.h</code>定义了<code>status</code>参数的几个宏：</p><p>　　● <code>WIFEXITED</code>：若子进程调用<code>exit()</code>或<code>return</code>正常终止，则返回真。</p><p>　　● <code>WEXITSTATUS</code>：返回1个正常终止的子进程的退出状态。只有在<code>WIFEXITED()</code>返回真时，才会定义该状态。</p><p>　　● <code>WIFSIGNALED</code>：若子进程因1个未捕获的信号终止，则返回真。</p><p>　　● <code>WTERMSIG</code>：返回导致子进程终止的信号的编号。只有在<code>WIFSIGNALED()</code>返回真时，才会定义该状态。</p><p>　　● <code>WIFSTOPPED</code>：若导致返回的子进程已停止，则返回真。</p><p>　　● <code>WIFCONTINUED</code>：若子进程收到信号SIGCONT重新运行，则返回真。</p><h5 id="相关示例">8.4.1.3 相关示例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status, i;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程创建N个子进程 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">100</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程回收这N个子进程 (无特定顺序) */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated normally with exit status=%d\n&quot;</span>, pid, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated abnormally\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有当没有子进程时才正常终止 */</span></span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在这个示例中，使用了函数<code>waitpid()</code>来 (不按照特定顺序) 等待所有<code>N</code>个子进程终止。在第11行中，父进程创建了<code>N</code>个子进程，在第13行中，每个子进程以唯一的退出状态退出。</p><p>　　在第18行中，父进程用函数<code>waitpid()</code>作为<code>while</code>循环条件，等待其所有子进程终止。函数<code>waitpid()</code>的第1个参数是-1，所以对函数<code>waitpid()</code>的调用会阻塞，直到任意1个子进程终止。每当子进程终止时，对函数<code>waitpid()</code>的调用会返回该子进程PID。第20行会检查子进程退出状态，若是正常终止 (调用函数<code>exit()</code>退出)，则父进程提取退出状态并输出到<code>stdout</code>。</p><p>　　当回收所有子进程后，再调用函数<code>waitpid()</code>会返回-1并将<code>errno</code>设置为<code>ECHILD</code>。第31行会检查函数<code>waitpid()</code>是否正常终止，若不是，则返回错误信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status, i;</span><br><span class="line">    <span class="type">pid_t</span> pid[N], retpid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程创建N个子进程 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid[i] = Fork()) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">100</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程按序回收这N个子进程 */</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((retpid = waitpid(pid[i++], &amp;status, <span class="number">0</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated normally with exit status=%d\n&quot;</span>, retpid, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated abnormally\n&quot;</span>, retpid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有当没有子进程时才正常终止 */</span></span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这是改进后版本，按照父进程创建子进程的顺序来回收这些子进程。父进程按照顺序存储了其子进程PID，然后通过适当的PID作为第1个参数来调用函数<code>waitpid()</code>，按照同样的顺序来等待每个子进程。</p><h4 id="加载并执行程序">8.4.2 加载并执行程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span>; <span class="comment">/* 若成功则不返回，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure><img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/organization_of_function_execve's_arguments.svg" title="organization_of_function_execve" alt="s_arguments"><p>　　函数<code>execve()</code>会加载并执行可执行文件<code>filename</code>，并且会带参数列表<code>argv</code>和环境变量列表<code>envp</code>。只有出错时 (找不到<code>filename</code>等)，函数<code>execve()</code>才会返回到调用程序。</p><p>　　参数<code>argv</code>指向以<code>NULL</code>结尾的指针数组，其中每个指针都指向1个参数字符串。按照惯例，<code>argv[0]</code>是可执行文件的名称。参数<code>envp</code>指向以<code>NULL</code>结尾的指针数组，其中每个指针指向1个环境变量字符串，每个字符串都是形如<code>name=value</code>的键值对。</p><p>　　函数<code>execve()</code>加载<code>filename</code>后，会调用7.7中介绍的系统启动函数。系统启动函数会设置栈并将控制权转移给程序的主函数，主函数有2种等价的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *envp[])</span>;</span><br></pre></td></tr></table></figure><p>　　主函数有3个参数，参数<code>argc</code>表示<code>argv[]</code>中非空指针的数量，参数<code>argv</code>指向数组<code>argv[]</code>的第1个元素，参数<code>envp</code>指向数组<code>envp[]</code>的第1个元素。</p><img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/typical_organization_of_the_user_stack_when_a_new_program_starts.svg" title="typical_organization_of_the_user_stack_when_a_new_program_starts"><p>　　主函数开始执行时，栈底是以<code>NULL</code>结尾的环境变量字符串和命令行参数字符串。其后是以<code>NULL</code>结尾的指针数组，其中每个指针都指向1个环境变量字符串，全局变量<code>environ</code>指向该数组的第1个元素<code>envp[0]</code>。其后是另一个以<code>NULL</code>结尾的指针数组，其中每个指针都指向1个参数字符串。栈顶是系统启动函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 若存在则返回指向name的指针，若不存在则返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *newvalue, <span class="type">int</span> overwrite)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><p>　　函数<code>getenv()</code>会在环境变量数组中搜索字符串<code>name=value</code>。若找到，则返回指向<code>value</code>的指针；否则，返回<code>NULL</code>。当环境变量数组中有形如<code>name=oldvalue</code>的字符串时，函数<code>unsetenv()</code>会删除它，此时，若<code>overwrite</code>非0，则函数<code>setenv()</code>会用<code>newvalue</code>替换<code>oldvalue</code>。若<code>name</code>不存在，则函数<code>setenv()</code>会把<code>name=newvalue</code>添加到环境变量数组。</p><h4 id="用fork和execve运行程序">8.4.3 用<code>fork()</code>和<code>execve()</code>运行程序</h4><p>　　Unix shell和Web服务器等程序大量地使用了函数<code>fork()</code>和<code>execve()</code>。shell是交互型程序，它代表用户运行其他程序。最早的shell是<code>sh</code>，后来出现了一些变种，例如，<code>csh</code>、<code>tcsh</code>、<code>ksh</code>和<code>bash</code>。shell会执行一系列读/求值步骤，然后终止。读步骤会读来自用户的1个命令行。求值步骤会解析命令行并代表用户运行程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">char</span> *buf, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *delim; <span class="comment">/* 指向首个空格分隔符 */</span></span><br><span class="line">    <span class="type">int</span> argc;    <span class="comment">/* 参数数量 */</span></span><br><span class="line">    <span class="type">int</span> bg;      <span class="comment">/* 是否后台执行 */</span></span><br><span class="line"></span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27; &#x27;</span>; <span class="comment">/* 用空格替换结尾的\n */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略开头的空格 */</span></span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        buf++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构建参数列表 */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        argv[argc++] = buf;</span><br><span class="line">        *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        buf = delim + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 忽略空格 */</span></span><br><span class="line">        <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            buf++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略空行 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 是否后台执行 */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">builtin_commond</span><span class="params">(<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 退出命令行 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略分隔符&amp; */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *argv[MAXARGS]; <span class="comment">/* 函数execve参数列表 */</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];   <span class="comment">/* 保存修改后的命令行 */</span></span><br><span class="line">    <span class="type">int</span> bg;              <span class="comment">/* 是否后台运行 */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;           <span class="comment">/* 进程ID */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, cmdline);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略空行 */</span></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!builtin_commond(argv))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 子进程运行用户作业 */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 父进程等待前台作业终止 */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                unix_error(<span class="string">&quot;waitfg: waitpid error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %s&quot;</span>, pid, cmdline);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        Fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        eval(cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了简单shell的主函数。shell会打印1个命令行提示符，等待用户在<code>stdin</code>上输入命令行，然后对该命令行求值。这里并没有回收后台子进程。</p><p>　　函数<code>eval()</code>会对命令行求值，其首要任务是调用函数<code>parseline()</code>，这个函数会解析以空格为分隔符的命令行参数并构造最终会传递给函数<code>execve()</code>的参数<code>argv</code>。若函数<code>parseline()</code>的最后1个参数是<code>&amp;</code>，则会返回1 (在后台执行)；否则，返回0 (在前台执行)。</p><p>　　在解析完命令行后，函数<code>eval()</code>会调用函数<code>builtin_command()</code>，该函数会检查第1个命令行参数是否是内置shell命令，若是，则解释该命令并返回1；否则，返回0。</p><p>　　若函数<code>builtin_command()</code>返回0，则shell会创建子进程并在子进程中执行所请求的程序。若用户要求在后台运行该程序，则shell会返回到循环的顶部，等待下一个命令行；否则，shell会用函数<code>waitpid()</code>等待作业终止。当作业终止时，shell会开始下一轮迭代。</p><h3 id="信号">8.5 信号</h3><p>　　Linux<strong>信号</strong>是更高层的软件形式的异常，允许进程和内核中断其他进程。每种信号类型都对应某种系统事件。底层的硬件异常是由内核异常处理程序处理，正常情况下，对用户进程不可见，信号能通知用户进程发生了这些异常。</p><table><colgroup><col style="width:6%"><col style="width:14%"><col style="width:33%"><col style="width:46%"></colgroup><thead><tr><th>编号</th><th>名称</th><th>默认行为</th><th>对应事件 (默认处理操作)</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>终止</td><td>终端线挂断</td></tr><tr><td>2</td><td>SIGINT</td><td>终止</td><td>来自键盘的中断</td></tr><tr><td>3</td><td>SIGQUIT</td><td>终止</td><td>来自键盘的退出</td></tr><tr><td>4</td><td>SIGILL</td><td>终止</td><td>非法指令</td></tr><tr><td>5</td><td>SIGTRAP</td><td>终止并转存内核</td><td>追踪陷阱</td></tr><tr><td>6</td><td>SIGABRT</td><td>终止并转存内核</td><td>来自函数<code>abort()</code>的中止信号</td></tr><tr><td>7</td><td>SIGBUS</td><td>终止</td><td>总线错误</td></tr><tr><td>8</td><td>SIGFPE</td><td>终止并转存内核</td><td>浮点异常</td></tr><tr><td>9</td><td>SIGKILL</td><td>终止</td><td>杀死进程</td></tr><tr><td>10</td><td>SIGUSR1</td><td>终止</td><td>用户定义的信号1</td></tr><tr><td>11</td><td>SIGSEGV</td><td>终止并转存内核</td><td>无效的内存引用 (段故障)</td></tr><tr><td>12</td><td>SIGUSR2</td><td>终止</td><td>用户定义的信号2</td></tr><tr><td>13</td><td>SIGPIPE</td><td>终止</td><td>写没有读用户的管道</td></tr><tr><td>14</td><td>SIGALRM</td><td>终止</td><td>来自函数<code>alarm()</code>的定时器信号</td></tr><tr><td>15</td><td>SIGTREM</td><td>终止</td><td>软件终止信号</td></tr><tr><td>16</td><td>SIGSTKFLT</td><td>终止</td><td>协处理器的栈错误</td></tr><tr><td>17</td><td>SIGCHLD</td><td>忽略</td><td>1个子进程已停止或终止</td></tr><tr><td>18</td><td>SIGCONT</td><td>忽略</td><td>继续运行停止的进程</td></tr><tr><td>19</td><td>SIGSTOP</td><td>停止直到下一个SIGCONT</td><td>不是来自终端的停止信号</td></tr><tr><td>20</td><td>SIGTSTP</td><td>停止直到下一个SIGCONT</td><td>来自终端的停止信号</td></tr><tr><td>21</td><td>SIGTTIN</td><td>停止直到下一个SIGCONT</td><td>后台进程从终端读</td></tr><tr><td>22</td><td>SIGTTOU</td><td>停止直到下一个SIGCONT</td><td>后台进程从终端写</td></tr><tr><td>23</td><td>SIGURG</td><td>忽略</td><td>套接字的紧急情况</td></tr><tr><td>24</td><td>SIGXCPU</td><td>终止</td><td>超出CPU时间限制</td></tr><tr><td>25</td><td>SIGXFSZ</td><td>终止</td><td>超出文件大小限制</td></tr><tr><td>26</td><td>SIGVTALRM</td><td>终止</td><td>虚拟定时器过期</td></tr><tr><td>27</td><td>SIGPROF</td><td>终止</td><td>剖析定时器过期</td></tr><tr><td>28</td><td>SIGWINCH</td><td>忽略</td><td>窗口大小变化</td></tr><tr><td>29</td><td>SIGIO</td><td>终止</td><td>在1个描述符上执行I/O操作</td></tr><tr><td>30</td><td>SIGPWR</td><td>终止</td><td>电源故障</td></tr></tbody></table><p>　　当进程除以0时，内核会发送信号SIGFPE给它。当进程执行非法指令时，内核会发送信号SIGILL给它。其他信号对应内核或用户进程中较高层的软件事件。例如，当键盘输入Ctrl+C时，内核会发送信号SIGINT给前台进程组的每个进程。同样，当键盘输入Ctrl+Z时，会发送信号SIGTSTP给前台进程组的每个进程。进程可以向其他进程发送信号SIGKILL信号来强制终止它。当子进程停止或终止时，内核会发送信号SIGCHLD给父进程。</p><p>　　转存内存 (dumping core) 是历史术语，表示将代码和数据内存段的映射写到磁盘上 (以前的内存用磁芯存储器来实现)。</p><p>　　信号的传输由<strong>发送信号</strong>和<strong>接收信号</strong>组成。</p><p>　　● 内核通过更新目的进程上下文中的某个状态来发送信号给目的进程。发送信号可以有2种原因，即内核检测到系统事件或进程调用函数<code>kill()</code>。进程可以发送信号给自己。</p><img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/signal_handling.svg" title="signal_handling"><p>　　● 当目的进程被内核强迫以某种方式来响应信号时，它就接收了信号。进程可以忽略该信号，也可以终止或通过执行称为<strong>信号处理程序</strong>的用户级函数来捕获该信号。信号SIGKILL和SIGSTOP既不能捕获，也不能忽略。</p><p>　　发出后未被接收的信号称为<strong>待处理信号</strong>。<span style="background-color:#ff0">同一类型的待处理信号最多只能有1个</span>。若进程有1个类型为<code>k</code>的待处理信号，则之后发送到该进程的类型为<code>k</code>的信号会直接被丢弃。进程可以有选择性地<strong>阻塞</strong>特定信号的接收。当信号被阻塞时，仍可以发送，但不会被接收，直到取消对应的阻塞。</p><p>　　内核为每个进程在<code>pengding</code>位向量中维护着待处理信号的集合，在<code>blocked</code>位向量 (也称为<strong>信号掩码</strong>) 中维护着阻塞的信号集合。当发送类型为<code>k</code>的信号时，内核会设置<code>pending</code>位向量中的第<code>k</code>位。当接收类型为<code>k</code>的信号时，内核会清除<code>pengding</code>位向量中的第<code>k</code>位。</p><h4 id="发送信号">8.5.1 发送信号</h4><p>　　Unix提供了大量向进程发送信号的机制，这些机制都是基于<strong>进程组</strong>。</p><p>　　每个进程都只属于1个进程组，进程组由1个正整数ID来标识。子进程的默认进程组是父进程的进程组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的进程组ID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>; <span class="comment">/* 返回上一个alarm剩余的秒数，若没有上一个alarm则返回0 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>getpgrp()</code>会返回当前进程的进程组ID。</p><p>　　函数<code>setpgid()</code>会将PID为<code>pid</code>的进程的进程组ID设置为<code>pgid</code>。若<code>pid</code>为0，则使用当前进程PID；若<code>pgid</code>为0，则将PID为<code>pid</code>的进程的进程组ID设置为<code>pid</code>；若<code>pid</code>和<code>pgid</code>都为0，则将调用进程的进程组ID设置为其PID。</p><p>　　函数<code>alarm()</code>会让内核在<code>secs</code>秒后发送信号SIGALRM给调用进程。每次调用函数<code>alarm()</code>时，若上一次调用该函数设置的延时还未结束，则会取消上一次调用该函数设置的延时并返回剩余时间；若上一次调用该函数设置的延时已结束，则返回0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>kill()</code>会发送编号为<code>sig</code>的信号给指定进程 (包括自己)。若<code>pid</code>大于0，则会发送编号为<code>sig</code>的信号给PID为<code>pid</code>的进程；若<code>pid</code>为0，则会发送编号为<code>sig</code>的信号给调用进程所属进程组中的每个进程；若<code>pid</code>小于0，则会发送编号为<code>sig</code>的信号给进程组ID为<code>pid</code><span style="background-color:#ff0">绝对值</span>的进程组中的所有进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 子进程休眠，直到收到SIGKILL，然后终止 */</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Pause();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;control should never reach here!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程发送SIGKILL给子进程 */</span></span><br><span class="line">    Kill(pid, SIGKILL);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在这个示例中，父进程会用函数<code>kill()</code>发送信号SIGKILL给其子进程。</p><p>　　<code>/bin/kill</code>程序可以向其他进程发送任意信号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/kill -9 15213</span><br><span class="line">/bin/kill -9 -15213</span><br></pre></td></tr></table></figure><p>　　第1条命令会发送信号9 (SIGKILL) 给进程15213。第2条命令会发送信号9 (SIGKILL) 给进程组15213中的每个进程。</p><p>　　shell使用<strong>作业</strong>来表示对命令行求值而创建的进程。前台作业只能有1个，后台作业可以有任意个。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | sort</span><br></pre></td></tr></table></figure><p>　　这条命令会创建包括2个进程 (分别运行<code>ls</code>和<code>sort</code>程序) 的前台作业，这2个进程通过Unix管道连接。shell会为每个作业创建独立的进程组。进程组ID通常来自作业中的某个父进程。</p><img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/foreground_and_background_process_groups.svg" title="foreground_and_background_process_groups"><p>　　在这个示例中，shell有1个前台作业和2个后台作业。前台作业的父进程PID为20，进程组ID为20。父进程创建了2个子进程，子进程的进程组ID都是20。</p><h4 id="接收信号">8.5.2 接收信号</h4><p>　　当内核把进程<code>p</code>从内核模式切换到用户模式时，会检查进程<code>p</code>的未阻塞的待处理信号的集合。若集合为空 (通常情况下)，则内核将控制权转移给<code>p</code>的控制流中的下一条指令；若集合不为空，则选择集合中的某个信号 (通常是编号值最小) 并且强制<code>p</code>接收该信号。收到信号后进程会进行某些操作。一旦进程完成操作，那么控制权将转移给<code>p</code>的控制流的下一条指令。每个信号类型都有预定义的默认 (处理) 操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>; <span class="comment">/* 若成功则返回指向前一个处理程序的指针，若出错则返回SIG_ERR (不设置errno) */</span></span><br></pre></td></tr></table></figure><p>　　进程可以使用函数<code>signal()</code>修改信号的默认操作。信号SIGSTOP和SIGKILL的默认操作无法修改。</p><p>　　函数<code>signal()</code>通过以下3种方式之一来改变信号的默认操作：</p><p>　　● 若<code>handler</code>是SIG_IGN，则忽略编号为<code>signum</code>的信号。</p><p>　　● 若<code>handler</code>是SIG_DFL，则恢复编号为<code>signum</code>的信号的默认操作。</p><p>　　● 若<code>handler</code>是用户定义的函数 (称为<strong>信号处理程序</strong>) 的地址，只要进程接收到编号为<code>signum</code>的信号，就会调用该程序。通过把处理程序的地址传递给函数<code>signal()</code>从而改变其默认操作，称为<strong>设置信号处理程序</strong>。调用信号处理程序称为<strong>捕获信号</strong>。执行信号处理程序称为<strong>处理信号</strong>。</p><p>　　当进程捕获编号为<code>k</code>的信号时，会调用对应的信号处理程序并将1个整数参数设置为<code>k</code>，该参数允许同一处理程序捕获不同类型的信号。</p><p>　　当程序执行<code>return</code>语句时，控制权通常会转移给控制流中进程被信号中断处的指令，在某些系统中，被中断的系统调用会立即返回错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* SIGINT的信号处理程序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Cought SIGINT\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 设置信号处理程序 */</span></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, sigint_handler) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待接收信号 */</span></span><br><span class="line">    pause();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会捕获键盘输入Ctrl+C时发送的信号SIGINT，然后将其默认操作改为输出1条消息再终止该进程。</p><img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/signal_handler_can_be_interrupted_by_other_signal_handlers.svg" title="signal_handler_can_be_interrupted_by_other_signal_handlers"><p>　　信号处理程序可以被其他信号处理程序中断。在这个示例中，处理程序<code>S</code>和<code>T</code>都是信号处理程序。首先，主程序捕获到信号，信号会中断主程序，将控制权转移给处理程序<code>S</code>。处理程序<code>S</code>运行时，主程序捕获了另一个不同的信号，该信号会中断处理程序<code>S</code>，将控制权转移到处理程序<code>T</code>。从处理程序<code>T</code>返回时，处理程序<code>S</code>从它被中断的地方继续执行。最后，从处理程序<code>S</code>返回，将控制权转移给主程序，主程序从它被中断的地方继续执行。</p><h4 id="阻塞和解除阻塞信号">8.5.3 阻塞和解除阻塞信号</h4><p>　　Linux提供了隐式和显式的信号阻塞机制。</p><p>　　● 隐式阻塞机制就是内核默认阻塞与当前信号处理程序正在处理的信号的类型相同的所有待处理的信号。例如，程序捕获了信号<code>s</code>，当前正在运行信号处理程序<code>S</code>，若该进程收到了另一个信号<code>s</code>，则刚接收的<code>s</code>会变成待处理，并且在从<code>S</code>返回后才会被接收。</p><p>　　● 应用程序可以使用函数<code>sigprocmask()</code>及其辅助函数显式地阻塞和解除阻塞指定的信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下函数都是成功则返回0，出错则返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>; <span class="comment">/* 若是成员则返回1，不是则返回0，出错则返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>sigprocmask()</code>会改变当前阻塞的信号集合。具体的行为取决于<code>how</code>的值：</p><p>　　● <code>SIG_BLOCK</code>表示将<code>set</code>中的信号添加到<code>blocked</code>位向量。</p><p>　　● <code>SIG_UNBLOCK</code>表示从<code>blocked</code>位向量中删除<code>set</code>中的信号。</p><p>　　● <code>SIG_SETMASK</code>表示将<code>set</code>赋值给<code>blocked</code>位向量。</p><p>　　若<code>oldset</code>非空，则其中保存着<code>blocked</code>位向量的上一个值。</p><p>　　函数<code>sigemptyset()</code>会初始化<code>set</code>为空集合。函数<code>sigfillset()</code>会把每个信号都添加到<code>set</code>。函数<code>sigaddset()</code>会把编号为<code>signum</code>的信号添加到<code>set</code>。函数<code>sigdelset()</code>会从<code>set</code>中删除编号为<code>signum</code>的信号。函数<code>sigismember()</code>会判断编号为<code>signum</code>的信号是否在<code>set</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> mask, prev_mask;</span><br><span class="line"></span><br><span class="line">Sigemptyset(&amp;mask);</span><br><span class="line">Sigaddset(&amp;mask, SIGINT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 阻塞信号SIGINT并保存blocked位向量的上一个值 */</span></span><br><span class="line">Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不会被信号SIGINT中断的代码段 */</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复blocked位向量的上一个值，解除阻塞信号SIGINT */</span></span><br><span class="line">Sigprocmask(SIG_SETMASK, &amp;prev_mask, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>　　这个示例会通过函数<code>sigprocmask()</code>来临时阻塞信号SIGINT。</p><h4 id="编写信号处理程序">8.5.4 编写信号处理程序</h4><p>　　信号处理程序的几个属性使得它们难以分析。首先，信号处理程序与主程序并发运行，共享全局变量，所以可能与主程序或其他处理程序相互干扰。其次，如何以及何时接收信号的规则是反常的。最后，不同系统有不同的信号处理语义。因此，编写信号处理程序时要保证函数尽可能简单，并且只调用<strong>异步信号安全</strong>的函数 (可重入或不能被信号处理程序中断)。</p><h5 id="安全的信号处理">8.5.4.1 安全的信号处理</h5><p>　　信号处理程序中调用函数<code>printf()</code>和<code>sprintf()</code>是异步信号不安全的，只能使用函数<code>write()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通过标准输出来输出字符串，若成功则返回字节数，若出错则返回-1 */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> write(STDOUT_FILEND, s, sio_strlen(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过标准输出来输出长整型数，若成功则返回字节数，若出错则返回-1*/</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_putl</span><span class="params">(<span class="type">long</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    sio_ltoa(v, s, <span class="number">10</span>); <span class="comment">/* 基于K&amp;R的函数itoa */</span></span><br><span class="line">    <span class="keyword">return</span> sio_puts(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过标准输出来输出错误信息并退出 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sio_error</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    sio_puts(s);</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这里为了方便，用前缀<code>sio</code>表示函数是异步信号安全的I/O函数。例如，函数<code>sio_fun()</code>是I/O函数<code>fun()</code>的异步信号安全版本。第12行的函数<code>sio_ltoa()</code>基于能将整型数转换为字符串的函数<code>itoa()</code>。第20行的函数<code>_exit()</code>是函数<code>exit()</code>的异步信号安全版本。</p><p>　　许多Linux异步信号安全的函数都会在出错时设置<code>errno</code>。信号处理程序调用这样的函数可能干扰主程序中其他依赖<code>errno</code>的部分。解决方法是进入信号处理程序后先把<code>errno</code><span style="background-color:#ff0">保存</span>在某个局部变量中，在信号处理程序返回前恢复。若信号处理程序会调用函数<code>_exit()</code>终止该进程，则不必如此。</p><p>　　若信号处理程序和主程序或其他处理程序共享同一全局数据结构，则在访问该数据结构时，信号处理程序和主程序应该<span style="background-color:#ff0">暂时阻塞所有信号</span>。这是因为在主程序访问数据结构<code>d</code>通常需要一系列指令，若指令序列被需要访问<code>d</code>的信号处理程序中断，则信号处理程序可能会发现<code>d</code>的状态不一致，得到不可预知的结果。</p><p>　　假设信号处理程序和主函数共享全局变量<code>g</code>，信号处理程序更新<code>g</code>，主函数周期性地读<code>g</code>。对于编译器优化，主函数中<code>g</code>的值看似没变，所以使用缓存在寄存器中<code>g</code>的副来满足<code>g</code>的引用是安全的。若真如此，主函数将永远无法看到信号处理程序更新后的值。解决方法是用关键字<code>volatile</code>来修饰变量 (<code>volatile int g</code>)，该关键字指示编译器<span style="background-color:#ff0">不要缓存</span>该变量。同样，和访问全局数据结构相同，访问全局变量时也应该暂时阻塞所有信号。</p><p>　　在常见的信号处理程序设计中，信号处理程序会写全局标志来记录收到了信号。主程序周期性地读该标志，响应信号并清除该标志。整形数据类型<code>sig_atomic_t</code>保证<span style="background-color:#ff0">单个的读和写是原子 (不可中断) 的</span>。因此，这个全局标志可以声明为<code>volatile sig_atomic_t flag</code>。</p><h5 id="正确的信号处理">8.4.5.2 正确的信号处理</h5><p>　　每种类型的待处理信号最多只能有1个。因此，程序正在执行类型为<code>k</code>的信号的处理程序 (阻塞类型为<code>k</code>的信号) 时，若正好有2个类型为<code>k</code>的信号发送给该程序，第2个到达的信号会被直接丢弃。由此可得，不能用信号来对其他进程中发生的事件进行计数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sio_puts(<span class="string">&quot;Handler reaped child\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">    &#123;</span><br><span class="line">        Sio_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Sleep(<span class="number">1</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    <span class="type">char</span> buf[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGCHLD, handler) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建子进程 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello from child%d\n&quot;</span>, (<span class="type">int</span>)getpid());</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待终端输入并执行 */</span></span><br><span class="line">    <span class="keyword">if</span> ((n = read(STDIN_FILEND, buf, <span class="keyword">sizeof</span>(buf))) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent processing input\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    eixt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例在本质上类似shell和Web服务器等程序，基本结构是父进程创建一些子进程，这些子进程各自独立运行一段时间并终止。然后，父进程回收子进程以避免留下僵尸进程。为了不让父进程显式地等待子进程终止，这里使用了SIGCHLD信号处理程序来回收子进程。</p><h5 id="可移植的信号处理">8.4.5.3 可移植的信号处理</h5><p>　　不同Unix系统有不同的信号处理语义。</p><p>　　● 函数<code>signal()</code>的语义不同。有些较早版本的Unix系统在信号<code>k</code>被处理程序捕获后，会把信号<code>k</code>的默认操作重置。在这些系统上，每次处理程序运行后，必须调用函数<code>signal()</code>来显式地重新设置。</p><p>　　● 系统调用可以被中断。<code>read()</code>、<code>write()</code>和<code>accept</code>等系统调用会隐式地阻塞进程一段较长的时间，称为<strong>慢速系统调用</strong>。在有些较早版本的Unix系统中，当信号处理程序捕获到信号后，被中断的慢速系统调用在信号处理程序返回时不会再继续，而是立即返回错误条件并将<code>errno</code>设置为EINTR。在这些系统上，必须要包括手动重启被中断的系统调用的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　Posix标准定义了函数<code>sigaction()</code>来解决以上问题，该函数允许用户在设置信号的默认操作时，明确指定信号处理语义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">handler_t</span> *<span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">    action.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;action.sa_mask); <span class="comment">/* 阻塞信号处理程序正在处理的信号的类型 */</span></span><br><span class="line">    action.sa_flags = SA_RESTART; <span class="comment">/* 只要可能，重启中断的系统调用 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action))</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;Signal error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数<code>sigaction()</code>应用并不广泛，因为它要求用户设置结构复杂的参数。更简洁的方法是函数<code>Signal()</code>，该函数最早由W. Richard Stevens提出，它是包装函数，会调用函数<code>sigaction()</code>，其调用方式与函数<code>signal()</code>相同。</p><p>　　函数<code>Signal()</code>会使用如下信号处理语义来设置信号处理程序：</p><p>　　● 只有与信号处理程序正在处理的信号的类型相同的信号会被阻塞。</p><p>　　● 信号不会排队。</p><p>　　● 只要可能，重启中断的系统调用。</p><p>　　● 一旦设置了信号处理程序，它会一直保持，直到<code>Signal()</code>带着<code>handler</code>参数为SIG_IGN或SIG_DFL被调用。</p><h4 id="同步流以避免并发漏洞">8.5.5 同步流以避免并发漏洞</h4><p>　　对于访问相同位置的并发流程序，流可能交错的数量与指令的数量呈指数关系。基本问题是以某种方式<span style="background-color:#ff0">同步</span>并发流来得到最大的可行的交错的集合，从而每个可行的交错都得到正确的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    Sigfillset(&amp;mask_all);</span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) <span class="comment">/* 回收子进程 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">        deletejob(pid); <span class="comment">/* 将子进程从作业列表删除 */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">    &#123;</span><br><span class="line">        Sio_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line"></span><br><span class="line">    Sigfillset(&amp;mask_all);</span><br><span class="line">    Signal(SIGCHLD, handler);</span><br><span class="line">    initjobs(); <span class="comment">/* 初始化作业列表 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) <span class="comment">/* 创建子进程 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            Execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);   <span class="comment">/* 父进程 */</span></span><br><span class="line">        addjob(pid);                               <span class="comment">/* 将子进程加入到作业列表 */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* 解除阻塞信号SIGCHLD */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了典型Unix shell的结构。父进程通过全局作业列表中的条目来跟踪当前子进程 (每个作业1个条目)。函数<code>addjob()</code>和<code>deletejob()</code>分别向作业列表中添加和删除作业。</p><p>　　当父进程创建新子进程后，它就把该子进程添加到作业列表中。当父进程在SIGCHLD处理程序中回收终止的子进程时，就从作业列表删除该子进程。</p><p>　　这段代码看似正确，但可能会出现以下事件序列：</p><p>　　1) 父进程执行函数<code>fork()</code>时，内核调度会让新创建的子进程来执行该函数。</p><p>　　2) 在父进程能够再次运行前，子进程已终止并变为僵尸进程，使得内核发送信号SIGCHLD给父进程。</p><p>　　3) 父进程再次变为可运行但又在它执行前，内核发现到有未处理的信号SIGCHLD并通过在父进程中运行信号处理程序来接收该信号。</p><p>　　4) 信号处理程序回收终止的子进程并调用函数<code>deletejob()</code>，该函数什么也不做，因为子进程未添加到作业列表。</p><p>　　5) 信号处理程序运行完毕后，内核运行父进程，父进程从函数<code>fork()</code>返回，调用函数<code>addjob()</code>错误地把 (不存在的) 子进程添加到作业列表。</p><p>　　这种同步错误称为<strong>竞争</strong>。主函数中调用的函数<code>addjob()</code>和信号处理程序中调用的函数<code>deletejob()</code>之间存在竞争。若函数<code>addjob()</code>竞争获胜，则程序会正确运行；否则，程序出错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line"></span><br><span class="line">    Sigfillset(&amp;mask_all);</span><br><span class="line">    Sigemptyset(&amp;mask_one);</span><br><span class="line">    Sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line">    Signal(SIGCHLD, handler);</span><br><span class="line">    initjobs(); <span class="comment">/* 初始化作业列表 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); <span class="comment">/* 阻塞信号SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>)                      <span class="comment">/* 创建子进程 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* 解除阻塞信号SIGCHLD */</span></span><br><span class="line">            Execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);   <span class="comment">/* 父进程 */</span></span><br><span class="line">        addjob(pid);                               <span class="comment">/* 将子进程加入到作业列表 */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* 解除阻塞信号SIGCHLD */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这是解决竞争的方法之一，在调用函数<code>fork()</code>前阻塞信号SIGCHLD，然后调用函数<code>addjob()</code>，最后取消阻塞该信号，这样保证在子进程添加到作业列表后回收该子进程。子进程继承了父进程的<code>blocked</code>位集合，所以在调用函数<code>execve()</code>前，必须解除子进程中阻塞的信号SIGCHLD。</p><h4 id="显式地等待信号">8.5.6 显式地等待信号</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>;</span><br></pre></td></tr></table></figure><p>　　函数<code>sigsuspend()</code>会暂时用参数<code>mask</code>替换当前<code>blocked</code>位集合，然后挂起该进程，直到收到处理操作是终止或运行信号处理程序的信号。若收到的信号的处理操作是终止，则进程会直接终止；若收到的信号的处理操作是运行信号处理程序，则会从信号处理程序返回到函数<code>sigsuspend()</code>，然后再从函数<code>sigsuspend()</code>返回，最后将<code>blocked</code>位集合恢复到调用<code>sigsuspend()</code>时的状态。</p><p>　　函数<code>sigsuspend()</code>等价于以下的代码的原子版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigprocmask(SIG_SETMASK, &amp;mask, &amp;prev);</span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>　　原子属性消除了潜在的竞争，即在函数<code>sigprocmask()</code>后和<code>pause()</code>前收到信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    pid = Waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line"></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);</span><br><span class="line">    Signal(SIGINT, sigint_handler);</span><br><span class="line">    Sigemptyset(&amp;mask);</span><br><span class="line">    Sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); <span class="comment">/* 阻塞信号SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 等待接收信号SIGCHLD */</span></span><br><span class="line">        pid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pid)</span><br><span class="line">        &#123;</span><br><span class="line">            sigsuspend(&amp;prev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>); <span class="comment">/* (可选) 解除阻塞信号SIGCHLD */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在这个示例中，每次调用函数<code>sigsuspend()</code>前，都会阻塞信号SIGCHLD。函数<code>sigsuspend()</code>会暂时取消阻塞信号SIGCHLD，然后休眠，直到父进程捕获信号。在返回前，它会恢复之前的<code>blocked</code>位集合，然后再阻塞信号SIGCHLD。由于父进程捕获的信号可能是SIGCHLD，这里可以解除阻塞信号SIGCHLD，这对于有后台作业需要回收的shell可能有用。</p><h3 id="非本地跳转">8.6 非本地跳转</h3><p>　　C语言提供了称为<strong>非本地跳转</strong>的用户级异常控制流形式，它将控制权直接从某个函数转移给其他正在执行的函数，而不需要经过正常的调用/返回过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>; <span class="comment">/* 返回0 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savesigs)</span>; <span class="comment">/* 返回非0 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> retval)</span>;</span><br></pre></td></tr></table></figure><p>　　函数<code>setjmp()</code>和<code>longjmp()</code>提供非本地跳转。函数<code>setjmp()</code>会在<code>env</code>缓冲区中保存当前<strong>调用环境</strong> (包括PC、栈指针和通用目的寄存器)，以供后面的函数<code>longjmp()</code>使用。函数<code>setjmp()</code>的返回值<span style="background-color:#ff0">不能</span>用于赋值，但可以用于<code>switch</code>和<code>if</code>语句的判断。函数<code>longjmp()</code>会从<code>env</code>缓冲区中恢复调用环境并触发从最近1次初始化<code>env</code>的函数<code>setjmp()</code>调用的返回，然后函数<code>setjmp()</code>返回并带有非0的返回值<code>retval</code>。</p><p>　　函数<code>setjmp()</code>即使被调用1次，也会返回多次，调用函数<code>setjmp()</code>并将调用环境保存在缓冲区<code>env</code>时会返回1次，之后每个对应的函数<code>longjmp()</code>调用也会返回1次。函数<code>longjmp()</code>无论被调用多少次，都不会返回。</p><p>　　函数<code>longjmp()</code>允许其跳过所有中间调用的特性可能会产生意外的结果，例如，某些中间函数调用涉及了数据结构的释放，因为这些代码被跳过，所以会产生内存泄漏。</p><p>　　非本地跳转的重要应用之一就是允许从多层嵌套的函数调用中立即返回，通常是由于检测到错误。若在多层嵌套的函数调用中发现了错误，则可以使用非本地跳转直接返回到普通的本地化错误处理程序，而非费力地展开调用栈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">jmp_buf buf;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> error1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> error2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>, <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (setjmp(buf))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        foo();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Detected an error1 condition in foo\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Detected an error2 condition in foo\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (error1)</span><br><span class="line">    &#123;</span><br><span class="line">        longjmp(buf, <span class="number">1</span>);</span><br><span class="line">        bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (error2)</span><br><span class="line">    &#123;</span><br><span class="line">        longjmp(buf, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在这个示例中，主函数会先调用函数<code>setjmp()</code>以保存当前的调用环境，然后调用函数<code>foo()</code>，函数<code>foo()</code>调用函数<code>bar()</code>。若函数<code>foo()</code>和<code>bar()</code>出错，则立即通过函数<code>longjmp()</code>从函数<code>setjmp()</code>返回。函数<code>setjmp()</code>的非0返回值指明了错误类型，可以做出相应的处理。</p><p>　　非本地跳转的另一个重要应用就是使信号处理程序跳转到特殊的代码位置，而非返回到信号到达时指令被中断的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sigjmp_buf buf;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    siglongjmp(buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sigsetjmp(buf, <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Signal(SIGINT, handler);</span><br><span class="line">        Sio_puts(<span class="string">&quot;starting\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Sio_puts(<span class="string">&quot;restarting\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sleep(<span class="number">1</span>);</span><br><span class="line">        Sio_puts(<span class="string">&quot;processing...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* 函数无法运行到异步信号不安全的exit函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在这个示例中，当键盘输入Ctrl+C时，会用信号和非本地跳转来实现软重启。函数<code>sigsetjmp()</code>和<code>setlongjmp()</code>是函数<code>setjmp()</code>和<code>longjmp()</code>的可供信号处理程序使用的版本。为了避免竞争，必须在调用函数<code>sigsetjmp()</code>之后设置信号处理程序。其次，函数<code>sigsetjmp()</code>和<code>siglongjmp()</code>不是异步信号安全的函数，因为函数<code>siglongjmp()</code>可以跳转到任意代码。因此，应该在<code>siglongjmp()</code>可达的代码中仅调用异步信号安全的函数。</p><p>　　当程序首次启动，对函数<code>sigsetjmp()</code>的初次调用会保存调用环境和信号的上下文 (包括<code>pending</code>和<code>blocked</code>位向量)。然后，主函数进入无限处理循环。当键盘输入Ctrl+C时，内核会发送信号SIGINT给该进程，该进程捕获信号。信号处理程序会执行非本地跳转，回到主函数的入口点。当运行该程序时，输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">./restart</span><br><span class="line">starting</span><br><span class="line">processing...</span><br><span class="line">processing...</span><br><span class="line">Ctrl+C</span><br><span class="line">restarting</span><br><span class="line">processing...</span><br><span class="line">Ctrl+C</span><br><span class="line">restarting</span><br><span class="line">processing...</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/" rel="prev" title="《深入理解计算机系统 第3版》第7章 链接"><i class="fa fa-angle-left"></i> 《深入理解计算机系统 第3版》第7章 链接</a></div><div class="post-nav-item"><a href="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/" rel="next" title="《深入理解计算机系统 第3版》第9章 虚拟内存">《深入理解计算机系统 第3版》第9章 虚拟内存 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script></body></html>