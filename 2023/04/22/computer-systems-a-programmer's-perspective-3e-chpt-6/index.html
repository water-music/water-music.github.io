<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><link rel="canonical" href="http://example.com/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/","path":"2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/","title":"《深入理解计算机系统 第3版》第6章 存储器层次结构"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《深入理解计算机系统 第3版》第6章 存储器层次结构 |</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF"><span class="nav-text">6.1 存储技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">6.1.1 随机存取存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#dram"><span class="nav-text">6.1.1.1 DRAM</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9D%97"><span class="nav-text">6.1.1.2 存储模块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98"><span class="nav-text">6.1.1.3 访问内存</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98"><span class="nav-text">6.1.2 磁盘</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C"><span class="nav-text">6.1.2.1 磁盘操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%A3%81%E7%9B%98%E5%9D%97"><span class="nav-text">6.1.2.2 逻辑磁盘块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#io%E6%80%BB%E7%BA%BF"><span class="nav-text">6.1.2.3 I&#x2F;O总线</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98"><span class="nav-text">6.1.3 固态硬盘</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-text">6.2 存储器层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">6.3 缓存存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%B1%BB%E5%9E%8B"><span class="nav-text">6.3.1 缓存类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E7%BC%93%E5%AD%98"><span class="nav-text">6.3.2 写缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%8F%82%E6%95%B0%E7%9A%84%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D"><span class="nav-text">6.3.3 缓存参数的性能影响</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%AF%B9%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-text">6.4 缓存对程序性能的影响</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《深入理解计算机系统 第3版》第6章 存储器层次结构 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《深入理解计算机系统 第3版》第6章 存储器层次结构</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-04-22 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-22T00:00:00+08:00">2023-04-22</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-09-15 00:00:00" itemprop="dateModified" datetime="2023-09-15T00:00:00+08:00">2023-09-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/computer-system/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>18k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　计算机的成功很大程度上源于存储技术的进步。早期的计算机只有几千字节的随机访问存储器。最早的IBM PC没有磁盘，1982年推出的IBM PC-XT才有10MB的磁盘。到2015年，常规计算机的磁盘容量是IBM PC-XT的30万倍，而且磁盘容量以每2年加倍的速度增长。</p><p>　　存储器层次结构的本质是上一级存储器作为下一级存储器的缓存。每1级都需要管理逻辑，包括划分缓存、在不同层级之间传输块和判断是否命中及后续处理。管理逻辑可以是硬件、软件或两者的结合。大多数情况下，缓存都是自动运行的，无需程序具体或显式的操作。</p><table><colgroup><col style="width:14%"><col style="width:14%"><col style="width:24%"><col style="width:24%"><col style="width:22%"></colgroup><thead><tr><th>存储器类型</th><th>存储内容</th><th>位置</th><th>延迟 (时钟周期数)</th><th>管理者</th></tr></thead><tbody><tr><td>CPU寄存器</td><td>4B或8B的字</td><td>芯片上的CPU寄存器</td><td>0</td><td>编译器</td></tr><tr><td>TLB</td><td>地址转换</td><td>芯片上的TLB</td><td>0</td><td>硬件存储管理单元</td></tr><tr><td>L1缓存</td><td>64B块</td><td>芯片上的L1缓存</td><td>4</td><td>硬件</td></tr><tr><td>L2缓存</td><td>64B块</td><td>芯片上的L2缓存</td><td>10</td><td>硬件</td></tr><tr><td>L3缓存</td><td>64B块</td><td>芯片上的L3缓存</td><td>50</td><td>硬件</td></tr><tr><td>虚拟内存</td><td>4KB页</td><td>内存</td><td>200</td><td>硬件和OS</td></tr><tr><td>缓冲区缓存</td><td>部分文件</td><td>内存</td><td>200</td><td>OS</td></tr><tr><td>磁盘缓存</td><td>磁盘扇区</td><td>磁盘控制器</td><td>100000</td><td>控制器硬件</td></tr><tr><td>网络缓存</td><td>部分文件</td><td>本地磁盘</td><td>10000000</td><td>NFS客户端</td></tr><tr><td>浏览器缓存</td><td>网页</td><td>本地磁盘</td><td>10000000</td><td>浏览器</td></tr><tr><td>网页缓存</td><td>网页</td><td>远程服务器磁盘</td><td>1000000000</td><td>网页代理服务器</td></tr></tbody></table><p>　　早期计算机的存储器层次结构只有3级，即CPU寄存器、内存和磁盘。随着CPU和内存之间的存取速度差距的增加，系统设计者不得不在寄存器文件和内存之间加入SRAM缓存存储器 (L1缓存)，L1缓存的存取速度与寄存器的差不多。之后又在L1缓存和内存之间加入L2缓存，在L2缓存和内存之间加入L3缓存。</p><p>　　只存储指令的缓存称为<strong>指令缓存</strong>，只存储数据的缓存称为<strong>数据缓存</strong>。同时存储指令和数据的缓存称为<strong>统一缓存</strong>。</p><p>　　良好的计算机程序通常有良好的<strong>局部性</strong>，即倾向于引用<span style="background-color:#ff0">最近引用过的数据项附近的数据项</span>或<span style="background-color:#ff0">最近引用过的数据项本身</span>，这种倾向称为<strong>局部性原理</strong>。</p><p>　　局部性有<strong>时间局部性</strong>和<strong>空间局部性</strong>这2种形式。时间局部性好的程序中，被引用过1次的内存位置可能不久后再次被引用。空间局部性好的程序中，内存位置被引用后，可能不久后引用该位置附近的内存位置。</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumarray</span><span class="params">(<span class="type">int</span> a[n])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　对于函数<code>sumarray()</code>，变量<code>sum</code>每次迭代都会被引用，所以变量<code>sum</code>有良好的时间局部性。相反，变量<code>sum</code>没有空间局部性。对于数组<code>a</code>，其中的元素会按序被读取。数组<code>a</code>有良好的空间局部性和很差的时间局部性。总体而言，函数<code>sumarray()</code>有良好的局部性。</p><p>　　像函数<code>sumarray()</code>这样顺序访问数组的每个元素的模式称为<strong>步长为1的引用模式</strong> (相对元素数据)，也称为<strong>顺序引用模式</strong>。同理，每次隔<span class="math inline">\(k\)</span>个元素进行访问的模式就是<strong>步长为<span class="math inline">\(k\)</span>的引用模式</strong>。一般情况下，随着步长的增加，空间局部性下降。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumarrayrows</span><span class="params">(<span class="type">int</span> a[m][n])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; i &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sumarraycols</span><span class="params">(<span class="type">int</span> a[m][n])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; i &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　对于引用多维数组的程序，步长会成为问题。函数<code>sumarrayrows()</code>按照<span style="background-color:#ff0">优先顺序</span>读数组元素，即先读第1行的元素，再读第2行的元素，依此类推，它有良好的空间局限性。函数<code>sumarraycols()</code>并非按照优先顺序的方式，使用的是步长为<span class="math inline">\(n\)</span>的引用模式，所以它的空间局部性较差。</p><p>　　程序从存储系统读数据的速率称为<strong>读吞吐量</strong>或<strong>读带宽</strong>。若程序在<span class="math inline">\(s\)</span>秒内读<span class="math inline">\(n\)</span>字节，则读吞吐量为<span class="math inline">\(\frac{n}{s}\)</span>，单位是MB/s。</p><p>　　<strong>存储器山</strong>是1个读带宽与时间和空间局部性的二维函数。</p><h3 id="存储技术">6.1 存储技术</h3><p>　　<strong>随机存取存储器</strong>分为静态和动态。SRAM比DRAM更快但更贵。SRAM用于CPU内外的缓存存储器，DRAM用于存储器和图形系统的帧缓冲区。常规桌面系统的SRAM的容量数量级是10MB，而DRAM的容量数量级可以达到1GB。</p><p>　　DRAM和SRAM在断电后会丢失信息，所以它们是<strong>易失</strong>的。<strong>非易失性存储器</strong>在断电后依然保存着信息。一类非易失性存储器是<strong>只读存储器</strong>，由于历史原因，虽然其中的部分类型即可读也可写，但是依然统称ROM。ROM按重编程 (写) 的次数和重编程所用的机制来区分。</p><p>　　● <strong>可编程ROM</strong>只能被编程1次，其中的每个存储器单元都有<span style="background-color:#ff0">熔丝</span>，只能用大电流熔断1次。</p><p>　　● <strong>可擦写可编程ROM</strong>有1个透明的石英窗口，允许光到存储单元。紫外线照射到窗口时，EPROM单元会置0。EPROM编程是通过把1写入EPROM的特殊设备完成的，它的擦除和重编程次数可以达到1000次。<strong>电可擦写PROM</strong>类似于EPROM，但无需物理上独立的编程设备，所以可以直接在印制电路卡上编程。EEPROM能编程的次数数量级可以达到<span class="math inline">\(10^5\)</span>次。</p><p>　　另一类非易失性存储器是<strong>闪存</strong>，它基于EEPROM。<strong>固态硬盘</strong>是基于闪存的磁盘驱动器。</p><p>　　存储在ROM设备中的的程序称为<strong>固件</strong>。当计算机系统通电后，它会运行存储在ROM中的固件。一些系统中的固件中提供了少量基本I/O函数，例如，PC的BIOS例程。显卡和磁盘驱动控制器等复杂的设备也依赖固件来转换CPU的I/O请求。</p><p>　　不同的存储技术有不同的价格和性能折中，它们的价格和性能正在以截然不同的速度变化。SRAM、DRAM和磁盘的存取速度都滞后于CPU的存取速度，但SRAM的存取速度与CPU的存取速度的差距远小于其他两者的存取速度和CPU的存取速度的差距。</p><h4 id="随机存取存储器">6.1.1 随机存取存储器</h4><img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/inverted_pendulum.svg" title="inverted_pendulum"><p>　　SRAM将每个位存储在<strong>双稳态</strong>的存储器单元里，每个单元用六晶体管电路实现。六晶体管电路类似于倒转的钟摆，当钟摆在最左边或最右边时，它是稳定的。在其他任何地方，钟摆最终都会倒向一边。原则上，钟摆能在垂直位置无期限地保持平衡，但该状态是<strong>亚稳态</strong>的——最细微的扰动就会使它倒下且再也不会恢复到垂直状态。只有有电，它就会永远保持其值。即使有干扰扰乱电压，干扰消除后，电路会恢复到稳定值。</p><p>　　DRAM将每个位存储为给电容充电，该电容很小，通常只有<span class="math inline">\(30\times 10^{-15}\)</span>F。DRAM可以制造得很密集——每个单元由1个电容和1个存取晶体管组成。与SRAM不同，DRAM存储单元的电容的电压被干扰后，就不会再恢复。暴露在光线下会导致电容的电压改变。实际上，数码照相机和摄像机中的传感器本质上就是DRAM单元阵列。</p><p>　　很多原因会导致漏电，使得DRAM单元在10~100ms内失去电荷。不过计算机运行的时钟周期是以ns来衡量的，所以相对而言这个保持时间是比较长的。存储器系统必须周期性地读写数据来刷新。有些系统会使用纠错码，其中的字的编码会多出几位，类似于CRC。</p><table><colgroup><col style="width:6%"><col style="width:20%"><col style="width:20%"><col style="width:6%"><col style="width:6%"><col style="width:13%"><col style="width:26%"></colgroup><thead><tr><th></th><th>每位晶体管数</th><th>相对存取时间</th><th>持续</th><th>敏感</th><th>相对花费</th><th>应用</th></tr></thead><tbody><tr><td>SRAM</td><td>6</td><td>1×</td><td>是</td><td>否</td><td>1000×</td><td>缓存存储器</td></tr><tr><td>DRAM</td><td>1</td><td>10×</td><td>否</td><td>是</td><td>1×</td><td>存储器和帧缓冲区</td></tr></tbody></table><h5 id="dram">6.1.1.1 DRAM</h5><p>　　DRAM芯片中的所有单元 (位) 被分为<span class="math inline">\(d\)</span>个<strong>超单元</strong>，每个超单元都由<span class="math inline">\(w\)</span>个DRAM单元组成。<span class="math inline">\(d\times w\)</span>的DRAM共存储了<span class="math inline">\(d\times w\)</span>位信息。超单元组织为<span class="math inline">\(r\)</span>行<span class="math inline">\(c\)</span>列的长方形阵列，其中<span class="math inline">\(r\times c=d\)</span>。每个超单元有形如<span class="math inline">\((i,j)\)</span>的地址，其中<span class="math inline">\(i\)</span>表示行，<span class="math inline">\(j\)</span>表示列。</p><p>　　DRAM阵列元素实际上并没有标准的名称，计算机架构师称之为 "单元"，表示DRAM存储单元。电路设计师称之为 "字"，表示存储器的1个字。这里为了避免混淆，采用了无歧义的术语 "超单元"。</p><img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/reading_the_contents_of_a_dram_supercell.svg" title="reading_the_contents_of_a_dram_supercell"><p>　　每个DRAM芯片都连接到称为<strong>存储控制器</strong>的电路，该电路可以单次将<span class="math inline">\(w\)</span>位传入或传出DRAM芯片。为了读出超单元<span class="math inline">\((i,j)\)</span>的内容，存储控制器先将行地址<span class="math inline">\(i\)</span>发送给DRAM，再将列地址<span class="math inline">\(j\)</span>发生给DRAM。最后，DRAM响应对应的内容。内容通过称为<strong>引脚</strong>的外部连接器传入或传出芯片。每个引脚携带1位的信号。行地址<span class="math inline">\(i\)</span>称为<strong>行地址选通脉冲</strong>请求，列地址<span class="math inline">\(j\)</span>称为<strong>列地址选通脉冲</strong>请求。</p><p>　　图中展示了从<span class="math inline">\(16\times8\)</span>的DRAM中读出超单元<span class="math inline">\((2,1)\)</span>的过程。在图a中，存储控制器发送行地址2，DRAM将行2的整个内容都复制到内部行缓冲区。在图b中，存储控制器发送列地址1，DRAM复制内部行缓存区中的超单元<span class="math inline">\((2,1)\)</span>中的8位并发将其发送给存储控制器。这里有2组引脚，即8个数据引脚 (能传输1个字节) 和2个地址引脚 (能携带2位的行或列超单元地址)。其他携带控制信息的引脚没有显示出来。</p><p>　　若需要<span style="background-color:#ff0">连续读取超单元同一行</span>的<span class="math inline">\(n\)</span> (<span class="math inline">\(n&gt;1\)</span>) 个数据：</p><p>　　● 对于DRAM，存储控制器会发送RAS/CAS请求，将指定行复制到行缓冲区，读取指定的数据并丢弃其他数据，然后重复这个过程<span class="math inline">\(n-1\)</span>次。</p><p>　　● 对于<strong>快页模式DRAM</strong>，存储控制器会发送RAS/CAS请求，将指定行复制到行缓冲区，然后读取指定数据。剩余<span class="math inline">\(n-1\)</span>次<span style="background-color:#ff0">只会发送CAS请求</span>，读取指定数据，只有在最后1次读取时，才会丢弃其他数据。<strong>扩展数据输出DRAM</strong>是FPM DRAM的增强型，允许各个CAS信号在时间上更紧密。</p><p>　　DRAM、FPM DRAM和DEO DRAM都是异步，因为它们用一组显式控制信号来与存储控制器通信。<strong>同步DRAM</strong>用驱动存储控制器的同一外部时钟信号的上升沿代替了很多控制信号。这里不会深入细节，最终效果是SDRAM能比异步的存储器更快地输出超单元的内容。<strong>双数据率同步DRAM</strong>是SDRAM的增强型，它使用了2个时钟沿作为控制信号，从而使DRAM的速率翻倍。DDR SDRAM按预取缓冲区 (可增加有效带宽) 容量区分类型，分别是DDR (2位)、DDR2 (4位) 和DDR3 (8位)。</p><p>　　<strong>显存</strong>用于图形系统的帧缓冲区，它类似于FPM DRAM，但有2个不同。第1个不同是VRAM的输出是通过按序移动内部缓冲区的全部内容得到，第2个不同是VRAM允许并行地读写。因此，系统可以在写下一次更新的值的同时，用帧缓冲区的像素刷新屏幕 (读)。</p><p>　　直到1995年，大多数计算机都是使用FPM DRAM。1996到1999年，EDO DRAM主导市场，FPM DRAM几乎消失。SDRAM最早出现在1995年的高端系统中，到2002年，大多数计算机都是使用SDRAM和DDR DRAM。到2010年，大多数服务器和桌面系统都是使用DDR3 SDRAM。</p><h5 id="存储模块">6.1.1.2 存储模块</h5><p>　　DRAM芯片封装在<strong>存储模块</strong>中，它插在主板的扩展槽上。Core i7系统使用的240个引脚的<strong>双列直插存储模块</strong>以64位为块的形式将数据传入或传出存储控制器。</p><img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/reading_the_contents_of_a_memory_module.svg" title="reading_the_contents_of_a_memory_module"><p>　　这里用8个<span class="math inline">\(8M\times8\)</span>的DRAM芯片来存储64MB，这些芯片编号为0~7。每个超单元存储内存的1B。对应超单元地址<span class="math inline">\((i,j)\)</span>的8个超单元表示内存中字节地址A的64位字，其中DRAM0表示第1B，DRAM1表示第2B，依此类推。</p><p>　　当读取内存地址A的1个字时，存储控制器会将地址转换为超单元地址<span class="math inline">\((i,j)\)</span>并发送到存储模块，然后存储模块将<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>广播到每个DRAM。每个DRAM输出超单元地址<span class="math inline">\((i,j)\)</span>的1B，模块中的电路收集这些输出并合并成64位的字，最后响应给存储控制器。</p><p>　　将多个存储模块连接到存储控制器，能聚合成内存。在这种情况下，当控制器收到地址A时，控制器会选择包含A的模块，将A转换为该模块的超单元地址<span class="math inline">\((i,j)\)</span>并发送给该模块。</p><h5 id="访问内存">6.1.1.3 访问内存</h5><p>　　数据通过称为<strong>总线</strong>的共享电子电路在CPU和DRAM之间传输。每次CPU和内存之间的数据传输都是通过称为<strong>总线事务</strong>的一系列步骤来完成的。<strong>读事务</strong>会将数据从内存传输到CPU，<strong>写事务</strong>会将数据从CPU传输到内存。</p><p>　　总线是一组并行的导线，能携带地址、数据和控制信号。根据总线的设计，数据和地址信号可以共享同一组总线，也可以使用不同的总线。2个及以上的设备可以共享同一总线，控制线携带的信号会同步事务并标识当前正在执行的事务的类型。第1章提到过，连接CPU和I/O桥接器的是<strong>系统总线</strong>，连接I/O桥接器和内存的是<strong>内存总线</strong>。</p><p>　　不同厂商的总线体系结构不同。部分Intel系统使用称为<strong>北桥</strong>和<strong>南桥</strong>的芯片组分别将CPU连接到内存和I/O设备。早期的Pentium和Core 2中，<strong>前端总线</strong>将CPU连接到北桥。AMD将FSB替换为<span style="background-color:#ff0">超传输</span>互联，Intel Core i7使用的是<span style="background-color:#ff0">快速通道</span>互联。</p><img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/memory_read_transaction_for_a_load_operation.svg" title="memory_read_transaction_for_a_load_operation"><p>　　这是加载操作<code>movq A, %rax</code>的内存读事务，<span style="background-color:#ff0">总线接口</span>在总线上发起读事务。首先，CPU将地址放到系统总线上，I/O桥将信号传输到内存总线。然后，内存侦测到地址信号，从内存总线上读地址，从DRAM取出对应的字并放回内存总线。I/O桥将内存信号转换为系统总线信号，沿着系统总线传输。最后，CPU侦测到系统总线上的数据，从总线上读数据并复制到对应的寄存器。</p><img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/memory_write_transaction_for_a_store_operation.svg" title="memory_write_transaction_for_a_store_operation"><p>　　这是存储操作<code>movq %rax, A</code>的内存写事务，<span style="background-color:#ff0">CPU</span>发起写事务。首先，CPU将地址放到系统总线上，内存从内存总线上读地址并等待数据到达。然后，CPU从寄存器中复制数据到系统总线。最后，内存从内存总线上读数据并存储到DRAM中。</p><h4 id="磁盘">6.1.2 磁盘</h4><p>　　<strong>磁盘</strong>是用于保存大量数据的存储设备，容量数量级可达到1TB，而基于RAM的存储器的容量数量级只能达到1GB。读磁盘的速度数量级是1ms，比读DRAM慢10万倍，比读SRAM慢100万倍。为了区别基于闪存的SSD，磁盘也称为<strong>旋转磁盘</strong>。</p><img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/disk_geometry.svg" title="disk_geometry"><p>　　磁盘由<strong>盘片</strong>构成。每个盘片的双面称为<strong>表面</strong>，表面覆盖着磁性记录材料。盘片中央的<strong>主轴</strong>让盘片以固定的速率旋转 (通常是5400~15000转每分钟)。</p><p>　　如图a所示，每个盘面由一组称为<strong>磁道</strong>的同心圆组成。每个磁道划分为一组扇区，每个扇区包含等量的数据位 (通常是512B)，这些数据编码在扇区的磁性材料中。扇区由<strong>间隙</strong>分隔，间隙存储表示扇区的格式化位。如图b所示，磁盘通常包含若干个盘片并封装在密封的容器中，整个设备称为<strong>磁盘驱动器</strong>，简称磁盘。</p><p>　　磁盘制造商用术语<strong>柱面</strong>来描述多个盘片驱动器的构造，即所有盘面上到主轴中心的距离相等的磁道集合。例如，若某个驱动器有3个盘片，每个盘面上磁道的编号都一致，柱面<span class="math inline">\(k\)</span>就是6个磁道<span class="math inline">\(k\)</span>的集合。</p><p>　　磁盘容量由<strong>记录密度</strong>、<strong>磁道密度</strong>和<strong>面密度</strong>决定。记录密度是磁道1英寸的段中可以存储的位数。磁道密度是盘片中心半径1英寸的段内磁道数。面密度是记录密度和磁道密度的乘积。 <span class="math display">\[ 磁盘容量=\frac{字节数}{扇区}\times\frac{平均扇区数}{磁道}\times\frac{磁道数}{表面}\times\frac{表面数}{盘片}\times\frac{盘片数}{磁盘} \]</span> 　　磁盘制造商通过提高面密度来增加容量。最初的磁盘的面密度很低，每个磁道分为数量相同的扇区，扇区的数量由最靠近主轴的磁道的扇区数决定，所以越远离主轴的磁道的扇区的间隔越大。随着面密度的提高，扇区的间隙变得过于大。因此，现代大容量磁盘使用<strong>多区记录</strong>，即将柱面集合划分为称为<strong>记录区</strong>的不相交的子集合。每个区包含1组连续的柱面，这些柱面的所有磁道的扇区数都相同。</p><h5 id="磁盘操作">6.1.2.1 磁盘操作</h5><img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/disk_dynamics.svg" title="disk_dynamics"><p>　　如图a所示，磁盘用<strong>读/写磁头</strong>来读写存储在磁性盘面的位，磁头连接到<strong>传动臂</strong>的一端，通过运动轨迹呈圆弧的方式移动传动臂，驱动器可以将磁道定位在盘面上的任何磁道上，这样的机械运动称为<strong>寻道</strong>。一旦磁头定位到指定的磁道，磁道上的位通过其下方时，磁头可以感知到该位的值 (读该位)。如图b所示，对于有多个盘片的磁盘，每个盘面都有独立的磁头。磁头垂直排列并一致移动。在任何时刻，所有的磁头都位于同一柱面。</p><p>　　磁头和盘面之间有1层大约0.1ms的气垫，磁头的速度大约为80km/h。在这样小的间隙内，磁头碰到盘面上的灰尘都会停止并撞到盘面上，这种情况称为<strong>磁头碰撞</strong>。因此，磁盘是密封包装的。</p><p>　　为了读取指定扇区的内容，传动臂会先将磁头定位到指定扇区所在的磁道上方。移动传动臂所需的时间称为<strong>寻道时间</strong>。寻道时间<span class="math inline">\(T_{seek}\)</span>取决于磁头之前的位置和传动臂在盘面上的移动速度。现代驱动器中的平均寻道时间<span class="math inline">\(T_{avg \enspace seek}\)</span>是通过对几千次对随机扇区的寻道取平均值，通常是3~9ms。单次寻道的最大时间<span class="math inline">\(T_{max\enspace seek}\)</span>高达20ms。</p><p>　　一旦磁头到达指定扇区所在的磁道的上方，驱动器会等待指定扇区的第1个位到达磁头下方，这段时间称为<strong>旋转延迟</strong>。旋转延迟取决于磁盘的旋转速度和当磁头到达指定扇区所在的磁道时盘面的位置。在最差的情况下，磁盘刚错过指定扇区，必须等待磁盘旋转1整圈 (需要<span class="math inline">\(T_{max\enspace rotaion}\)</span>)。平均旋转时间<span class="math inline">\(T_{avg\enspace rotation}\)</span>是<span class="math inline">\(T_{max\enspace rotation}\)</span>的一半。 <span class="math display">\[ T_{max\enspace rotation}=\frac{1}{RPM}\times\frac{60s}{1min} \]</span> 　　当指定扇区的第1个位到磁头下方时，驱动器就能开始访问该扇区的内容。扇区的<strong>传输时间</strong>取决于旋转速度和每条磁道的平均扇区数。 <span class="math display">\[ T_{avg\enspace transfer}=\frac{1}{RPM}\times\frac{1磁道}{每条磁道平均扇区数}\times\frac{60s}{1min} \]</span> 　　扇区内容的平均访问时间为平均寻道时间、平均旋转延迟和平均传输时间之和。</p><p>　　例如，某个磁盘的旋转速率为7200RPM，<span class="math inline">\(T_{avg\enspace seek}\)</span>为9ms，每条磁道平均有400个扇区。 <span class="math display">\[ \begin{align} T_{access}&amp;=T_{avg\enspace seek}+T_{avg\enspace rotation}+T_{avg\enspace transfer}\\[3px] &amp;=9ms+\frac{1}{2}\times\frac{60s}{1min\times7200RPM}\times1000ms/s+\frac{60s}{1min\times7200RPM}\times\frac{1磁道}{400扇区}\times1000ms/s\\[3px] &amp;\approx9ms+4ms+0.02ms\\[3px] &amp;=13.02ms \end{align} \]</span> 　　从这个示例中可以看出，存取时间中寻道时间和旋转延迟的占比极高。由于寻道时间和旋转延迟大致相等，可以直接将寻道时间翻倍来估算存取时间。</p><p>　　访问SRAM中的64位字大约需要4ns，访问DRAM中的64位字大约需要60ns。因此，访问SRAM中的512B大约需要256ns，访问DRAM中的512B大约需要4μs，而访问磁盘中的512B大约需要10ms，所以磁盘的访问时间大约是SRAM的4万倍，DRAM的2500倍。</p><h5 id="逻辑磁盘块">6.1.2.2 逻辑磁盘块</h5><p>　　现代磁盘有多个盘面，每个盘面有不同的记录区。为了对操作系统隐藏这些细节，现代磁盘将其结构呈现为<span class="math inline">\(B\)</span>个扇区大小的<strong>逻辑块</strong>的序列，其编号为0到<span class="math inline">\(B-1\)</span>。磁盘封装中有称为<strong>磁盘控制器</strong>的硬件/固件设备，用于维护逻辑块号和实际 (物理) 磁盘扇区间的映射。</p><p>　　磁盘控制器必须先格式化磁盘才能访问磁盘中的数据。格式化过程包括<span style="background-color:#ff0">用标识扇区的信息填写扇区之间的间隙</span>、<span style="background-color:#ff0">识别任何有故障的柱面并禁用</span>以及<span style="background-color:#ff0">在每个区预留1组柱面备用</span>。当区域内有柱面出现故障时，会使用备用柱面。因此，磁盘制造商所说的格式化容量比最大容量小。</p><p>　　当操作系统执行从磁盘读数据到内存等I/O操作时，会发送命令到磁盘控制器来让其访问某个逻辑块号。控制器上的固件会查找快速表来将逻辑块号转换为 <span style="background-color:#ff0">(盘面，磁道，扇区)</span> 的三元组，该三元组唯一地标识对应的物理扇区。控制器上的硬件会根据该三元组移动磁头到对应的柱面，等待扇区移动到磁头下，然后将磁头感知的数据收集到控制器的缓冲区，最后将该数据复制到内存。</p><p>　　例如，某个磁盘有4个盘面，扇区容量为512B，旋转速率为13000RPM，<span class="math inline">\(T_{avg\enspace seek}\)</span>为6ms，每个磁道平均有5000个扇区。显然，<span class="math inline">\(T_{max\enspace rotation}\approx4.61\)</span>ms。若某程序需要 (顺序) 从该磁盘中读文件 (需要10000个逻辑块) ：</p><p>　　● 当逻辑块到磁盘扇区的映射是顺序时，文件的第1个位到达磁头下方后，就无需再移动磁头。因此，磁头需要2整圈就能读取所有数据。 <span class="math display">\[ \begin{align} T_{contiguous}&amp;\approx T_{avg\enspace seek}+T_{avg\enspace rotation}+2\times T_{max\enspace rotation}\\[3px] &amp;\approx6ms+2.30ms+9.22ms\\[3px] &amp;=17.52ms \end{align} \]</span> 　　● 当逻辑块到磁盘扇区的映射是乱序时，每次读取新逻辑块时都要移动磁头。 <span class="math display">\[ \begin{align} T_{random}&amp;\approx (T_{avg\enspace seek}+T_{avg\enspace rotation})\times10000\\[3px] &amp;\approx(6ms+2.30ms)\times10000\\[3px] &amp;=83s \end{align} \]</span></p><h5 id="io总线">6.1.2.3 I/O总线</h5><p>　　系统总线和内存总线都与CPU相关，但Intel的<strong>外围组件互连</strong>总线等I/O总线与CPU无关。虽然I/O总线比系统总线和内存总线慢，但它可以容纳多种第三方I/O设备。</p><p>　　● <strong>通用串行总线</strong>是广泛使用的标准，用于连接各种外围I/O设备，例如键盘、鼠标、调制解调器、数码相机、手柄、打印件、外部磁盘驱动器和固态硬盘。USB控制器是连接到USB的设备的中转。USB 3.0的最大带宽为625MB/s。USB 3.1的最大带宽为1250MB/s。</p><p>　　● <strong>显卡</strong> (适配器) 包含负责代表CPU在显示器上显示像素的硬件和软件逻辑。</p><p>　　● <strong>主机总线适配器</strong>通过特殊的<strong>主机总线接口</strong>定义的通信协议将若干个磁盘连接到I/O总线，最常用的磁盘接口就是<strong>小型计算机系统接口</strong>和<strong>串行高级技术附件</strong>。SCSI磁盘通常比SATA磁盘更快但也更贵。SCSI主机总线适配器 (简称SCSI控制器) 可以支持多个磁盘，而SATA适配器只能支持1个磁盘。</p><p>　　其他设备 (包括网络设配器) 可以通过将适配器插在主板上的扩展槽来连接到I/O总线，这些插槽提供了到总线的直接电路连接。</p><p>　　在PCI模型中，系统中的所有设备共享总线，同一时刻只能有1个设备访问这些线路。在现代系统中，共享的PCI总线已经被PCI Express (PCEe) 总线取代，PCIe是一组高速串行、通过交换机连接的点到点链路，类似于以太网。PCI总线的最大吞吐量是533MB/s，PCIe总线的最大吞吐量为16GB/s。</p><img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/reading_a_disk_sector.svg" title="reading_a_disk_sector"><p>　　如同a所示，CPU通过<strong>内存映射I/O</strong>来向I/O设备发送命令。在包含内存映射I/O的系统中，地址空间中有为I/O设备通信通信保留的地址，这样的地址称为<strong>I/O端口</strong>。当设备连接到总线时，会关联 (映射) 到若干个端口。</p><p>　　若磁盘控制器映射的端口是<code>0xa0</code>，则CPU可能需要执行3条对地址<code>0xa0</code>的存储指令来发起对磁盘的读。第1条指令发送1个命令字来告诉CPU发起读和其他参数 (例如，当读完成时是否中断CPU)。第2条指令指明应该读的逻辑块号。第3条指令指明应该存储磁盘扇区内容的内存地址。</p><p>　　当CPU发起了读请求后，在磁盘执行读时，CPU还会进行其他工作。1GHz的CPU时钟周期为1ns，在磁盘执行读的16ms内，CPU可以执行1600万条指令。</p><p>　　如同b所示，磁盘控制器收到CPU的读命令后，会将逻辑块号转换为扇区地址并读其中的内容，然后将这些数据通过DMA的方式来将传输到内存。</p><p>　　若图c所示，DMA传输完成，磁盘扇区的内容安全地存储在内存中后，磁盘控制器通过给CPU发送中断信号来通知CPU (中断会发信号到CPU芯片的1个外部引脚上)。这会导致CPU暂停当前工作，跳转到1个操作系统例程，该例程会记录I/O已经完成并将控制权交回给CPU中断的位置。</p><h4 id="固态硬盘">6.1.3 固态硬盘</h4><img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/ssd.svg" title="ssd"><p>　　SSD插在I/O总线上的标准磁盘插槽上 (通常是USB和SATA)，行为同其他硬盘相同，处理来自CPU的读写逻辑磁盘块的读写请求。SSD由若干个闪存芯片和<strong>闪存转换层</strong>组成，闪存芯片对应磁盘中的机械驱动，FTL是硬件/固件设备，对应磁盘中的磁盘控制器。读SSD的速度比写SSD的速度快，这是由底层闪存的基本属性决定。</p><p>　　1个闪存由<span class="math inline">\(B\)</span>个块的序列组成，每个块有<span class="math inline">\(P\)</span>页。通常，页是512B~4KB，块有32~128页 (16KB~512KB)。数据以页为单元读写。只有在页所属的块<strong>擦除</strong> (块的所有位置1) 后，才能写该页。块擦除后，块中的每个页都可以直接写。大约写10万次后，块会<strong>磨损</strong>并无法使用。</p><p>　　擦除块需要较长的时间 (1ms级)，比访问页所需的时间高1个数量级。若需要写已包含数据的页<span class="math inline">\(p\)</span> (不全是1)，必须先将<span style="background-color:#ff0">与该页同块</span>的其他所有包含有效数据的页复制到新 (擦除过的) 块。制造商已经在FTL中实现了复杂的逻辑来抵消写块的高昂代价和最小化写时内部副本的数量，但是随机写的速度还是不如随机读。</p><p>　　SSD由半导体存储器构成，没有可移动的部件，所以随机存取时间比磁盘快，能耗更低，更坚固。但是，SSD会磨损，FTL中的<strong>磨损均衡</strong>逻辑通过将擦除均匀分布在所有块来最大化每个块的使用寿命，实际使用寿命有好几年。此外，SSD每个字节的价格比磁盘的贵。</p><h3 id="存储器层次结构">6.2 存储器层次结构</h3><p>　　<strong>高速缓存</strong> (简称<strong>缓存</strong>) 是小而存取速度快的存储设备，它作为存储在更大更慢的设备中的数据对象的缓存区域。使用缓存的过程称为<strong>缓存</strong>。</p><img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/the_basic_principle_of_caching_in_a_memory_hierarchy.svg" title="the_basic_principle_of_caching_in_a_memory_hierarchy"><p>　　如图所示，<span class="math inline">\(k+1\)</span>级存储器划分为连续的数据对象块，称为<strong>块</strong>。每个块都有唯一的地址或名称。块可以是固定大小 (大多数情况下)，也可以是可变大小的 (例如，存储在Web服务器上的HTML文件)。例如，图中<span class="math inline">\(k+1\)</span>级存储器划分为16个固定的块，编号为0~15。</p><p>　　<span class="math inline">\(k\)</span>级存储器也划分为块，块的容量同<span class="math inline">\(k+1\)</span>级的相同。<span class="math inline">\(k\)</span>级缓存中的块始终是<span class="math inline">\(k+1\)</span>级块的某个子集的副本。例如，图中<span class="math inline">\(k\)</span>级缓存有4个块，即块4、9、14和3的副本。</p><p>　　数据总是以块为<strong>传输单元</strong>在<span class="math inline">\(k\)</span>级和<span class="math inline">\(k+1\)</span>级之间复制。在存储器层次结构中，任何相邻的层级之间的块的容量是固定的，但其他层级之间的块的容量可以不同。例如，寄存器和L1缓存之间的块的容量通常是1个字，而L1缓存和L2缓存之间、L2缓存和L3缓存之间以及L3缓存和内存之间的块的数量级通常是10B。内存和本地磁盘间块的数量级通常是100B或1KB。层次结构中层级较低 (离CPU较远) 的设备的存取时间较长，所以用较大的块来弥补较长的存取时间。</p><p>　　当程序需要<span class="math inline">\(k+1\)</span>级的某个数据对象<code>d</code>，会先在<span class="math inline">\(k\)</span>级当前存储的块中查找。若<span class="math inline">\(k\)</span>级缓存中有<code>d</code> (称为<strong>缓存命中</strong>)，程序会直接从<span class="math inline">\(k\)</span>级中读取<code>d</code>。相反，若<span class="math inline">\(k\)</span>级缓存中没有<code>d</code> (称为<strong>缓存未命中</strong>)，程序会从<span class="math inline">\(k+1\)</span>级中读取<code>d</code>并在<span class="math inline">\(k\)</span>级中缓存<code>d</code>。若<span class="math inline">\(k\)</span>级缓存已满，则会用<code>d</code>覆盖其中1个块。</p><p>　　覆盖现存的块的过程称为<strong>替换</strong>或<strong>驱逐</strong>，被替换的块称为<strong>牺牲块</strong>，缓存的<strong>替换策略</strong>决定牺牲块。例如，随机替换策略会选择随机牺牲块，而<strong>最近最少使用</strong>策略会选择最后访问时间距今最长的块，<strong>最不常用使用</strong>策略会选择某个过去时间窗口内引用次数最少的块。所有策略都需要额外的硬件和时间，但是层级越低的缓存出现未命中后，其代价越高。</p><p>　　当<span class="math inline">\(k\)</span>级缓存从<span class="math inline">\(k+1\)</span>级中读取<code>d</code>后，程序以后就能直接从<span class="math inline">\(k\)</span>级读取<code>d</code>。例如，假设需要读图中<span class="math inline">\(k+1\)</span>级的块12的某个数据对象，会先出现缓存未命中并直接在<span class="math inline">\(k+1\)</span>级中读取块12。当<span class="math inline">\(k\)</span>级中缓存块12后，块12会留在<span class="math inline">\(k\)</span>级等待后续的访问。</p><p>　　若<span class="math inline">\(k\)</span>级缓存为空 (称为<strong>冷缓存</strong>)，任何数据对象的访问都会未命中，此类未命中称为<strong>强制未命中</strong>或<strong>冷未命中</strong>。冷未命中通常是暂时的，当多次访问存储器后，缓存会<strong>热身</strong>并进入稳定态，之后不会再出现冷未命中。</p><p>　　一旦出现缓存未命中，<span class="math inline">\(k\)</span>级缓存必须执行<strong>放置策略</strong>，确定从<span class="math inline">\(k+1\)</span>级取出的块放置的位置。最灵活的替换策略是允许来自<span class="math inline">\(k+1\)</span>级的块存储在<span class="math inline">\(k\)</span>级的任何位置。对于存储器层级结构中层级较高的缓存，该策略的成本很高，因为随机放置的块定位成本高。因此，通常使用更简单的放置策略，即将<span class="math inline">\(k+1\)</span>级的特定块限制为<span class="math inline">\(k\)</span>级的块的子集 (有时只有1个块)。例如，图中使用的放置策略是<span style="background-color:#ff0"><span class="math inline">\(k+1\)</span>级的块<span class="math inline">\(m\)</span>必须放置在<span class="math inline">\(k\)</span>级的块<span class="math inline">\(n\)</span> (<span class="math inline">\(n=m\bmod4\)</span>) 中</span>，所以<span class="math inline">\(k+1\)</span>级中的块0、4、8、12会映射到<span class="math inline">\(k\)</span>级中的块0，<span class="math inline">\(k+1\)</span>级中的块1、5、9、13会映射到<span class="math inline">\(k\)</span>级中的块1，依此类推。</p><p>　　这种简单的放置策略会导致<strong>冲突未命中</strong>，即使有足够的空间来存储<span class="math inline">\(k+1\)</span>的块，由于这些块映射到同一位置，缓存会一直未命中。例如，依次读<span class="math inline">\(k+1\)</span>级的块0、块4，然后循环这个过程。</p><p>　　程序通常是按照一系列阶段 (例如，循环) 来执行，每个阶段会存取某个合理且相对固定的缓存块集，例如，嵌套的循环可能反复访问同一数组的元素。这个块集合称为该阶段的<strong>工作集</strong>。当工作集大小超过缓存容量时，会出现<strong>容量未命中</strong>。</p><h3 id="缓存存储器">6.3 缓存存储器</h3><img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/general_organization_of_cache.svg" title="general_organization_of_cache"><p>　　若某计算机的每个存储器地址都是<span class="math inline">\(m\)</span>位，则有<span class="math inline">\(M=2^m\)</span>个地址。该计算机的缓存构成1个有<span class="math inline">\(S=2^s\)</span>个<strong>缓存组</strong>的数组，每个缓存组有<span class="math inline">\(E\)</span>个<strong>缓存行</strong>。每行有1位<strong>有效位</strong> (表示是否包含有用信息)、<span class="math inline">\(t\)</span>位<strong>标识位</strong> (同一组内块的唯一标识) 和<span class="math inline">\(B\)</span>字节数据块。</p><p>　　缓存结构可以用<span class="math inline">\((S,E,B,m)\)</span>来表示，其容量 (<span style="background-color:#ff0">仅计算数据块</span>) <span class="math inline">\(C=S\times E\times B\)</span>。</p><p>　　<span class="math inline">\(S\)</span>和<span class="math inline">\(B\)</span>将<span class="math inline">\(m\)</span>位的地址分为3部分，即<span class="math inline">\(t\)</span>位标识、<span class="math inline">\(s\)</span>位组索引 (无符号数) 和<span class="math inline">\(b\)</span>位块偏移。第<span class="math inline">\(i\)</span>组的组索引是<span class="math inline">\(i\)</span>。当CPU读内存地址A的内容时，若设置了有效位，<span class="math inline">\(t\)</span>位标识会指明块，<span class="math inline">\(s\)</span>位组索引会指明块所属组，最后<span class="math inline">\(b\)</span>位块偏移指明块的偏移量。若与标识匹配的块未设置有效位，则缓存未命中。</p><img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/why_caches_index_with_middle_bits.svg" title="why_caches_index_with_middle_bits"><p>　　若将地址的高位作为组索引，那么部分连续的缓存块将会映射到同一缓存组。如图所示，连续四个缓存块映射到同一缓存中。具有良好空间局部性的程序会顺序读取一个数组的元素，若每个组能容纳的行数很少时，会频繁出现缓存未命中。地址中间位作为组索引时，数组相邻的元素会映射到不同的缓存组。</p><p>　　抽取缓存行中的字的过程分为<strong>组选择</strong>、<strong>行匹配</strong>和<strong>字抽取</strong>。</p><p>　　例如，某32位计算机的缓存容量为1024B，每个缓存组有4个缓存行，每个数据块有8B。 <span class="math display">\[ \begin{align} S&amp;=\frac{C}{E\times B}=\frac{1024B}{4\times8B}=32\\[3px] s&amp;=\log_2S=\log_232=5\\[3px] b&amp;=\log_2B=\log_28=3\\[3px] t&amp;=m-s-b=32-5-3=24 \end{align} \]</span></p><h4 id="缓存类型">6.3.1 缓存类型</h4><p>　　缓存组只有1行 (<span class="math inline">\(E=1\)</span>) 的缓存称为<strong>直接映射缓存</strong>。</p><img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/extracting_a_word_in_direct-mapped_cahe.svg" title="extracting_a_word_in_direct-mapped_cahe"><p>　　对于直接映射缓存，组选择就是根据组索引选择，这里是<span class="math inline">\(i\)</span>。组选择完成后，会先判断有效位是否设置。若有效位已设置，则判断标识是否匹配，这里是0100，匹配则得到缓存命中；若有效位未设置或标识不匹配，则得到缓存未命中。最后，根据块偏移来判断数据的偏移量，这里是100 (假设字长是4B)。若缓存未命中，替换策略就替换组索引中唯一的1行。</p><table style="width:100%"><colgroup><col style="width:21%"><col style="width:16%"><col style="width:20%"><col style="width:20%"><col style="width:21%"></colgroup><thead><tr><th>地址 (十进制)</th><th>标识 (1位)</th><th>组索引 (2位)</th><th>块偏移 (1位)</th><th>块号 (十进制)</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>00</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>00</td><td>1</td><td>0</td></tr><tr><td>2</td><td>0</td><td>01</td><td>0</td><td>1</td></tr><tr><td>3</td><td>0</td><td>01</td><td>1</td><td>1</td></tr><tr><td>4</td><td>0</td><td>10</td><td>0</td><td>2</td></tr><tr><td>5</td><td>0</td><td>10</td><td>1</td><td>2</td></tr><tr><td>6</td><td>0</td><td>11</td><td>0</td><td>3</td></tr><tr><td>7</td><td>0</td><td>11</td><td>1</td><td>3</td></tr><tr><td>8</td><td>1</td><td>00</td><td>0</td><td>4</td></tr><tr><td>9</td><td>1</td><td>00</td><td>1</td><td>4</td></tr><tr><td>10</td><td>1</td><td>01</td><td>0</td><td>5</td></tr><tr><td>11</td><td>1</td><td>01</td><td>1</td><td>5</td></tr><tr><td>12</td><td>1</td><td>10</td><td>0</td><td>6</td></tr><tr><td>13</td><td>1</td><td>10</td><td>1</td><td>6</td></tr><tr><td>14</td><td>1</td><td>11</td><td>0</td><td>7</td></tr><tr><td>15</td><td>1</td><td>11</td><td>1</td><td>7</td></tr></tbody></table><p>　　这是直接映射缓存的4位地址空间。标识和组索引组合是内存中的每个块的唯一标识。这里有8个内存块，但只有4组，所以有2个块会映射到同一组。映射到同一组的块由标识区分。例如，块0和块4会映射到同一组，块0的标识是0，块4的标识是1。</p><table><thead><tr><th>组</th><th>有效位</th><th>标识</th><th>块0</th><th>块1</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td><td>m[0]</td><td>m[1]</td></tr><tr><td>1</td><td>0</td><td></td><td></td><td></td></tr><tr><td>2</td><td>0</td><td></td><td></td><td></td></tr><tr><td>3</td><td>0</td><td></td><td></td><td></td></tr></tbody></table><p>　　1) 初始时，缓存都是空的。第1次读地址0的字，出现缓存未命中，缓存从内存取出块0并返回m[0]。然后读地址1的字，出现缓存命中，缓存返回m[1]。</p><table><thead><tr><th>组</th><th>有效位</th><th>标识</th><th>块0</th><th>块1</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td><td>m[8]</td><td>m[9]</td></tr><tr><td>1</td><td>0</td><td></td><td></td><td></td></tr><tr><td>2</td><td>1</td><td>1</td><td>m[12]</td><td>m[13]</td></tr><tr><td>3</td><td>0</td><td></td><td></td><td></td></tr></tbody></table><p>　　2) 读地址13的字，出现缓存未命中，缓存从内存取出块6并返回m[13]。然后读地址8的字，出现缓存未命中，缓存从内存取出块4替换块0并返回m[8]。</p><table><thead><tr><th>组</th><th>有效位</th><th>标识</th><th>块0</th><th>块1</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td><td>m[0]</td><td>m[1]</td></tr><tr><td>1</td><td>0</td><td></td><td></td><td></td></tr><tr><td>2</td><td>1</td><td>1</td><td>m[12]</td><td>m[13]</td></tr><tr><td>3</td><td>0</td><td></td><td></td><td></td></tr></tbody></table><p>　　3) 读地址0的字，出现缓存未命中，缓存从内存取出块0替换块4并返回m[0]。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">dotprod</span><span class="params">(<span class="type">float</span> x[<span class="number">8</span>], <span class="type">float</span> y[<span class="number">8</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += x[i] * y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　对于参数<code>x</code>和<code>y</code>，函数<code>dotprod()</code>有良好的空间局部性，但访问这种<span style="background-color:#ff0">元素个数是2的幂的数组</span>通常会出现冲突未命中。这里假设浮点类型为4B，<code>x</code>存放在地址0开始的连续32B，<code>y</code>紧随其后，从地址32开始。变量<code>sum</code>存放在寄存器中。进一步假设缓存有2个组，每个块有16B。第1次迭代引用<code>x[0]</code>时会出现缓存未命中，将块<code>x[0]</code>到<code>x[3]</code>加载到组0，然后引用<code>y[0]</code>时再次出现缓存未命中，将块<code>y[0]</code>到<code>y[3]</code>加载到组0。在之后每次迭代都会如此，这种情况称为<strong>抖动</strong>，即缓存反复地加载和驱逐同一缓存块中的组。</p><p>　　这种抖动导致性能下降2或3倍并不罕见。若将<code>x</code>定义为<code>float x[12]</code>，则<code>x[i]</code>不会和<code>y[i]</code>映射到相同的组，也就不会再出现抖动。</p><p>　　缓存行数<span class="math inline">\(E\)</span>满足<span class="math inline">\(1&lt;E&lt;\frac{C}{B}\)</span>的缓存称为<span class="math inline">\(E\)</span>路<strong>组相联缓存</strong>。它的字抽取过程类似直接映射缓存的。出现缓存未命中时，若缓存组内有空行，则直接替换；反之，则使用替换策略。</p><p>　　缓存行数<span class="math inline">\(E=\frac{C}{B}\)</span>的缓存称为<strong>全相联缓存</strong>，它只有1个缓存组，所以<span style="background-color:#ff0">地址中没有组索引</span>。它的抽取字过程类似直接映射缓存的，但缓存电路必须并行地搜索很多可能匹配的标识，所以构造大且快速的全相联缓存很困难且贵。全相联缓存只适合做较小的缓存 (例如，虚拟内存中的TLB)。</p><h4 id="写缓存">6.3.2 写缓存</h4><p>　　相比读缓存，写缓存更复杂。假设写一个已缓存的字 (<strong>写命中</strong>)，最简单的方法是<strong>透写</strong>，即该字的块直接写入到下一层级中，但这会占用总线流量。另一种方法是<strong>回写</strong>，即将该字的块写入到下一层级的时间推迟到替换这个更新后的块时。由于局部性，回写的总线流量占用远低于透写的总线流量占用，但它增加了复杂性，需要为每个缓存行维护额外的修改位，指明该缓存块是否被修改过。替换块时若块已修改，则将其写到下一层级再替换；否则，直接替换。</p><p>　　若出现写未命中，可以使用<strong>写分配</strong>，即先将下一层级的块先缓存再更新。这种方法充分利用了空间局部性，但每次未命中都会缓存下一层级的块。另一种方法是<strong>非写分配</strong>，即跳过缓存并直接更新下一层级的块。<strong>透写缓存</strong>通常使用非写分配，<strong>回写缓存</strong>通常使用写分配。</p><p>　　通常，由于较长的传输时间，存储器层次结构中层级较低的缓存更可能使用回写而非透写。此外，由于逻辑电路密度的提高，回写的复杂性越来越不成为障碍，回写缓存可以出现在存储器层次结构中各个层级。另一方面，与处理读的方式对应，回写缓存写分配更能利用局部性。</p><h4 id="缓存参数的性能影响">6.3.3 缓存参数的性能影响</h4><p>　　衡量缓存性能的指标有<strong>未命中率</strong>、<strong>命中率</strong>、<strong>命中时间</strong>和<strong>未命中处罚</strong>。</p><p>　　未命中率指未命中的内存引用比例。命中率指命中的内存引用比例。命中时间指从缓存传输1个字到CPU所用时间，包括组选择、行确认和字选择的时间。未命中处罚指由于未命中而所需的额外时间。L1缓存未命中时，从L2缓存得到服务的处罚是10个时钟周期，从L3缓存得到服务的处罚是50个时钟周期，从内存得到服务的处罚是200个时钟周期。</p><p>　　容量较大的缓存命中率较高，但命中时间也较长。</p><p>　　容量较大的缓存块更能利用空间局部性，进而提高命中率。但是，对于给定大小的缓存，缓存块越大表示缓存行数越少，这会降低时间局部性优于空间局部性的程序的命中率。此外，较大的缓存块会增加传输时间，进而增加未命中处罚。</p><p>　　较高的相联度 (即缓存行较多) 会降低由于冲突未命中出现的抖动的可能性，但实现成本较高且较复杂，进而导致存取速度更慢，每行都需要更多的标识位、额外的LRU状态位和额外的控制逻辑。此外，较高的相联度会增加命中时间和未命中处罚。</p><p>　　透写缓存更易实现，而且能使用独立于缓存的<span style="background-color:#ff0">写缓冲区</span>来更新存储器。回写缓存需要传输的数据更少，能让出更多的存储器带宽给执行DMA的I/O设备。</p><h3 id="缓存对程序性能的影响">6.4 缓存对程序性能的影响</h3><p>　　局部性较好的程序的命中率较高，命中率高的程序一般比命中率低的程序运行更快。因此，编写<strong>缓存友好</strong>的代码很重要，具体实现方法包括<span style="background-color:#ff0">让常见情况快速进行</span>和<span style="background-color:#ff0">尽量减少每个循环内部的缓存未命中次数</span>。</p><p>　　编译器会将局部变量缓存在寄存器文件中，所以应尽量使用局部变量。</p><p>　　假设缓存的块容量为<span class="math inline">\(B\)</span>字节，步长为<span class="math inline">\(k\)</span> (单位是字) 的引用模式每次迭代平均有<span class="math inline">\(min(1,\frac{字长\times k}{B})\)</span>次缓存未命中。当<span class="math inline">\(k=1\)</span>时，它取最小值。</p><p>　　对于<span class="math inline">\(n\times n\)</span>矩阵乘法<span class="math inline">\(C=AB\)</span>，当<span class="math inline">\(n=2\)</span>时，有 <span class="math display">\[ \begin{align} \begin{bmatrix} c_{11} &amp; c_{12}\\ c_{21}&amp;c_{22}\\ \end{bmatrix} &amp;= \begin{bmatrix} a_{11}&amp;a_{12}\\ a_{21}&amp;a_{22}\\ \end{bmatrix} \begin{bmatrix} b_{11}&amp;b_{12}\\ b_{21}&amp;b_{22}\\ \end{bmatrix}\\[3px] c_{11}&amp;=a_{11}b_{11}+a_{12}b_{21}\\[3px] c_{12}&amp;=a_{11}b_{12}+a_{12}b_{22}\\[3px] c_{21}&amp;=a_{21}b_{11}+a_{22}b_{21}\\[3px] c_{22}&amp;=a_{21}b_{12}+a_{22}b_{22}\\[3px] \end{align} \]</span> 　　矩阵乘法函数通常使用3个嵌套的循环来实现，这里分别用<span class="math inline">\(i\)</span>、<span class="math inline">\(j\)</span>和<span class="math inline">\(k\)</span>来表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ijk版本 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += A[i][k] * B[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">        C[i][j] += sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* jik版本 */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += A[i][k] * B[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">        C[i][j] += sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* jki版本 */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        r = B[k][j];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i][j] += A[i][k] * r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* kji版本 */</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        r = B[k][j];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i][j] += A[i][k] * r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* kij版本 */</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        r = A[i][k];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i][j] += r * B[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ikj版本 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        r = A[i][k];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i][j] += r * B[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这6个函数成对地形成3个等价类，这里用内循环中访问的矩阵来区分。例如，<span class="math inline">\(ijk\)</span>和<span class="math inline">\(jik\)</span>版本是类AB，因为它们最内层循环中引用的是矩阵A和B。同理，<span class="math inline">\(jki\)</span>和<span class="math inline">\(kji\)</span>版本是类AC，<span class="math inline">\(kij\)</span>和<span class="math inline">\(ikj\)</span>版本是类BC。</p><table style="width:100%"><colgroup><col style="width:11%"><col style="width:13%"><col style="width:13%"><col style="width:15%"><col style="width:15%"><col style="width:15%"><col style="width:16%"></colgroup><thead><tr><th>矩阵乘法版本类</th><th>每次迭代加载次数</th><th>每次迭代存储次数</th><th>每次迭代A未命中次数</th><th>每次迭代B未命中次数</th><th>每次迭代C未命中次数</th><th>每次迭代未命中总次数</th></tr></thead><tbody><tr><td>AB</td><td>2</td><td>0</td><td>0.25</td><td>1.00</td><td>0.00</td><td>1.25</td></tr><tr><td>AC</td><td>2</td><td>1</td><td>1.00</td><td>0.00</td><td>1.00</td><td>2.00</td></tr><tr><td>BC</td><td>2</td><td>1</td><td>0.00</td><td>0.25</td><td>0.25</td><td>0.50</td></tr></tbody></table><p>　　类AB以步长为1的引用模式扫描A的行，每个缓存块的容量是4个8B的字，每次迭代的命中率是0.25。内循环以步长为<span class="math inline">\(n\)</span>的引用模式扫描数组B的列，每次对B的访问都未命中。因此，每次迭代共1.25次未命中。</p><p>　　对于类AC，每次迭代执行2次加载和1次存储。内循环以步长为<span class="math inline">\(n\)</span>的引用模式扫描A和C的列，结果每次加载都未命中。因此，每次迭代共有2次未命中。相比AB，交换循环较低了空间局部性。</p><p>　　对于类BC，每次迭代执行2次加载和1次存储。内循环为步长为1的引用模式扫描B和C的行，每次迭代的命中率是0.25。因此，每次迭代共0.50次未命中。</p><p>　　<strong>分块</strong>可以提高循环的时间局部性，其基本思想是将程序中的数据结构组织为大的片，称为<strong>块</strong> (此块非彼块)，这样使得单个片能加载到L1缓存并执行相关读写，完成后丢掉该片，加载下一片，依此类推。分块会使得代码更难阅读和理解，所以它只适合优化编译器和频繁执行的库函数。</p><p>　　有时循环中的数组远大于任何SRAM缓存，<span style="background-color:#ff0">预取</span>硬件能识别步长为1的引用模式以执行预取，并且其速度能跟上循环中的访问存储器的速度。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/" rel="prev" title="《深入理解计算机系统 第3版》第5章 优化程序性能"><i class="fa fa-angle-left"></i> 《深入理解计算机系统 第3版》第5章 优化程序性能</a></div><div class="post-nav-item"><a href="/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/" rel="next" title="《深入理解计算机系统 第3版》第7章 链接">《深入理解计算机系统 第3版》第7章 链接 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script></body></html>