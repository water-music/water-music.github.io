<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><link rel="canonical" href="http://example.com/2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/","path":"2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/","title":"《深入理解计算机系统 第3版》第11章 网络编程"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《深入理解计算机系统 第3版》第11章 网络编程 |</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-text">11.1 网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E7%90%83ip%E4%BA%92%E8%81%94%E7%BD%91"><span class="nav-text">11.2 全球IP互联网</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ip%E5%9C%B0%E5%9D%80"><span class="nav-text">11.2.1 IP地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%9F%E5%90%8D"><span class="nav-text">11.2.2 域名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5"><span class="nav-text">11.2.3 网络连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E6%8E%A5%E5%8F%A3"><span class="nav-text">11.3 套接字接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80"><span class="nav-text">11.3.1 套接字地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0socket"><span class="nav-text">11.3.2 函数socket()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0connect"><span class="nav-text">11.3.3 函数connect()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0bindlisten%E5%92%8Caccept"><span class="nav-text">11.3.4 函数bind()、listen()和accept()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E6%9C%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">11.3.5 主机和服务的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0getaddrinfo"><span class="nav-text">11.3.5.1 函数getaddrinfo()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0getnameinfo"><span class="nav-text">11.3.5.2 函数getnameinfo()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="nav-text">11.3.6 套接字接口的辅助函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0open_clientfd"><span class="nav-text">11.3.6.1 函数open_clientfd()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0open_listenfd"><span class="nav-text">11.3.6.2 函数open_listenfd()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#echo%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">11.3.7 echo客户端和服务器示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">11.4 Web服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#web%E5%86%85%E5%AE%B9"><span class="nav-text">11.4.1 Web内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http%E4%BA%8B%E5%8A%A1"><span class="nav-text">11.4.2 HTTP事务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#http%E8%AF%B7%E6%B1%82"><span class="nav-text">11.4.2.1 HTTP请求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#http%E5%93%8D%E5%BA%94"><span class="nav-text">11.4.2.2 HTTP响应</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%8A%A8%E6%80%81%E5%86%85%E5%AE%B9"><span class="nav-text">11.4.3 服务动态内容</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tiny-web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">11.5 TINY Web服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="nav-text">11.5.1 主函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0doit"><span class="nav-text">11.5.2 函数doit()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0clienterror"><span class="nav-text">11.5.3 函数clienterror()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0read_requesthdrs"><span class="nav-text">11.5.4 函数read_requesthdrs()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0parse_uri"><span class="nav-text">11.5.5 函数parse_uri()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0serve_static"><span class="nav-text">11.5.6 函数serve_static()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0serve_dynamic"><span class="nav-text">11.5.7 函数serve_dynamic()</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《深入理解计算机系统 第3版》第11章 网络编程 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《深入理解计算机系统 第3版》第11章 网络编程</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-09-22 00:00:00" itemprop="dateCreated datePublished" datetime="2023-09-22T00:00:00+08:00">2023-09-22</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-23 00:00:00" itemprop="dateModified" datetime="2023-12-23T00:00:00+08:00">2023-12-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/computer-system/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>32k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　互联网起源于1957年，正处于冷战最激烈的时期，苏联第1颗人造卫星的发射震惊世界。作为响应，美国成立了高级研究计划署，其任务是重建美国在科学和技术上领导地位。1967年，ARPA的Lawrence Roberts提出了建立ARPANET网络的计划。第1个ARPANET节点在1969年建立并运行。到1971年，已有13个ARPANET节点，电子邮件作为其第1个重要的网络应用出现。</p><p>　　1972年，Robert Kahn提供了互联网的基本原则，即一组互联的网络通过称为 "路由器" 的黑盒子按照 "尽力而为原则" 在相互独立处理的网络间通信。1974年，Kahn和Vinton Cerf发表了TCP/IP的第1本详细资料，到1982年，它成为了ARPANET的标准网络互联协议。1983年1月1日，ARPANET的每个节点都切换到了TCP/IP，这标志着全球互联网的诞生。</p><p>　　1985年，Paul Mockapetris发明了DNS，此时，有1000多台主机。1986年，(美国) 国家科学基金会用56KB/s的电话线连接了13个节点来构建NSFNET的骨干网，其速率在1988年升级到1.5MB/s，1991年又升级到45MB/s。在1988年，有超过50000台主机。1989年，原始ARPANET正式退休。1995年，有几乎千万台主机，此时，NSF取消了NSFNET并用现代互联网架构取代它，该架构基于公共网络接入点连接的私有商业骨干网。</p><p>　　所有网络应用程序都基于<strong>客户端-服务器</strong>模型。在该模型中，有1个服务器进程和若干个客户端进程。服务器管理一些<span style="background-color:#ff0">资源</span>并通过控制这些资源来为客户端提供一些服务。例如，Web服务器管理一组磁盘文件并代表客户端检索和执行这些文件。</p><p>　　Web客户端和服务器通过基于文本的应用层协议HTTP来通信。HTTP是简单的协议。Web客户端 (即浏览器) 打开到服务器的连接并请求一些内容，然后，服务器响应内容并关闭连接，最后，浏览器读取内容并显示在屏幕上。</p><img src="/2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/a_client-server_transaction.svg" title="a_client-server_transaction"><p>　　客户端-服务器模型中的基本操作是<strong>事务</strong> (这里的事务和数据库里的事务毫无关联)，它是客户端和服务器执行的一系列步骤。</p><p>　　1) 当客户端需要服务时，它通过发送<strong>请求</strong>给服务器来初始化事务。例如，浏览器需要某个文件，它会发送请求给Web服务器。</p><p>　　2) 服务器收到请求，解析它并通过合适的方式操作其资源。例如，当Web服务器收到浏览器的请求，它会读磁盘文件。</p><p>　　3) 服务器发送<strong>响应</strong>给客户端，然后等待下一个请求。例如，Web服务器将文件发回给浏览器。</p><p>　　4) 客户端收到响应并处理。例如，浏览器收到来自服务器的页面并将其显示到屏幕上。</p><span id="more"></span><p>　　客户端和服务器是<span style="background-color:#ff0">进程</span>而非主机。1个主机可以同时运行多个不同的客户端和服务器。1个事务可以在相同或不同的主机上。客户端-服务器模型与客户端和服务器到主机的映射无关。</p><p>　　全球IP互联网最早起源于1969年。虽然互联网的内部架构很复杂且不断变化，但自20世纪80年代以来，客户端-服务器应用程序的组织一直保存着非常稳定的状态。</p><p>　　所有互联网主机都运行实现<span style="background-color:#ff0">TCP/IP</span>的软件。互联网客户端和服务器通过<strong>套接字接口</strong>和Unix I/O函数来通信。套接字函数通常实现为嵌入内核的系统调用，它能调用TCP/IP中的各种内核模式函数。</p><p>　　套接字接口是加州大学伯克利分校的研究人员于20世纪80年代早期提出，所以也称为伯克利套接字。伯克利的研究人员使得套接字适用于任何底层协议。第1个实现是针对TCP/IP，该实现包含在Unix 4.2 BSD的内核中，并且分发给了很多大学和实验室。</p><p>　　瑞士物理实验室CERN的软件工程师Tim Berners-Lee发明了万维网。在1989年，Berners-Lee开发了1个内部备忘录，提出了能连接 "用链接组成的笔记网络" 的分布式超文本系统，该系统旨在帮助CERN的科学家分享和管理信息。在之后的2年内，在Berners-Lee实现了首个Web服务器和浏览器后，在CERN内部和其他一些网站中，Web拥有了小规模的拥护者。在1993年发生了关键事件，Marc Andreesen (之后成立Netscape和Andreessen Horowitz) 和他在NCSA的同事发布了图形化的浏览器MOSAIC，该浏览器可用于Linux、Windows和Macintosh。自此以后，Web网站以每年10倍或更高的数量暴增。</p><p>　　互联网的官方信息资源存储在一组可免费获取的带编号的文档中，这些文档称为<span style="background-color:#ff0">RFC</span>。</p><h3 id="网络">11.1 网络</h3><p>　　客户端和服务器通常运行在不同的主机上，通过<strong>计算机网络</strong>的硬件和软件资源来通信。网络是复杂的系统，这里只介绍一些简单的内容。</p><p>　　对于主机，网络只是I/O设备，作为数据的源和接收器。插在I/O总线扩展槽的网络适配器提供网络的物理接口。从网络接收的数据会从适配器通过I/O和内存总线复制到内存，通常通过DMA传输。同样，也能从内存复制到网络。</p><p>　　从物理角度，网络是按地理领进性组织的层次结构系统。最底层是跨越建筑或校区的<strong>局域网</strong>。迄今为止最流行的LAN技术是在Xerox PARC于20世纪70年代中期开发的<strong>以太网</strong>。以太网有出色的弹性，支持的速率从3Mb/s到10Gb/s。</p><p>　　<strong>以太网段</strong>由一组电缆 (通常是双绞线) 和1个称为<strong>集线器</strong>的小盒子组成。以太网段通常跨越房间或楼层等较小的区域。每根电缆都有相同的最大位带宽，通常是100Mb/s或1Gb/s。电缆的一端连接着主机的网络适配器，另一端连接着集线器上的<strong>端口</strong>。集线器将端口收到的每个位直接复制到所有其他端口。因此，每个端口都能看到每个位。</p><p>　　每个以太网适配器都有存储在内置非易失存储器中的全球唯一的48位地址。主机可以发送一组位 (称为<strong>帧</strong>) 到以太网段上的其他主机。每个帧都有固定的首部字段来表示其源、目的地和大小，其后是存储数据的有效载荷。每个主机适配器都可以看到帧，但只有对应的目的主机能读。</p><img src="/2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/bridged_ethernet_segments.svg" title="bridged_ethernet_segments"><p>　　多个以太网段可以通过一组电缆和称为<strong>网桥</strong>的小盒子来连接到更大的以太网中，称为<strong>桥接以太网</strong>。桥接以太网能跨越整个建筑物或校区。在桥接以太网中，有些电缆连接网桥和网桥，其他电缆连接网桥和集线器。</p><p>　　网桥比集线器更能充分利用线路带宽。通过巧妙的分配算法，它们能随着时间自动学习哪些端口可以访问哪些主机，然后仅在必要时可选地将帧从某个端口复制到其他端口。 例如，若主机A需要发送帧到主机B，两者在同一网段，当该帧到达网桥X的输入端口时，网桥X会直接丢弃，这样可以节约其他网段的带宽。若主机A需要发送帧到主机C，两者不在同一网段，当帧到达网桥X的输入端口时，网桥X只会将帧复制到通往网桥Y的端口，网桥Y只会将帧复制到通往主机C所属网段的端口。</p><p>　　在层次结构的较高层中，多个兼容的LAN通过称为<strong>路由器</strong>的特殊计算机连接来形成互联网络。每个路由器对它连接的每个网络都有1个适配器 (端口)。路由器也能连接<strong>广域网</strong>等高速点对点电话连接。广域网比局域网有更大的地理覆盖范围。路由器通常可以使用任意LAN和WAN集合来构建互联网络。</p><p>　　为了让源主机跨越不兼容的网络发送数据给目的主机，需要使用一层消除底层网络差异的<strong>协议软件</strong> (运行在所有主机和路由器上)，该软件会实现能协调控制主机和路由器来传输数据的协议。该协议必须提供<span style="background-color:#ff0">命名方案</span>和<span style="background-color:#ff0">传输机制</span>。</p><p>　　● 不同的LAN技术通过不同且不兼容的方式来分配主机地址，网络协议需要通过定义统一的地址格式来消除这些差异。每个主机必须分配最少1个<strong>网络地址</strong>，该地址唯一地标识该主机。</p><p>　　● 不同的网络技术通过不同且不兼容的方式来编码电缆上的位并将这些位封装成帧。网络协议需要通过定义统一的将数据位封装成独立的片 (称为<strong>分组</strong>) 的方法来消除这些差异。分组包括首部和有效载荷，首部包含分组大小、源主机地址和目的主机地址，有效载荷包含数据位。</p><img src="/2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/how_data_travel_from_one_host_to_another_on_an_internet.svg" title="how_data_travel_from_one_host_to_another_on_an_internet"><p>　　为了简化，这里用较粗的线表示集线器、网桥以及连接它们的电缆。客户端运行在主机A上，主机A连接到LAN1。服务器运行在主机B上，主机B连接到LAN2。客户端发送数据到服务器需要8个步骤，这里仅介绍主要部分，省去了很多细节，例如，如何处理不同网络的帧大小不同的情况、如何路由和丢包后的处理。</p><p>　　1) 主机A的客户端通过系统调用来复制客户端虚拟内存中的数据到内核缓冲区。</p><p>　　2) 主机A的协议软件将网络分组首部和LAN1帧首部附加到数据来生成LAN1帧。分组首部的地址是主机B的地址。LAN1帧的地址是路由器的地址。这里LAN1帧的有效载荷是分组，分组的有效载荷才是数据。这种<strong>封装</strong>是网络互联的基本方法之一。</p><p>　　3) LAN1适配器将帧复制到网络。</p><p>　　4) 当帧到达路由器时，路由器的LAN1适配器会从电缆上读取帧并将其传递给协议软件。</p><p>　　5) 路由器的协议软件从分组首部提取目的网络地址，根据网络地址路由分组。路由器去除原来的LAN1帧首部，生成地址为主机B地址的LAN2帧首部，然后将它们封装成帧并发送到适配器。</p><p>　　6) 路由器的LAN2适配器复制帧到网络。</p><p>　　7) 当帧到达主机B时，它的适配器会从电缆上读取帧并将其传递给协议软件。</p><p>　　8) 主机B的协议软件去除帧首部和分组首部。当服务器通过系统调用来读数据时，协议软件会复制数据到服务器虚拟内存。</p><h3 id="全球ip互联网">11.2 全球IP互联网</h3><p>　　TCP/IP实际是一组协议，其中的每个协议负责不同的功能。IP负责基础的命名方案和传输机制，IP对应的分组称为<strong>数据报</strong>。当数据报丢失或重复时，IP不会尝试恢复，所以IP的传输机制是不可靠的。UDP稍微扩展了IP，它会在进程之间传输数据报而非主机之间。TCP是基于IP构建的复杂协议，可在进程之间提供可靠的全双工连接。这里为了简化，这里会将TCP/IP视为单个协议，忽略其内部细节和UDP，仅介绍TCP和IP为应用程序提供的部分基础功能。</p><p>　　地址是32位的IP称为<strong>IPv4</strong>。在1996年，IETF提出了用于代替IPv4的地址是128位的新版本IP，称为<strong>IPv6</strong>。这里的内容还是基于IPv4。</p><p>　　从程序员角度，可以将互联网视为带有如下属性的全球主机集合：</p><p>　　● 主机集合映射到32位IP地址集。</p><p>　　● IP地址集映射到一组称为<strong>域名</strong>的标识符。</p><p>　　● 主机上的进程通过<strong>连接</strong>与其他主机上的进程通信。</p><h4 id="ip地址">11.2.1 IP地址</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IP地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> s_addr; <span class="comment">/* 大端对齐 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　IP地址是无符号的32位整数。由于主机可以有不同的字节顺序，TCP/IP为所有整数数据项定义了统一的<strong>网络字节顺序</strong>，即<span style="background-color:#ff0">大端对齐</span>。在结构体<code>in_addr</code>中存储标量地址是早期实现中不幸的产物，将其定义为标量类型更有意义，但现在更改已经太迟了，因为已经有大量应用程序基于该结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 转换为网络字节顺序 */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 转换为主机字节顺序 */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;</span><br></pre></td></tr></table></figure><p>　　函数<code>htonl()</code>和<code>htons()</code>会将参数从主机字节顺序转换到网络字节顺序。函数<code>ntohl()</code>和<code>ntohs()</code>会将参数从网络字节顺序转换到主机字节顺序。</p><p>　　IP地址通常以<strong>点分十进制表示法</strong>的形式呈现给人。例如，128.2.194.242是地址<code>0x8002f2f2</code>的点分十进制表示形式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(AF_INET, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>; <span class="comment">/* 若成功则返回1，若src是非法点分十进制则返回0，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(AF_INET, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>; <span class="comment">/* 若成功则返回执行点分十进制的指针，若失败则返回NULL */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>inet_pton()</code>会将点分十进制形式的字符串<code>src</code>转换为网络字节顺序的二进制形式的IP地址<code>dst</code>。若<code>src</code>没有指向合法的点分十进制字符串，则返回0；若出错，则返回-1并设置<code>errno</code>。函数<code>inet_ntop()</code>会将网络字节顺序的二进制形式的IP地址<code>src</code>转换为对应的点分十进制形式的字符串，并将得到的以<code>NULL</code>结尾的字符串中的最多<code>size</code>字节复制到<code>dst</code>。</p><h4 id="域名">11.2.2 域名</h4><p>　　客户端和服务器通过IP地址通信，但是IP地址并不易于记忆，于是就有了域名。</p><p>　　域名集形成1个层次结构，每个域名编码它在层次结构中的位置。</p><img src="/2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/subset_of_the_internet_domain_name_hierarchy.svg" title="subset_of_the_internet_domain_name_hierarchy"><p>　　域名的层次结构展示为树。树的节点表示域名，子树表示子域名。1级域名由非盈利组织ICANN定义，通用1级域名包括<code>com</code>、<code>edu</code>、<code>gov</code>、<code>org</code>和<code>net</code>。2级域名按照先到先服务的原则由ICANN代理分配，例如，<code>cmu.edu</code>。当机构收到2级域名后，该机构就可以免费创建该2级域名的所有子域名，例如，<code>cs.cmu.edu</code>。</p><p>　　互联网定义了域名集到IP地址集的映射。1988年前，域名映射通过手动维护文本文件<code>hosts.txt</code>实现。1988年后，域名映射通过称为<strong>域名系统</strong>的分布式全球数据库实现。DNS包含数百万条主机条目，每个条目定义一组域名和一组IP地址的映射，在数学意义上，每个主机条目可以视为域名和IP地址的等式。可以通过命令<code>nslookup</code>来查看DNS映射：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup localhost</span><br></pre></td></tr></table></figure><p>　　每个主机都有本地定义的域名<code>localhost</code>，该域名会映射到<strong>环回地址</strong>127.0.0.1，这对同一主机运行客户端和服务器的情况很有用。命令<code>hostname</code>可以查看主机的通用域名和IP地址。</p><p>　　在最简单的情况下，域名和IP地址之间是一对一映射。有时，多个域名会映射到同一IP地址。通常，多个域名会映射到同一组IP地址。</p><h4 id="网络连接">11.2.3 网络连接</h4><p>　　客户端和服务器通过连接发送和接收字节流来通信。连接是点对点的，因为它连接2个进程。连接是全双工的，因为数据能同时在2个方向流动。连接是可靠的，因为发送的数据总能被接收，除非出现切断电缆等灾难性故障。</p><p>　　套接字是连接的端点。每个套接字都有对应的<strong>套接字地址</strong>，套接字地址由IP地址和16位的整数端口组成，其格式为<code>地址:端口</code>。</p><p>　　当客户端发起连接请求时，内核会自动分配客户端套接字地址中的端口，该端口是<span style="background-color:#ff0">临时端口</span>。服务器套接字地址中的端口通常是与服务永久关联的<span style="background-color:#ff0">知名端口</span>。例如，Web服务器通常使用端口80，邮件服务器通常使用端口25。与知名端口关联的服务有对应的<span style="background-color:#ff0">知名服务名</span>。例如，Web服务也称为http，邮件服务也称为smtp。知名服务名和知名端口之间的映射存储在文件<code>etc/services</code>中。</p><p>　　连接的唯一标识是形如<code>(客户端地址:客户端端口, 服务器地址:服务器端口)</code>的<strong>套接字对</strong>，即2个端口的套接字地址。</p><h3 id="套接字接口">11.3 套接字接口</h3><img src="/2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/overview_of_network_applications_based_on_the_sockets_interface.svg" title="overview_of_network_applications_based_on_the_sockets_interface"><p>　　套接字接口是一组函数，用于与Unix I/O函数同时使用来构建网络应用程序。大多数现代操作系统中已经实现了套接字接口，包括Unix的所有版本、Windows和Macintosh。</p><p>　　对于网络连接，进程关闭其连接端点后，连接的另一个端口的进程试图从该连接读取数据时，会出现EOF。</p><h4 id="套接字地址">11.3.1 套接字地址</h4><p>　　从Linux内核角度，套接字就是连接的端点。从Linux程序角度，套接字就是具有对应标识符的打开的文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 互联网套接字地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> sin_family;     <span class="comment">/* 协议族 (总是AF_INET) */</span></span><br><span class="line">    <span class="type">uint16_t</span> sin_port;       <span class="comment">/* 网络字节顺序的端口号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* 网络字节顺序的IP地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通用套接字地址 (对于函数connect、bind和accept) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> sa_family; <span class="comment">/* 协议族 */</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];   <span class="comment">/* 地址数据 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　互联网套接字地址存储在16B的结构体<code>sockaddr_in</code>中，这里的后缀<code>_in</code>表示互联网而非输入。对于网络应用程序，<code>sin_family</code>字段是<code>AF_INET</code>，<code>sin_port</code>字段是16位端口号，<code>sin_addr</code>字段是32位IP地址。IP地址和端口号总是按照网络字节顺序存储。</p><p>　　函数<code>connect()</code>、<code>bind()</code>和<code>accept()</code>所需的指针指向协议专属的套接字地址。套接字接口设计者当时碰到的问题是如何让这些函数能适用于各种类型的套接字地址，那时，通用指针<code>void *</code>还不存在。当时的解决方法是定义结构体<code>sockaddr</code>，然后要求应用程序将所有协议专属的套接字地址转换为该结构体。为了简化，这里将结构体<code>sockaddr</code>定义为如下类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">SA</span>;</span></span><br></pre></td></tr></table></figure><h4 id="函数socket">11.3.2 函数<code>socket()</code></h4><p>　　客户端和服务器通过函数<code>socket()</code>创建<strong>套接字描述符</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>; <span class="comment">/* 若成功则返回非负描述符，若失败则返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　若需要让套接字成为连接的端点，可以带有如下参数调用函数<code>socket()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clientfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>　　<code>AF_INET</code>表示使用32位IP地址，<code>SOCK_STREAM</code>表示套接字会成为连接端点。不过，最好的方法是调用函数<code>getaddrinfo()</code>来自动生成这些参数，这样代码就与协议无关。</p><p>　　函数<code>socket()</code>返回的描述符<code>clientfd</code>只是部分打开的，还无法进行读写。</p><h4 id="函数connect">11.3.3 函数<code>connect()</code></h4><p>　　客户端调用函数<code>connect()</code>来与服务器建立连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> clientfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>connect()</code>会与服务器建立套接字地址为<code>addr</code>的连接。参数<code>addrlen</code>是<code>sizeof(sockaddr_in)</code>。函数<code>connect()</code>会阻塞，直到连接成功建立或出错。若成功，则描述符<code>clientfd</code>可以进行读写，得到的连接对应的套接字对为<code>(x:y, addr.sin_addr:addr.sin_port)</code>，这里<code>x</code>是客户端的IP地址，<code>y</code>是客户端的端口号。同函数<code>socket()</code>一样，最好的方法是调用函数<code>getaddrinfo()</code>来为函数<code>connect()</code>提供参数。</p><h4 id="函数bindlisten和accept">11.3.4 函数<code>bind()</code>、<code>listen()</code>和<code>accept()</code></h4><p>　　服务器调用函数<code>bind()</code>、<code>listen()</code>和<code>accept()</code>来与客户端建立连接。</p><p>　　客户端是初始化连接请求的主动实体，服务器是等待客户端连接请求的被动实体。默认情况下，内核假设通过函数<code>socket()</code>创建的描述符对应客户端上的<strong>主动套接字</strong>。服务器调用函数<code>listen()</code>来告知内核描述符会被服务器使用，调用函数<code>accept()</code>来等待客户端的连接请求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> listenfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> *addrlen)</span>; <span class="comment">/* 若成功则返回非负描述符，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>bind()</code>会请求内核将服务器的套接字地址<code>addr</code>与套接字描述符<code>sockfd</code>关联。参数<code>addrlen</code>是<code>sizeof(sockaddr_in)</code>。同函数<code>socket()</code>和<code>connect()</code>一样，最好的方法是调用函数<code>getaddrinfo()</code>来为函数<code>bind()</code>提供参数。</p><p>　　函数<code>listen()</code>会将<code>sockfd</code>从主动套接字转换为可以接收客户端的连接请求的监听套接字。参数<code>backlog</code>是关于内核在开始拒绝请求前应排队的未完成的连接请求数的提示，其具体含义需要根据超出本书范围的TCP/IP内容，这里将其设置为1024等较大的值。</p><p>　　函数<code>accept()</code>会等待客户端的连接请求到达<strong>监听描述符</strong><code>listenfd</code>，然后填充<code>addr</code>中的客户端套接字地址并返回<strong>已连接描述符</strong>。已连接描述符可以用于调用Unix I/O函数来与客户端通信。</p><p>　　监听描述符作为客户端请求连接的端点，它通常只会被创建1次并在服务器的生命周期内会一直存在。已连接描述符是客户端和服务器已建立的连接的端口，它会在服务器每次接收请求连接时被创建并只会在服务器服务对应的客户端时存在。</p><img src="/2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/the_roles_of_the_listending_and_connected_descriptors.svg" title="the_roles_of_the_listending_and_connected_descriptors"><p>　　监听描述符和已连接描述符的作用如图所示。</p><p>　　1) 服务器调用函数<code>accept()</code>来等待连接请求到达监听描述符<code>listenfd</code>。由于标准文件占用描述符0~2，这里假设监听描述符的描述符号是3。</p><p>　　2) 客户端调用函数<code>connect()</code>来发起到<code>listenfd</code>的连接请求。</p><p>　　3) 函数<code>accept()</code>打开新的已连接描述符<code>connfd</code> (这里假设为描述符4)，建立<code>cliendfd</code>和<code>connfd</code>的连接，然后将<code>connfd</code>返回给应用程序。客户端也从函数<code>connect()</code>返回。此时，客户端和服务器可以读写<code>cliendfd</code>和<code>connfd</code>来传输数据。</p><p>　　监听描述符和已连接描述符看似没有必要区分，但事实证明区分两者会很有用，因为这样可以建立能同时处理多个客户端连接的并发服务器。例如，每当连接请求到达监听描述符时，可以派生新进程来通过已连接描述符与客户端通信。</p><h4 id="主机和服务的转换">11.3.5 主机和服务的转换</h4><p>　　Linux提供了函数<code>getaddrinfo()</code>和<code>getnameinfo()</code>来完成二进制套接字地址与主机名、主机地址、服务名和端口号的字符串形式的相互转换。当它们与套接字接口一同使用时，可以使应用程序独立于IP协议版本。这2个函数分别包含函数<code>inet_pton()</code>和<code>inet_ntop()</code>的功能，而且它们提供独立于任何特定地址格式的更高级抽象。</p><h5 id="函数getaddrinfo">11.3.5.1 函数<code>getaddrinfo()</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *service, <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **result)</span>; <span class="comment">/* 若成功则返回0，若出错则返回非0错误码 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo *result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">gai_strerror</span><span class="params">(<span class="type">int</span> errcode)</span>; <span class="comment">/* 返回错误信息 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>getaddrinfo()</code>会将主机名、主机地址、服务名和端口号的字符串形式转换为套接字地址，它是过时的函数<code>gethostbyname()</code>和<code>getservbyname()</code>的替代函数。和这些过时的函数不同，该函数是可重入且独立于任何协议的。</p><img src="/2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/data_structure_returned_by_function_getaddrinfo.svg" title="data_structure_returned_by_function_getaddrinfo"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> ai_flags;             <span class="comment">/* 提示参数标志 */</span></span><br><span class="line">    <span class="type">int</span> ai_family;            <span class="comment">/* 函数socket的第1个参数 */</span></span><br><span class="line">    <span class="type">int</span> ai_socktype;          <span class="comment">/* 函数socket的第2个参数 */</span></span><br><span class="line">    <span class="type">int</span> ai_protocol;          <span class="comment">/* 函数socket的第3个参数 */</span></span><br><span class="line">    <span class="type">char</span> *ai_canonname;       <span class="comment">/* 规范主机名 */</span></span><br><span class="line">    <span class="type">size_t</span> ai_addrlen;        <span class="comment">/* 结构体ai_addr的大小 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span> <span class="comment">/* 指向套接字地址的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span> <span class="comment">/* 指向后继项的指针 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　给定参数<code>host</code>和<code>service</code>，函数<code>getaddrinfo()</code>返回的<code>result</code>会指向由结构体<code>addrinfo</code>组成的链表，其中的每个元素指向的套接字地址都对应<code>host</code>和<code>service</code>。若函数<code>getaddrinfo()</code>返回非0的错误码，则应用程序可以调用函数<code>gai_strerror()</code>来将错误码转换为错误字符串。默认情况下，函数<code>getaddrinfo()</code>返回的套接字地址能被客户端作为调用函数<code>connect()</code>的主动套接字。</p><p>　　参数<code>host</code>可以是主机名和点分十进制IP地址等数字形式的地址。参数<code>service</code>可以是http等服务名和十进制端口号。若无需将主机名转换IP地址，则可以将参数<code>host</code>设置为<code>NULL</code>。服务名也是同样。但是，参数<code>host</code>和<code>service</code><span style="background-color:#ff0">不能</span>全为<code>NULL</code>。</p><p>　　可选的参数<code>hints</code>是结构体<code>addrinfo</code>，可以提供对函数<code>getaddrinfo()</code>返回的套接字地址列表的更好的控制。当传递该参数时，只有成员<code>ai_flags</code>、<code>ai_family</code>、<code>ai_socktype</code>和<code>ai_protocol</code>能设置，其他成员必须设置为0或<code>NULL</code>。实际中，可以调用函数<code>memset</code>将结构体<code>addrinfo</code>的所有成员设置为0，然后再按需设置成员。</p><p>　　成员<code>ai_flags</code>是用于修改默认行为的位掩码，可以设置为多个值的或运算。</p><p>　　● <code>AI_ADDRCONFIG</code>表示仅当本地主机配置了IPv4时，函数<code>getaddrinfo()</code>会返回IPv4地址。IPv6也是同样。</p><p>　　● <code>ÀI_CANONNAME</code>会让函数<code>getaddrinfo()</code>将列表中第1个结构体<code>addrinfo</code>中的成员<code>ai_cannonname</code>指向主机的规范主机名。</p><p>　　● <code>AI_NUMERICSERV</code>会强制参数<code>service</code>为端口号。</p><p>　　● <code>AI_PASSIVE</code>会让函数<code>getaddrinfo()</code>返回的套接字能被服务器用作监听套接字。这种情况下，参数<code>host</code>必须为<code>NULL</code>。返回的套接字地址的地址字段将会是<span style="background-color:#ff0">通配符地址</span>，通配符地址会告知内核此服务器将接收对此主机的任何IP地址的请求。</p><p>　　当函数<code>getaddrinfo()</code>在输出列表创建结构体<code>addrinfo</code>时，会填充除成员<code>ai_flags</code>外的所有成员。成员<code>ai_addr</code>指向套接字地址，成员<code>ai_addrlen</code>表示该套接字地址的大小，成员<code>ai_next</code>指向列表中的下一个结构体<code>addrinfo</code>。</p><p>　　默认情况下，函数<code>getaddrinfo()</code>能返回IPv4和IPv6套接字地址。可以将成员<code>ai_family</code>设置为<code>AF_INET</code>来限制为仅返回IPv4地址，或设置为<code>AF_INET6</code>来限制为仅返回IPv6地址。</p><p>　　默认情况下，对于主机关联的每个唯一地址，函数<code>getaddrinfo()</code>能返回最多3个结构体<code>addrinfo</code>，它们的成员<code>ai_socktype</code>都不同，分别用于连接、数据报和原始套接字。可以将成员<code>ai_socktype</code>设置为<code>SOCK_STREAM</code>来限制为每个唯一地址最多1个结构体<code>addrinfo</code>，该结构体对应的套接字地址能用作连接端点。</p><p>　　当客户端调用函数<code>getaddrinfo()</code>后，会遍历列表并依次尝试套接字地址，直到成功调用函数<code>socket()</code>和<code>connect()</code>并完成连接建立。同样，服务器也会尝试列表中的每个套接字地址，直到成功调用函数<code>socket()</code>和<code>bind()</code>并将描述符绑定到合法的套接字地址。为了防止内存泄漏，应用程序最后必须调用函数<code>freeaddrinfo()</code>来释放列表。</p><p>　　函数<code>getaddrinfo()</code>的优点之一是结构体<code>addrinfo</code>的字段是不透明的，因为它们可以直接传递给套接字接口中的函数，应用程序代码无需任何进一步的操作。例如，成员<code>ai_family</code>、<code>ai_socktype</code>和<code>ai_protocol</code>能直接传递给函数<code>socket()</code>。同样，成员<code>ai_addr</code>和<code>ai_addrlen</code>能直接传递给函数<code>connect()</code>和<code>bind()</code>。这个属性允许客户端和服务器独立于任何版本的IP协议。</p><h5 id="函数getnameinfo">11.3.5.2 函数<code>getnameinfo()</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen, <span class="type">char</span> *host, <span class="type">size_t</span> hostlen, <span class="type">char</span> *service, <span class="type">size_t</span> servlen, <span class="type">int</span> flags)</span>; <span class="comment">/* 若成功则返回0，若出错则返回非0错误码 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>getnameinfo()</code>和函数<code>getaddrinfo()</code>是相反的。该函数会将套接字地址转换为主机名和服务名的字符串形式，它是过时的函数<code>gethostbyaddr()</code>和<code>getservbyport()</code>的替代函数。与这些过时的函数不同，该函数是可重入且独立于任何协议的。</p><p>　　参数<code>sa</code>指向<code>salen</code>字节的套接字地址，参数<code>host</code>指向<code>hostlen</code>字节的字符串，参数<code>service</code>指向<code>servlen</code>字节的字符串。若函数<code>getnameinfo()</code>返回非0的错误码，应用程序可以调用函数<code>gai_strerror()</code>将其转换为字符串。</p><p>　　若不需要主机名，则可以将<code>host</code>设置为<code>NULL</code>并将<code>hostlen</code>设置为0。服务名也是同样。但是，参数<code>host</code>和<code>service</code><span style="background-color:#ff0">不能</span>全为<code>NULL</code>。</p><p>　　参数<code>flags</code>是用于修改默认行为的位掩码，可以设置为多个值的或运算。</p><p>　　● <code>NI_NUMERICHOST</code>会让函数<code>getnameinfo()</code>在参数<code>host</code>中返回数字形式的地址。</p><p>　　● <code>NI_NUMERICSERV</code>会强制函数<code>getnameinfo()</code>跳过查询<code>/etc/services</code>并简单地返回端口号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">p</span>, *<span class="title">listp</span>, <span class="title">hints</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">int</span> rc, flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;domain name&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取结构体addrinfo列表 */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_family = AF_INET;       <span class="comment">/* 仅限IPv4 */</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">/* 仅限连接 */</span></span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(argv[<span class="number">1</span>], <span class="literal">NULL</span>, &amp;hints, &amp;listp)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;getaddrinfo error: %s\n&quot;</span>, gai_strerror(rc));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历列表并输出每个IP地址 */</span></span><br><span class="line">    flags = NI_NUMERICHOST; <span class="comment">/* 输出地址字符串而非域名 */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        Getnameinfo(p-&gt;ai_addr, p-&gt;ai_addrlen, buf, MAXLINE, <span class="literal">NULL</span>, <span class="number">0</span>, flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放 */</span></span><br><span class="line">    Freeaddrinfo(listp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会调用函数<code>getaddrinfo()</code>和<code>getnameinfo()</code>来输出域名和IP地址的映射，它和<code>nslookup</code>类似。首先，初始化函数<code>getaddrinfo()</code>的参数<code>hints</code>，这里是用于连接端点的32位IP地址 (第15~16行)。因为这里只需要获取域名，所以将函数<code>getaddrinfo()</code>的参数<code>service</code>设置为<code>NULL</code>。</p><p>　　调用函数<code>getaddrinfo()</code>后，会遍历结构体<code>addrinfo</code>列表并通过函数<code>getnameinfo()</code>将每个套接字地址转换为点分十进制地址字符串。遍历完成后，会调用函数<code>freeaddrinfo()</code>来释放该列表 (尽管对这个示例不是必需的)。</p><h4 id="套接字接口的辅助函数">11.3.6 套接字接口的辅助函数</h4><p>　　函数<code>getaddrinfo()</code>和套接字接口看似有些麻烦，这里会实现更高级的包装它们的辅助函数<code>open_clientfd()</code>和<code>open_listenfd()</code>，客户端和服务器可以使用这2个函数来进行通信。</p><h5 id="函数open_clientfd">11.3.6.1 函数<code>open_clientfd()</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 若成功则返回描述符，若出错则返回-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param hostname 服务器的主机名</span></span><br><span class="line"><span class="comment"> * @param port 服务器的端口号</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open_clientfd</span><span class="params">(<span class="type">char</span> *hostname, <span class="type">char</span> *port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> clientfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">listp</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取潜在的服务器地址列表 */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">/* 打开连接 */</span></span><br><span class="line">    hints.ai_flags = AI_NUMERICSERV; <span class="comment">/* 使用数字端口号参数 */</span></span><br><span class="line">    hints.ai_flags |= AI_ADDRCONFIG;</span><br><span class="line">    Getaddrinfo(hostname, port, &amp;hints, &amp;listp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历列表来获取可连接的服务器 */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 创建套接字描述符 */</span></span><br><span class="line">        <span class="keyword">if</span> ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* 连接失败，尝试下一个 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 连接服务器 */</span></span><br><span class="line">        <span class="keyword">if</span> (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* 成功 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        Close(clientfd); <span class="comment">/* 连接失败，尝试其他 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放 */</span></span><br><span class="line">    Freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">/* 所有连接失败 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* 最后1个连接成功 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> clientfd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　客户端可以调用函数<code>open_clientfd()</code>来与运行在主机<code>hostname</code>上的监听端口<code>port</code>上的连接请求的服务器建立连接，它会返回打开的套接字描述符，该套接字描述符可以通过Unix I/O函数来进行输入和输出。</p><p>　　调用函数<code>getaddrinfo()</code>后，返回的由结构体<code>addrinfo</code>组成的列表中的每个元素都指向可用于建立连接的套接字地址。然后，遍历该列表中的每个元素，直到成功调用函数<code>socket()</code>和<code>connect()</code>。若调用函数<code>connect()</code>失败，则会在尝试下一个元素前关闭套接字描述符；若调用函数<code>connect()</code>成功，则释放列表并返回套接字描述符给客户端。</p><h5 id="函数open_listenfd">11.3.6.2 函数<code>open_listenfd()</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LISTENQ 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 若成功则返回描述符，若出错则返回-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param port 端口号</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open_listenfd</span><span class="params">(<span class="type">char</span> *port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">listp</span>, *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">int</span> listenfd, optval = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取潜在的服务器地址列表 */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;             <span class="comment">/* 接受连接 */</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; <span class="comment">/* 任何IP地址 */</span></span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV;            <span class="comment">/* 使用端口号 */</span></span><br><span class="line">    Getaddrinfo(<span class="literal">NULL</span>, port, &amp;hints, &amp;listp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历列表来获取可绑定的服务器 */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 创建套接字描述符 */</span></span><br><span class="line">        <span class="keyword">if</span> ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* 调用函数socket失败，尝试下一个 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 消除函数bind中的地址已使用错误 */</span></span><br><span class="line">        Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (<span class="type">const</span> <span class="type">void</span> *)&amp;optval, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将描述符和地址绑定 */</span></span><br><span class="line">        <span class="keyword">if</span> (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* 成功 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        Close(listenfd); <span class="comment">/* 调用函数bind失败，尝试下一个 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放 */</span></span><br><span class="line">    Freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">/* 没有合适的地址 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 让监听套接字准备好接收连接请求 */</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, LISTENQ) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Close(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　服务器可以调用函数<code>open_listenfd()</code>来获取可以接收端口<code>port</code>上的连接请求的监听描述符。</p><p>　　与函数<code>open_clientfd()</code>有些类似，调用函数<code>getaddrinfo()</code>后，会遍历结果列表，直到成功调用函数<code>socket()</code>和<code>connect()</code>。第29行的函数<code>setsockopt()</code>会设置服务器，使其能被终止、被重启和立即重新接收连接请求。默认情况下，重启服务器后大约30s内不会接受连接请求，这会严重妨碍调试。</p><p>　　调用函数<code>getaddrinfo()</code>时，参数<code>flag</code>中有<code>AI_PASSIV</code>，参数<code>host</code>为<code>NULL</code>，所以每个套接字地址中的地址字段都会被设置为通配符地址，即告知内核此服务器将接收对此主机的任何IP地址的请求。</p><p>　　最后，调用函数<code>listen()</code>将<code>listenfd</code>转换为监听描述符并将其返回给调用者。若调用函数<code>listen()</code>失败，会在返回前将描述符关闭来避免内存泄漏。</p><h4 id="echo客户端和服务器示例">11.3.7 echo客户端和服务器示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief echo客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> clientfd;</span><br><span class="line">    <span class="type">char</span> *host, *port, buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;host&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    host = argv[<span class="number">1</span>];</span><br><span class="line">    port = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    clientfd = Open_clientfd(host, port);</span><br><span class="line">    Rio_readinitb(&amp;rio, clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Rio_writen(clientfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        Rio_readlineb(&amp;rio, buf, MAXLINE);</span><br><span class="line">        Fputs(buf, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(clientfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　对于echo客户端，在建立与服务器的连接后，它会进入从标准输入读取文本行，发送文本行到服务器，从服务器读取echo行以及输出结果到标准输出的循环。当函数<code>fget()</code>在标准输入遇到EOF、键盘输入Ctrl+D或读取完重定向输入文件的文本行时，循环终止。</p><p>　　当循环终止时，客户端会关闭描述符，这会导致发送EOF通知给服务器。当服务器从函数<code>rio_readlineb()</code>中收到的返回值为0时，它就检测该通知。关闭描述符后，客户端会终止。当程序关闭时，内核会关闭程序打开的描述符，所以，第29行的函数<code>close()</code>不是必要的。但是，显式关闭打开的描述符是良好的编程习惯之一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 读并回显文本行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param connfd 已连接描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %d bytes\n&quot;</span>, (<span class="type">int</span>)n);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief echo服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span> <span class="comment">/* 足够的空间来容纳任何地址 */</span></span><br><span class="line">    <span class="type">char</span> client_hostname[MAXLINE], client_port[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Getnameinfo((SA *)&amp;clientaddr, clientlen, client_hostname, MAXLINE, client_port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connected to (%s, %s)\n&quot;</span>, client_hostname, client_port);</span><br><span class="line">        echo(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　对于echo服务器，在打开监听描述符后，它会进入无限循环。每次迭代会等待来自客户端的连接请求，输出客户端的主机名和端口，然后调用函数<code>echo()</code>来服务客户端。从函数<code>echo()</code>返回后，服务器会关闭已连接描述符。一旦客户端和服务器关闭各自的描述符后，连接会终止。这里的服务器每次只能处理1个客户端，这种类型的服务器称为<strong>迭代服务器</strong>。相反，同时能处理多个客户端的服务器称为<strong>并发服务器</strong>。</p><p>　　第28行的变量<code>clientaddr</code>是将作为参数传递给函数<code>accept()</code>的套接字地址。在函数<code>accept()</code>返回前，会用客户端的套接字地址来填充<code>clientaddr</code>，这里<code>clientaddr</code>的类型是<code>struct sockaddr_storage</code>，该类型足以容纳任何类型的套接字地址，这样代码就与协议无关。</p><p>　　函数<code>echo()</code>会反复读写文本行，直到函数<code>rio_readlineb()</code>遇到EOF (第13行)。</p><h3 id="web服务器">11.4 Web服务器</h3><p>　　相比FTP等常规的文件检索服务，Web服务的内容使用的是HTML。HTML页包含指示浏览如何显示各种文本和图形对象的标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Make me bold!<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.cmu.edu/index.html&quot;</span>&gt;</span>Carnegie Mellon<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>　　第1行代码会告知浏览器将<code>&lt;b&gt;</code>和<code>&lt;/b&gt;</code>标签之间的文本加粗。第2行代码会告知浏览器高亮<code>&lt;a&gt;</code>和<code>&lt;/a&gt;</code>标签之间的文本并创建到HTML文件<code>index.html</code>的超链接，该HTML文件存放在Web服务器上。若用户点击高亮的文本对象，浏览器会从Web服务器请求对应的HTML文件并显示它。</p><h4 id="web内容">11.4.1 Web内容</h4><p>　　对于Web客户端和服务器，<strong>内容</strong>就是关联MIME类型的字节序列。</p><table><thead><tr><th>MIME类型</th><th>描述</th></tr></thead><tbody><tr><td><code>text/html</code></td><td>HTML页</td></tr><tr><td><code>text/plain</code></td><td>未格式化的文本</td></tr><tr><td><code>application/postscript</code></td><td>Postscript文档</td></tr><tr><td><code>image/gif</code></td><td>GIF格式编码的二进制图像</td></tr><tr><td><code>image/png</code></td><td>PNG格式编码的二进制图像</td></tr><tr><td><code>image/jpeg</code></td><td>JPEG格式编码的二进制图像</td></tr></tbody></table><p>　　Web服务器通过以下2种方式提供内容给客户端：</p><p>　　● <span style="background-color:#ff0">取磁盘文件并将其内容返回给客户端</span>。该磁盘文件称为<strong>静态内容</strong>。将磁盘文件返回给客户端的过程称为<strong>服务静态内容</strong>。</p><p>　　● <span style="background-color:#ff0">运行可执行文件并将其输出返回给客户端</span>。可执行文件在运行时产生的输出称为<strong>动态内容</strong>。运行程序并将其输出返回给客户端的过程称为<strong>服务动态内容</strong>。</p><p>　　Web服务器返回的每条内容都关联其管理的某些文件，这些文件都有称为URL的唯一名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.google.com:80/index.html</span><br></pre></td></tr></table></figure><p>　　该URL标识主机<code>www.google.com</code>上的HTML文件<code>/index.html</code>，该文件由监听80端口的Web服务器管理。</p><p>　　可执行文件的URL能包含程序参数，即文件名加上<code>?</code>，再加上<code>&amp;</code>分隔的参数。参数中不允许出现特殊字符，这些特殊字符需要转换为ASCII码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://bluefish.ics.cs.cmu.edu:8000/cgi-bin/adder?15000&amp;213</span><br></pre></td></tr></table></figure><p>　　该URL标识可执行文件<code>/cgi-bin/adder</code>，并且带有2个参数字符串<code>15000</code>和<code>213</code>。</p><p>　　在事务中，客户端和服务器使用URL的不同部分。例如，客户端使用前缀<code>https://www.google.com:80</code>来决定服务器的类型、位置和监听端口。服务器使用后缀<code>/index</code>来在文件系统中查找文件并决定请求的是静态内容还是动态内容。</p><p>　　没有标准规定来确定URL引用的静态内容还是动态内容，所以每个服务器都有自己的规定。经典方法之一是将所有可执行文件存放在某组目录。</p><p>　　URL中的<code>/</code>并不表示Linux的根目录，它表示请求内容类型的主目录。例如，某个服务器可能设置为将所有静态内容和所有动态内容分别存储在<code>/usr/httpd/html</code>和<code>/usr/httpd/cgi-bin</code>中。</p><p>　　URL中最短的后缀是<code>/</code>，所有服务器会将其扩展为某个默认的主页，例如，<code>/index.html</code>。因此，可以直接在浏览器输入域名来访问主页。浏览器会给URL附上缺失的<code>/</code>并传递给服务器，服务器将其扩展给某个默认的文件名。</p><h4 id="http事务">11.4.2 HTTP事务</h4><p>　　由于HTTP是基于网络连接的文本行，可以使用Linux的程序<code>telnet</code>来与网络上的所有Web服务器执行事务。<code>telnet</code>程序在很大程度被远程登录工具ssh取代，但对于调试通过基于连接的文本行来与客户端通信的服务器很有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; telnet www.aol.com 80        客户端: 打开到服务器的连接</span><br><span class="line">Trying 205.188.146.23...            telnet打印3行到终端</span><br><span class="line">Connected to aol.com.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">GET / HTTP/1.1                      客户端: 请求行</span><br><span class="line">Host: www.aol.com                   客户端: 请求的HTTP/1.1首部</span><br><span class="line">                                    客户端: 终止首部的空行</span><br><span class="line">HTTP/1.0 200 OK                     服务器: 响应行</span><br><span class="line">MIME-Version: 1.0                   服务器: 紧接的5行响应首部</span><br><span class="line">Date: Mon, 8 Jan 2010 4:59:42 GMT</span><br><span class="line">Server: Apache-Coyote/1.1</span><br><span class="line">Content-Type: text/html             服务器: 响应体预计是HTML</span><br><span class="line">Content-Length: 42092               服务器: 响应体预计有42092字节</span><br><span class="line">                                    服务器: 终止响应首部的空行</span><br><span class="line">&lt;html&gt;                              服务器: 响应体中第1行HTML</span><br><span class="line">...                                 服务器: 766行HTML未展示</span><br><span class="line">&lt;/html&gt;                             服务器: 响应体中最后1行HTML</span><br><span class="line">Connection closed by foreign host.  服务器: 关闭连接</span><br><span class="line">linux&gt;                              服务器: 关闭连接和终端</span><br></pre></td></tr></table></figure><p>　　在这个示例中，第1行会打开到AOL Web服务器的连接。<code>telnet</code>打印3行输出到终端，打开连接并等待用户输入 (第5行)。当输入文本行并按下enter键时，<code>telnet</code>读该行，附上回车符和换行符 (C语言中的<code>\r\n</code>) 并发送给服务器。这与HTTP标准相符，HTTP标准要求每个文本行都<span style="background-color:#ff0">以回车符和换行符结尾</span>。为了初始化事务，输入HTTP请求 (第5~7行)。服务器返回HTTP响应并关闭连接 (第8~18行)。</p><h5 id="http请求">11.4.2.1 HTTP请求</h5><p>　　HTTP请求由请求行 (第5行)、若干行请求首部 (第6行)、终止首部的空行 (第7行) 和请求体组成。请求行的格式为<code>方法 URI 版本</code>。</p><p>　　HTTP支持多种<strong>方法</strong>，包括<code>PUT</code>、<code>POST</code>、<code>OPTIONS</code>、<code>HEAD</code>、<code>PUT</code>、<code>DELETE</code>和<code>TRACE</code>。</p><p>　　● <code>GET</code>方法指示服务器生成并返回由URI标识的内容。当服务器请求内容时，URI是对应URL的后缀 (包括文件名和参数)。但是，代理服务器请求内容时，URI必须是完整的URL。</p><p>　　● <code>POST</code>方法的参数通过请求体传递。</p><p>　　请求行的<strong>版本</strong>表示请求的HTTP版本。HTTP/1.0诞生于1996年，HTTP/1.1在其基础上加上了额外的首部，用于提供缓存、安全以及允许客户端和服务器在同一<span style="background-color:#ff0">持久连接</span>上执行多个事务等功能。实际上，这2个版本是兼容的，HTTP/1.0会直接忽略HTTP/1.1首部。</p><p>　　综上所述，第5行的请求行会请求服务器返回HTML文件<code>/index.html</code>，并且版本为HTTP/1.1。</p><p>　　请求首部会提供额外信息给服务器，例如，浏览器的品牌名和MIME类型。请求首部的格式为<code>首部名: 首部数据</code>。这里仅关注首部<code>Host</code> (第6行)，该首部是HTTP/1.1必需的。<strong>代理缓存</strong>会使用首部<code>Host</code>，代理缓存有时作为浏览器和管理被请求文件的<strong>原始服务器</strong>之间的中转。客户端和原始服务器之间可以有多个代理，称为<strong>代理链</strong>。首部<code>Host</code>的数据标识原始服务器的域名，使得代理链中的代理能够判断它是否可以在本地缓存中拥有所请求内容的副本。</p><p>　　第7行的空行 (通过输入回车键生成) 终止首部并指示服务器发送所请求的HTML文件。</p><h5 id="http响应">11.4.2.2 HTTP响应</h5><p>　　HTTP响应与HTTP请求类似，HTTP响应包含响应行 (第8行)、若干行响应首部 (第9~13行)、终止首部的空行 (第14行) 以及响应体 (第15~17行)。响应行的格式为<code>版本 状态码 状态信息</code>。</p><p>　　版本字段表示响应体的支持的HTTP版本。状态码字段是表示请求状态的3位数的正整数。状态信息字段表示错误码的英文描述。</p><table><colgroup><col style="width:8%"><col style="width:38%"><col style="width:52%"></colgroup><thead><tr><th>状态码</th><th>状态信息</th><th>描述</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求被正常处理</td></tr><tr><td>301</td><td>Moved permanently</td><td>内容已移动到首部<code>Location</code>中的主机名</td></tr><tr><td>400</td><td>Bad request</td><td>服务器无法解析请求</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器无权访问所请求的文件</td></tr><tr><td>404</td><td>Not found</td><td>服务器找不到所请求的文件</td></tr><tr><td>501</td><td>Not implemented</td><td>服务器不支持请求方法</td></tr><tr><td>505</td><td>HTTP version not supported</td><td>服务器不支持所请求的版本</td></tr></tbody></table><p>　　响应首部提供关于响应的额外信息 (第9~13行)，这里仅介绍首部<code>Content-Type</code>和<code>Content-Length</code>。前者表示响应体中的内容的MIME类型，后者表示响应体中的内容的大小 (单位是字节)。</p><p>　　第14行的空行终止首部，其后是包含所请求内容的响应体。</p><h4 id="服务动态内容">11.4.3 服务动态内容</h4><p>　　CGI定义了CGI程序在运行时可以设置的很多环境变量。</p><table><thead><tr><th>环境变量</th><th>描述</th></tr></thead><tbody><tr><td><code>QUERY_STRING</code></td><td>程序参数</td></tr><tr><td><code>SERVER_PORT</code></td><td>父进程正在监听的端口</td></tr><tr><td><code>REQUEST_METHOD</code></td><td><code>GET</code>或<code>POST</code></td></tr><tr><td><code>REMOTE_HOST</code></td><td>客户端域名</td></tr><tr><td><code>REMOTE_ADDR</code></td><td>客户端点分十进制IP地址</td></tr><tr><td><code>CONTENT_TYPE</code></td><td>请求体的MIME类型 (仅限<code>POST</code>方法)</td></tr><tr><td><code>CONTENT_LENGTH</code></td><td>请求体的以字节为单位的大小 (仅限<code>POST</code>方法)</td></tr></tbody></table><p>　　在服务器收到请求后，例如，<code>GET /cgi-bin/adder?15000&amp;213 HTTP/1.1</code>，它会调用函数<code>fork()</code>来创建子进程并在子进程的上下文调用函数<code>execve()</code>来运行程序<code>/cgi-bin/adder</code>。类似<code>adder</code>的程序通常称为<span style="background-color:#ff0">CGI程序</span>，因为它们遵循CGI标准。在调用函数<code>execve()</code>前，子进程会将环境变量<code>QUERY_STRING</code>设置为<code>15000&amp;213</code>，程序<code>adder</code>能在运行时使用Linux函数<code>getenv()</code>引用。</p><p>　　CGI程序会传递其动态内容到标准输出。在子进程加载和运行CGI程序前，它会调用Linux函数<code>dup2()</code>来将标准输出重定向到与客户端关联的已连接描述符。因此，CGI程序对标准输出的所有写操作会重定向到客户端。</p><p>　　父进程并不知道子进程生成内容的大小和类型，所以子进程需要生成响应首部中的<code>Content-Type</code>、<code>Content-Length</code>和终止响应首部的空行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *buf, *p;</span><br><span class="line">    <span class="type">char</span> arg1[MAXLINE], arg2[MAXLINE], content[MAXLINE];</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提取2个参数 */</span></span><br><span class="line">    <span class="keyword">if</span> ((buf = getenv(<span class="string">&quot;QUERY_STRING&quot;</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">        *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(arg1, buf);</span><br><span class="line">        <span class="built_in">strcpy</span>(arg2, p + <span class="number">1</span>);</span><br><span class="line">        n1 = atoi(arg1);</span><br><span class="line">        n2 = atoi(arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造响应体 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;QUERY_STRING=%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;Welcome to add.com: &quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;%sThe Internet addition portal.\r\n&lt;p&gt;&quot;</span>, content);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;%sThe answer is: %d + %d = %d\r\n&lt;p&gt;&quot;</span>, content, n1, n2, n1 + n2);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;%sThanks for visiting!\r\n&quot;</span>, content);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造HTTP响应 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Connection: close\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content-length: %d\r\n&quot;</span>, (<span class="type">int</span>)<span class="built_in">strlen</span>(content));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content-type: text/html\r\n\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, content);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会计算2个参数的和并返回带有结果的HTML文件给客户端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; telnet kittyhawk.cmcl.cs.cmu.edu 8000        客户端: 打开连接</span><br><span class="line">Trying 128.2.194.242...</span><br><span class="line">Connected to kittyhawk.cmcl.cs.cmu.edu.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">GET /cgi-bin/adder?15000&amp;213 HTTP/1.0               客户端: 请求行</span><br><span class="line">                                                    客户端: 终止首部的空行</span><br><span class="line">HTTP/1.0 200 OK                                     服务器: 响应行</span><br><span class="line">Server: Tiny Web Server                             服务器: 标识服务器</span><br><span class="line">Content-length: 115                                 Adder: 响应体预计有115字节</span><br><span class="line">Content-type: text/html                             Adder: 响应体预计是HTML</span><br><span class="line">                                                    Adder: 终止首部的空行</span><br><span class="line">Welcome to add.com: THE Internet addition portal.   Adder: 响应体中第1行HTML</span><br><span class="line">&lt;p&gt;The answer is: 15000 + 213 = 15213               Adder: 响应体中第2行HTML</span><br><span class="line">&lt;p&gt;Thanks for visiting!                             Adder: 响应体中第3行HTML</span><br><span class="line">Connection closed by foreign host.                  服务器: 关闭连接</span><br><span class="line">linux&gt;                                              客户端: 关闭连接和终端</span><br></pre></td></tr></table></figure><p>　　这个示例是某个HTTP事务，它提供程序<code>adder</code>的动态内容。</p><h3 id="tiny-web服务器">11.5 TINY Web服务器</h3><p>　　这里将实现称为TINY的Web服务器，它结合了进程控制、Unix I/O、套接字接口和HTTP。虽然它缺乏了真实服务器的功能性、可靠性和安全性，但足以提供静态和动态内容给真实浏览器。TINY是基于HTTP/1.0的简单迭代服务器，使用<code>GET</code>方法提供静态内容和动态内容。</p><p>　　若服务器写已被客户端关闭的连接，第1次写会正常返回，第2次写会导致发送信号SIGPIPE，该信号的默认行为是关闭进程。若信号SIGPIPE被捕获或忽略，则第2次写操作会返回-1并将<code>errno</code>设置为<code>EPIPE</code>。函数<code>strerr()</code>和<code>perror()</code>会将错误<code>EPIPE</code>报告为 "Broken pipe"，这个信息并不直观。</p><h4 id="主函数">11.5.1 主函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">doit</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_requesthdrs</span><span class="params">(<span class="type">rio_t</span> *rp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">parse_uri</span><span class="params">(<span class="type">char</span> *uri, <span class="type">char</span> *filename, <span class="type">char</span> *cgiargs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_filetype</span><span class="params">(<span class="type">char</span> *filename, <span class="type">char</span> *filetype)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_static</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *filename, <span class="type">int</span> filesize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_dynamic</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *filename, <span class="type">char</span> *cgiargs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clienterror</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *cause, <span class="type">char</span> *errnum, <span class="type">char</span> *shortmsg, <span class="type">char</span> *longmsg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">char</span> hostname[MAXLINE], port[MAXLINE];</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查命令行参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Getnameinfo((SA *)&amp;clientaddr, clientlen, hostname, MAXLINE, port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);</span><br><span class="line">        doit(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这是TINY的主函数，它监听连接请求的端口通过命令行传递。在调用函<code>open_listenfd()</code>打开监听套接字后，TINY会进行常规的服务器无限循环——反复接收连接请求 (第28行)、执行事务 (第31行) 和关闭连接端点 (第32行)。</p><h4 id="函数doit">11.5.2 函数<code>doit()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理HTTP事务</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param fd 文件描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">doit</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> is_static;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="type">char</span> filename[MAXLINE], cgiargs[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读请求行和首部 */</span></span><br><span class="line">    Rio_readinitb(&amp;rio, fd);</span><br><span class="line">    Rio_readlineb(&amp;rio, buf, MAXLINE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Request headers:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        clienterror(fd, method, <span class="string">&quot;501&quot;</span>, <span class="string">&quot;Not implemented&quot;</span>, <span class="string">&quot;Tiny does not implement this method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    read_requesthdrs(&amp;rio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从请求中解析URI */</span></span><br><span class="line">    is_static = parse_uri(uri, filename, cgiargs);</span><br><span class="line">    <span class="keyword">if</span> (stat(filename, &amp;sbuf) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clienterror(fd, filename, <span class="string">&quot;404&quot;</span>, <span class="string">&quot;Not found&quot;</span>, <span class="string">&quot;Tiny couldn&#x27;t find this file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_static)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 服务静态内容 */</span></span><br><span class="line">        <span class="keyword">if</span> (!(S_ISREG(sbuf.st_mode)) || !(S_IRUSR &amp; sbuf.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line">            clienterror(fd, filename, <span class="string">&quot;403&quot;</span>, <span class="string">&quot;Forbidden&quot;</span>, <span class="string">&quot;Tiny couldn&#x27;t read the file&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        serve_static(fd, filename, sbuf.st_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 服务动态内容 */</span></span><br><span class="line">        <span class="keyword">if</span> (!(S_ISREG(sbuf.st_mode)) || !(S_IXUSR &amp; sbuf.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line">            clienterror(fd, filename, <span class="string">&quot;403&quot;</span>, <span class="string">&quot;Forbidden&quot;</span>, <span class="string">&quot;Tiny couldn&#x27;t run the CGI program&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        serve_dynamic(fd, filename, cgiargs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数<code>doit()</code>会处理HTTP事务。首先，读并解析请求行 (第16~19行)，这里使用函数<code>rio_readlineb()</code>来读取请求行。</p><p>　　TINY仅支持<code>GET</code>方法。若客户端请求其他方法，则发送错误信息并返回到主函数 (第20~24行)，主函数会关闭连接并等待下一个连接请求；否则，进行读操作并忽略所有请求首部 (第25行)。</p><p>　　然后，解析URI为文件名和CGI参数字符串，这里使用了1个标志来指示请求的是静态内容还是动态内容 (第28行)。若在磁盘上找不到所请求的文件，则立即发送错误信息给客户端并返回。</p><p>　　最后，当请求的是静态内容时，会验证该文件是否是普通文件以及是否有读权限 (第38行)，若是，则提供静态内容给客户端 (第43行)。当请求的是动态内容，会验证该文件是否是可执行文件，若是，则提供动态内容 (第53行)。</p><h4 id="函数clienterror">11.5.3 函数<code>clienterror()</code></h4><p>　　TINY缺乏真实服务器的多种错误处理功能。但是，它会检查一些常见的错误并反馈给客户端。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 发送错误信息给客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param fd 文件描述符</span></span><br><span class="line"><span class="comment"> * @param cause 原因</span></span><br><span class="line"><span class="comment"> * @param errnum 错误码</span></span><br><span class="line"><span class="comment"> * @param shortmsg 短信息</span></span><br><span class="line"><span class="comment"> * @param longmsg 长信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clienterror</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *cause, <span class="type">char</span> *errnum, <span class="type">char</span> *shortmsg, <span class="type">char</span> *longmsg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], body[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构建HTTP响应体 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;&lt;html&gt;&lt;title&gt;Tiny Error&lt;/title&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;body bgcolor=&quot;</span><span class="string">&quot;ffffff&quot;</span><span class="string">&quot;&gt;\r\n&quot;</span>, body);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s%s: %s\r\n&quot;</span>, body, errnum, shortmsg);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;p&gt;%s: %s\r\n&quot;</span>, body, longmsg, cause);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;hr&gt;&lt;em&gt;The Tiny Web server&lt;/em&gt;\r\n&quot;</span>, body);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印HTTP响应 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 %s %s\r\n&quot;</span>, errnum, shortmsg);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: text/html\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-length: %d\r\n\r\n&quot;</span>, (<span class="type">int</span>)<span class="built_in">strlen</span>(body));</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    Rio_writen(fd, body, <span class="built_in">strlen</span>(body));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数<code>clienterror()</code>会发送HTTP响应给客户端，响应行会包含合适的状态码和状态信息，响应体会包含解释错误的HTML文件。</p><p>　　HTTP响应需要指明大小和内容类型，所以选择将HTTP内容构建为单个字符串，这样易于判断其大小。这里对所有的输出使用了函数<code>rio_writen()</code>。</p><h4 id="函数read_requesthdrs">11.5.4 函数<code>read_requesthdrs()</code></h4><p>　　TINY不会使用请求首部中的任何信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 读并忽略请求首部</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rp 指向读缓冲区的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_requesthdrs</span><span class="params">(<span class="type">rio_t</span> *rp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">    Rio_readlineb(rp, buf, MAXLINE);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;\r\n&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Rio_readlineb(rp, buf, MAXLINE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数<code>read_requsethdrs()</code>会读并忽略请求首部。第11行会检查终止请求首部的空行 (以<code>\r\n</code>结束)。</p><h4 id="函数parse_uri">11.5.5 函数<code>parse_uri()</code></h4><p>　　TINY会假设静态内容的主目录是当前目录，可执行文件的主目录是<code>./cgi-bin</code>。所有包含字符串<code>./cgi-bin</code>的URI都会被假设为动态内容请求。默认文件名是<code>./home.html</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 解析HTTP URI</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param uri</span></span><br><span class="line"><span class="comment"> * @param filename 文件名</span></span><br><span class="line"><span class="comment"> * @param cgiargs CGI参数</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parse_uri</span><span class="params">(<span class="type">char</span> *uri, <span class="type">char</span> *filename, <span class="type">char</span> *cgiargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(uri, <span class="string">&quot;cgi-bin&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 静态内容 */</span></span><br><span class="line">        <span class="built_in">strcpy</span>(cgiargs, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(filename, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(filename, uri);</span><br><span class="line">        <span class="keyword">if</span> (uri[<span class="built_in">strlen</span>(uri) - <span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcat</span>(filename, <span class="string">&quot;home.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 动态内容 */</span></span><br><span class="line">        ptr = index(uri, <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(cgiargs, ptr + <span class="number">1</span>);</span><br><span class="line">            *ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(cgiargs, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(filename, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(filename, uri);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数<code>parse_uri()</code>会将URI解析为文件名和可选的CGI参数字符串。若请求的是静态内容 (第13行)，则清除CGI参数字符串并将URI转换为对应的Linux路径名 (第16~17行)，若URI以<code>/</code>结尾，则附上默认文件名 (第21行)；若请求的是动态内容，则提取CGI参数 (第28~37行) 并将URI的剩余部分转换为相关的Linux文件名 (第38~39行)。</p><h4 id="函数serve_static">11.5.6 函数<code>serve_static()</code></h4><p>　　TINY提供5种类型的静态内容，即HTML文件、未格式化的文本文件、GIF格式图片、PNG格式图片和JPEG格式图片。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据文件名获取文件类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param filename 文件名</span></span><br><span class="line"><span class="comment"> * @param filetype 文件类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_filetype</span><span class="params">(<span class="type">char</span> *filename, <span class="type">char</span> *filetype)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">&quot;.html&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">&quot;.gif&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;image/gif&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">&quot;.png&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;image/png&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">&quot;.jpg&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 提供静态内容给客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param fd 文件描述符</span></span><br><span class="line"><span class="comment"> * @param filename 文件名</span></span><br><span class="line"><span class="comment"> * @param filesize 文件大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_static</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *filename, <span class="type">int</span> filesize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> srcfd;</span><br><span class="line">    <span class="type">char</span> *srcp, filetype[MAXLINE], buf[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送响应首部到客户端 */</span></span><br><span class="line">    get_filetype(filename, filetype);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%sServer: Tiny Web Server\r\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%sConnection: close\r\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%sContent-length: %d\r\n&quot;</span>, buf, filesize);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%sContent-type: %s\r\n\r\n&quot;</span>, buf, filetype);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Response headers:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送响应体到客户端 */</span></span><br><span class="line">    srcfd = Open(filename, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    srcp = Mmap(<span class="number">0</span>, filesize, PROT_READ, MAP_PRIVATE, srcfd, <span class="number">0</span>);</span><br><span class="line">    Close(srcfd);</span><br><span class="line">    Rio_writen(fd, srcp, filesize);</span><br><span class="line">    Munmap(srcp, filesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数<code>serve_static()</code>会发送HTTP响应到客户端，响应体包含本地文件的内容。首先，根据文件名的后缀来决定文件类型 (第44行)，发送响应行和响应首部到客户端，这里包含终止首部的空行 (第45~50行)。</p><p>　　然后，将所请求的文件复制到已连接描述符<code>fd</code>来发送响应体。第55行会打开<code>filename</code>来读和获取描述符。第56行会调用函数<code>mmap()</code>来将所请求的文件映射到虚拟内存区域，即将文件<code>srcfd</code>的前<code>filesize</code>字节映射到虚拟内存中地址<code>srcp</code>处的私有只读区域。</p><p>　　将文件映射到内存后，就不会再使用它的描述符，所以需要关闭文件 (第57行)。第58行才会真正将文件传输给客户端。函数<code>rio_writen()</code>会将位置<code>srcp</code>处的<code>filesize</code>字节 (被映射到所请求的文件) 复制到客户端的已连接描述符。最后，第59行会释放映射的虚拟内存区域。</p><h4 id="函数serve_dynamic">11.5.7 函数<code>serve_dynamic()</code></h4><p>　　TINY通过派生子进程来提供任何类型的动态内容，然后在子进程的上下文中运行CGI程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 提供动态内容给客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param fd 文件描述符</span></span><br><span class="line"><span class="comment"> * @param filename 文件名</span></span><br><span class="line"><span class="comment"> * @param cgiargs CGI参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_dynamic</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *filename, <span class="type">char</span> *cgiargs)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], *emptylist[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送HTTP响应的第1部分 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Server: Tiny Web Server\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 子进程 */</span></span><br><span class="line">    <span class="keyword">if</span> (Fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 真实服务器会在这里设置所有的CGI变量 */</span></span><br><span class="line">        setenv(<span class="string">&quot;QUERY_STRING&quot;</span>, cgiargs, <span class="number">1</span>);</span><br><span class="line">        Dup2(fd, STDOUT_FILENO);              <span class="comment">/* 将标准输出重定向到客户端 */</span></span><br><span class="line">        Execve(filename, emptylist, environ); <span class="comment">/* 运行CGI程序 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    Wait(<span class="literal">NULL</span>); <span class="comment">/* 父进程等待并回收子进程 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数<code>serve_dynamic()</code>会先给客户端发送表明成功的响应行和包含信息的首部<code>Server</code>。CGI程序负责发送HTTP响应的剩余部分。这里并没有考虑CGI程序可能会碰到某些错误。</p><p>　　在发送HTTP响应的第1部分后，会派生子进程 (第20行)。子进程会使用请求URI中的CGI参数来初始化环境变量<code>QUERY_STRING</code>，真实服务器还会在这里设置其他CGI环境变量 (这里为了简化，省略这一步)。</p><p>　　然后，子进程将其标准输出重定向到已连接描述符 (第24行)，加载并运行CGI程序 (第25行)。由于CGI程序运行在子进程的上下文，它可以访问调用函数<code>execve()</code>之前存在的所有打开的文件和环境变量。因此，CGI程序对标准输出的所有写操作会重定向到客户端，父进程调用函数<code>wait()</code>来阻塞自己并在子进程终止时将其回收 (第27行)。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2023/08/16/computer-systems-a-programmer's-perspective-3e-chpt-10/" rel="prev" title="《深入理解计算机系统 第3版》第10章 系统级I/O"><i class="fa fa-angle-left"></i> 《深入理解计算机系统 第3版》第10章 系统级I/O</a></div><div class="post-nav-item"><a href="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/" rel="next" title="《深入理解计算机系统 第3版》第12章 并发编程">《深入理解计算机系统 第3版》第12章 并发编程 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script></body></html>