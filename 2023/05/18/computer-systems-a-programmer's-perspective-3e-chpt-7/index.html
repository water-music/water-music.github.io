<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><link rel="canonical" href="http://example.com/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/","path":"2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/","title":"《深入理解计算机系统 第3版》第7章 链接"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《深入理解计算机系统 第3版》第7章 链接 |</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">7.1 编译器驱动程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="nav-text">7.2 可重定位目标文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="nav-text">7.3 符号和符号表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90"><span class="nav-text">7.4 符号解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%99%A8%E8%A7%A3%E6%9E%90%E9%87%8D%E5%A4%8D%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%90%8D%E7%A7%B0"><span class="nav-text">7.4.1 链接器解析重复的符号名称</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E9%9D%99%E6%80%81%E5%BA%93"><span class="nav-text">7.4.2 链接静态库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%99%A8%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%BA%93%E8%A7%A3%E6%9E%90%E5%BC%95%E7%94%A8"><span class="nav-text">7.4.3 链接器使用静态库解析引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="nav-text">7.5 重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E6%9D%A1%E7%9B%AE"><span class="nav-text">7.5.1 重定位条目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8"><span class="nav-text">7.5.2 重定位符号引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8Dpc%E7%9B%B8%E5%AF%B9%E5%BC%95%E7%94%A8"><span class="nav-text">7.5.2.1 重定位PC相对引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%BB%9D%E5%AF%B9%E5%BC%95%E7%94%A8"><span class="nav-text">7.5.2.2 重定位绝对引用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-text">7.6 可执行文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-text">7.7 加载可执行文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="nav-text">7.8 动态链接共享库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="nav-text">7.9 从应用程序中加载和链接共享库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81"><span class="nav-text">7.10 位置无关代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pic%E6%95%B0%E6%8D%AE%E5%BC%95%E7%94%A8"><span class="nav-text">7.10.1 PIC数据引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pic%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-text">7.10.2 PIC函数调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%93%E6%89%93%E6%A1%A9"><span class="nav-text">7.11 库打桩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E6%89%93%E6%A1%A9"><span class="nav-text">7.11.1 编译时打桩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E6%97%B6%E6%89%93%E6%A1%A9"><span class="nav-text">7.11.2 链接时打桩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%93%E6%A1%A9"><span class="nav-text">7.11.3 运行时打桩</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《深入理解计算机系统 第3版》第7章 链接 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《深入理解计算机系统 第3版》第7章 链接</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-05-18 00:00:00" itemprop="dateCreated datePublished" datetime="2023-05-18T00:00:00+08:00">2023-05-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-10-13 00:00:00" itemprop="dateModified" datetime="2023-10-13T00:00:00+08:00">2023-10-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/computer-system/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>21k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　<strong>链接</strong>是收集各种代码和数据并组合成单一文件的过程，合成的文件可以被加载 (复制) 到内存并执行。链接可以在编译时执行，即将源码转换为机器码时；也可以在加载时执行，即使用加载器将程序加载到内存并执行时；也可以在运行时执行，即由应用程序来执行。在早期计算机系统中，链接需要手动执行。在现代计算机系统中，链接由称为<strong>链接器</strong>的程序自动执行。</p><p>　　链接器使得程序能够<strong>分离编译</strong>，这样可以将大型程序拆解为更小且更易于管理的模块，这些模块可以单独修改和编译。当修改模块后，只需重新编译并链接该模块，无需编译其他模块。</p><p>　　<strong>目标模块</strong>是字节序列，<strong>目标文件</strong>是以文件形式存放在磁盘中的目标模块。目标文件按类型分为<span style="background-color:#ff0">可重定位目标文件</span>、<span style="background-color:#ff0">可执行 (目标) 文件</span>和<span style="background-color:#ff0">共享目标文件</span>。共享目标文件是特殊的可重定位目标文件，可以在加载或运行时动态地加载到内存并链接。</p><p>　　不同系统的<strong>目标文件格式</strong>不同。诞生于贝尔实验室的首个Unix系统使用的是<code>a.out</code>格式。直到今天，可执行文件仍然称为<code>a.out</code>文件。Windows使用<strong>可移植可执行</strong>格式。Mac OS-X使用的是Mach-O格式。现代x86-64 Linux和Unix系统使用的是<strong>可执行可链接格式</strong>。</p><p>　　Linux LD等<strong>静态链接器</strong>以一组可重定位目标文件和命令行参数作为输入，输出为可以加载和运行的完全链接的可执行文件。输入的可重定位目标文件由各种不同的代码和<strong>数据节</strong>组成，每个数据节都是连续的字节序列。指令占1节，已初始化的全局变量占1节，未初始化的变量占1节。</p><p>　　为了生成可执行文件，链接器必须进行<strong>符号解析</strong>和<strong>重定位</strong>。</p><p>　　● 目标文件定义和引用符号，每个符号都对应1个函数或1个全局变量或1个静态变量 (C语言中关键字<code>static</code>声明的变量)。符号解析将每个符号引用和对应的符号定义关联。</p><p>　　● 编译器和汇编器生成从地址0开始的代码和数据节。链接器把每个符号定义和1个内存位置关联，然后修改所有对这些符号的引用，使得它们指向对应的内存位置，这个过程就是重定位。链接器使用汇编器生成的<strong>重定位条目</strong>的详细指令来执行重定位。</p><p>　　C++和Java都允许重载方法，即函数名相同但参数列表不同，因为编译器将每个唯一的方法和参数列表组合编码为<span style="background-color:#ff0">对链接器唯一</span>的名称。这种编码过程称为<strong>倾轧</strong>，相反的过程称为<strong>还原</strong>。</p><p>　　C++和Java使用兼容的倾轧策略，倾轧过的类名由名称的字符数加上名称构成。例如，类<code>Foo</code>编码为<code>3Foo</code>。函数编码为函数名加上<code>_</code>，再加上倾轧过的类名，最后加上每个参数的类型的首字母。例如，函数<code>Foo::bar(int, long)</code>编码为<code>bar__3Fooil</code>。倾轧全局变量和模板名称的方法与之类似。</p><span id="more"></span><p>　　Linux中有很多工具可以用于理解和处理目标文件。GNU binutils包就是其中之一，它可以运行在每个Linux平台上。</p><p>　　● AR：创建静态库，插入、删除、列出和提取成员。</p><p>　　● STRINGS：列出目标文件中所有可打印的字符串。</p><p>　　● STRIP：删除目标文件中的符号表信息。</p><p>　　● NM：列出目标文件中符号表中定义的符号。</p><p>　　● SIZE：列出目标文件中节的名称和大小。</p><p>　　● READELF：显示目标文件的完整结构，包含SIZE和NM的功能。</p><p>　　● OBJDUMP：显示目标文件的所有信息。最大的作用是反汇编<code>.text</code>节中的二进制指令。</p><p>　　● LDD：列出可执行文件在运行时所需的共享库。</p><h3 id="编译器驱动程序">7.1 编译器驱动程序</h3><p>　　大多数编译系统提供<strong>编译器驱动程序</strong>，在需要时代表用户调用预处理器、编译器、汇编器和链接器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sum.c */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sum.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val = sum(<span class="built_in">array</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　编译以上源程序可以通过以下命令来调用GCC驱动程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Og -o prog main.c sum.c</span><br></pre></td></tr></table></figure><p>　　驱动程序首先运行C预处理器，将源程序<code>main.c</code>转换为ASCII中间文件<code>main.i</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpp [其他参数] main.c /tmp/main.i</span><br></pre></td></tr></table></figure><p>　　接下来，驱动程序运行C编译器，将<code>main.i</code>转换为ASCII汇编文件<code>main.s</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ccl /tmp/main.i -Og [其他参数] -o /tmp/main.s</span><br></pre></td></tr></table></figure><p>　　然后，驱动程序运行汇编器，将<code>main.s</code>转换为可重定位目标文件<code>main.o</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as [其他参数] -o /tmp/main.o /tmp/main.s</span><br></pre></td></tr></table></figure><p>　　驱动程序以相同的步骤生成<code>sum.o</code>。最后，它运行链接器，将<code>main.o</code>、<code>sum.o</code>和一些必要的系统目标文件组合起来生成可执行文件<code>prog</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -o prog [系统目标文件和参数] /tmp/main.o /tmp/sum.o</span><br></pre></td></tr></table></figure><p>　　通过以下命令可以执行文件<code>prog</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./prog</span><br></pre></td></tr></table></figure><p>　　shell调用操作系统中的称为<strong>加载器</strong>的函数，将可执行文件<code>prog</code>中的代码和数据复制到内存，然后将控制权转移给该程序的开头。</p><h3 id="可重定位目标文件">7.2 可重定位目标文件</h3><img src="/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/typical_elf_relocatable_object_file.svg" title="typical_elf_relocatable_object_file"><p>　　<strong>ELF首部</strong>以16B的序列开始，该序列描述了生成该文件的系统的字长和字节顺序。ELF首部的剩余部分包含链接器语法分析和解释目标文件所需的信息 (包括ELF首部的大小、目标文件类型、机器类型、节首部表的文件偏移以及节首部表条目的数量和大小)。<strong>节首部表</strong>描述各个节的位置和大小，每个节都对应1个固定大小的条目。</p><p>　　在ELF首部和节首部表中间的是节。</p><p>　　● <code>.text</code>节存放已编译程序的机器代码。</p><p>　　● <code>.rodata</code>节存放只读数据，例如，函数<code>printf()</code>中的格式串和<code>switch</code>语句中的跳转表。</p><p>　　● <code>.data</code>节存放已初始化的C语言全局和静态变量。</p><p>　　● <code>.bss</code>节存放未初始化和初始化为0的C语言全局和静态变量。该节只是占位符，并不占用目标文件的空间。目标文件区分变量是否初始化是为了空间效率，未初始化变量不占用实际的磁盘空间，运行时由内存分配空间并赋予初始值0。</p><p>　　● <code>.symtab</code>节是符号表，存放程序中定义和引用的<span style="background-color:#ff0">函数和全局变量</span>的信息。每个可重定位目标文件的该节中都有符号表，除非使用命令<code>STRIP</code>去除。</p><p>　　● <code>.rel.text</code>节是<code>.text</code>节中位置的列表，当链接器把该目标文件和其他文件组合时，会修改这些位置。任何调用外部函数和引用全局变量的指令都需要修改。调用本地函数的指令则无需修改。可执行文件中并不需要重定位信息，所以通常忽略，除非用户显示地指示链接器包含这些信息。</p><p>　　● <code>rel.data</code>节存放模块定义和引用的所有全局变量的重定位信息。任何已初始化且初始值是全局变量地址或外部定义函数地址的变量都需要修改。</p><p>　　● <code>.debug</code>节是调试符号表，其条目是程序中定义的局部变量、类型定义、定义/引用的全局变量和原始C源文件。只有使用命令行选项<code>-g</code>时，才会生成该表。</p><p>　　● <code>.line</code>节是原始C源程序中的行号和<code>.text</code>节中机器指令之间的映射。只有使用命令行选项<code>-g</code>时，才会生成该表。</p><p>　　● <code>.strtab</code>节是字符串表，包括<code>.symtab</code>节和<code>.debug</code>节中的符号表以及节首部中的节名称。字符串表是以<code>null</code>结尾的字符串序列。</p><p>　　<code>.bss</code>节的名称源自IBM 704汇编语言 (约1957年) 中块存储开始指令的首字母缩写，并沿用至今。</p><h3 id="符号和符号表">7.3 符号和符号表</h3><p>　　每个可重定位目标文件<code>m</code>都有1个符号表，该表包含<code>m</code>定义和引用的符号的信息。在链接器的上下文中，有3种不同的符号。</p><p>　　● 由模块<code>m</code>定义但由其他模块引用的<span style="background-color:#ff0">全局符号</span>，对应非静态的C语言函数和全局变量。</p><p>　　● 由其他模块定义但由模块<code>m</code>引用的<span style="background-color:#ff0">全局符号</span>，对应其他模块定义的非静态的C语言函数和全局变量。这种符号是<strong>外部</strong>的。</p><p>　　● 只被模块<code>m</code>定义和引用的<span style="background-color:#ff0">局部符号</span>，对应C语言静态函数和静态全局变量。这些符号仅在模块<code>m</code>中可见，不能被其他模块引用。</p><p>　　在C语言中，源文件对应模块，关键字<code>static</code>可用于隐藏模块内部的变量和函数声明，声明为<code>static</code>的全局变量或函数都是模块私有的。相反，任何不声明为<code>static</code>的全局变量或函数是公有的，可以被其他模块访问。</p><p>　　C语言中的局部变量在运行时由栈管理，与链接器无关。但是，声明为<code>static</code>的局部变量由链接器管理，链接器会为其在<code>.data</code>节或<code>.bss</code>节中分配空间并在符号表中创建1个有唯一名称的局部链接器符号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">g</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在这个示例中，2个函数都定义了静态局部变量<code>x</code>，编译器会向汇编器提供2个名称不同的局部链接器符号。例如，用<code>x.1</code>表示函数<code>f()</code>中定义的<code>x</code>，用<code>x.2</code>表示函数<code>g()</code>中定义的<code>x</code>。</p><p>　　汇编器根据编译器输出到<code>.s</code>汇编文件的符号来生成符号表。<code>.symtab</code>节中包含ELF符号表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf64_Symbol</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="type">char</span> type : <span class="number">4</span>, binding : <span class="number">4</span>;</span><br><span class="line">    <span class="type">char</span> reserved;</span><br><span class="line">    <span class="type">short</span> section;</span><br><span class="line">    <span class="type">long</span> value;</span><br><span class="line">    <span class="type">long</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　这是ELF符号表条目的格式，<code>name</code>表示字符串表中的字节偏移，指向符号的以<code>null</code>结尾的字符串名称。<code>value</code>是符号的地址。对于可重定位的模块，<code>value</code>是到定义目标的节的起始处偏移。对于可执行文件，<code>value</code>是绝对运行时地址。<code>size</code>是目标的大小 (以字节为单位)。<code>type</code>只能是数据或函数。符号表还可以包含各个节的条目和原始源文件的路径名的条目，所以这些目标的类型也有所不同。<code>binding</code>表示符号是局部还是全局。</p><p>　　每个符号都被分配到目标文件的某个节，由<code>section</code>表示，它是节首部表的索引。有3个特殊的<span style="background-color:#ff0">伪节</span>，它们在节首部表中没有条目，即<code>ABS</code>、<code>UNDEF</code>和<code>COMMON</code>。<code>ABS</code>表示不应该被重定位的符号。<code>UNDEF</code>表示未定义的符号，即本目标模块引用但由其他模块定义的符号。<code>COMMON</code>表示未分配空间的未初始化数据条目。对于<code>COMMON</code>符号，<code>value</code>指明对齐要求，<code>size</code>给出最小值。<span style="background-color:#ff0">只有可重定位目标文件才有伪节</span>，可执行文件没有。</p><p>　　<code>COMMON</code>和<code>.bss</code>节有细微差别。GCC会将<span style="background-color:#ff0">未初始化的全局变量</span>分配给<code>COMMON</code>，将未初始化的静态变量和初始化为0的全局/静态变量分配给<code>.bss</code>节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Num:	Value           Size	Type	Bind	Vis 	Ndx	Name</span><br><span class="line">  8: 0000000000000000	  24	FUNC	GLOBAL	DEFAULT   1	main</span><br><span class="line">  9: 0000000000000000	   8	OBJECT	GLOBAL	DEFAULT   3	array</span><br><span class="line"> 10: 0000000000000000	   0	NOTYPE	GLOBAL	DEFAULT UND	sum</span><br></pre></td></tr></table></figure><p>　　这个示例是7.1中的<code>main.o</code>的符号表中的最后3个条目。READELF用整数索引来标识每个节。<code>Ndx=1</code>表示<code>.text</code>节，<code>Ndx=3</code>表示<code>.data</code>节。全局符号<code>main</code>定义的条目是<code>.text</code>节中偏移为0处的24B的函数。其后是全局符号<code>array</code>的定义，它是<code>.data</code>节中偏移为0处的8B的目标。最后是对外部符号<code>sum</code>的引用。</p><h3 id="符号解析">7.4 符号解析</h3><p>　　链接器通过将每个引用和其输入重定位目标文件的符号表中的1个的符号定义关联来解析符号引用。对于那些定义和引用在同一模块的局部符号的引用，符号解析是直接明了的。编译器仅允许模块中每个局部符号有1个定义。编译器还确保有局部链接器符号的静态局部变量有唯一的名称。</p><p>　　当编译器遇到不在本模块定义的全局符号时，会假设该符号在其他模块中定义，生成链接器符号表条目并将其交给链接器处理。若链接器在它的所有输入模块中都找不到该符号的定义，就输出错误信息 (通常难以阅读) 并终止。有时多个目标文件可能定义名称相同的全局符号，此时，链接器要么标志错误，要么以某种方法选择1个定义并抛弃其他定位。Linux使用的方法涉及编译器、汇编器和链接器之间的协作。</p><h4 id="链接器解析重复的符号名称">7.4.1 链接器解析重复的符号名称</h4><p>　　在编译时，编译器会向汇编器提供所有全局符号，汇编器会隐式地把它们编码在可重定位目标文件的符号表中。函数和已初始化的全局变量是<strong>强</strong>符号，未初始化的全局变量是<strong>弱</strong>符号。</p><p>　　Linux链接器不允许多个同名的强符号。若1个强符号与多个弱符号同名，则选择强符号。若多个弱符号同名，则随机选择1个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* foo.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> y = <span class="number">15212</span>;</span><br><span class="line"><span class="type">int</span> x = <span class="number">15213</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = 0x%x y = 0x%x \n&quot;</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bar.c */</span></span><br><span class="line"><span class="type">double</span> x;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    x = <span class="number">-0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在x86-64/Linux机器上，<code>double</code>是8B，<code>int</code>是4B。当<code>x</code>和<code>y</code>的地址相邻且<code>x</code>的地址在<code>y</code>之前时，<code>bar.c</code>中第6行代码会用<span style="background-color:#ff0">0的双精度浮点表示</span>覆盖<code>foo.c</code>中定义的<code>x</code>和<code>y</code>，此时只会触发警告。当怀疑出现此类情况时，可以用<code>GCC-fno-common</code>等命令参数调用链接器，用于指示链接器遇到重名的全局符号时触发错误。也可以用命令行选项<code>-Werror</code>，将所有的警告变为错误。</p><h4 id="链接静态库">7.4.2 链接静态库</h4><p>　　用所有相关的目标模块打包成的单个文件称为<strong>静态库</strong>，它可以作为链接器的输入。当链接器生成作为输出的可执行文件时，只会复制静态库中被应用程序引用的的目标模块。</p><p>　　若不使用静态库，可以通过<span style="background-color:#ff0">让编译器识别标准函数并生成对应的代码</span>或<span style="background-color:#ff0">将所有标准函数都放在同一可重定位目标文件</span>来使用标准函数。Pascal (仅提供了小部分标准函数) 使用的方法是前者，但C语言定义了大量的标准函数，若使用前者会显著增加编译器的复杂性，并且每次增删改标准函数时都需要更新编译器来适配。后者的优点是将编译器的实现和标准函数的实现分离，但需要每个可执行文件都包含1份标准函数集合的副本，并且增删改标准函数会要求库的开发者重新编译整个源文件，其改进方法是为每个标准函数生成独立的可重定位目标文件并把它们放在约定俗成的目录中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c /usr/lib/printf.o /usr/lib/scanf.o ...</span><br></pre></td></tr></table></figure><p>　　静态库正是为了解决以上问题，相关的函数可以编译为单独的目标模块并封装在单独的静态库文件中。然后，应用程序可以在命令行中指定对应的文件名称来使用这些库中定义的函数。例如，以下命令用于使用了C标准库和数学库中的函数的应用程序编译和链接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c /usr/lib/libm.a /usr/lib/libc.a</span><br></pre></td></tr></table></figure><p>　　实际上，C编译器驱动程序每次都会提供标准库文件<code>libc.a</code>给链接器，这里可以省略。</p><p>　　在Linux中，静态库存储为称为<strong>存档</strong>的特殊文件格式，其后缀名为<code>.a</code>。存档文件是一组串联的可重定位目标文件的集合，其首部指明其中每个目标文件的大小和位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* addarray.c */</span></span><br><span class="line"><span class="type">int</span> addcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addarray</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y, <span class="type">int</span> *z, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    addcnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        z[i] = x[i] + y[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* multarray.c */</span></span><br><span class="line"><span class="type">int</span> multcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multarray</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y, <span class="type">int</span> *z, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    multcnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        z[i] = x[i] * y[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　要创建函数<code>addarray()</code>和<code>multarray()</code>的静态库，可以使用AR工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c addarray.c multarray.c</span><br><span class="line">ar rcs libarray.a addarray.o multarray.o</span><br></pre></td></tr></table></figure><p>　　这里在头文件<code>array.h</code>中定义了这2个函数的函数原型。若需要使用这个库，只需要引入该头文件即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;array.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> z[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    addarray(x, y, z, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d]\n&quot;</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　为了创建可执行文件，需要编译和链接输入文件<code>main.o</code>和<code>libarray.a</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.c</span><br><span class="line">gcc -static -o prog main.o ./libarray.a</span><br></pre></td></tr></table></figure><p>　　第2条命令等价于以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -static -o prog main.o -L. -larray</span><br></pre></td></tr></table></figure><p>　　命令行选项<code>-static</code>指示链接器应生成完全链接的可执行文件，<code>-larray</code>是<code>libarray.a</code>的缩写，<code>-L.</code>指示链接器在当前目录查找<code>libarray.a</code>。</p><img src="/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/linking_with_static_libraries.svg" title="linking_with_static_libraries"><p>　　当链接器运行时，它发现<code>main.o</code>引用了<code>addarray.o</code>中定义的<code>addarray</code>符号，所以它会复制<code>addarray.o</code>到可执行文件。程序并没有引用<code>multarray</code>中定义的任何符号，所以链接器不会复制这个模块。链接器还会复制<code>libc.a</code>中的模块<code>printf.o</code>和运行时系统中的部分模块。</p><h4 id="链接器使用静态库解析引用">7.4.3 链接器使用静态库解析引用</h4><p>　　在符号解析阶段，链接器<span style="background-color:#ff0">从左到右按照它们在编译器驱动程序命令行上出现的顺序</span>来扫描可重定位目标文件和存档文件 (驱动程序自动将命令行中所有的<code>.c</code>文件转换为<code>.o</code>文件)。在扫描时，链接器会维护可重定位目标文件的集合<span class="math inline">\(E\)</span> (该集合中的文件会组合成可执行文件)、未解析的符号集合<span class="math inline">\(U\)</span> (即引用了但未定义的符号) 和之前输入文件中已定义的符号集合<span class="math inline">\(D\)</span>。初始时，<span class="math inline">\(E\)</span>、<span class="math inline">\(U\)</span>和<span class="math inline">\(D\)</span>均为空。</p><p>　　对于命令行上的每个输入文件<span class="math inline">\(f\)</span>，链接器会判断<span class="math inline">\(f\)</span>是目标文件还是存档文件。</p><p>　　● 若<span class="math inline">\(f\)</span>是目标文件，则将<span class="math inline">\(f\)</span>添加到<span class="math inline">\(E\)</span>，更新<span class="math inline">\(U\)</span>和<span class="math inline">\(D\)</span>来表示<span class="math inline">\(f\)</span>中的符号定义和引用。然后，链接器处理下一个输入文件。</p><p>　　● 若<span class="math inline">\(f\)</span>是存档文件，则链接器尝试匹配<span class="math inline">\(U\)</span>中未解析的符号和存档文件中的模块定义的符号。若存档文件中的某个模块<span class="math inline">\(m\)</span>定义了符号解析<span class="math inline">\(U\)</span>中引用的符号，则将<span class="math inline">\(m\)</span>添加到<span class="math inline">\(E\)</span>，修改<span class="math inline">\(U\)</span>和<span class="math inline">\(D\)</span>来表示<span class="math inline">\(m\)</span>中的符号定义和引用。这个过程会一直持续到<span class="math inline">\(U\)</span>和<span class="math inline">\(D\)</span>不再发生变化。此时，存档文件中任何不包含在<span class="math inline">\(E\)</span>的模块将会被丢弃。然后，链接器处理下一个输入文件。</p><p>　　当链接器完成对命令行中输入文件的扫描后，若<span class="math inline">\(U\)</span>非空，则链接器会输出错误并终止；否则，它会合并和重定位<span class="math inline">\(E\)</span>中的目标文件，生成作为输出的可执行文件。</p><p>　　文件出现在命令行的顺序至关重要，所以库一般放在命令行的结尾。若库的各个模块相互独立 (同一库的模块之间没有符号引用)，那么这些模块可以以任何顺序出现在命令行结尾处；相反，若同一库的模块之间存在符号引用，则必须对它们进行排序，保证<span style="background-color:#ff0">至少有1个符号的定义在该符号的引用之后</span>。</p><p>　　若<code>foo.c</code>调用了<code>libx.a</code>和<code>libz.a</code>中的函数，而这2个库又调用了<code>liby.a</code>中的符号，则命令行上<code>libx.a</code>和<code>libz.a</code>必须在<code>liby.a</code>之前。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc foo.c libx.a libz.a liby.a</span><br></pre></td></tr></table></figure><p>　　若<code>foo.c</code>调用了<code>libx.a</code>中的函数，<code>libx.a</code>调用了<code>liby.a</code>中的函数，<code>liby.a</code>调用了<code>libx.a</code>中的函数，则<code>libx.a</code>必须在命令行上重复出现。这种情况下，也可以将<code>libx.a</code>和<code>liby.a</code>合并。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc foo.c libx.a liby.a libx.a</span><br></pre></td></tr></table></figure><h3 id="重定位">7.5 重定位</h3><p>　　链接器完成符号解析后，会把代码的每个符号引用和对应的符号定义 (即它的1个输入目标模块的1个符号表条目) 关联起来。此时，链接器就知道器输入模块中的代码节和数据节的确切大小。然后，就可以进行重定位。重定位分为<span style="background-color:#ff0">重定位节和符号定义</span>以及<span style="background-color:#ff0">重定位节中的符号引用</span>。</p><p>　　● 在重定位节和符号定义时，链接器会将所有相同类型的节合并为同一类型的聚合节。例如，将所有输入模块的<code>.data</code>节合并为单个节作为输出 (可执行) 文件的<code>.data</code>节。然后，链接器将运行时内存地址赋值给聚合节以及输入模块定义的所有节和符号。完成后，程序中的所有指令和全局变量都有了唯一的运行时内存地址。</p><p>　　● 在重定位节的符号引用时，链接器会修改代码节和数据节中的所有符号引用，保证它们指向正确的运行时地址。完成这一步需要使用可重定位目标模块中的<span style="background-color:#ff0">重定位条目</span>。</p><h4 id="重定位条目">7.5.1 重定位条目</h4><p>　　当汇编器遇到最终位置未知的引用时，会生成<strong>重定位条目</strong>，用于告诉链接器在用目标文件合成可执行文件时如何修改该引用。代码的重定位条目存放在<code>.rel.text</code>节中，数据的重定位条目存放在<code>.rel.data</code>节中。</p><p>　　ELF定义了32种重定位类型，这里只介绍2种最基本的重定位类型，即R_X86_64_PC32和R_X86_64_32。前者用于重定位使用<span style="background-color:#ff0">32位PC相对地址</span>的引用，后者用于重定位使用<span style="background-color:#ff0">32位绝对地址</span>的引用。此外，两者都支持x86-64<strong>小型代码模型</strong>，该模型默认可执行文件中的代码和数据的总体大小小于2GB，所以在运行时可以用32位PC相对地址来访问。</p><p>　　GCC默认使用小型代码模型，更大的程序可以用<code>-mcmodel=medium</code> (中型代码模型) 和<code>-mcmodel=large</code> (大型代码模型) 命令行参数来编译。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf64_Rela</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> offset;</span><br><span class="line">    <span class="type">long</span> type : <span class="number">32</span>, symbol : <span class="number">32</span>;</span><br><span class="line">    <span class="type">long</span> addend;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　这是ELF重定位条目的格式。<code>offset</code>是待修改的引用的节偏移。<code>type</code>指示链接器如何修改新引用。<code>symbol</code>标识修改后的引用指向的符号。<code>addend</code>是常数，部分类型的重定位用它来偏置修改后的引用的值。</p><h4 id="重定位符号引用">7.5.2 重定位符号引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">foreach section s </span><br><span class="line">&#123;</span><br><span class="line">    foreach relocation entry r </span><br><span class="line">    &#123;</span><br><span class="line">        refptr = s + r.offset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 重定位PC相对 (寻址) 引用 */</span></span><br><span class="line">        <span class="keyword">if</span> (r.type == R_X86_64_PC32)</span><br><span class="line">        &#123;</span><br><span class="line">            refaddr = ADDR(s) + r.offset; <span class="comment">/* 引用的运行时地址 */</span></span><br><span class="line">            *refptr = (<span class="type">unsigned</span>)(ADDR(r.symbol) + r.addend - refaddr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 重定位绝对 (寻找) 引用 */</span></span><br><span class="line">        <span class="keyword">if</span> (r.type == R_X86_64_32)</span><br><span class="line">        &#123;</span><br><span class="line">            *refptr = (<span class="type">unsigned</span>)(ADDR(r.symbol) + r.addend);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这是链接器重定位算法的伪代码，其中节<code>s</code>是字节数组，重定位条目<code>r</code>是<code>Elf64_Rela</code>结构体。链接器为每个节和符号分配的运行时地址表示为<code>ADDR(s)</code>和<code>ADDR(r.symbol)</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:	48 83 ec 08         sub     $0x8, %rsp</span><br><span class="line">   4:	be 02 00 00 00      mov     $0x2, %esi</span><br><span class="line">   9:	bf 00 00 00 00      mov     $0x0, %edi</span><br><span class="line">                        a: R_X86_64_32 array</span><br><span class="line">   e:	e8 00 00 00 00      call    13 &lt;main+0x13&gt;</span><br><span class="line">                        f: R_X86_64_PC32 sum-0x4	</span><br><span class="line">  13:	48 83 c4 08         add     $0x8, %rsp</span><br><span class="line">  17:	c3                  retq</span><br></pre></td></tr></table></figure><p>　　这是用OBJDUMP根据7.1中的<code>main.c</code>生成的反汇编代码。主函数引用了2个全局符号，即<code>array</code>和<code>sum</code>。汇编器为它们都生成了对应的重定位体条目，显示在引用的后一行 (实际上重定位条目和指令存放在不同的节中，为了方便才将它们显示在一起)。这些重定位条目指示链接器对<code>sum</code>的引用使用32位PC相对地址来重定位，对<code>array</code>的引用使用32位绝对地址来重定位。</p><h5 id="重定位pc相对引用">7.5.2.1 重定位PC相对引用</h5><p>　　主函数调用了函数<code>sum()</code>，函数<code>sum()</code>是在模块<code>sum.o</code>中定义的。指令<code>call</code>从节偏移<code>0xe</code>处开始，包括1B的操作码<code>0xe8</code>，其后是对目标<code>sum</code>的32位PC相对引用的占位符。对应的重定位条目<code>r</code>由4个字段组成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.offset = <span class="number">0xf</span>;</span><br><span class="line">r.symbol = sum;</span><br><span class="line">r.type = R_X86_64_PC32;</span><br><span class="line">r.addend = <span class="number">-4</span>;</span><br></pre></td></tr></table></figure><p>　　这些字段指示链接器修改偏移量<code>0xf</code>处的32位PC相对引用，这样在运行时它会指向<code>sum</code>例程。此时，假设链接器已经确定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADDR(s) = ADDR(.text) = <span class="number">0x4004d0</span>;</span><br><span class="line">ADDR(r.symbol) = ADDR(sum) = <span class="number">0x4004e8</span>;</span><br></pre></td></tr></table></figure><p>　　使用链接器重定位算法，链接器先计算出引用的运行时地址 (第10行)，得到<code>refaddr = 0x4004df</code>。然后，更新该引用，使其在运行时指向<code>sum</code> (第11行)，即<code>*refptr = 0x5</code>。在得到的可执行文件中，指令<code>call</code>有如下的重定位形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4004de:	e8 05 00 00 00      callq   4004e8 &lt;sum&gt;</span><br></pre></td></tr></table></figure><p>　　在运行时，指令<code>call</code>将存放在地址<code>0x4004de</code>。当CPU执行指令<code>call</code>时，PC的值是<code>0x4004e3</code>，即<code>call</code>的下一条指令的地址。为了执行这条指令，CPU会先将PC压入栈，再将PC值加上<code>0x5</code>得到新PC值。</p><h5 id="重定位绝对引用">7.5.2.2 重定位绝对引用</h5><p>　　重定位绝对引用更简单。在链接器重定位算法的反汇编代码中的第4行，指令<code>mov</code>将<code>array</code>地址 (32位立即数) 复制到寄存器<code>%edi</code>中。指令<code>mov</code>从节偏移<code>0x9</code>处开始，包括1B的操作码<code>0xbf</code>，其后是<code>array</code>的32位绝对引用的占位符。对应的重定位条目<code>r</code>由4个字段组成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.offset = <span class="number">0xa</span>;</span><br><span class="line">r.symbol = <span class="built_in">array</span>;</span><br><span class="line">r.type = R_X86_64_32;</span><br><span class="line">r.addend = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>　　这些字段指示链接器要修改偏移量<code>0xa</code>的引用，这样在运行时它会指向<code>array</code>的首字节。此时，假设链接器已经确定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADDR(r.symbol) = ADDR(<span class="built_in">array</span>) = <span class="number">0x601018</span>;</span><br></pre></td></tr></table></figure><p>　　链接器使用重定位算法修改引用，得到<code>*refptr = 0x601018</code>。在得到的可执行文件中，该引用有如下的重定位形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4004d9:	bf 18 10 60 00      mov $0x601018, %edi</span><br></pre></td></tr></table></figure><p>　　综上所述，最终可执行文件中已重定位的<code>.text</code>节和<code>.data</code>节如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 已重定位的.text节</span><br><span class="line">00000000004004d0 &lt;main&gt;:</span><br><span class="line">  4004d0:	48 83 ec 08     sub     $0x8, %rsp</span><br><span class="line">  4004d4:	be 02 00 00 00  mov     $0x2, %esi</span><br><span class="line">  4004d9:	bf 18 10 60 00  mov     $0x601018, %edi</span><br><span class="line">  4004de:	e8 05 00 00 00  callq   4004e8 &lt;sum&gt;</span><br><span class="line">  4004e3:	48 83 c4 08     add     $0x8, %rsp</span><br><span class="line">  4004e7:	c3              retq</span><br><span class="line"></span><br><span class="line">00000000004004e8 &lt;sum&gt;:</span><br><span class="line">  4004e8:	b8 00 00 00 00  mov     $0x0, %eax</span><br><span class="line">  4004ed:	ba 00 00 00 00  mov     $0x0, %edx</span><br><span class="line">  4004f2:	eb 09           jmp     4004fd &lt;sum+0x15&gt;</span><br><span class="line">  4004f4:	48 63 ca        movslq  %edx, %rcx</span><br><span class="line">  4004f7:	03 04 8f        add     (%rdi,%rcx,4), %eax</span><br><span class="line">  4004fa:	83 c2 01        add     $0x1, %edx</span><br><span class="line">  4004fd:	39 f2           cmp     %esi, %edx</span><br><span class="line">  4004ff:	7c f3           jl      4004f4 &lt;sum+0xc&gt;</span><br><span class="line">  400501:	f3 c3           repz retq</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 已重定位的.data节</span><br><span class="line">00000000004004e8 &lt;array&gt;:</span><br><span class="line">  601080:	01 00 00 00 02 00 00</span><br></pre></td></tr></table></figure><p>　　在加载时，加载器会将这些节中的数据直接复制到内存中，不加修改地执行这些指令。</p><h3 id="可执行文件">7.6 可执行文件</h3><img src="/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/typical_elf_executable_file.svg" title="typical_elf_executable_file"><p>　　可执行文件的格式类似可重定位目标文件，因为可执行文件是完全链接的，所以没有<code>rel</code>节。ELF首部描述文件的总体格式，它还包括程序的<strong>入口点</strong>，即程序运行时执行的首条指令的地址。<code>.init</code>节定义了函数<code>_init()</code>，即程序的初始化函数。<code>.text</code>节、<code>.rodata</code>节和<code>.data</code>节与可重定位目标文件中的相似，区别是这些节已经被重定位到其最终运行时地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 只读代码段</span><br><span class="line">LOAD off	0x0000000000000000 vaddr 0x0000000000400000 paddr 0x0000000000400000 align 2**21</span><br><span class="line">	filesz 	0x000000000000069c memsz 0x000000000000069c flags r-x</span><br><span class="line"># 读写代码段</span><br><span class="line">LOAD off	0x0000000000000df8 vaddr 0x0000000000600df8 paddr 0x0000000000600df8 align 2**21</span><br><span class="line">	filesz 	0x0000000000000228 memsz 0x0000000000000230 flags rw-</span><br></pre></td></tr></table></figure><p>　　这是可执行文件<code>prog</code>的程序首部表，由OBJDUMP显示。其中<code>off</code>是目标文件的偏移，<code>vaddr</code>和<code>paddr</code>是内存地址，<code>align</code>是对齐要求 (这里<code>2**21</code>表示<span class="math inline">\(2^{21}\)</span>，即<code>0x200000</code>)，<code>filesz</code>是目标文件中的段大小，<code>memsz</code>是内存中的段大小，<code>flags</code>是运行时访问权限。根据这个程序首部表，有2个内存段将使用可执行文件的内容进行初始化。</p><p>　　第1个段 (第2~3行) 是代码段，有读和执行权限，从内存地址<code>0x400000</code>处开始，共占用<code>0x69c</code>字节，并用可执行文件的前<code>0x69c</code>字节初始化，其中包括ELF首部、程序首部表、<code>.init</code>节、<code>.text</code>节和<code>.rodata</code>节。</p><p>　　第2个段 (第5~6行) 是数据段，有读和写权限，从内存地址<code>0x600df8</code>处开始，共占用<code>0x230</code>字节，并用可执行文件中偏移量为<code>0xdf8</code>的<code>.data</code>节中的<code>0x228</code>字节初始化前<code>0x228</code>字节，剩下的8字节对应将在运行时初始化为0的<code>.bss</code>节数据。</p><p>　　对应任何段<code>s</code>，链接器必须选择起始地址<span class="math inline">\(vaddr\)</span>，使得 <span class="math display">\[ vaddr\bmod align=off\bmod aligh \]</span> 　　这里，<span class="math inline">\(off\)</span>是目标文件中段的首个节的偏移，<span class="math inline">\(align\)</span>是程序首部中指定的对齐要求。</p><h3 id="加载可执行文件">7.7 加载可执行文件</h3><p>　　每个Linux程序都可以调用函数<code>execve()</code>来调用加载器，加载器将可执行文件中的代码和数据从磁盘复制到内存中，然后跳转到程序的入口点来运行程序。这个将程序复制到内存并运行的过程称为<strong>加载</strong>。</p><img src="/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/linux_x86-64_run-time_memory_image.svg" title="linux_x86-64_run-time_memory_image"><p>　　每个Linux程序都有运行时内存映像。在Linux x86-64系统中，代码段总是从地址<code>0x400000</code>处开始，其后是数据段。运行时堆在数据段之后，通过调用库<code>malloc</code>可以向上增长。堆后的区域是为共享库保留。用户级代码地址的最大值是<span class="math inline">\(2^{48}-1\)</span>，向较小内存地址增长。栈后的区域是内核内存，从地址<span class="math inline">\(2^{48}\)</span>开始，为<strong>内核</strong>中的代码段和数据保留。</p><p>　　由于<code>.data</code>节有对齐要求，所以代码段和数据段之间有间隙 (这里省略了该间隙)。在为栈、共享库和堆分配运行地址时，链接器会使用地址空间布局随机化，每次程序运行时这些区域的地址会改变，但它们的相对位置不变。</p><p>　　当加载器运行时，会创建运行时内存映像。在程序首部表的引导下，加载器将可执行文件的片复制到代码段和数据段。然后，加载器跳转到程序的入口点，即函数<code>_start()</code>的地址，该函数定义在系统目标文件<code>ctrl.o</code>中，对所有C语言程序都相同。函数<code>_start()</code>调用<code>libc.so</code>中定义的<span style="background-color:#ff0">系统启动函数</span><code>__libc_start_main()</code>，它会初始化执行环境，调用用户级函数<code>main()</code>，处理函数<code>main()</code>的返回值并在需要的时候把控制权转移给内核。</p><h3 id="动态链接共享库">7.8 动态链接共享库</h3><p>　　<strong>动态链接</strong>就是运行/加载时将目标模块加载到内存并和其中的程序链接，该目标模块称为<strong>共享库</strong>或<strong>共享目标</strong>。动态链接由称为<strong>动态链接器</strong>的程序执行，动态链接器本身就是共享库。共享库在Linux和Windows中的后缀分别是<code>.so</code>和<code>.dll</code>。</p><p>　　共享库以2种不同的形式共享。首先，在任何给定的文件系统中，1个库<span style="background-color:#ff0">只有1个</span><code>.so</code>文件，所以引用该库的可执行文件共享这个<code>.so</code>文件，而非像静态库的内容那样被复制并嵌入到它们的可执行文件中。其次，在内存中，共享库的<code>.text</code>节的同一副本可以被不同的正在运行的进程共享。</p><img src="/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/dynamic_linking_with_shared_libraries.svg" title="dynamic_linking_with_shared_libraries"><p>　　这是7.4.2中的示例的动态链接版本。为了生成示例中的数组例程的共享库<code>libarray.so</code>，需要调用编译器驱动程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fpic -o libarray.so addarray.c multarray.c</span><br></pre></td></tr></table></figure><p>　　命令行选项<code>-fpic</code>指示编译器生成位置无关代码，<code>-shared</code>指示链接器生成共享库文件。生成共享库后，需要链接到程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o prog main.c ./libarray.so</span><br></pre></td></tr></table></figure><p>　　这样就生成了可执行文件<code>prog</code>，该文件的形式使得它能在运行时和<code>libarray.so</code>链接。基本思想是在创建可执行文件时，静态执行部分链接，然后在程序加载时，动态完成剩余链接。静态链接时仅复制了一些重定位和符号表信息，使得它们在运行时可以解析对<code>libarray.so</code>中代码和数据的引用。</p><p>　　相比静态链接，动态链接生成的<code>prog</code>包含<code>.interp</code>节，该节包含动态链接器的路径名。加载器会直接加载和运行对应的动态链接器而非将控制权转移给程序，然后动态链接器执行以下的重定位来完成链接任务：</p><p>　　● 重定位<code>libc.so</code>的文本和数据到某个内存段。</p><p>　　● 重定位<code>libarray.so</code>的文本和数据到另一个内存段。</p><p>　　● 重定位<code>prog</code>中所有<code>libc.so</code>和<code>libarray.so</code>定义的符号的引用。</p><p>　　最后，动态链接器将控制权转移给程序，此时，共享库的位置就已固定并在程序执行时不会改变。</p><h3 id="从应用程序中加载和链接共享库">7.9 从应用程序中加载和链接共享库</h3><p>　　实际中，应用程序可能在运行时要求链接器加载和链接某个共享库而非在编译时。</p><p>　　动态链接的常见应用场景包括<span style="background-color:#ff0">分发软件</span>和<span style="background-color:#ff0">构建高性能Web服务器</span>。</p><p>　　● Windows应用开发者经常用共享库来分发软件更新，即生成共享库的新版本，用户下载后用新共享库替代旧版本。下一次运行应用程序时，应用将自动加载新共享库。</p><p>　　● 很多Web服务器会生成动态内容，例如，个性化的Web页面、账户余额和广告标语。早期的Web服务器通过使用<code>fork()</code>和<code>execve()</code>创建子进程，在子进程的上下文中运行CGI程序来生成动态内容。通过使用动态链接可以更有效和完善地来生成动态内容。基本思想是将每个动态内容打包在共享库中，当Web请求到达时，服务器动态地加载和链接对应的函数并调用它们。函数会一直缓存在服务器的地址空间中，所以只需简单的函数调用就可以处理随后的请求。这样，可以在不停止服务器的情况下更新和增加函数。</p><p>　　Linux为动态链接提供了接口，允许应用程序在运行时加载和链接共享库。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flag)</span>; <span class="comment">/* 若成功则返回指向句柄的指针，若出错则返回空指针 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlsym</span><span class="params">(<span class="type">void</span> *handle, <span class="type">char</span> *symbol)</span>; <span class="comment">/* 若成功则返回指向符号的指针，若出错则返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dlclose</span><span class="params">(<span class="type">void</span> *handle)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">dlerror</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 若最近对函数dlopen()、dlsym()或dlerror()的调用失败则返回错误信息，若调用成功则返回NULL */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>dlopen()</code>会加载和链接共享库<code>filename</code>。<code>filename</code>中的外部符号通过之前使用<code>RTLD_GLOBAL</code>选项打开的库来解析。若当前可执行文件是带<code>-rdynamic</code>选项编译，则其全局符号可用于符号解析。参数<code>flag</code>只能为<code>RTLD_NOW</code> (指示链接器立即解析外部符号引用) 或<code>RTLD_LAZY</code> (指示链接器将符号解析推迟到执行来自库中的代码)，两者都可以和<code>RTLD_GLOBAL</code>取或。</p><p>　　函数<code>dlsym()</code>的参数<code>handle</code>分别指向之前已打开的共享库的句柄，<code>symbol</code>是符号名，若该符号存在，则返回符号地址；否则，返回<code>NULL</code>。</p><p>　　函数<code>dlclose()</code>用于卸载共享库。</p><p>　　函数<code>dlerror()</code>用于返回最近对以上3个函数的调用的错误信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* dll.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> z[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *handle;</span><br><span class="line">    <span class="type">void</span> (*addarrray)(<span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 动态加载包含addarray()的共享库 */</span></span><br><span class="line">    handle = dlopen(<span class="string">&quot;./libarray.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (!handle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取指向刚加载的函数addarray()的指针 */</span></span><br><span class="line">    addarrray = dlsym(handle, <span class="string">&quot;addarray&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, error);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 现在就可以调用函数addarray() */</span></span><br><span class="line">    addarrray(x, y, z, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d\n]&quot;</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 卸载共享库 */</span></span><br><span class="line">    <span class="keyword">if</span> (dlclose(handle) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会用上述接口动态链接共享库<code>libarray.so</code>并调用其例程<code>addarray</code>。要编译该程序，需要如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -dynamic -o prog dll.c -ldl</span><br></pre></td></tr></table></figure><p>　　<strong>Java本地接口</strong>允许Java程序调用C/C++函数。JNI的思想就是将本地C函数 (如<code>foo()</code>) 编译到共享库 (如<code>foo.so</code>) 中。当运行的Java程序调用函数<code>foo()</code>时，Java解释器通过<code>dlopen()</code>等接口动态链接和加载<code>foo.so</code>，然后调用<code>foo()</code>。</p><h3 id="位置无关代码">7.10 位置无关代码</h3><p>　　若多个进程需要共享同一共享库，可以给每个共享库分配事先准备的专用的地址空间并要求加载器总是加载到该区域。显然，这种方法的地址使用率不高，首先，即使进程不是该共享库也会分配空间。其次，分配的空间难以管理，必须保证没有片会重叠。每当修改共享库时，必须确认分配的片的大小合适。若不合适，需要重新找新片。若创建了新共享库，必须为其分配空间。随着系统中共享库及其版本的增加，很可能导致出现很多小到无法使用的地址块。此外，每个系统的共享库的空间分配不同，这会导致更多的问题。</p><p>　　以上问题可以用<strong>位置无关代码</strong>避免，即可以加载而无需重定位的代码。对GCC使用<code>-fpic</code>选项可以指示GNU编译系统生成PIC代码。共享库的编译<span style="background-color:#ff0">必须</span>使用该选项。</p><p>　　在x86-64系统中，同一目标模块中的符号的引用无需特殊处理就能成为PIC。生成目标文件时，这种引用可以用PC相对寻址来编译，用静态链接器来重定位。</p><p>　　无论在内存中的何处加载目标模块，数据段与代码段的距离总是保存不变的。因此，代码段中的任何指令和数据段中的任何变量之间的<span style="background-color:#ff0">距离</span>都是运行时常量。</p><h4 id="pic数据引用">7.10.1 PIC数据引用</h4><p>　　编译器在生成全局变量PIC引用时，会在数据段起始处创建<strong>全局偏移表</strong> (其条目是8B)，还会为每个GOT条目生成重定位记录。每个引用全局目标 (过程或全局变量) 的目标模块都有GOT，目标模块引用的每个全局目标都有对应的GOT条目。在加载时，动态链接器会重定位GOT中的每个条目，使其包含目标的绝对地址。</p><img src="/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/using_the_got_to_reference_a_global_variable.svg" title="using_the_got_to_reference_a_global_variable"><p>　　这是共享库<code>libarray.so</code>的GOT。例程<code>addarray</code>通过<code>GOT[3]</code>间接加载全局变量<code>addcnt</code>的地址并在内存中将<code>addcnt</code>加1。若<code>addcnt</code>是非外部符号，编译器可以利用代码段和数据段之间的固定距离直接生成<code>addcnt</code>的PC相对引用，并增加1个重定位用于链接器在生成共享库时解析；若<code>addcnt</code>是外部符号，则需要通过GOT间接访问。这里编译器采用最通用的方法，即对所有引用都使用GOT。</p><h4 id="pic函数调用">7.10.2 PIC函数调用</h4><p>　　若程序需要调用共享库定义的函数，但编译器无法预测该函数的运行时地址 (共享库在运行时可以加载到任何位置)，常规的方法是为该引用生成重定位记录，动态链接器在程序加载时再解析它。这种方法是并不是PIC，因为它需要链接器修改调用模块的代码段，GNU使用了<strong>延迟绑定</strong>来将过程地址的绑定推迟到首次调用该过程。</p><p>　　常规程序只会使用<code>libc.so</code>等包括成大量函数的共享库中的很少一部分函数，把函数地址的解析推迟到实际被调用的地方，能<span style="background-color:#ff0">避免动态链接器在加载时进行大量无意义的重定位</span>。这样只有首次调用过程的运行时开销很大，之后每次调用都只需单条指令和单个间接内存引用。</p><p>　　延迟绑定通过GOT和<strong>过程链接表</strong>来实现。若目标模块调用共享库中定义的函数，则它会有自己的GOT和PLT。GOT是数据段的一部分，PLT是代码段的一部分。</p><p>　　PTL是由若干个16B的条目组成的数组。<code>PTL[0]</code>是特殊条目，它会跳转到动态链接器中。每个可执行文件调用的库都有自己的PTL条目。每个条目负责调用具体函数。<code>PTL[1]</code>会调用7.7中的<span style="background-color:#ff0">系统启动函数</span>。<code>PLT[2]</code>及以后的条目会调用用户级代码调用的函数。</p><p>　　GOT是由若干个8B的条目组成的数组。和PTL共同使用时，<code>GOT[0]</code>和<code>GOT[1]</code>包含动态链接器在解析函数地址时会使用的信息。<code>GOT[2]</code>是动态链接器在模块<code>ld-linux.so</code>中的入口点。其余的每个条目都对应1个被调函数，其地址在运行时被解析。此外，每个GOT条目都有对应的POT条目。初始化时，每个GOT条目都指向对应PTL条目的的<span style="background-color:#ff0">第2条</span>指令。</p><img src="/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/using_the_got_and_plt_to_call_external_functions.svg" title="using_the_got_and_plt_to_call_external_functions"><p>　　图a是在首次调用<code>addarray()</code>时，GOT和PLT协同工作来延迟解析其运行地址的流程。</p><p>　　1) 程序会先调用<code>addarray()</code>的PLT条目而非直接调用该函数。</p><p>　　2) 首条PTL指令通过<code>GOT[4]</code>间接跳转。这里<code>GOT[4]</code>指向<code>PTL[2]</code>的第2条指令，因此，这一步只是为了把控制权转移给<code>PTL[2]</code>的第2条指令。</p><p>　　3) 把<code>addarray()</code>的ID<code>0x1</code>压入栈后，<code>PTL[2]</code>跳转到<code>PTL[0]</code>。</p><p>　　4) <code>PLT[0]</code>通过<code>GOT[1]</code>间接地把动态链接器的1个参数压入栈，再通过<code>GOT[2]</code>间接地跳转到动态链接器。动态链接器通过2个栈条目来确定的<code>addarray()</code>的运行时地址，用该地址覆写<code>GOT[4]</code>，再把控制权转移给<code>addarray()</code>。</p><p>　　图b是后续调用<code>addarray()</code>的控制流。</p><p>　　1) 和前面一样，控制权转移到<code>PTL[2]</code>。</p><p>　　2) 通过<code>GOT[4]</code>的间接跳转将控制权直接转移给<code>addarray()</code>。</p><h3 id="库打桩">7.11 库打桩</h3><p>　　Linux链接器的<strong>库打桩</strong>允许追踪指定的共享库函数的调用次数，验证和追踪其输入和输出值，甚至可以将其替换为其他的实现。基本思想是为目标函数创建<strong>包装函数</strong>，其原型与目标函数的原型相同。包装函数通常会执行自己的逻辑，然后调用目标函数，最后将目标函数的返回值传递给调用者。使用某些特殊的库打桩机制，可以达到欺骗操作系统调用包装函数而非目标函数。打桩可以发生在编译时、链接时和运行时。</p><h4 id="编译时打桩">7.11.1 编译时打桩</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* int.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 本地的malloc.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> malloc(size) mymalloc(size);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> free(ptr) myfree(ptr);</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mymalloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">myfree</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mymalloc.c中关于编译时打桩的函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILETIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc的包装函数 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mymalloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d)=%p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free的包装函数 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">myfree</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    prtinf(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>　　<code>mymalloc.h</code>中的包装函数会调用目标函数，打印追踪记录，最后返回。本地的<code>malloc.h</code>指示预处理器将目标函数的调用替换为对应的包装函数的调用。编译和链接该程序的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -DCOMPILETIME -c mymalloc.c</span><br><span class="line">gcc -I. -o intc int.c mymalloc.c</span><br></pre></td></tr></table></figure><p>　　命令行选项<code>-I.</code>表示执行打桩，即指示预处理器在搜索系统目录前，先在当前目录中查找<code>malloc.h</code>。这里<code>mymalloc.c</code>中的包装函数是使用标准头文件<code>malloc.h</code>编译。</p><h4 id="链接时打桩">7.11.2 链接时打桩</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mymalloc.c中关于链接时打桩的函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LINKTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *__real_malloc(<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">void</span> __real_free(<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc的包装函数 */</span></span><br><span class="line"><span class="type">void</span> *__wrap_malloc(<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr = __real_malloc(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d) = %p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free的包装函数 */</span></span><br><span class="line"><span class="type">void</span> __wrap_free(<span class="type">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    __real_free(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>　　Linux静态链接器支持用<code>--wrap f</code>参数进行链接时打桩。该参数指示链接器把符号<code>f</code>的引用解析为<code>__wrap_f</code>，把符号<code>__real_f</code>的引用解析为<code>f</code>。以上源文件通过以下命令编译为可重定位目标文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -DLINKTIME -c mymalloc.c</span><br><span class="line">gcc -c int.c</span><br></pre></td></tr></table></figure><p>　　然后，把目标文件链接为可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -W1,--warp,malloc -W1,--warp,free -o intl int.o mymalloc.o</span><br></pre></td></tr></table></figure><p>　　命令行选项<code>-W1,option</code>表示把<code>option</code>传递给链接器，<code>option</code>中的逗号会替换为空格，所以<code>-W1,--wrap,malloc</code>会传递<code>--wrap malloc</code>给链接器。</p><h4 id="运行时打桩">7.11.3 运行时打桩</h4><p>　　编译时打桩需要能够访问程序的源文件，链接时打桩需要能够访问程序的可重定位目标文件。基于动态链接器的<code>LD_PRELOAD</code>环境变量的运行时打桩只需要能够访问可执行文件。</p><p>　　若<code>LD_PRELOAD</code>环境变量设置为共享库路径名的列表 (以空格或分号分隔)，当加载和执行程序并解析未定义的引用时，动态链接器会先搜索<code>LD_PERLOAD</code>中设置的库，再搜索其他库。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mymalloc.c中关于运行时打桩的函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RUNTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc的包装函数 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *(*mallocp)(<span class="type">size_t</span> size);</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    mallocp = dlsym(RTLD_NEXT, <span class="string">&quot;malloc&quot;</span>); <span class="comment">/* 获取libc中malloc的地址 */</span></span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *ptr = mallocp(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d) = %p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free的包装函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (*freep)(<span class="type">void</span> *) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    freep = dlsym(RTLD_NEXT, <span class="string">&quot;free&quot;</span>); <span class="comment">/* 获取libc中free的地址 */</span></span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    freep(ptr); <span class="comment">/* 调用libc中的free */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>　　每个包装函数中，调用<code>dlsym()</code>会返回指向目标<code>libc</code>函数的指针，然后包装函数调用目标函数，打印追踪记录，最后返回。生成包含这些包装函数的共享库的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl</span><br></pre></td></tr></table></figure><p>　　编译主程序的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o intr int.c</span><br></pre></td></tr></table></figure><p>　　在bash shell运行该程序的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_PERLOAD=&quot;./mymalloc.so&quot; ./intr</span><br></pre></td></tr></table></figure><p>　　在<code>csh</code>或<code>tcsh</code>中运行该程序的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(setenv LD_PRELOAD &quot;./mymalloc.so&quot;; ./intr; unsetenv LD_PRELOAD)</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/" rel="prev" title="《深入理解计算机系统 第3版》第6章 存储器层次结构"><i class="fa fa-angle-left"></i> 《深入理解计算机系统 第3版》第6章 存储器层次结构</a></div><div class="post-nav-item"><a href="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/" rel="next" title="《深入理解计算机系统 第3版》第8章 异常控制流">《深入理解计算机系统 第3版》第8章 异常控制流 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script></body></html>