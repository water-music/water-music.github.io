<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><link rel="canonical" href="http://example.com/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/","path":"2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/","title":"《深入理解计算机系统 第3版》第12章 并发编程"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《深入理解计算机系统 第3版》第12章 并发编程 |</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-text">12.1 基于进程的并发编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Eio%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-text">12.2 基于I&#x2F;O多路复用的并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Eio%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">12.2.1 基于I&#x2F;O多路复用的并发事件驱动服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="nav-text">12.2.2 I&#x2F;O多路复用的优点和缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-text">12.3 基于线程的并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#posix%E7%BA%BF%E7%A8%8B"><span class="nav-text">12.3.1 Posix线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-text">12.3.2 创建线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E7%A8%8B"><span class="nav-text">12.3.3 初始化线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E5%92%8C%E5%9B%9E%E6%94%B6%E7%BA%BF%E7%A8%8B"><span class="nav-text">12.3.4 终止和回收线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%A6%BB%E7%BA%BF%E7%A8%8B"><span class="nav-text">12.3.5 分离线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91echo%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">12.3.6 基于线程的并发echo服务器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%8C%96%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F"><span class="nav-text">12.4 线程化程序的共享变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">12.5 同步线程与信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E5%BA%A6%E5%9B%BE"><span class="nav-text">12.5.1 进度图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">12.5.2 信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9D%A5%E4%BA%92%E6%96%A5"><span class="nav-text">12.5.3 使用信号量来互斥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9D%A5%E8%B0%83%E5%BA%A6%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="nav-text">12.5.4 使用信号量来调度共享资源</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-text">12.5.4.1 生产者-消费者问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-text">12.5.4.2 读者-写者问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%A2%84%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">12.5.5 基于预线程的并发服务器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%B9%B6%E8%A1%8C"><span class="nav-text">12.6 使用线程来实现并行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%B9%B6%E8%A1%8C%E9%97%AE%E9%A2%98"><span class="nav-text">12.7 其他并行问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">12.7.1 线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7"><span class="nav-text">12.7.2 可重入性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AB%9E%E4%BA%89"><span class="nav-text">12.7.3 竞争</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-text">12.7.4 死锁</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《深入理解计算机系统 第3版》第12章 并发编程 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《深入理解计算机系统 第3版》第12章 并发编程</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-11-03 00:00:00" itemprop="dateCreated datePublished" datetime="2023-11-03T00:00:00+08:00">2023-11-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-08 00:00:00" itemprop="dateModified" datetime="2024-01-08T00:00:00+08:00">2024-01-08</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/computer-system/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>30k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　若多个逻辑控制流在时间上有重叠，则它们是并发的，这种机制称为<strong>并发</strong>，并且存在于计算机系统的各个层级中，例如，硬件异常处理程序、进程和Linux信号处理程序。</p><p>　　<strong>线程</strong>是运行在进程上下文中的逻辑流，由内核自动调度。每个线程都有自己的<strong>线程上下文</strong>，包括唯一的整数<strong>线程ID</strong>、栈、栈指针、PC、通用目的寄存器和条件码。同一进程中所有线程共享虚拟地址空间，包括只读代码区域、读写区域、堆、共享库和打开的文件。</p><p>　　栈位于虚拟地址空间中的栈区域，<span style="background-color:#ff0">通常</span>由对应的线程访问。但是，栈并没有严格的访问权限控制，若某个线程以某种方式得到指向其他线程的栈的指针，则它可以读写该栈的任意部分。</p><p>　　使用应用级并发的程序称为<strong>并发程序</strong>。现代操作系统提供了3种构建并发程序的基本方法，即<span style="background-color:#ff0">进程</span>、<span style="background-color:#ff0">I/O多路复用</span>和<span style="background-color:#ff0">线程</span>。</p><p>　　● 对于基于进程的并发编程，每个逻辑流1个进程。内核自动调度每个进程，每个进程都有私有的地址空间，这使得逻辑流共享数据比较困难。</p><p>　　● 对于基于I/O多路复用的并发编程，需要手动创建逻辑流并通过I/O多路复用来显式调度这些逻辑流。因为只有1个进程，所以逻辑流共享地址空间。</p><p>　　● 对于基于线程的并发编程，它结合前2种方法的特点。</p><p>　　函数<code>waitpid()</code>和信号量是基本的IPC机制，它们允许同一主机上的进程相互发送短信息。套接字接口是IPC的重要形式之一，它允许不同主机上的进程通信。术语Unix IPC是所有允许同一主机上的进程通信的技术的统称，包括管道、FIFO、系统V共享内存和系统V信号量。</p><p>　　实现同步的方法不止有信号量。Java线程可以通过<span style="background-color:#ff0">监视器</span>来实现同步，监视器提供信号量的互斥访问和调度功能的高级抽象。实际上，监视器可以通过信号量来实现。</p><p>　　Posix线程是C程序控制线程的标准接口 (1995年新增)，可用于所有Linux系统上。Posix线程定义了一组对互斥锁和条件变量的同步操作，前者用于互斥，后者用于调度共享资源的访问。</p><p>　　程序可以分为<span style="background-color:#ff0">顺序程序</span>和<span style="background-color:#ff0">并发程序</span>。顺序程序实现为单个逻辑流。并发程序实现为多个逻辑流。<span style="background-color:#ff0">并行程序</span>是运行在多核CPU的并发程序。</p><span id="more"></span><h3 id="基于进程的并发编程">12.1 基于进程的并发编程</h3><p>　　最简单的构建并发程序的方法是使用进程，调用类似<code>fork</code>、<code>exec</code>和<code>waitpid()</code>的函数。</p><p>　　这里以构建并发服务器为例，构建并发服务器最自然的方法是服务器接收客户端的连接请求，然后创建子进程来服务客户端。</p><img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/simple_example_of_concurrent_programming_with_processes.svg" title="simple_example_of_concurrent_programming_with_processes"><p>　　假设有2个客户端和1个服务器 (监听描述符为描述符3)。</p><p>　　如图a所示，服务器接收客户端1的连接请求并返回新的已连接描述符 (描述符4)。</p><p>　　如图b所示，客户端创建子进程1，子进程1有服务器的描述符表的完整副本。子进程1<span style="background-color:#ff0">关闭自己的描述符3</span>，服务器<span style="background-color:#ff0">关闭自己的描述符4</span>。然后，子进程1服务客户端1。</p><p>　　如图c所示，服务器接收新客户端2的连接请求并返回新的已连接描述符 (描述符5)。</p><p>　　如图d所示，服务器创建子进程2，子进程2通过描述符5来服务客户端2。</p><p>　　此时，服务器等待下一个连接请求，2个子进程并发地服务对应的客户端。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 基于进程的并发echo服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Close(listenfd); <span class="comment">/* 子进程关闭它的的监听描述符 */</span></span><br><span class="line">            echo(connfd);    <span class="comment">/* 子进程服务客户端 */</span></span><br><span class="line">            Close(connfd);   <span class="comment">/* 子进程关闭和客户端的连接 */</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);         <span class="comment">/* 子进程退出 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        Close(connfd); <span class="comment">/* 服务器关闭它的已连接标识符 (重要) */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　对于基于进程的并发echo服务器，由于服务器会运行较长时间，必须要加入信号处理程序来回收子进程 (第3~8行)。因为信号SGICHLD在信号SGICHLD处理程序运行时会被阻塞并且信号不会排队，所以信号SIGCHLD处理程序必须准备回收多个僵尸子进程。由于套接字的文件表条目中的引用次数，只有当父子进程都关闭各自的<code>connfd</code>时，与客户端的连接才会关闭。</p><p>　　进程拥有用于父子进程之间共享状态信息的清晰模型，即文件表是共享的，而用户地址空间不是共享的。不共享的地址空间既是优点也是缺点，优点是进程不可能意外地覆写其他进程的虚拟内存，缺点是不共享的地址空间不易于共享状态信息。若需要共享状态信息，必须使用显式IPC机制。基于进程的并发编程的另一个缺点是不低的进程控制和IPC成本，所以更可能会导致效率低下。</p><h3 id="基于io多路复用的并发编程">12.2 基于I/O多路复用的并发编程</h3><p>　　若需要编写能够响应通过键盘输入的命令行的echo服务器，可以使用I/O多路复用。基本思想是调用函数<code>select()</code>来请求内核挂起进程，并在I/O事件发生后将控制权转移给应用程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> n, fd_set *fdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span>; <span class="comment">/* 若成功则返回准备好读的描述符数，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于控制描述符集的宏 */</span></span><br><span class="line">FD_ZERO(fd_set *fdset);          <span class="comment">/* 清除fdset的所有位 */</span></span><br><span class="line">FD_CLR(<span class="type">int</span> fd, fd_set *fdset);   <span class="comment">/* 清除fdset的fd位 */</span></span><br><span class="line">FD_SET(<span class="type">int</span> fd, fd_set *fdset);   <span class="comment">/* 启用fdset的fd位 */</span></span><br><span class="line">FD_ISSET(<span class="type">int</span> fd, fd_set *fdset); <span class="comment">/* fdset的fd位是否启用 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>select()</code>控制类型为<code>fd_set</code>的集合，称为<strong>描述符集</strong>。从逻辑角度，可以将描述符集视为长度为<span class="math inline">\(n\)</span>的位向量<span class="math inline">\([b_{n-1},...,b_{1},b_{0}]\)</span>，<span class="math inline">\(b_k\)</span>对应描述符<span class="math inline">\(k\)</span>。当且仅当<span class="math inline">\(b_k=1\)</span>时，描述符<span class="math inline">\(k\)</span>才是描述符集的成员。能对描述符集的进行操作只有3个，即分配它们、将该类型的变量赋值给其他变量以及通过宏<code>FD_ZERO</code>、<code>FD_CLR</code>、<code>FD_SET</code>和<code>FD_ISSET</code>来修改和查看它们。</p><p>　　函数<code>select()</code>有多种应用场景。这里仅介绍其中之一，即等待一组描述符准备好读。因此，这里仅需要使用函数<code>select()</code>的2个参数，即称为<strong>读集合</strong>的描述符集<code>fdset</code>和读集合的基数 (所有描述符集的最大基数)。函数<code>select()</code>会阻塞，直到读集合中至少有1个描述符准备好读。当前仅当从描述符<code>k</code>读1B的请求不会阻塞时，描述符<code>k</code>才准备好读。</p><p>　　函数<code>select()</code>有1个副作用，它会让参数<code>fdset</code>指向<code>fd_set</code>来指示读集合的子集，该子集称为<strong>准备集合</strong>，由准备好读的描述符组成。该函数返回的值表示准备集合的基数。因此，每次调用函数<code>select()</code>时必须更新读集合。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从标准输入读命令</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">command</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">if</span> (!Fgets(buf, MAXLINE, <span class="built_in">stdin</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* EOF */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf); <span class="comment">/* 处理命令 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 基于I/O多路复用的echo服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    fd_set read_set, ready_set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;read_set);              <span class="comment">/* 清空读集合 */</span></span><br><span class="line">    FD_SET(STDIN_FILENO, &amp;read_set); <span class="comment">/* 将标准输入加入读集合 */</span></span><br><span class="line">    FD_SET(listenfd, &amp;read_set);     <span class="comment">/* 将监听描述符加入读集合 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ready_set = read_set;</span><br><span class="line">        Select(listenfd + <span class="number">1</span>, &amp;ready_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;ready_set))</span><br><span class="line">        &#123;</span><br><span class="line">            command(); <span class="comment">/* 从标准输入读命令行 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;ready_set))</span><br><span class="line">        &#123;</span><br><span class="line">            clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">            connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">            echo(connfd); <span class="comment">/* echo客户端输入，直到EOF */</span></span><br><span class="line">            Close(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例通过函数<code>select()</code>来实现能够响应通过键盘输入的命令行的迭代echo服务器。</p><p>　　首先，通过函数<code>open_listenfd()</code>来打开监听描述符 (第34行)，调用宏<code>FD_ZERO</code>来创建空的读集合 (第36行)。然后，将描述符0 (标准输入) 和3 (监听描述符) 加入读集合。最后，开始常规的服务器循环，这里调用函数<code>select()</code>来阻塞自己，直到标准输入和监听描述符之一准备好读 (第43行)。函数<code>select()</code>返回后，调用宏<code>FD_ISSET</code>来判断描述符是否准备好读。若标准输入准备好读 (第44行)，则调用函数<code>command()</code>；若监听描述符准备好读 (第48行)，则调用函数<code>accept()</code>和<code>echo()</code>。</p><p>　　这个示例有1个问题，即一旦它连接客户端，会不断回显输入行，直到客户端关闭其连接端点。因此，若在键盘输入命令到标准输入，则需要在服务器完成服务客户端后才会得到响应，这可以通过每次服务器循环回显最多1行文本来解决。</p><h4 id="基于io多路复用的并发事件驱动服务器">12.2.1 基于I/O多路复用的并发事件驱动服务器</h4><p>　　I/O多路复用可用于实现并发事件驱动程序，其逻辑流会随着特定事件的完成而进行。基本思想是将逻辑流模型为<strong>状态机</strong>。状态机是状态、输入事件和转换的集合，每个事件将1个输入状态和1个输入事件映射到1个输出状态。<strong>自循环</strong>是输入状态和输出状态相同的转换。状态机通常描述为有向图，节点表示状态，有向弧表示转换，弧标签表示输入事件。状态机在开始执行时有初始状态。每个输入事件会触发从当前状态到下一状态的转换。</p><img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/state_machine_for_a_logical_flow_in_a_concurrent_event_driven_echo_server.svg" title="state_machine_for_a_logical_flow_in_a_concurrent_event_driven_echo_server"><p>　　对于每个新的客户端<span class="math inline">\(k\)</span>，基于I/O多路复用的并发服务器会创建1个新的状态机<span class="math inline">\(s_k\)</span>并将其关联到描述符<span class="math inline">\(d_k\)</span>。如图所示，每个状态机<span class="math inline">\(s_k\)</span>都有1个状态 (等待描述符<span class="math inline">\(d_k\)</span>准备好读)、输入事件 (描述符<span class="math inline">\(d_k\)</span>准备好读) 和转换 (从描述符<span class="math inline">\(d_k\)</span>中读1行文本)。</p><p>　　服务器通过I/O多路复用 (由函数<code>select()</code>提供) 来检查输入事件的发生。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 已连接描述符 (客户端) 池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> maxfd;                   <span class="comment">/* 读集合中的最大描述符 */</span></span><br><span class="line">    fd_set read_set;             <span class="comment">/* 已启用的描述符集 */</span></span><br><span class="line">    fd_set ready_set;            <span class="comment">/* 准备好读的描述符集*/</span></span><br><span class="line">    <span class="type">int</span> nready;                  <span class="comment">/* 函数select的准备好读的描述符数 */</span></span><br><span class="line">    <span class="type">int</span> maxi;                    <span class="comment">/* 客户端池的最大索引 */</span></span><br><span class="line">    <span class="type">int</span> clientfd[FD_SETSIZE];    <span class="comment">/* 已启用的描述符集 */</span></span><br><span class="line">    <span class="type">rio_t</span> clientrio[FD_SETSIZE]; <span class="comment">/* 已启用的读缓冲区集合 */</span></span><br><span class="line">&#125; pool;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> byte_cnt = <span class="number">0</span>; <span class="comment">/* 服务器接收的字节总数 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 基于I/O多路复用的并发事件驱动echo服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">static</span> pool pool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    init_pool(listenfd, &amp;pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 等待监听/已连接描述符准备好读 */</span></span><br><span class="line">        pool.ready_set = pool.read_set;</span><br><span class="line">        pool.nready = Select(pool.maxfd + <span class="number">1</span>, &amp;pool.ready_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 若监听描述符准备好读，则将新的客户端加入池中 */</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;pool.ready_set))</span><br><span class="line">        &#123;</span><br><span class="line">            clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">            connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">            add_client(connfd, &amp;pool);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从每个已连接描述符中回显1行文本行 */</span></span><br><span class="line">        check_clients(&amp;pool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　对于并发事件驱动echo服务器，客户端集合通过结构体<code>pool</code>来维护。在调用函数<code>init_pool()</code>初始化客户端池后 (第35行)，服务器进入无限循环。在每次迭代时，服务器会调用函数<code>select()</code>来确定2个事件，即新客户端的连接请求的到达和已存在客户端的已连接描述符的准备好读。当新客户端的连接请求到达时 (第44行)，服务器会接受连接并调用函数<code>add_client()</code>来将该客户端加入到客户端池 (第47~48行)。最后，服务器调用函数<code>check_clients()</code>来从每个已连接描述符中回显1行文本行 (第52行)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化客户端池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param listenfd 监听描述符</span></span><br><span class="line"><span class="comment"> * @param p 客户端池指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pool</span><span class="params">(<span class="type">int</span> listenfd, pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始时，没有已连接的描述符 */</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    p-&gt;maxi = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;clientfd[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始时, 函数select的读集合中只有监听描述符 */</span></span><br><span class="line">    p-&gt;maxfd = listenfd;</span><br><span class="line">    FD_ZERO(&amp;p-&gt;read_set);</span><br><span class="line">    FD_SET(listenfd, &amp;p-&gt;read_set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数<code>init_pool()</code>会初始化客户端池。数组<code>clientfd</code>表示已连接描述符集，整数-1表示有可用的位置。初始时，已连接描述符集是空集合 (第11~15行)，函数<code>select()</code>的读集合中只有监听描述符 (第18~20行)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将新的客户端加入到客户端池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param connfd 已连接描述符</span></span><br><span class="line"><span class="comment"> * @param p 客户端池指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_client</span><span class="params">(<span class="type">int</span> connfd, pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    p-&gt;nready--;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">        <span class="comment">/* 找到可用的位置 */</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;clientfd[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 将已连接描述符加入池中 */</span></span><br><span class="line">            p-&gt;clientfd[i] = connfd;</span><br><span class="line">            Rio_readinitb(&amp;p-&gt;clientrio[i], connfd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将该描述符加入函数select的读集合 */</span></span><br><span class="line">            FD_SET(connfd, &amp;p-&gt;read_set);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 更新最大描述符以及相关参数 */</span></span><br><span class="line">            <span class="keyword">if</span> (connfd &gt; p-&gt;maxfd)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;maxfd = connfd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; p-&gt;maxi)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;maxi = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == FD_SETSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 找不到可用的位置 */</span></span><br><span class="line">        app_error(<span class="string">&quot;add_client error: Too many clients&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数<code>add_client()</code>会将新的客户端加入到客户端池。若在数组<code>clientfd</code>中找到位置，则服务器会将连接描述符加入到该数组并初始化对应的RIO读缓冲区 (第16~17行)。然后，将该已连接描述符加入到函数<code>select()</code>的读集合 (第20行) 并更新客户端池的部分全局属性。变量<code>maxfd</code>表示函数<code>select()</code>的最大文件描述符 (第23~26行)，变量<code>maxi</code>表示数组<code>clientfd</code>中的最大索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 服务客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param p 客户端池指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_clients</span><span class="params">(pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, connfd, n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; (i &lt;= p-&gt;maxi) &amp;&amp; (p-&gt;nready &gt; <span class="number">0</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        connfd = p-&gt;clientfd[i];</span><br><span class="line">        rio = p-&gt;clientrio[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 若描述符准备好读，则从中回显1行文本 */</span></span><br><span class="line">        <span class="keyword">if</span> ((connfd &gt; <span class="number">0</span>) &amp;&amp; (FD_ISSET(connfd, &amp;p-&gt;ready_set)))</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;nready--;</span><br><span class="line">            <span class="keyword">if</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                byte_cnt += n;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Server received %d (%d total) bytes on fd %d\n&quot;</span>, n, byte_cnt, connfd);</span><br><span class="line">                Rio_writen(connfd, buf, n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 检测到EOF，从池中移除描述符 */</span></span><br><span class="line">                Close(connfd);</span><br><span class="line">                FD_CLR(connfd, &amp;p-&gt;read_set);</span><br><span class="line">                p-&gt;clientfd[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数<code>check_clients()</code>会从每个准备好读的已连接描述符中返回1行文本，并将那行文本返回给客户端 (第23~25行)。第23行会维护全局变量<code>byte_cnt</code>来表示从所有客户端接收的总字节数。当客户端关闭连接端点时，服务器会检测到EOF，进而关闭连接端点 (第30行) 并将对应的描述符从客户端池中移除 (第31~32行)。</p><p>　　从状态机角度，函数<code>select()</code>用于检测输入事件，函数<code>add_client()</code>用于创建新状态机，函数<code>check_clients()</code>用于执行状态转换 (回显输入行) 和在客户端完成发送文本行时删除状态机。</p><h4 id="io多路复用的优点和缺点">12.2.2 I/O多路复用的优点和缺点</h4><p>　　I/O多路复用有2个优点和2个缺点。</p><p>　　第1个优点是相比进程驱动的设计，事件驱动的设计能让程序员更好地基于程序行为来控制程序。例如，若需要设计优先服务某些客户端的并发服务器，使用进程驱动的设计来实现会比较复杂。</p><p>　　第2个优点是基于I/O多路复用的事件驱动服务器可以运行在单个进程的上下文中，所以每个逻辑流都可以访问该进程的地址空间，这样易于逻辑流之间共享数据。运行在单个进程还可以使用GDB等调试工具来像调试顺序程序一样调试并发服务器。此外，事件驱动的设计通常比进程驱动的设计高效很多，因为无需执行进程上下文切换来调度新的逻辑流。</p><p>　　第1个缺点是事件驱动的设计的实现代码比较复杂。并发事件驱动echo服务器的代码量是并发进程驱动echo服务器的3倍多。复杂度随着并发粒度 (每个逻辑流在每个时间片上执行的指令数) 的降低而增加。例如，对于12.2.1中的示例，并发粒度就是读1整行文本所需的指令数。当某个逻辑流在读1行文本时，其他逻辑流无法进行，这使得服务器更容易受到恶意客户端的攻击 (仅发送部分文本行，再停止)。修改事件驱动服务器以处理这种攻击并不简单，但进程驱动服务器可以自动处理这种攻击。</p><p>　　第2个缺点是事件驱动的设计无法充分利用多核CPU。</p><p>　　虽然事件驱动的设计有以上缺点，但Node.js、Nginx和Tornado等现代高性能服务器都是使用基于I/O多路复用的事件驱动来实现，因为相比通过进程或线程来实现，这种方式有良好的性能。</p><h3 id="基于线程的并发编程">12.3 基于线程的并发编程</h3><img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/concurrent_thread_execution.svg" title="concurrent_thread_execution"><p>　　多线程的执行模型与多进程的执行模型有些类似。每个进程的生命周期开始时会有1个进程，称为<strong>主线程</strong>。在某个时刻下，主线程会创建<strong>对等线程</strong>，此时，主线程与对等线程并发运行。一段时间后，主线程会将控制权转移给对等线程 (调用<code>read</code>和<code>sleep</code>等慢系统调用或被系统间隔定时器中断)。对等线程执行一段时间后将控制权转移给主线程，依此类推。</p><p>　　线程执行与进程执行有一些重要的不同。首先，由于线程上下文比进程上下文小很多，所以线程上下文切换比进程上下文切换快很多。其次，不同于进程组织为严格的父子层次结构，进程关联的线程形成<span style="background-color:#ff0">对等体池</span>，与线程是否由其他线程创建无关。主线程与其他线程的唯一区别是主线程是进程中运行的第1个线程。对等体池的主要作用是某个线程可以终止任意对等体线程或等待任意对等体终止。</p><h4 id="posix线程">12.3.1 Posix线程</h4><p>　　Posix线程定义了大约60种函数来创建线程、终止线程、回收线程、安全地在对等线程之间共享数据和通知对等线程系统状态的改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 线程例程</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param vargp</span></span><br><span class="line"><span class="comment"> * @return void* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在这个示例中，主线程会创建对等线程并等待其终止。对等线程打印<code>Hello, world!\n</code>并终止。当主线程检测到对等线程终止时，会调用函数<code>exit()</code>来终止进程。对等线程的代码称为<strong>线程例程</strong> (第17~21行)，其输入和输出都是通用指针。若需要给线程例程传递多个参数，则可以将这些参数封装为结构体并将指向该结构体的指针传递给线程例程；若需要线程例程返回多个参数，则可以返回指向结构体的指针。</p><p>　　主函数就是主线程的代码。首先，主线程声明局部变量<code>tid</code>来存放对等线程TID并调用函数<code>Pthread_create()</code>来创建对等线程 (第11~12行)，当函数<code>Pthread_create()</code>返回时，对等线程TID会存放在参数<code>tid</code>中且对等线程与主线程并发运行。然后，主线程调用函数<code>Pthread_join()</code>来等待对等线程终止 (第13行)。最后，主线程调用函数<code>exit()</code>来终止进程中的所有线程 (第14行)。</p><h4 id="创建线程">12.3.2 创建线程</h4><p>　　可以调用函数<code>pthread_create()</code>来创建线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *(func)(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *tid, <span class="type">pthread_attr_t</span> *attr, func *f, <span class="type">void</span> *arg)</span>; <span class="comment">/* 若成功则返回0，若出错则返回非0错误码 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">()</span>; <span class="comment">/* 返回调用者TID */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>pthread_create()</code>会创建线程并在新线程的上下文中带有参数<code>arg</code>调用线程例程。参数<code>attr</code>可用于改变新线程的默认属性。</p><p>　　当函数<code>pthread_create()</code>返回时，参数<code>tid</code>会包含新线程TID。新线程可以调用函数<code>pthread_self()</code>来查看自己TID。</p><h4 id="初始化线程">12.3.3 初始化线程</h4><p>　　可以调用函数<code>pthread_once()</code>来初始化线程例程的相关状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_once</span><span class="params">(<span class="type">pthread_once_t</span> *once_control, <span class="type">void</span> (*init_routine)(<span class="type">void</span>))</span>; <span class="comment">/* 总是返回0 */</span></span><br></pre></td></tr></table></figure><p>　　变量<code>once_control</code>是全局/静态变量，总是初始化为<code>PTHREAD_ONCE_INIT</code>。第1次带有参数<code>once_control</code>调用函数<code>pthread_once()</code>时，会调用既没输入也没有输出的函数<code>init_routine()</code>。之后带有参数<code>once_control</code>调用函数<code>pthread_once()</code>时，不会做任何事。函数<code>pthread_once()</code>适合初始化多个线程共享的全局变量。</p><h4 id="终止和回收线程">12.3.4 终止和回收线程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *thread_return)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> tid)</span>; <span class="comment">/* 若成功则返回0，若出错则返回非0错误码 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> tid, <span class="type">void</span> **thread_return)</span>; <span class="comment">/* 若成功则返回0，若出错则返回非0错误码 */</span></span><br></pre></td></tr></table></figure><p>　　可以通过以下方式来终止线程：</p><p>　　● 当线程的上级线程例程返回时，该线程会<span style="background-color:#ff0">隐式</span>终止。</p><p>　　● 调用函数<code>pthread_exit()</code>来显式终止当前线程。</p><p>　　● 调用函数<code>exit()</code>来关闭当前进程以及与之关联的所有线程。</p><p>　　● 调用函数<code>pthread_cancel()</code>来关闭TID为参数<code>tid</code>的线程。</p><p>　　当主线程调用函数<code>pthread_exit()</code>时，会等待所有对等线程终止，再终止主线程，最后整个进程返回<code>thread_return</code>。</p><p>　　线程可以调用函数<code>pthread_join()</code>来等待其他线程终止，当前线程会阻塞，直到TID为参数<code>tid</code>的线程终止，然后，将线程例程返回的通用指针<code>void *</code>分配给<code>thread_return</code>指向的位置，最后，回收已终止线程的所有内存资源。</p><p>　　不同于函数<code>wait()</code>，函数<code>pthread_join()</code>只会等待1个特定的线程终止，这使得检测进程终止需要使用其他更复杂的机制来实现。</p><h4 id="分离线程">12.3.5 分离线程</h4><p>　　线程要么是<span style="background-color:#ff0">可合并</span>的，要么是<span style="background-color:#ff0">可分离</span>的。可合并的线程能被其他线程回收或终止，其内存资源不会释放，直到被其他线程回收。相反，可分离的线程不能被其他线程回收或终止，在终止时，其内存资源会被系统自动回收。</p><p>　　线程创建时默认是可合并的。为了避免内存泄漏，可合并的线程的内存资源应该显式被其他线程回收或调用函数<code>pthread_detach()</code>来变为可分离的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span>; <span class="comment">/* 若成功则返回0，若出错则返回非0错误码 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>pthread_detach()</code>会将TID为参数<code>tid</code>的可合并的线程变为可分离的。</p><h4 id="基于线程的并发echo服务器">12.3.6 基于线程的并发echo服务器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 基于线程的并发echo服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, *connfdp;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfdp = Malloc(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *connfdp = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, connfdp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> connfd = *((<span class="type">int</span> *)vargp);</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    Free(vargp);</span><br><span class="line">    echo(connfd);</span><br><span class="line">    Close(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　基于线程的并发echo服务器的大体结构与进程驱动的设计相似，主线程等待连接请求并创建对等线程来处理请求。</p><p>　　在调用函数<code>pthread_create()</code>时 (第28行)，会将指向已连接描述符的指针<code>connfdp</code>作为参数。在线程例程中，将该指针分配给局部变量 (第34行)。若像之前的示例一样直接使用<code>int</code>来存储已连接描述符会导致对等线程中的赋值语句与主线程中下一次调用函数<code>accept()</code>之间出现<span style="background-color:#ff0">竞争</span>。若前者竞争胜利，则线程例程中局部变量<code>connfd</code>会得到正确的描述符值；若后者竞争胜利，则线程例程中局部变量<code>connfd</code>会得到下一个连接的描述符值。为了避免这种竞争，必须将函数<code>accept()</code>返回的已连接描述符赋值给动态分配的内存块 (第26~27行)。</p><p>　　为了避免线程例程中的内存泄漏，这里会将每个线程变为可分离的并释放在主线程中分配的内存块 (第35~36行)。</p><h3 id="线程化程序的共享变量">12.4 线程化程序的共享变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> **ptr; <span class="comment">/* 全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">char</span> *msgs[N] = &#123;<span class="string">&quot;Hello from foo&quot;</span>, <span class="string">&quot;Hello from bar&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    ptr = msgs;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, (<span class="type">void</span> *)i);</span><br><span class="line">    &#125;</span><br><span class="line">    Pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> myid = (<span class="type">int</span>)vargp;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]: %s (cnt=%d)\n&quot;</span>, myid, ptr[myid], ++cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例中有1个主线程和2个对等线程。主线程会给每个对等线程传递唯一的ID，对等线程通过该ID来输出个性化信息和线程例程被调用的总次数。在第25行，对等线程通过指针<code>ptr</code>来间接引用主线程的栈中的内容。</p><p>　　线程化程序中的变量会按照其存储类别映射到虚拟内存：</p><p>　　● 全局变量是声明在函数外的变量。在运行时，虚拟内存的读写区域仅包含全局变量的1个实例，例如，第3行声明的指针<code>ptr</code>。当变量仅有1个实例时，可以简单地使用变量名来引用该实例。</p><p>　　● 局部自动变量是函数体内声明的变量。在运行时，每个线程的栈都包含所有局部自动变量的私有实例。例如，局部变量<code>tid</code>仅有1个实例，它存储在主线程的栈中，这里用<code>tid.m</code>来表示。局部变量<code>myid</code>有2个实例，分别存储在对等线程1和2的栈中，这里分别用<code>myid.p0</code>和<code>myid.p1</code>来表示。</p><p>　　● 局部静态变量是函数体内使用关键字<code>static</code>声明的变量。在运行时，虚拟内存的读写区域仅包含局部静态变量的1个实例。例如，即使每个对等线程都会声明局部静态变量<code>cnt</code> (第24行)，在运行时，虚拟内存的读写区域仅包含该变量的1个实例，所有对等线程都读写该实例。</p><p>　　综上所述，当且仅当变量只有1个实例时，它才是共享的。例如，变量<code>cnt</code>在运行时仅有1个实例，所以它是共享的。变量<code>myid</code>在运行时有2个实例，每个线程引用1个实例，所以它是不共享的。此外，局部自动变量<span style="background-color:#ff0">可能</span>是共享的，例如，第11行声明的<code>msgs</code>。</p><h3 id="同步线程与信号量">12.5 同步线程与信号量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> niters;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;niters&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    niters = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建线程并等待其结束 */</span></span><br><span class="line">    Pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">    Pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">    Pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查结果 */</span></span><br><span class="line">    <span class="keyword">if</span> (cnt != (<span class="number">2</span> * niters))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;BOOM! cnt=%ld\n&quot;</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OK cnt=%ld\n&quot;</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i, niters = *((<span class="type">long</span> *)vargp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; niters; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会创建2个线程，每个线程都会增加共享变量<code>cnt</code>，<code>cnt</code>的最终值应该是<code>2 * niters</code>，但实际并非如此。</p><img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/assembly_code_for_the_counter_loop.svg" title="assembly_code_for_the_counter_loop"><p>　　这里将线程例程中循环部分的汇编代码分为5部分。对于线程<span class="math inline">\(i\)</span>，<span class="math inline">\(H_i\)</span>表示循环首部的指令块。<span class="math inline">\(L_i\)</span>表示将共享变量<code>cnt</code>加载到累加寄存器<code>%rdx</code>的指令。<span class="math inline">\(U_i\)</span>表示更新寄存器<code>%rdx</code>的指令。<span class="math inline">\(S_i\)</span>表示将寄存器<code>%rdx</code>更新后的值存回共享变量<code>cnt</code>的指令。<span class="math inline">\(T_i\)</span>表示循环尾部的指令块。这里<span class="math inline">\(H_i\)</span>和<span class="math inline">\(T_i\)</span>操作局部栈变量，<span class="math inline">\(L_i\)</span>、<span class="math inline">\(U_i\)</span>和<span class="math inline">\(S_i\)</span>操作共享变量<code>cnt</code>。</p><p>　　当2个对等线程在单核CPU上并发运行时，指令会按照某种顺序执行。每次并发执行会定义2个线程中指令的顺序，其中的某些顺序可能会产生正确的结果，而其他则不会。</p><table><thead><tr><th>步骤</th><th>线程</th><th>指令</th><th style="text-align:left"><code>%rdx</code> (线程1)</th><th style="text-align:left"><code>%rdx</code> (线程2)</th><th style="text-align:left"><code>cnt</code></th></tr></thead><tbody><tr><td>1</td><td>1</td><td><span class="math inline">\(H_1\)</span></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">0</td></tr><tr><td>2</td><td>1</td><td><span class="math inline">\(L_1\)</span></td><td style="text-align:left">0</td><td style="text-align:left"></td><td style="text-align:left">0</td></tr><tr><td>3</td><td>1</td><td><span class="math inline">\(U_1\)</span></td><td style="text-align:left">1</td><td style="text-align:left"></td><td style="text-align:left">0</td></tr><tr><td>4</td><td>1</td><td><span class="math inline">\(S_1\)</span></td><td style="text-align:left">1</td><td style="text-align:left"></td><td style="text-align:left">1</td></tr><tr><td>5</td><td>2</td><td><span class="math inline">\(H_2\)</span></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">1</td></tr><tr><td>6</td><td>2</td><td><span class="math inline">\(L_2\)</span></td><td style="text-align:left"></td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr><tr><td>7</td><td>2</td><td><span class="math inline">\(U_2\)</span></td><td style="text-align:left"></td><td style="text-align:left">2</td><td style="text-align:left">1</td></tr><tr><td>8</td><td>2</td><td><span class="math inline">\(S_2\)</span></td><td style="text-align:left"></td><td style="text-align:left">2</td><td style="text-align:left">2</td></tr><tr><td>9</td><td>2</td><td><span class="math inline">\(T_2\)</span></td><td style="text-align:left"></td><td style="text-align:left">2</td><td style="text-align:left">2</td></tr><tr><td>10</td><td>1</td><td><span class="math inline">\(T_1\)</span></td><td style="text-align:left">1</td><td style="text-align:left"></td><td style="text-align:left">2</td></tr></tbody></table><p>　　这是首次迭代的正确指令执行顺序。在2个线程都更新共享变量<code>cnt</code>后，其值为2。</p><table><thead><tr><th>步骤</th><th>线程</th><th>指令</th><th style="text-align:left"><code>%rdx</code> (线程1)</th><th style="text-align:left"><code>%rdx</code> (线程2)</th><th style="text-align:left"><code>cnt</code></th></tr></thead><tbody><tr><td>1</td><td>1</td><td><span class="math inline">\(H_1\)</span></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">0</td></tr><tr><td>2</td><td>1</td><td><span class="math inline">\(L_1\)</span></td><td style="text-align:left">0</td><td style="text-align:left"></td><td style="text-align:left">0</td></tr><tr><td>3</td><td>1</td><td><span class="math inline">\(U_1\)</span></td><td style="text-align:left">1</td><td style="text-align:left"></td><td style="text-align:left">0</td></tr><tr><td>4</td><td>2</td><td><span class="math inline">\(H_2\)</span></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">0</td></tr><tr><td>5</td><td>2</td><td><span class="math inline">\(L_2\)</span></td><td style="text-align:left"></td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td>6</td><td>1</td><td><span class="math inline">\(S_1\)</span></td><td style="text-align:left">1</td><td style="text-align:left"></td><td style="text-align:left">1</td></tr><tr><td>7</td><td>1</td><td><span class="math inline">\(T_1\)</span></td><td style="text-align:left">1</td><td style="text-align:left"></td><td style="text-align:left">1</td></tr><tr><td>8</td><td>2</td><td><span class="math inline">\(U_2\)</span></td><td style="text-align:left"></td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr><tr><td>9</td><td>2</td><td><span class="math inline">\(S_2\)</span></td><td style="text-align:left"></td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr><tr><td>10</td><td>2</td><td><span class="math inline">\(T_2\)</span></td><td style="text-align:left"></td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr></tbody></table><p>　　这是首次迭代的错误指令执行顺序。线程2过早地加载共享变量<code>cnt</code> (第5步)。</p><h4 id="进度图">12.5.1 进度图</h4><p>　　<strong>进度图</strong>将<span class="math inline">\(n\)</span>个并发进程的执行模型化为通过<span class="math inline">\(n\)</span>维笛卡尔空间的轨迹。轴<span class="math inline">\(k\)</span>对应线程<span class="math inline">\(k\)</span>的进度。每个点都对应某个状态。点<span class="math inline">\(I_k\)</span>表示线程<span class="math inline">\(k\)</span>已完成指令<span class="math inline">\(I_k\)</span>。原点对应初始状态，表示没有线程完成指令。</p><p>　　进度图将指令执行模型化为从某个状态到其他状态的<strong>过渡</strong>，表示为某个点到相邻点的有向边。过渡只能是向右 (线程1完成指令) 或向上 (线程2完成指令)，不允许对角线过渡 (2个指令同时完成)。程序的执行过程模型化为通过状态空间的<strong>轨迹</strong>。</p><img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/an_example_trajectory.svg" title="an_example_trajectory"><p>　　在这个示例中，轨迹对应的指令顺序为<span class="math inline">\(H_1\)</span>、<span class="math inline">\(L_1\)</span>、<span class="math inline">\(U_1\)</span>、<span class="math inline">\(H_2\)</span>、<span class="math inline">\(L_2\)</span>、<span class="math inline">\(S_1\)</span>、<span class="math inline">\(T_1\)</span>、<span class="math inline">\(U_2\)</span>、<span class="math inline">\(S_2\)</span>和<span class="math inline">\(T_2\)</span>。</p><p>　　对于线程<span class="math inline">\(i\)</span>，操作共享变量<code>cnt</code>的指令<span class="math inline">\(L_i\)</span>、<span class="math inline">\(U_i\)</span>和<span class="math inline">\(S_i\)</span>组成<strong>关键部分</strong>。某个线程的关键部分不应该与其他线程的关键部分重叠，即线程在执行其关键部分的指令时，对共享变量有互斥访问权限，这种情况称为<strong>互斥</strong>。</p><img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/safe_and_unsafe_trajectories.svg" title="safe_and_unsafe_trajectories"><p>　　在进度图中，2个关键部分的交集定义了状态空间的<strong>不安全区域</strong>，不安全区域并不包括其边界。例如，状态<span class="math inline">\((H_1,H2)\)</span>和<span class="math inline">\((S_1,U_2)\)</span>毗邻不安全区域，但并不属于不安全区域。绕开不安全区域的轨迹称为<strong>安全轨迹</strong>，通过不安全区域的轨迹称为<strong>不安全轨迹</strong>。所有安全轨迹都会正确地更新共享变量<code>cnt</code>。</p><p>　　进度图提供了很好的方法来可视化运行在单核CPU上的并发程序和理解同步。但是，进度图并不适用于运行在多核CPU的并发程序。多核CPU的存储系统可以处于与进度图中任何轨迹都不对应的状态。</p><h4 id="信号量">12.5.2 信号量</h4><p>　　并发编程先驱Edsger Dijkstra (1930~2002，荷兰人) 提出了不同线程的同步问题的经典解决方法之一，该方法基于称为<strong>信号量</strong>的特殊类型变量。信号量<code>s</code>是非负的整数值，只能通过2种特殊操作来控制，即<code>P</code>和<code>V</code>。<code>P</code>和<code>V</code> 源自荷兰语proberen (尝试) 和verhogen (增加)。</p><p>　　● <code>P(s)</code>会判断<code>s</code>。若<code>s</code>非0，则将<code>s</code>减1并立即返回；若<code>s</code>是0，则挂起线程，直到<code>s</code>变为非0，然后通过<code>V</code>操作来恢复该线程。在恢复后，<code>P</code>操作将<code>s</code>减1并将控制权转移给调用者。</p><p>　　● <code>V(s)</code>会将<code>s</code>加1。若存在线程阻塞在<code>P</code>操作 (等待<code>s</code>变为非0)，则恢复其中的<span style="background-color:#ff0">1个</span>线程。</p><p>　　<code>P</code>中的判断和递减操作是不可分割的。<code>V</code>操作中的递增操作也是不可分割的。V操作并<span style="background-color:#ff0">未定义</span>等待线程的恢复顺序。</p><p>　　<code>P</code>和<code>V</code>的定义确保正在运行的程序不会进入正确初始化的信号量为负值的状态，这个属性称为<strong>信号量不变式</strong>，它提供了用于控制并发程序的轨迹的有效工具。</p><p>　　Posix标准定义了多个函数来操作信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="number">0</span>, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *s)</span>; <span class="comment">/* P(s) */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *s)</span>; <span class="comment">/* V(s) */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="type">sem_t</span> *s)</span>; <span class="comment">/* sem_wait的包装函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="type">sem_t</span> *s)</span>; <span class="comment">/* sem_post的包装函数 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>sem_init()</code>会将信号量<code>sem</code>初始化为<code>value</code> (这里将第2个参数直接设置为0)，信号量在使用前必须初始化。可以调用函数<code>sem_wait()</code>和<code>sem_post()</code>来执行<code>P</code>和<code>V</code>操作，为了简洁，这里使用它们的包装函数。</p><h4 id="使用信号量来互斥">12.5.3 使用信号量来互斥</h4><p>　　信号量提供了便利的方法来实现共享变量的互斥访问。基本思想是将每个共享变量与1个初始值为1的信号量关联，然后将对应的关键部分用<code>P</code>和<code>V</code>操作包围起来。</p><p>　　用于实现共享变量的互斥访问的信号量称为<strong>二进制信号量</strong> (因为其值只能是0和1) 或<strong>互斥锁</strong>。执行<code>V</code>操作的过程称为<strong>解锁</strong>。已上锁的线程<strong>持有</strong>锁。用作可用资源计数器的信号量称为<strong>计数信号量</strong>。</p><img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/using_semaphores_for_mutual_exclusion.svg" title="using_semaphores_for_mutual_exclusion"><p>　　以同步12.5中的计数器程序为例，这里每个状态都标上了对应的<code>s</code>值，其关键思想是<code>P</code>和<code>V</code>操作的结合产生了称为<strong>禁止区域</strong>的状态集，其中<code>s</code>的值为负。由于信号量非负，所有可行的轨迹都不能通过禁止区域。由于禁止区域包含不安全区域，所以所有可行的轨迹都是安全的，无论指令运行时以何种顺序执行，程序总能正确地增加计数器。</p><p>　　首先，声明互斥锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> cnt = <span class="number">0</span>; <span class="comment">/* 计数器 */</span></span><br><span class="line"><span class="type">sem_t</span> mutex;           <span class="comment">/* 包含计数器的信号量 */</span></span><br></pre></td></tr></table></figure><p>　　然后，在主函数将信号量初始化为1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>　　最后，将线程例程中共享变量<code>cnt</code>的更新用<code>P</code>和<code>V</code>操作包围起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; niters; i++)</span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    cnt++;</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用信号量来调度共享资源">12.5.4 使用信号量来调度共享资源</h4><p>　　除了提供互斥访问，信号量的另一个重要用途是调度共享资源的访问。在这种情况下，线程通过信号量操作来通知其他线程程序状态中某些条件变为真，例如，生产者-消费者问题和读者-写者问题。</p><h5 id="生产者-消费者问题">12.5.4.1 生产者-消费者问题</h5><img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/producer-consumer_problem.svg" title="producer-consumer_problem"><p>　　生产者线程和消费者线程共享<span style="background-color:#ff0">有限</span>缓冲区。生产者线程反复生成新项并将其放入缓冲区。消费者线程反复从缓冲区取出项并使用。此外，可能出现多个生产者和消费者的情况。</p><p>　　由于放入和取出项涉及更新共享变量，必须确保对缓冲区的互斥访问，但这还不够，还需要调度缓冲区的访问。若缓冲区已满，则生产者线程必须等待缓冲区中有空位；若缓冲区为空，则消费者必须等待缓冲区中有可用项。</p><p>　　这里将实现包<code>SBUF</code>，用于实现生产者-消费者程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> *buf;    <span class="comment">/* 缓冲区数组 */</span></span><br><span class="line">    <span class="type">int</span> n;       <span class="comment">/* 缓冲区大小 */</span></span><br><span class="line">    <span class="type">int</span> front;   <span class="comment">/* 第1个项buf[(front+1)%n] */</span></span><br><span class="line">    <span class="type">int</span> rear;    <span class="comment">/* 最后1个项buf[rear%n] */</span></span><br><span class="line">    <span class="type">sem_t</span> mutex; <span class="comment">/* 互斥锁 */</span></span><br><span class="line">    <span class="type">sem_t</span> slots; <span class="comment">/* 缓冲区的可用空位数 */</span></span><br><span class="line">    <span class="type">sem_t</span> items; <span class="comment">/* 缓冲区的可用项数 */</span></span><br><span class="line">&#125; <span class="type">sbuf_t</span>;</span><br></pre></td></tr></table></figure><p>　　<code>SBUF</code>通过结构体<code>sbuf_t</code>来操作缓冲区。项存储在大小为<code>n</code>的动态分配的整数数组<code>buf</code>中。<code>front</code>和<code>rear</code>表示数组中第1个和最后1个项。3个信号量用于同步缓冲区的访问，<code>mutex</code>提供缓冲区的互斥访问，<code>slots</code>和<code>items</code>分别计算缓冲区中可用空位和可用项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 生成带有n个空位的FIFO缓冲区</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sp 缓冲区指针</span></span><br><span class="line"><span class="comment"> * @param n 缓冲区大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    sp-&gt;buf = Calloc(n, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    sp-&gt;n = n;</span><br><span class="line">    sp-&gt;front = sp-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    Sem_init(&amp;sp-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">/* 互斥锁 */</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;slots, <span class="number">0</span>, n); <span class="comment">/* 缓冲区初始化有n个空位  */</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;items, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">/* 缓冲区初始化没有数据项 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放缓冲区</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sp 缓冲区指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Free(sp-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将项放入到缓冲区的尾部</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sp 缓冲区指针</span></span><br><span class="line"><span class="comment"> * @param item 项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span></span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;sp-&gt;slots);                          <span class="comment">/* 等待可用空位 */</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);                          <span class="comment">/* 对缓冲区上锁 */</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear) % (sp-&gt;n)] = item; <span class="comment">/* 放入项 */</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);                          <span class="comment">/* 解锁缓冲区 */</span></span><br><span class="line">    V(&amp;sp-&gt;items);                          <span class="comment">/* 更新可用项 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从缓冲区的头部取出项</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sp 缓冲区指针</span></span><br><span class="line"><span class="comment"> * @return int 取出的项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    P(&amp;sp-&gt;items);                           <span class="comment">/* 等待可用空位 */</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);                           <span class="comment">/* 对缓冲区上锁 */</span></span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front) % (sp-&gt;n)]; <span class="comment">/* 取出项 */</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);                           <span class="comment">/* 解锁缓冲区 */</span></span><br><span class="line">    V(&amp;sp-&gt;slots);                           <span class="comment">/* 更新可用空位 */</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数<code>sbuf_init()</code>会给缓冲区分配堆空间，设置<code>front</code>和<code>rear</code>以及初始化3个信号量，该函数在调用其他3个函数前会被调用1次。函数<code>sbuf_deinit()</code>会释放缓冲区。函数<code>sbuf_insert()</code>会等待空位，对缓冲区上锁，放入项，解锁缓冲区并更新可用项数。函数<code>sbuf_remove()</code>会等待可用项，对缓冲区上锁，取出项，解锁缓冲区并更新可用空位数。</p><h5 id="读者-写者问题">12.5.4.2 读者-写者问题</h5><p>　　读者-写者问题是互斥问题的综合。一组并发线程访问同一共享变量，例如，内存中的某个数据结构和磁盘上的某个数据库。部分线程只会读对象，其他线程会修改对象，前者称为<span style="background-color:#ff0">读者</span>，后者称为<span style="background-color:#ff0">写者</span>。写者必须互斥地访问对象，读者可能会与其他任意数量的读者共享对象。读者和写者的数量通常可以是任意个。</p><p>　　读者-写者问题有多个变体，都基于读者和写者的优先级。</p><p>　　● 对于偏向于读者的读者-写者问题，读者无须等待，除非有写者已被授权使用该对象，即读者不应该因为写者在等待而等待。</p><p>　　● 对于偏向于写者的读者-写者问题，一旦写者准备好写，就会尽快开始。若读者在写者后到达，即使写者在等待，读者也必须等待。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 全局变量 */</span></span><br><span class="line"><span class="type">int</span> readcnt;    <span class="comment">/* 初始值为0 */</span></span><br><span class="line"><span class="type">sem_t</span> mutex, w; <span class="comment">/* 初始值都为1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt++;</span><br><span class="line">        <span class="keyword">if</span> (readcnt == <span class="number">1</span>) <span class="comment">/* 先进 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            P(&amp;w);</span><br><span class="line">        &#125;</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 关键部分 */</span></span><br><span class="line">        <span class="comment">/* 执行读操作 */</span></span><br><span class="line"></span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt--;</span><br><span class="line">        <span class="keyword">if</span> (readcnt == <span class="number">0</span>) <span class="comment">/* 后出 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            V(&amp;w);</span><br><span class="line">        &#125;</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(&amp;w);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 关键部分 */</span></span><br><span class="line">        <span class="comment">/* 执行写操作 */</span></span><br><span class="line"></span><br><span class="line">        V(&amp;w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这是第1个读者-写者问题的解决方法。信号量<code>w</code>控制关键部分的访问。信号量<code>mutex</code>控制共享变量<code>cnt</code>的访问，该变量用于给当前正在访问关键部分的读者计数。写者每次访问关键部分时都会上锁并在完成访问时解锁，这保证了同时最多有1个写者访问关键部分。只有第1个读者访问关键部分时才会上锁，并且只有最后1个读者完成访问时才会解锁，中间的读者可以无视锁。这表示<span style="background-color:#ff0">只要有读者持有锁</span>，其他读者可以直接访问关键部分而无需等待。</p><p>　　这2个读者-写者问题的解决方法都会导致<strong>饥荒</strong>，即线程无期限地阻塞。例如，第1个读者-写者问题会可能导致大量读者到达时，写者长时间等待。</p><h4 id="基于预线程的并发服务器">12.5.5 基于预线程的并发服务器</h4><img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/organization_of_a_prethreaded_concurrent_server.svg" title="organization_of_a_prethreaded_concurrent_server"><p>　　基于<strong>预线程</strong>的服务器可以通过生产者-消费者模型来减少创建新线程的成本，该服务器有1个主线程和多个工作线程。主线程反复接收客户端的连接请求并将作为结果的描述符放入缓冲区。工作线程反复从缓冲区取出描述符，服务客户端并等待下一个描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbuf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NTHREADS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBUFSIZE</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo_cnt</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sbuf_t</span> sbuf; <span class="comment">/* 共享的已连接描述符缓冲区 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 基于预线程的并发echo服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    sbuf_init(&amp;sbuf, SBUFSIZE);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHREADS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>); <span class="comment">/* 创建工作线程 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        sbuf_insert(&amp;sbuf, connfd); <span class="comment">/* 将已连接描述符放入缓冲区 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> connfd = sbuf_remove(&amp;sbuf); <span class="comment">/* 从缓冲区取出已连接描述符 */</span></span><br><span class="line">        echo_cnt(connfd);                <span class="comment">/* 服务客户端 */</span></span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会使用包<code>SBUF</code>来实现基于预线程的并发echo服务器。在初始化缓冲区<code>sbuf</code>后 (第28行)，主线程会创建工作线程 (第29~32行)，开始无限循环，接收连接请求并将作为结果的已连接描述符放入缓冲区。工作线程会一直等待，直到缓冲区中有可用已连接描述符，然后从缓冲区取出已连接描述符 (第47行) 并调用函数<code>echo_cnt()</code>来回显客户端输入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> byte_cnt; <span class="comment">/* 字节计数器 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">sem_t</span> mutex;  <span class="comment">/* 字节计数器的互斥锁 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_echo_cnt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    byte_cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 计算从所有客户端接收的字节总数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param connfd 已连接描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo_cnt</span><span class="params">(<span class="type">int</span> connfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_once_t</span> once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line">    Pthread_once(&amp;once, init_echo_cnt);</span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        byte_cnt += n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %d (%d total) bytes on fd %d\n&quot;</span>, n, byte_cnt, connfd);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数<code>echo_cnt()</code>会通过全局变量<code>byte_cnt</code>来计算从所有客户端接收的字节总数。这里需要初始化计数器<code>byte_cnt</code>和信号量<code>mutex</code>，可以通过包<code>SBUF</code>和<code>RIO</code>来初始化 (需要主线程显式调用1次初始化函数)，这里通过函数<code>pthread_once()</code>来初始化 (第22行)。这种初始化方法的优点是易用，缺点是每次调用函数<code>echo_cnt()</code>也会调用函数<code>pthread_once()</code> (大多数对函数<code>pthread_once()</code>的调用都是无效的)。</p><p>　　初始化后，函数<code>pthread_once()</code>会初始化包<code>RIO</code>的缓冲区 (第23行) 并回显从客户端收到的每行文本。共享变量<code>byte_cnt</code>的访问是互斥的 (第26~29行)。</p><p>　　实现事件驱动并非只能通过I/O多路复用，预线程也可以用于实现事件驱动。对于这里的示例，主线程有2个状态 (等待连接请求和等待可用缓冲区空位)、2个I/O事件 (连接请求到达和缓冲区中有可用空位) 和2个转换 (接收连接请求和将描述符放入缓冲区)。工作线程有1个状态 (等待缓冲区中的可用描述符)、1个I/O事件 (缓冲区中有可用描述符) 和1个转换 (从缓冲区取出描述符)。</p><h3 id="使用线程来实现并行">12.6 使用线程来实现并行</h3><p>　　以并行地计算0到<span class="math inline">\(n-1\)</span>这<span class="math inline">\(n\)</span>个数的和为例，最直接的方法是将这<span class="math inline">\(n\)</span>个数分为<span class="math inline">\(t\)</span>组，然后让<span class="math inline">\(t\)</span>个线程分别计算这<span class="math inline">\(t\)</span>组。此外，假设<span class="math inline">\(n\)</span>是<span class="math inline">\(t\)</span>的整数倍，所以每组有<span class="math inline">\(\frac{n}{t}\)</span>个元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTHREADS 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 线程例程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param vargp</span></span><br><span class="line"><span class="comment"> * @return void*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sum_mutex</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局共享变量 */</span></span><br><span class="line"><span class="type">long</span> gsum = <span class="number">0</span>;          <span class="comment">/* 总和 */</span></span><br><span class="line"><span class="type">long</span> nelems_per_thread; <span class="comment">/* 每个线程中参与计算的元素数 */</span></span><br><span class="line"><span class="type">sem_t</span> mutex;            <span class="comment">/* 总和的互斥锁 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 通过多线程来计算多个元素序列的和</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i, nelems, log_nelems, nthreads, myid[MAXTHREADS];</span><br><span class="line">    <span class="type">pthread_t</span> tid[MAXTHREADS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;nthreads&gt; &lt;log_nelems&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nthreads = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    log_nelems = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    nelems = (<span class="number">1L</span> &lt;&lt; log_nelems);</span><br><span class="line">    nelems_per_thread = nelems / nthreads;</span><br><span class="line">    sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建对等线程并等待它们结束 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        myid[i] = i;</span><br><span class="line">        Pthread_create(&amp;tid[i], <span class="literal">NULL</span>, sum_mutex, &amp;myid[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查总和 */</span></span><br><span class="line">    <span class="keyword">if</span> (gsum != (nelems * (nelems - <span class="number">1</span>)) / <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: result=%ld\n&quot;</span>, gsum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　最直白的实现方法是让线程通过共享变量来计算总和。在第38~46行，主线程创建对等线程并等待它们终止，这里主线程给每个对等线程都传递了ID来作为其TID。每个对等线程会通过其TID来决定它应该计算序列的哪个组。最后，主线程通过封闭解来验证结果 (第49~52行)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">sum_mutex</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> myid = *((<span class="type">long</span> *)vargp);          <span class="comment">/* 提取TID */</span></span><br><span class="line">    <span class="type">long</span> start = myid * nelems_per_thread; <span class="comment">/* 开始元素索引 */</span></span><br><span class="line">    <span class="type">long</span> end = start + nelems_per_thread;  <span class="comment">/* 结束元素索引 */</span></span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt; end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        gsum += i;</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在函数<code>sum_mutex()</code>中，第3行会从参数中提取TID并通过TID来决定它应该计算序列的哪个组 (第4~5行)。第8~13行会迭代求和。</p><p>　　当在4核CPU上对有<span class="math inline">\(2^{32}\)</span>个元素的序列调用函数<code>sum_mutex()</code>时，可以得到如下结果：</p><table><thead><tr><th>线程数</th><th>函数<code>sum_mutex()</code>运行时间 (单位是s)</th></tr></thead><tbody><tr><td>1</td><td>68</td></tr><tr><td>2</td><td>432</td></tr><tr><td>4</td><td>719</td></tr><tr><td>8</td><td>552</td></tr><tr><td>16</td><td>599</td></tr></tbody></table><p>　　在这种情况下，程序并行运行比单线程运行的效率低很多，并且效率会随着核的数量增加继续降低，这是因为同步操作的开销很大。因此，<span style="background-color:#ff0">应尽量避免使用同步操作</span>，若无法避免，则通过尽可能多有用的计算来摊销。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">sum_array</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> myid = *((<span class="type">long</span> *)vargp);          <span class="comment">/* 提取TID */</span></span><br><span class="line">    <span class="type">long</span> start = myid * nelems_per_thread; <span class="comment">/* 开始元素索引 */</span></span><br><span class="line">    <span class="type">long</span> end = start + nelems_per_thread;  <span class="comment">/* 结束元素索引 */</span></span><br><span class="line">    <span class="type">long</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt; end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    psum[myid] = sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　避免在线程例程中使用同步操作的方法之一是让对等线程用局部变量来计算每个组的和，这里是在主线程中定义了全局数组<code>psum</code>，对等线程将对应组的和存储在数组<code>psum</code>中的索引为自身TID的元素中。最后，主线程只需计算数组<code>psum</code>中的元素的和。</p><p>　　当在4核CPU上对有<span class="math inline">\(2^{32}\)</span>个元素的序列调用函数<code>sum_array()</code>时，可以得到如下结果：</p><table><thead><tr><th>线程数</th><th>函数<code>sum_array()</code>运行时间 (单位是s)</th></tr></thead><tbody><tr><td>1</td><td>1.06</td></tr><tr><td>2</td><td>0.54</td></tr><tr><td>4</td><td>0.28</td></tr><tr><td>8</td><td>0.29</td></tr><tr><td>16</td><td>0.30</td></tr></tbody></table><p>　　在理想情况下，运行时间应该随着线程数的增加而线性减少，即每次都减少一半。但事实并非如此，因为在<span style="background-color:#ff0">同一核上进行线程上下文需要额外的时间</span>。因此，并行程序通常实现为每个核1个线程。</p><p>　　并行程序的<strong>加速比</strong>定义为<span class="math inline">\(S_p=\frac{T_1}{T_p}\)</span>，该公式也称为<strong>强缩放</strong>。<span class="math inline">\(p\)</span>是CPU核心数，<span class="math inline">\(T_p\)</span>是程序在<span class="math inline">\(p\)</span>核CPU上的运行时间。当<span class="math inline">\(T_1\)</span>是并行程序的顺序版本的运行时间时，<span class="math inline">\(S_p\)</span>是<strong>绝对加速比</strong>。当<span class="math inline">\(T_1\)</span>是并行程序在单核CPU上的运行时间时，<span class="math inline">\(S_p\)</span>是<strong>相对加速比</strong>。相比相对加速比，绝对加速比能更真实地衡量并行的提升。</p><p>　　即使并行程序在单核CPU上运行，也需要受到同步操作的影响 (即增加相对加速比)，因为它会增加加速比公式的分子。绝对加速比相对加速比更难以衡量，因为绝对加速比需要2个版本的程序。对于复杂的并行代码，编写对应的顺序代码并非易事。</p><p>　　<strong>效率</strong>是加速比的相关度量之一，定义为<span class="math inline">\(E_p=\frac{S_p}{p}=\frac{T_1}{pT_p}\)</span>，其取值范围是 (0,1]。效率用于衡量并行的影响。相比低效率的程序，高效率的程序将更多的时间用在执行有用的工作，将更少的时间用在同步和通信上。</p><p>　　函数<code>sum_array()</code>的加速比和效率如下：</p><table><colgroup><col style="width:10%"><col style="width:28%"><col style="width:36%"><col style="width:13%"><col style="width:10%"></colgroup><thead><tr><th>线程数<span class="math inline">\(t\)</span></th><th>CPU核心数<span class="math inline">\(p\)</span> (实际使用)</th><th>函数<code>sum_array()</code>运行所需<span class="math inline">\(T_p\)</span></th><th>加速比<span class="math inline">\(S_p\)</span></th><th>效率<span class="math inline">\(E_p\)</span></th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1.06</td><td>1</td><td>1</td></tr><tr><td>2</td><td>2</td><td>0.54</td><td>1.9</td><td>0.98</td></tr><tr><td>4</td><td>4</td><td>0.28</td><td>3.8</td><td>0.95</td></tr><tr><td>8</td><td>4</td><td>0.29</td><td>3.7</td><td>0.91</td></tr><tr><td>16</td><td>4</td><td>0.30</td><td>3.5</td><td>0.88</td></tr></tbody></table><p>　　这里展示的示例的效率都很高，但实际中并非如此。数十年来，并行编程一直都是活跃的研究领域。</p><p>　　除了强缩放，另一种加速比的理解是<strong>弱缩放</strong>，它让问题的大小随着CPU核心数的增加而增加，即随着CPU核心数的增加，每个核心上执行的工作量保存不变。在这种情况下，加速比和效率表示为单位时间内完成的工作量。例如，若在将CPU核心数加倍后，完成的工作量也能加倍，则加速比是线性的，效率是1。</p><p>　　弱缩放通常比强缩放更符合实际情况，因为它能更准确地表达用更好的机器去完成更多的工作的愿景。但是，对于那些工作量不易轻易增加的程序，强缩放更合适。例如，实时信号处理程序的工作量通常由产生信号的物理传感器来决定，这类程序通常通过并行来尽快完成固定量的工作。</p><h3 id="其他并行问题">12.7 其他并行问题</h3><p>　　同步会导致一些顺序程序中根本不会出现的问题，这里主要介绍线程安全和可重入性的相关问题。</p><h4 id="线程安全">12.7.1 线程安全</h4><p>　　当且仅当函数被多个线程反复调用且都产生正确的结果时，该函数才是<span style="background-color:#ff0">线程安全</span>的。线程不安全的函数可以分为4类，即<span style="background-color:#ff0">不保护共享变量的函数</span>、<span style="background-color:#ff0">多个调用中保持状态的函数</span>、<span style="background-color:#ff0">返回静态变量指针的函数</span>、<span style="background-color:#ff0">调用线程不安全的函数的函数</span>。</p><p>　　● 不保护共享变量的函数很容易变为线程安全，只需要将共享变量用同步操作来保护起来。这种方法的优点是调用者无需进行任何更改，缺点是同步操作会降低性能。</p><p>　　● 线程不安全的伪随机数生成器就是多个调用中保持状态的函数的简单示例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> next_seed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 返回0~32767内的伪随机整数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return unsigned </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">rand</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    next_seed = next_seed * <span class="number">1103515245</span> + <span class="number">12543</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span>)(next_seed &gt;&gt; <span class="number">16</span>) % <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置函数rand的种子</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param new_seed 种子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">srand</span><span class="params">(<span class="type">unsigned</span> new_seed)</span></span><br><span class="line">&#123;</span><br><span class="line">    next_seed = new_seed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数<code>rand()</code>是线程不安全的，因为本次调用的结果取决于上次调用产生的结果。当在单线程中调用函数<code>srand()</code>来设置种子并反复调用函数<code>rand()</code>时，得到的结果是符合预期的。但当多个线程调用函数<code>rand()</code>时，得到的结果就不再符合预期。</p><p>　　将函数<code>rand()</code>改为线程安全的方法是不再使用静态数据，而是调用者将状态信息作为参数传递。这种方法的缺点是必须修改代码。</p><p>　　● <code>ctime</code>和<code>gethostbyname</code>等函数会将结果存储在静态变量中，然后返回指向该静态变量的指针。若在并发线程中调用这类函数会导致严重后果，因为返回的结果可能会被其他线程覆盖。</p><p>　　将此类函数变为线程安全的函数有2种方法。第1种方法是重写函数，调用者传递某个变量的地址，函数将结果保存在该变量中。第2种方法是使用<span style="background-color:#ff0">上锁并复制</span>技术，即每次调用前先上锁，然后将结果复制到私有内存中，最后解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief C标准库函数ctime的线程安全的包装函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param timep</span></span><br><span class="line"><span class="comment"> * @param privatep</span></span><br><span class="line"><span class="comment"> * @return char*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime_ts</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="type">char</span> *privatep)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *sharedp;</span><br><span class="line"></span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    sharedp = ctime(timep);</span><br><span class="line">    <span class="built_in">strcpy</span>(privatep, sharedp); <span class="comment">/* 将字符串复制到私有区域 */</span></span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> privatep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　对于第2种方法，为了修改最少的代码，应使用对应的线程安全的包装函数，并将对原来函数的调用修改为对包装函数的调用。</p><p>　　● 对于调用线程不安全的函数<code>g()</code>的函数<code>f()</code>，若函数<code>g()</code>是多个调用中保持状态的函数，则只能重写函数<code>g()</code>来让函数<code>f()</code>变为线程安全的；若函数<code>g()</code>是其他类型的线程不安全的函数，则可以用上锁并复制技术来让函数<code>f()</code>变为线程安全的。</p><h4 id="可重入性">12.7.2 可重入性</h4><p>　　<strong>可重入的函数</strong>是重要的线程安全的函数之一，其特点是当它们被多个线程调用时，它们<span style="background-color:#ff0">不会引用任何共享数据</span>。</p><p>　　可重入的函数比非可重入的线程安全的函数更高效，因为它无需同步操作。将多个调用中保持状态的函数变为线程安全的函数的唯一方法是将其重写为可重入的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数rand的可重入的版本</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param nextp</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rand_r</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *nextp)</span></span><br><span class="line">&#123;</span><br><span class="line">    *nextp = *nextp * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)(*nextp / <span class="number">65536</span>) % <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这是函数<code>rand()</code>的可重入的版本，关键思想是将共享变量<code>next_seed</code>替换为作为参数的指针。</p><p>　　对于可重入函数，若所有的函数参数都是值传递 (即没有指针) 且所有的数据引用都是指向局部自动栈变量，则该函数是<span style="background-color:#ff0">显式可重入</span>的；若将条件放宽到所有的函数参数可以有引用传递 (即有指针)，则该函数是<span style="background-color:#ff0">隐式可重入</span>的。例如，函数<code>rand_r()</code>就是隐式可重入的。</p><h4 id="竞争">12.7.3 竞争</h4><p>　　当程序的正确执行需要线程A的控制流在线程B的控制流到达<span class="math inline">\(y\)</span>点前到达<span class="math inline">\(x\)</span>点时，就会出现<span style="background-color:#ff0">竞争</span>。竞争的出现通常是程序员假设线程将在执行状态空间中按照特定的轨迹执行，而这与程序必须能适用于所有可行的轨迹相矛盾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 竞争示例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[N];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread, &amp;i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> myid = *((<span class="type">int</span> *)vargp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread %d\n&quot;</span>, myid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在这个示例中，主线程会创建4个对等线程并会给对等线程传递指向唯一整数ID的指针。对等线程将参数复制到局部变量并输出包含该ID的字符串 (第27~28行)。</p><p>　　当主线程创建对等线程并传递指针给该对等线程时 (第16行)，竞争出现在<code>i</code>的增加 (第14行) 与参数的解引用和赋值 (第27行)。若前者先执行，则得到其他线程的ID；若后者先执行，则得到正确的ID。是否得到正确的ID完全取决于内核如何调度线程的执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 消除竞争</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[N];</span><br><span class="line">    <span class="type">int</span> i, *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = Malloc(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *ptr = i;</span><br><span class="line">        Pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> myid = *((<span class="type">int</span> *)vargp);</span><br><span class="line">    Free(vargp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread %d\n&quot;</span>, myid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　为了消除竞争，可以给每个ID动态分配空间并将对应的指针传递给线程例程 (第16~18行)，线程例程需要释放对应的空间 (第30行)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread, (<span class="type">void</span> *)i);</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="type">int</span> myid = (<span class="type">int</span>)vargp;</span><br></pre></td></tr></table></figure><p>　　另一种消除竞争的方法是将<code>i</code>转换成指针并作为参数传递给线程例程，然后线程例程将参数转换为<code>int</code>。这种方法无需分配和释放空间，但需要指针的长度至少和<code>int</code>的长度相同。</p><h4 id="死锁">12.7.4 死锁</h4><p>　　信号量引入了称为<strong>死锁</strong>的运行时错误，即一组线程阻塞，等待永远不会为真的条件。</p><img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/progress_graph_for_a_program_that_can_deadlock.svg" title="progress_graph_for_a_program_that_can_deadlock"><p>　　在这个示例中，2个线程使用2个信号量来进行互斥。若按照错误的顺序使用<code>P</code>和<code>V</code>操作，则2个信号量的禁止区域会有重叠。重叠的禁止区域包括一组<strong>死锁状态</strong> (即<strong>死锁区域</strong>)。若某些轨迹碰巧到达死锁状态，则这2个线程都会等待对方执行<code>V</code>操作。</p><p>　　可以通过<span style="background-color:#ff0">互斥锁排序原则</span>来避免死锁，即规定所有互斥锁的总顺序，线程按序申请互斥锁，并按反序释放互斥锁。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/" rel="prev" title="《深入理解计算机系统 第3版》第11章 网络编程"><i class="fa fa-angle-left"></i> 《深入理解计算机系统 第3版》第11章 网络编程</a></div><div class="post-nav-item"><a href="/2023/12/21/computer-systems-a-programmer's-perspective-3e-appx/" rel="next" title="《深入理解计算机系统 第3版》 附录">《深入理解计算机系统 第3版》 附录 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script></body></html>