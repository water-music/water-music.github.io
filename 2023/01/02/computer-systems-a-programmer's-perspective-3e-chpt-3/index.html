<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><link rel="canonical" href="http://example.com/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/","path":"2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/","title":"《深入理解计算机系统 第3版》第3章 程序的机器级表示"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《深入理解计算机系统 第3版》第3章 程序的机器级表示 |</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A0%81"><span class="nav-text">3.1 程序编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E7%BA%A7%E4%BB%A3%E7%A0%81"><span class="nav-text">3.1.1 机器级代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">3.1.2 代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%A1%E6%81%AF"><span class="nav-text">3.2 访问信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="nav-text">3.2.1 操作数指示符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%A7%BB%E5%8A%A8%E6%8C%87%E4%BB%A4"><span class="nav-text">3.2.2 数据移动指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E6%A0%88%E6%95%B0%E6%8D%AE"><span class="nav-text">3.2.3 压入和弹出栈数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="nav-text">3.2.4 代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C"><span class="nav-text">3.3 算术和逻辑操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6"><span class="nav-text">3.4 控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="nav-text">3.4.1 条件码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">3.4.2 条件码的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-text">3.4.3 跳转指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF"><span class="nav-text">3.4.4 用条件控制实现条件分支</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%9D%A1%E4%BB%B6%E7%A7%BB%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF"><span class="nav-text">3.4.5 用条件移动实现条件分支</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-text">3.4.6 循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E5%88%86%E6%94%AF"><span class="nav-text">3.4.7 多重分支</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B"><span class="nav-text">3.5 过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88"><span class="nav-text">3.5.1 运行时栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6%E6%9D%83"><span class="nav-text">3.5.2 转移控制权</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="nav-text">3.5.3 传递数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E4%B8%8A%E7%9A%84%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8"><span class="nav-text">3.5.4 栈上的局部存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4"><span class="nav-text">3.5.5 寄存器中的局部存储空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-text">3.5.6 递归</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E8%AE%BF%E9%97%AE"><span class="nav-text">3.6 数组的分配和访问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E6%95%B0%E7%BB%84"><span class="nav-text">3.6.1 嵌套数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E9%95%BF%E6%95%B0%E7%BB%84"><span class="nav-text">3.6.2 定长数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84"><span class="nav-text">3.6.3 变长数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E8%B4%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">3.7 异质的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">3.7.1 结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E5%90%88%E4%BD%93"><span class="nav-text">3.7.2 联合体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90"><span class="nav-text">3.7.3 数据对齐</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%9C%BA%E5%99%A8%E7%BA%A7%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%BB%93%E5%90%88%E6%8E%A7%E5%88%B6%E5%92%8C%E6%95%B0%E6%8D%AE"><span class="nav-text">3.8 在机器级程序中结合控制和数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#gdb%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">3.8.1 GDB的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C%E5%BC%95%E7%94%A8%E5%92%8C%E7%BC%93%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-text">3.8.2 内存越界引用和缓存溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E6%8A%97%E7%BC%93%E5%AD%98%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB"><span class="nav-text">3.8.3 对抗缓存溢出攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%95%BF%E6%A0%88%E5%B8%A7"><span class="nav-text">3.8.4 变长栈帧</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E4%BB%A3%E7%A0%81"><span class="nav-text">3.9 浮点代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E7%A7%BB%E5%8A%A8%E5%92%8C%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="nav-text">3.9.1 浮点移动和转换操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C"><span class="nav-text">3.9.2 浮点运算操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%B8%B8%E6%95%B0"><span class="nav-text">3.9.3 浮点常数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E4%BD%8D%E7%BA%A7%E6%93%8D%E4%BD%9C%E5%92%8C%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C"><span class="nav-text">3.9.4 浮点位级操作和比较操作</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《深入理解计算机系统 第3版》第3章 程序的机器级表示 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《深入理解计算机系统 第3版》第3章 程序的机器级表示</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-01-02 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-02T00:00:00+08:00">2023-01-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-05-02 00:00:00" itemprop="dateModified" datetime="2023-05-02T00:00:00+08:00">2023-05-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/computer-system/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>42k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　计算机执行<strong>机器代码</strong>，即字节序列编码的底层操作，包括操作数据、管理内存、从存储设备中读写和网络通信。编译器根据编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列阶段生成机器代码。GCC以<strong>汇编代码</strong>的形式生成输出，汇编代码是机器代码的文本表示，给出了程序的所有指令。然后，GCC调用<strong>汇编器</strong>和<strong>链接器</strong>根据汇编代码生成可执行的机器代码。</p><p>　　8086 (1978年，29K个晶体管) 是第1代16位处理器之一。8088是8086的变种，在其基础上增加了1个8位外部总线，作为最初的IBM个人计算机的心脏。1980年，Intel推出了8087浮点协处理器 (45K个晶体管)，它与8086或8088一同运行，执行浮点指令。8087建立了x86系列的浮点模型，称为x87。</p><p>　　80286 (1982年，134K个集体管) 增加了更多的寻址模式 (现已过时)，它是IBM PC-AT个人计算机的基础，这种计算机是Windows最初的使用平台。</p><p>　　i386 (1985年，275K个晶体管) 将体系结构扩展到32位并增加了<span style="background-color:#ff0">平坦寻址模式</span>，这是Intel系列中首个全面支持Unix的机器。</p><p>　　i486 (1989年，1.2M个晶体管) 在提高性能的同时将浮点单元集成到了CPU芯片，但指令集没有明显的变化。</p><p>　　Pentium (1993年，3.1M个晶体管) 提高了性能，仅对指令集进行了小扩展。</p><p>　　PentiumPro (1995年，5.5M个晶体管) 采用了全新的CPU设计，在内部称为P6微体系架构，指令集增加了1类<span style="background-color:#ff0">条件移动</span>指令。</p><p>　　Pentium/MMX (1997年，4.5M个晶体管) 在Pentium CPU中增加了1类新的处理整数向量的指令。每个数据可以是8、16或32位。每个向量都是64位。</p><p>　　Pentium II (1997年，7M个晶体管) 是P6微体系结构的延续。</p><p>　　Pentium III (1999年，8.2M个晶体管) 使用了SSE，这是1类处理整数或浮点数向量的指令。每个数据可以是8、16或32位，打包成128位的向量。由于芯片里有L2缓存，该芯片后来的版本最多使用了24M个晶体管。</p><p>　　Pentium 4 (2000年，42M个晶体管) 将SSE扩展到了SSE2，增加了新的数据类型 (包括双精度浮点) 以及相关的144条新指令。有了这些扩展，编译器可以使用SSE指令而非x87指令来编译浮点代码。</p><p>　　Pentium 4E (2004年，125M个晶体管) 增加了超线程和EM64T。EM64T是Intel对AMD开发的IA32的64位扩展的实现，称为x86-64。</p><p>　　Core 2 (2006年，291M个晶体管) 回归到类似于P6的微体系架构，也是Intel的首个多核CPU，但不支持超线程。</p><p>　　每个后继CPU的设计都是向后兼容的，所以指令集中有许多奇怪的东西。</p><span id="more"></span><p>　　虽然GCC在把程序中表达的计算转换到机器代码方面表项出色，但有些机器特性是C程序访问不到的。例如，每次x86-64 CPU执行算术或逻辑运算时，若得到的运算结果的低8位有偶数个1，则把1位的<span style="background-color:#ff0">奇偶标志</span>PF置1；否则，置0。C语言中计算这个信息至少需要7次移位、掩码和异或运算，而几行汇编代码就可以完成这项任务。硬件将奇偶标志的计算作为算术或逻辑运算的一部分来执行，但C程序无法得知PF的值。</p><p>　　在C语言程序中插入汇编代码有2种方法。第1种是编写完整的函数，放进单独的汇编代码文件中，并用汇编器和链接器将它和C语言代码合并。第2种方法是使用GCC的<span style="background-color:#ff0">内联汇编</span>，用关键字<code>asm</code>在C程序中加入简短的汇编代码，这种方法可以减少特定于机器的代码。</p><p>　　大多数指令都有<strong>操作数</strong>，表示源数据和结果的存储位置。</p><p>　　由于16位体系结构发展成了32位，Intel用<strong>字</strong>表示16位数据类型，所以32位数据类型称为<strong>双字</strong>，64位数据类型称为<strong>四字</strong>，128位数据类型称为<strong>八字</strong>。</p><p>　　之后内容使用的都是<span style="background-color:#ff0">ATT</span>格式汇编代码，根据曾经运营过贝尔实验室的公司AT&amp;T命名，这是GCC、OBJDUMP和其他工具的默认格式。其他一些编程工具 (包括Microsoft的工具) 以及来自Intel的文档，其汇编格式都是Intel格式，这2种格式在许多方面有所不同。</p><p>　　● 相比ATT汇编代码，Intel汇编代码省略了表示大小的后缀，例如，ATT汇编代码的<code>pushq</code>和<code>movq</code>指令对应Intel汇编代码的<code>push</code>和<code>mov</code>指令。</p><p>　　● 相比ATT汇编代码，Intel汇编代码省略了寄存器名称前的<code>%</code>，例如，ATT汇编代码中的寄存器<code>%rbx</code>对应Intel汇编代码中的<code>rbx</code>。</p><p>　　● ATT汇编代码和Intel汇编代码描述内存中位置的方式不同，例如，ATT汇编代码中的<code>(%rbx)</code>对应Intel汇编代码中的<code>QWORD PTR [rbx]</code>。</p><p>　　● 对于有多个操作数的指令，ATT汇编代码和Intel汇编代码操作数的顺序相反。</p><p>　　逆向工程中理解汇编代码和源代码之间的关系的关键是找到程序值和寄存器之间的映射关系。GCC会重组计算，因为有些C语言代码中的变量在汇编代码中没有对应的值，有时会在汇编代码中加入源代码中不存在的值。此外，GCC还经常试图将多个程序值映射到1个寄存器上来最小化寄存器的使用。GCC执行的部分映射并非一定能提高性能，反而可能降低性能。</p><h3 id="程序编码">3.1 程序编码</h3><p>　　若某C程序有<code>p1.c</code>和<code>p2.c</code>两个文件，其编译指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Og -o p p1.c p2.c</span><br></pre></td></tr></table></figure><p>　　<code>gcc</code>表示GCC。命令行选项<code>-Og</code>表示GCC生成符合原始C语言代码体系优化等级的机器代码，因为使用较高级别优化生成的代码会严重变形，导致生成的机器代码和源代码之间看似毫无关联。从性能角度，<code>-O1</code>或<code>-O2</code>是更好的选择。</p><table><thead><tr><th>C语言声明 (x86-64)</th><th>Intel数据类型</th><th>汇编代码后缀</th><th>大小 (单位是B)</th></tr></thead><tbody><tr><td><code>char</code></td><td>字节</td><td><code>b</code></td><td>1</td></tr><tr><td><code>short</code></td><td>字</td><td><code>w</code></td><td>2</td></tr><tr><td><code>int</code></td><td>双字</td><td><code>l</code></td><td>4</td></tr><tr><td><code>long</code></td><td>四字</td><td><code>q</code></td><td>8</td></tr><tr><td><code>char *</code></td><td>四字</td><td><code>q</code></td><td>8</td></tr><tr><td><code>float</code></td><td>单精度</td><td><code>s</code></td><td>4</td></tr><tr><td><code>double</code></td><td>双精度</td><td><code>l</code></td><td>8</td></tr></tbody></table><p>　　部分GCC生成的汇编代码中会有表示操作数大小的后缀。例如，数据移动指令<code>mov</code>有4个变种，即<code>movb</code>、<code>movw</code>、<code>movl</code>和<code>movq</code>，后缀<code>l</code>可以表示4B的<code>int</code>和8B的<code>double</code>，但这不会产生歧义，因为浮点数使用一组完全不同的指令和寄存器。</p><p>　　浮点数分为单精度和双精度，对应C语言中的<code>float</code>和<code>double</code>。x86系的CPU也支持特殊的80位 (10B) 浮点格式，在C语言中可以使用<code>long double</code>来声明，这种格式不能移植到其他类型的机器，而且也不如单精度和双精度浮点运算高效。</p><h4 id="机器级代码">3.1.1 机器级代码</h4><p>　　对机器级编程，有2种抽象模型很重要。第1种抽象是由<strong>指令集架构</strong>来定义机器级程序的格式和行为，它定义了CPU状态、指令格式以及每条指令对状态的影响。大多数ISA将程序的行为描述为每条指令按序执行，但CPU的硬件远不如此精简，它们并发执行指令，但可以保证整体行为与ISA指定的执行顺序一致。第2种抽象是机器级程序使用的内存地址是虚拟地址，提供的内存模型看似1个很大的字节数组。</p><p>　　x86-64的机器代码和原始的C语言代码差距很大，一些通常对C语言隐藏的处理状态都是可见的。</p><p>　　● <span style="background-color:#ff0">程序计数器</span> (在x86-64中用<code>%rip</code>表示) 给出待执行的下一条指令的内存地址。</p><p>　　● <span style="background-color:#ff0">整数寄存器</span>包含16个用于存储64位值的已命名的位置，可以存储地址 (对应C语言的指针) 或整型数据。有些寄存器用于记录某些重要的程序状态，其他寄存器用于存储临时数据，例如，过程中的参数和局部变量以及函数返回值。</p><p>　　● <span style="background-color:#ff0">条件码寄存器</span>保存最近执行的算术或逻辑指令的状态信息，用于实现控制或数据流中的条件改变，例如，<code>if</code>和<code>while</code>语句。</p><p>　　● 一组<span style="background-color:#ff0">向量寄存器</span>可以存储若干个整数或浮点值。</p><p>　　虽然C语言提供了1种不同数据类型可以声明和分配内存的模型，但机器代码只是将内存视为1个按字节寻址的大数组。C语言中的聚合类型 (例如，数组和结构) 在机器代码中用一组连续的字节表示。即使对标量数据类型，汇编代码也不区分有符号和无符号整数，不区分各种类型的指针，甚至不区分指针和整数。</p><p>　　程序内存包含程序的可执行机器代码、操作系统所需的信息、用于管理过程调用和返回的运行时栈和用户分配的内存块 (例如，通过库函数<code>malloc()</code>分配)。程序使用虚拟内存寻址，在任意给定的时刻，只有虚拟内存的部分区域有效。例如，x86-64的虚拟地址由1个64位的字表示，在目前的实现中，地址的高16位必须设置为0，所以地址的实际范围是<span class="math inline">\(2^{48}\)</span>。操作系统负责管理虚拟内存地址并将其转换为内存中的物理地址。</p><p>　　1条机器指令仅执行很基本的操作，例如，将存储在寄存器中的两个数相加，在存储器和寄存器之间移动数据以及条件分支移动到新的指令地址，编译器必须生成指令的序列从而实现程序结构。</p><h4 id="代码示例">3.1.2 代码示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mstore.c */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span>, <span class="type">long</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> t = mult2(x, y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Og -S mstore.c</span><br></pre></td></tr></table></figure><p>　　执行这条命令后，GCC会根据<code>mstore.c</code>生成汇编代码，但不会进一步执行编译流程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	.file	&quot;010-mstore.c&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl	multstore</span><br><span class="line">	.type	multstore, @function</span><br><span class="line">multstore:</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	movq	%rdx, %rbx</span><br><span class="line">	call	mult2</span><br><span class="line">	movq	%rax, (%rbx)</span><br><span class="line">	addq	$32, %rsp</span><br><span class="line">	popq	%rbx</span><br><span class="line">	ret</span><br><span class="line">	.seh_endproc</span><br><span class="line">	.ident &quot;GCC: (Ubuntu 4.8.1-2ubuntu1~12.04) 4.8.1&quot;</span><br><span class="line">	.section .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure><p>　　这是<code>mstore.s</code>的完整内容。<code>.</code>开头的行是<strong>汇编指示</strong>，用于引导汇编器和链接器，通常可以忽略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">multstore:</span><br><span class="line">    pushq	%rbx</span><br><span class="line">    movq	%rdx,%rbx</span><br><span class="line">    call	mult2</span><br><span class="line">    movq	%rax,(%rbx)</span><br><span class="line">    popq	%rbx</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>　　为了更清楚地说明汇编代码，这里省略了大部分汇编指示。<code>mstore.c</code>中每个缩进的行都对应1条机器指令。例如，<code>pushq</code>指令表示将寄存器<code>%rbx</code>中的内容压入程序栈中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Og -c mstore.c</span><br></pre></td></tr></table></figure><p>　　执行这条这条命令后，GCC会编译并汇编该代码，即生成目标代码文件<code>mstore.o</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3</span><br></pre></td></tr></table></figure><p>　　这是汇编指令对应的目标代码，从中可以看出，机器执行的程序只是字节序列，即一系列指令的编码。</p><p>　　<strong>反汇编器</strong>可以查看机器代码文件的内容，可以根据机器代码生成类似汇编格式的代码，例如，Linux系统中的<code>objdump</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d mstore.o</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;multstore&gt;:</span><br><span class="line">0:	53		push	%rbx</span><br><span class="line">1:	48 89 d3	mov	%rdx,%rbx</span><br><span class="line">4:	e8 00 00 00 00	callq	9 &lt;multstore+0x9&gt;</span><br><span class="line">9:	48 89 03	mov	%rax,(%rbx)</span><br><span class="line">c:	5b		pop	%rbx</span><br><span class="line">d:	c3		retq</span><br></pre></td></tr></table></figure><p>　　左边是前面看到的14个十六进制数，它们分成若干组，每组长度为1B~5B且对应右边的指令。</p><p>　　● x86-64指令长度从1B~15B不等，常用或操作数较少的指令长度较短，不常用或操作数较多的指令长度较长。</p><p>　　● 指令格式是从某个给定位置开始将字节唯一地解码成机器指令的方式。例如，只有<code>pushq %rbx</code>以字节值53开始。</p><p>　　● 反汇编器只是基于机器代码文件中的字节序列来生成汇编代码，并不需要访问程序的源代码或汇编代码。</p><p>　　● 反汇编器使用的指令命名规则与GCC生成的汇编代码有细微差别。例如，反汇编输出中省略了部分指令的后缀<code>q</code>。指令<code>callq</code>和<code>retq</code>对应<code>call</code>和<code>ret</code>，后缀<code>q</code>只是为了强调这是x86-64指令而非IA32，在x86-64汇编代码中，两者没有区别。</p><p>　　生成实际可执行的代码需要对目标代码文件运行链接器，而目标代码文件中必须包含主函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span>, <span class="type">long</span>, <span class="type">long</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> d;</span><br><span class="line">    multstore(<span class="number">2</span>, <span class="number">3</span>, &amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2 * 3 --&gt; %d\n&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> s = a * b;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Og -o prog main.c mstore.c</span><br></pre></td></tr></table></figure><p>　　<code>prog</code>的大小是8655B，因为它不仅包含编写的代码，还包括用于启动和终止程序以及与操作系统交互的代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d prog</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000400540 &lt;multstore&gt;:</span><br><span class="line">400540:	53		push %rbx</span><br><span class="line">400541:	48 89 d3 	mov %rdx,%rbx</span><br><span class="line">400544:	e8 42 00 00 00	callq 40058b &lt;mult2&gt;</span><br><span class="line">400549:	48 89 03	mov %rax,(%rbx)</span><br><span class="line">40054c:	5b		pop %rbx</span><br><span class="line">40054d:	c3		retq</span><br><span class="line">40054e:	90		nop</span><br><span class="line">40054f:	90		nop</span><br></pre></td></tr></table></figure><p>　　这是反汇编器生成的代码的一部分，这段代码与<code>mstore.c</code>反汇编生成的代码几乎相同，但也有区别。第1个区别是左边列出的地址不同——链接器将这段代码的位置移动到一段不同的地址范围中。第2个区别是链接器填上了指令<code>callq</code>调用函数<code>mult2()</code>需要使用的地址 (第4行)，这体现了链接器的任务之一——为函数调用找到对应可执行代码的位置。第3个区别是结尾多了2行代码 (第8~9行)，它们对程序没有影响，因为出现返回指令 (第7行) 之后。插入这些指令是为了让函数代码变为16B，以便于更好地放置下一个代码块。</p><h3 id="访问信息">3.2 访问信息</h3><img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/16_integer_registers.svg" title="16_integer_registers"><p>　　x86-64 CPU包含16个64位的<strong>通用目的寄存器</strong>，这些寄存器用于存储整型数据和指针。它们都以<code>%r</code>开头，后面跟着一些根据不同命名规则命名的名称 (由于指令集历史的演化)。最初的8086有8个16位的寄存器，即<code>%ax</code>到<code>%sp</code>。每个寄存器都有特殊的用途，其名称反映了这些用途。扩展到IA32架构时，这些寄存器也扩展成32位寄存器，即从<code>%eax</code>到<code>%esp</code>。扩展到64位时，原来的8个寄存器也扩展成64位，即<code>%rax</code>到<code>%rsp</code>，此外，还增加了8个新寄存器，它们都根据新的命名规则命名，即<code>%r8</code>到<code>%r15</code>。</p><h4 id="操作数指示符">3.2.1 操作数指示符</h4><p>　　操作数中的源数据可以是常数，也可以从寄存器或内存中读取，结果可以存储在寄存器或内存中。因此，操作数大致可以分为3种类型。</p><p>　　● 第1种类型是<strong>立即数</strong>，用于表示常数。在ATT汇编代码中，立即数的格式是<code>$</code>加上用C语言风格表示的整数，例如，<code>$-577</code>或<code>$0x1F</code>。不同指令允许的立即数范围不同。汇编器会自动选择最紧凑的方式进行数组编码。</p><p>　　● 第2种类型是<strong>寄存器</strong>，用于表示寄存器的内容，16个寄存器的低8、16、32或64位都可以作为操作数。</p><p>　　● 第3种类型是<strong>内存引用</strong>，用于根据计算出来的地址 (通常称为<strong>有效地址</strong>) 访问某个内存位置。由于内存可以视很大的字节数组，所以这里用<span class="math inline">\(M_b[Addr]\)</span>表示从地址<span class="math inline">\(Addr\)</span>开始的<span class="math inline">\(b\)</span>个字节值的引用。为了简便，可以省略<span class="math inline">\(b\)</span>。</p><table><colgroup><col style="width:8%"><col style="width:23%"><col style="width:42%"><col style="width:26%"></colgroup><thead><tr><th>类型</th><th>格式</th><th>操作数值</th><th>名称</th></tr></thead><tbody><tr><td>立即数</td><td><span class="math inline">\(\$Imm\)</span></td><td><span class="math inline">\(Imm\)</span></td><td>立即数寻址</td></tr><tr><td>寄存器</td><td><span class="math inline">\(r_a\)</span></td><td><span class="math inline">\(R[r_a]\)</span></td><td>寄存器寻址</td></tr><tr><td>存储器</td><td><span class="math inline">\(Imm\)</span></td><td><span class="math inline">\(M[Imm]\)</span></td><td>直接/绝对寻址</td></tr><tr><td>存储器</td><td><span class="math inline">\((r_a)\)</span></td><td><span class="math inline">\(M[R[r_a]]\)</span></td><td>间接寻址</td></tr><tr><td>存储器</td><td><span class="math inline">\(Imm(r_b)\)</span></td><td><span class="math inline">\(M[Imm+R[r_b]]\)</span></td><td>(基址+偏移量) 寻址</td></tr><tr><td>存储器</td><td><span class="math inline">\((r_b,r_i)\)</span></td><td><span class="math inline">\(M[R[r_b]+R[r_i]]\)</span></td><td>变址寻址</td></tr><tr><td>存储器</td><td><span class="math inline">\(Imm(r_b,r_i)\)</span></td><td><span class="math inline">\(M[Imm+R[r_b]+[r_i]]\)</span></td><td>变址寻址</td></tr><tr><td>存储器</td><td><span class="math inline">\((,r_i,s)\)</span></td><td><span class="math inline">\(M[R[r_i]\cdot s]\)</span></td><td>比例变址寻址</td></tr><tr><td>存储器</td><td><span class="math inline">\(Imm(,r_i,s)\)</span></td><td><span class="math inline">\(M[Imm+R[r_i]\cdot s]\)</span></td><td>比例变址寻址</td></tr><tr><td>存储器</td><td><span class="math inline">\((r_b,r_i,s)\)</span></td><td><span class="math inline">\(M[R[r_b]+R[r_i]\cdot s]\)</span></td><td>比例变址寻址</td></tr><tr><td>存储器</td><td><span class="math inline">\(Imm(r_b,r_i,s)\)</span></td><td><span class="math inline">\(M[Imm+R[r_b]+R[r_i]\cdot s]\)</span></td><td>比例变址寻址</td></tr></tbody></table><p>　　有不同的<strong>寻址模式</strong>允许不同形式的内存引用。<span class="math inline">\(Imm(r_b,r_i,s)\)</span>是最常用的形式，<span class="math inline">\(Imm\)</span>表示立即数偏移，<span class="math inline">\(r_b\)</span>表示基址寄存器 (64位)，<span class="math inline">\(r_i\)</span>表示变址寄存器 (64位)，<span class="math inline">\(s\)</span>表示比例因子 (必须是1、2、4或8)，地址计算公式是<span class="math inline">\(Imm+R[r_b]+R[r_i]\cdot s\)</span>。引用数组时会用到这种通用形式，其他形式都是这种通用形式的变体 (省略部分元素)。</p><h4 id="数据移动指令">3.2.2 数据移动指令</h4><table><thead><tr><th>指令</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td><code>MOV S, D</code></td><td><code>D</code> ← <code>S</code></td><td>移动</td></tr><tr><td><code>movb</code></td><td></td><td>移动字节</td></tr><tr><td><code>movw</code></td><td></td><td>移动字</td></tr><tr><td><code>movl</code></td><td></td><td>移动双字</td></tr><tr><td><code>movq</code></td><td></td><td>移动四字</td></tr><tr><td><code>movabsp I, R</code></td><td><code>R</code> ← <code>I</code></td><td>移动完整的四字</td></tr></tbody></table><p>　　数据移动指令的源操作数可以是立即数、寄存器或内存引用，目的操作数可以是寄存器或内存引用。x86-64要求数据移动指令的操作数不能都是内存引用。将值从某个内存位置复制到其他内存位置需要2条指令——第1条指令将值加载到寄存器，第2条指令将值从寄存器写入到目的位置。</p><p>　　指令<code>movq</code>只能以32位值作为源操作数，它会把这个值符号扩展 (复制最高位) 到64位并移动目的位置。指令<code>movabsp</code>以64位值作为源操作数，但只能以寄存器作为目的操作数。</p><p>　　数据移动指令需要和整数寄存器的大小相匹配。大多数情况下，数据移动指令只会更新目的操作数指定的位置。唯一的例外是指令<code>movl</code>的目的操作数是寄存器时，它会把该寄存器的高4B置0，因为x86-64的惯例——任何为寄存器生成32位值的指令都会把该寄存器的<span style="background-color:#ff0">高位部分置0</span>。</p><table><thead><tr><th>零扩展数据移动指令</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td><code>MOVZ S, R</code></td><td><code>R</code> ← <code>S</code> (零扩展)</td><td>以零扩展进行移动</td></tr><tr><td><code>movzbw</code></td><td></td><td>将零扩展后的字节移动到字</td></tr><tr><td><code>movzbl</code></td><td></td><td>将零扩展后的字节移动到双字</td></tr><tr><td><code>movzwl</code></td><td></td><td>将零扩展后的字移动到双字</td></tr><tr><td><code>movzbq</code></td><td></td><td>将零扩展后的字节移动到四字</td></tr><tr><td><code>movzwq</code></td><td></td><td>将零扩展后的字移动到四字</td></tr></tbody></table><table><colgroup><col style="width:27%"><col style="width:35%"><col style="width:37%"></colgroup><thead><tr><th>符号扩展数据移动指令</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td><code>MOVS S, R</code></td><td><code>R</code> ← <code>S</code> (符号扩展)</td><td>以符号扩展进行移动</td></tr><tr><td><code>movsbw</code></td><td></td><td>将符号扩展后的字节移动到字</td></tr><tr><td><code>movsbl</code></td><td></td><td>将符号扩展后的字节移动到双字</td></tr><tr><td><code>movswl</code></td><td></td><td>将符号扩展后的字移动到双字</td></tr><tr><td><code>movsbq</code></td><td></td><td>将符号扩展后的字节移动到四字</td></tr><tr><td><code>movswq</code></td><td></td><td>将符号扩展后的字移动到四字</td></tr><tr><td><code>movslq</code></td><td></td><td>将符号扩展后的双字移动到四字</td></tr><tr><td><code>cltq</code></td><td><code>%rax</code> ← <code>%eax</code> (符号扩展)</td><td>将<code>%eax</code>符号扩展到<code>%rax</code></td></tr></tbody></table><p>　　<span style="background-color:#ff0">零扩展数据移动指令</span>和<span style="background-color:#ff0">符号扩展数据移动指令</span>用于将较小的源操作数 (寄存器或内存引用) 复制到较大的目的操作数 (寄存器)。这2类指令的最后2个字符分别表示源操作数和目的操作数的大小。零扩展数据移动指令中并没有将4B源操作数移动到8B目的操作数的指令，因为指令<code>movl</code>可以实现这个功能。指令<code>cltq</code>没有操作数，因为源操作数只能是<code>%eax</code>，目的操作数只能是<code>%rax</code>，等同于<code>movslq %eax, %rax</code>。</p><h4 id="压入和弹出栈数据">3.2.3 压入和弹出栈数据</h4><table><colgroup><col style="width:14%"><col style="width:67%"><col style="width:17%"></colgroup><thead><tr><th>指令</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td><code>pushq S</code></td><td><code>R[%rsp]</code> ← <code>R[%rsp] - 8</code>; <code>M[R[%rsp]]</code> ← <code>S</code></td><td>将四字压入栈</td></tr><tr><td><code>popq D</code></td><td><code>D</code> ← <code>M[R[%rsp]]</code>; <code>R[%rsp]</code> ← <code>R[%rsp] + 8</code></td><td>将四字弹出栈</td></tr></tbody></table><p>　　栈是后进先出的数据结构，可以添加或删除元素。通过指令<code>pushq</code>压入 (添加) 元素，通过指令<code>popq</code>弹出 (删除) 元素。栈可用于实现数组，总是从数组的一端 (称为<strong>栈顶</strong>) 插入和删除元素。在x86-64中，程序栈存储在内存中某个区域，栈向下增长，栈顶元素的地址值最小。栈指针<code>%rsp</code><span style="background-color:#ff0">总是</span>保存栈顶元素的地址。</p><p>　　将1个四字压入栈时，会先将栈指针减8，然后将值写入新的栈顶地址。因此，<code>pushq %rbp</code>等价于以下2条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subq  $8, %rsp</span><br><span class="line">movq  %rbp, (%rsp)</span><br></pre></td></tr></table></figure><p>　　编码为机器代码后，指令<code>pushq</code>仅需1B，而这2条指令共需8B。</p><p>　　弹出1个四字时，会先从栈顶读出数据，然后将栈指针加8。因此，<code>popq %rax</code>等价于以下2条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq  (%rsp), %rax</span><br><span class="line">addq  $8, %rsp</span><br></pre></td></tr></table></figure><img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/stack_operation.svg" title="stack_operation"><p>　　因为栈、程序代码和其他形式的程序数据都存储在同一内存中，所以程序可以用标准的内存寻址方式访问栈内的任意位置。</p><h4 id="代码示例-1">3.2.4 代码示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">exchange</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> x = *xp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exchange:</span><br><span class="line">	movq	(%rdi), %rax</span><br><span class="line">	movq	%rsi, (%rdi)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><p>　　这是是函数<code>exchange()</code>的C语言和汇编代码，寄存器<code>%rdi</code>和<code>%rsi</code>分别存储参数<code>xp</code>和<code>y</code>。C语言中的指针实际上是地址。<code>*xp</code>表示读取<code>xp</code>所指位置的值，该操作称为<strong>指针间接引用</strong>。操作符<code>*</code>执行指针间接引用，而操作符<code>&amp;</code>执行取址，例如，<code>&amp;a</code>会创建1个指针，该指针指向保存<code>a</code>的位置。</p><p>　　像<code>x</code>这样的局部变量通常保存储在寄存器中，因为寄存器的存取速度比内存的快很多。</p><p>　　在函数开始执行时，参数<code>xp</code>和<code>y</code>分别存储在寄存器<code>%rdi</code>和<code>%rsi</code>中。第2行指令从内存中读出<code>x</code>并将它存入寄存器<code>%rax</code>中，对应<code>x = *xp</code>。然后，寄存器<code>%rax</code>作为返回值，即<code>x</code>。第3行指令将<code>y</code>写入到寄存器<code>%rdi</code>中的<code>xp</code>指向的内存位置，对应<code>*xp = y</code>。</p><h3 id="算术和逻辑操作">3.3 算术和逻辑操作</h3><table><thead><tr><th>指令</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td><code>leaq S, D</code></td><td><code>D</code> ← <code>&amp;S</code></td><td>加载有效地址</td></tr><tr><td><code>INC D</code></td><td><code>D</code> ← <code>D + 1</code></td><td>加1</td></tr><tr><td><code>DEC D</code></td><td><code>D</code> ← <code>D - 1</code></td><td>减1</td></tr><tr><td><code>NEG D</code></td><td><code>D</code> ← <code>- D</code></td><td>取负</td></tr><tr><td><code>NOT D</code></td><td><code>D</code> ← <code>~ D</code></td><td>取补</td></tr><tr><td><code>ADD S, D</code></td><td><code>D</code> ← <code>D + S</code></td><td>加</td></tr><tr><td><code>SUB S, D</code></td><td><code>D</code> ← <code>D - S</code></td><td>减</td></tr><tr><td><code>IMUL S, D</code></td><td><code>D</code> ← <code>D * S</code></td><td>乘</td></tr><tr><td><code>XOR S, D</code></td><td><code>D</code> ← <code>D ^ S</code></td><td>异或</td></tr><tr><td><code>OR S, D</code></td><td><code>D</code> ← <code>D | S</code></td><td>或</td></tr><tr><td><code>AND S, D</code></td><td><code>D</code> ← <code>D &amp; S</code></td><td>与</td></tr><tr><td><code>SAL k, D</code></td><td><code>D</code> ← <code>D &lt;&lt; k</code></td><td>左移</td></tr><tr><td><code>SHL k, D</code></td><td><code>D</code> ← <code>D &lt;&lt; k</code></td><td>左移 (等同于<code>SAL</code>)</td></tr><tr><td><code>SAR k, D</code></td><td><code>D</code> ← <code>D &gt;&gt; k</code></td><td>算术右移</td></tr><tr><td><code>SHR k, D</code></td><td><code>D</code> ← <code>D &gt;&gt; k</code></td><td>逻辑右移</td></tr></tbody></table><p>　　x86-64整数和逻辑操作指令可分为<span style="background-color:#ff0">加载有效地址</span>、<span style="background-color:#ff0">一元操作</span>、<span style="background-color:#ff0">二元操作</span>和<span style="background-color:#ff0">移位</span>。</p><p>　　加载有效地址指令<code>leaq</code>实际上是<code>movq</code>的变体，其指令形式是从内存读数据到寄存器，但实际上不会引用内存。第1个操作数看似是内存引用，但并非从指定的位置读取数据，而是将有效地址写入到目的操作数，所以用C语言中的取址操作符<code>&amp;</code>表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">scale</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> t = x + y * <span class="number">4</span> + <span class="number">12</span> * z;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scale:</span><br><span class="line">	leaq	(%rdi,%rsi,4), %rax</span><br><span class="line">	leaq	(%rdx,%rdx,2), %rdx</span><br><span class="line">	leaq	(%rax,%rdx,4), %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><p>　　<code>leaq</code>指令能执行加法和有限形式的乘法，在编译简单的算术表达式时很有用。</p><p>　　一元操作指令只有1个操作数，这个操作数既是源操作数又是目的操作数，可以是寄存器或内存引用。</p><p>　　二元操作指令有2个操作数，第2个操作数既是源操作数又是目的操作数。第1个操作数可以是任何类型，第2个操作数可以是寄存器或内存引用。当第2个操作数是内存引用时，必须先从内存中读出数据并执行操作，然后把结果回写到内存。</p><p>　　移位操作指令的第1个操作数是移位量，第2个操作数是待移位的数。移位量可以是立即数或单字节寄存器<code>%cl</code>中的值 (最大移位量为<span class="math inline">\(2^8-1\)</span>)。左移指令有<code>SAL</code>和<code>SHL</code>，两者效果相同，都是在右边填上0。右移指令有<code>SAR</code>和<code>SHR</code>，前者是算术右移 (填上符号位)，后者是逻辑右移 (填上0)。x86-64中，对<span class="math inline">\(w\)</span>位的数据移位时，移位量由寄存器<code>%cl</code>中的低<span class="math inline">\(m\)</span>位决定，其中<span class="math inline">\(2^m=w\)</span>，高位会被忽略。例如，当寄存器<code>%cl</code>值为<code>0xFF</code>时，指令<code>salb</code>会左移7位，指令<code>salw</code>会左移15位，指令<code>sall</code>会左移31位，指令<code>salq</code>会左移63位。</p><p>　　2个64位有符号数或无符号数的乘积需要128位来表示。x86-64指令集对128位数据类型提供了支持。</p><table><colgroup><col style="width:12%"><col style="width:75%"><col style="width:12%"></colgroup><thead><tr><th>指令</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td><code>imulq S</code></td><td><code>R[%rdx], R[%rax]</code> ← <code>S * R[%rax]</code></td><td>有符号乘法</td></tr><tr><td><code>mulq S</code></td><td><code>R[%rdx], R[%rax]</code> ← <code>S * R[%rax]</code></td><td>无符号乘法</td></tr><tr><td><code>clto</code></td><td><code>R[%rdx], R[%rax]</code> ← <code>R[%rax]</code> (符号扩展)</td><td>转换为八字</td></tr><tr><td><code>idivq S</code></td><td><code>R[%rdx]</code> ← <code>R[%rdx]:R[%rax] % S</code>；<code>R[%rax]</code> ← <code>R[%rdx]:R[%rax] / S</code></td><td>有符号除法</td></tr><tr><td><code>divq S</code></td><td><code>R[%rdx]</code> ← <code>R[%rdx]:R[%rax] % S</code>；<code>R[%rax]</code> ← <code>R[%rdx]:R[%rax] / S</code></td><td>无符号除法</td></tr></tbody></table><p>　　乘法指令除了双操作数指令，还有单操作数指令，即<code>mulq</code>和<code>imulq</code>。这2条指令都要求一个参数存储在寄存器<code>%rax</code>中，另一个参数数作为指令的源操作数给出。乘积的高64位存储在寄存器<code>%rdx</code>中，低64位存储在寄存器<code>%rax</code>中。指令<code>imulq</code>的操作数可以是1或2个，汇编器会根据操作数的数量来分辨。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> __int128 <span class="type">uint128_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">store_upord</span><span class="params">(<span class="type">uint128_t</span> *dest, <span class="type">uint64_t</span> x, <span class="type">uint64_t</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    *dest = x * (<span class="type">uint128_t</span>)y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">store_upord:</span><br><span class="line">	movq	%rsi, %rax</span><br><span class="line">	mulq	%rdx</span><br><span class="line">	movq	%rax, (%rdi)</span><br><span class="line">	movq	%rdx, 8(%rdi)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><p>　　存储乘积需要使用2次指令<code>movq</code>，分别存储低64位和高64位。由于生成这段代码的是小端机器，所以高64位存储在较大的地址。</p><p>　　除法指令也是单操作数指令，被除数的高64位存储在寄存器<code>%rdx</code>中，低64位存储在寄存器<code>%rax</code>中，除数作为操作数，商存储在寄存器<code>%rax</code>中，余数存储在寄存器<code>%rdx</code>中。</p><p>　　对于大多数64位应用程序，被除数通常也是64位，存储在寄存器<code>%rax</code>中，寄存器<code>%rdx</code>应该全为0 (无符号运算) 或符号位 (有符号运算)。64位有符号被除数符号扩展到128位可以通过指令<code>cqto</code>实现 (对应Intel格式中指令<code>cqo</code>)，该指令不需要操作数，默认读取寄存器<code>%rax</code>的符号位并复制到寄存器<code>%rdx</code>的所有位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remdiv</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> *qp, <span class="type">long</span> *rp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> q = x / y;</span><br><span class="line">    <span class="type">long</span> r = x % y;</span><br><span class="line">    *qp = q;</span><br><span class="line">    *rp = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">remdiv:</span><br><span class="line">	movq	%rdx, %r8</span><br><span class="line">	movq	%rdi, %rax</span><br><span class="line">	cqto</span><br><span class="line">	idivq	%rsi</span><br><span class="line">	movq	%rax, (%r8)</span><br><span class="line">	movq	%rdx, (%rcx)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><p>　　在这个示例中，会先把参数<code>qp</code>保存到寄存器<code>%r8</code>，因为除法会使用寄存器<code>%rdx</code>。然后准备被除数并进行符号扩展。除法完成后，将寄存器<code>%rax</code>中的商保存到<code>qp</code>，寄存器<code>%rdx</code>中的余数保存到<code>rp</code>。</p><h3 id="控制">3.4 控制</h3><p>　　机器代码提供了2种基本的底层机制来实现条件行为，即先判断数据值，再根据判断结果来改变控制流或数据流。</p><h4 id="条件码">3.4.1 条件码</h4><p>　　除了整数寄存器，CPU还维护着一组单个位的<strong>条件码</strong>寄存器，它们表示最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。</p><p>　　● 进位标志CF为1时，表示最近的操作使最高位产生了进位，可用来检测无符号操作的溢出。</p><p>　　● 零标志ZF为1时，表示最近的操作得到的结果为0。</p><p>　　● 符号标志SF为1时，表示最近的操作得到的结果为负。</p><p>　　● 溢出标志OF为1时，表示最近的操作导致补码溢出 (无论正负)。</p><p>　　指令<code>leaq</code>不会设置条件码寄存器，因为它用于取址。对于逻辑操作，CF和OF都会置0。对于移位操作，CF会设置为最后1个被移出的位，而OF会置0。指令<code>INC</code>和<code>DEC</code>会设置OF和ZF，但不会改变CF。</p><table><thead><tr><th>指令</th><th>基于</th><th>描述</th></tr></thead><tbody><tr><td><code>CMP S1, S2</code></td><td><code>S2 - S1</code></td><td>比较</td></tr><tr><td><code>cmpb</code></td><td></td><td>比较字节</td></tr><tr><td><code>cmpw</code></td><td></td><td>比较字</td></tr><tr><td><code>cmpl</code></td><td></td><td>比较双字</td></tr><tr><td><code>cmpq</code></td><td></td><td>比较四字</td></tr></tbody></table><p>　　指令<code>CMP</code>和<code>SUB</code>的行为相同，但<code>CMP</code>只设置条件码而不更新目的寄存器。若2个操作数相等，<code>CMP</code>会将ZF置1。</p><table><thead><tr><th>指令</th><th>基于</th><th>描述</th></tr></thead><tbody><tr><td><code>TEST S1, S2</code></td><td><code>S1 &amp; S2</code></td><td>判断</td></tr><tr><td><code>testb</code></td><td></td><td>判断字节</td></tr><tr><td><code>testw</code></td><td></td><td>判断字</td></tr><tr><td><code>testl</code></td><td></td><td>判断双字</td></tr><tr><td><code>testq</code></td><td></td><td>判断四字</td></tr></tbody></table><p>　　指令<code>TEST</code>和<code>AND</code>的行为相同，但<code>TEST</code>只设置条件码而不更新目的寄存器。指令<code>TEST</code>可用于判断两个操作数是否相同和实现掩码，例如，<code>testq %rax, %rax</code>可用于检测寄存器<code>%rax</code>的正负。</p><h4 id="条件码的使用">3.4.2 条件码的使用</h4><p>　　条件码通常不会直接读取，常见的用法有<span style="background-color:#ff0">根据条件码将字节置0或1</span>、<span style="background-color:#ff0">条件跳转到程序某个部分</span>和<span style="background-color:#ff0">条件移动数据</span>。</p><table><thead><tr><th>指令</th><th>别名</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td><code>sete D</code></td><td><code>setz</code></td><td><code>D</code> ← <code>ZF</code></td><td>相等或为0</td></tr><tr><td><code>setne D</code></td><td><code>setnz</code></td><td><code>D</code> ← <code>~ZF</code></td><td>不等或非0</td></tr><tr><td><code>sets D</code></td><td></td><td><code>D</code> ← <code>SF</code></td><td>为负</td></tr><tr><td><code>setns D</code></td><td></td><td><code>D</code> ← <code>~SF</code></td><td>非负</td></tr><tr><td><code>setg D</code></td><td><code>setnle</code></td><td><code>D</code> ← <code>~(SF ^ OF) &amp; ~ZF</code></td><td>大于 (有符号)</td></tr><tr><td><code>setge D</code></td><td><code>setnl</code></td><td><code>D</code> ← <code>~(SF ^ OF)</code></td><td>大于等于 (有符号)</td></tr><tr><td><code>setl D</code></td><td><code>setnge</code></td><td><code>D</code> ← <code>SF ^ OF</code></td><td>小于 (有符号)</td></tr><tr><td><code>setle D</code></td><td><code>setng</code></td><td><code>D</code> ← <code>(SF ^ OF) | ZF</code></td><td>小于等于 (有符号)</td></tr><tr><td><code>seta D</code></td><td><code>setnbe</code></td><td><code>D</code> ← <code>~CF &amp; ~ZF</code></td><td>大于 (无符号)</td></tr><tr><td><code>setae D</code></td><td><code>setnb</code></td><td><code>D</code> ← <code>~CF</code></td><td>大于等于 (无符号)</td></tr><tr><td><code>setb D</code></td><td><code>setnae</code></td><td><code>D</code> ← <code>CF</code></td><td>小于 (无符号)</td></tr><tr><td><code>setbe D</code></td><td><code>setna</code></td><td><code>D</code> ← <code>CF | ZF</code></td><td>小于等于 (无符号)</td></tr></tbody></table><p>　　指令<code>SET</code>会根据条件码将字节置0或1，其后缀表示不同的条件。指令<code>SET</code>的操作数是单字节整数寄存器或单字节的内存位置，指令会将操作数置0或1。为了得到32或64位结果，必须将高位置0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">comp</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">comp:</span><br><span class="line">	cmpq	%rsi, %rdi</span><br><span class="line">	setl	%al</span><br><span class="line">	movzbl	%ral, %eax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><p>　　在这个示例中，指令<code>movzbl</code>会把寄存器<code>%eax</code>的高3B和<code>%rax</code>的高4B置0。</p><p>　　假设有符号数<span class="math inline">\(a\)</span>、<span class="math inline">\(b\)</span>和<span class="math inline">\(t\)</span>的补码形式为<span class="math inline">\(\alpha\)</span>、<span class="math inline">\(\beta\)</span>和<span class="math inline">\(\tau\)</span>且<span class="math inline">\(\tau=\alpha-^t_w\beta\)</span>。对于指令<code>sete</code>，当<span class="math inline">\(\tau=0\)</span>时，ZF为1。对于指令<code>setl</code>，在不溢出的情况下 (OF为0)，若<span class="math inline">\(\tau&lt;0\)</span>，则SF为1；若<span class="math inline">\(\tau\geqslant0\)</span>，则SF为0。在溢出的情况下 (OF为1)，若<span class="math inline">\(\tau&lt;0\)</span> (SF为0)，则<span class="math inline">\(a&gt;b\)</span>；若<span class="math inline">\(\tau&gt;0\)</span> (SF为1)，则<span class="math inline">\(a&lt;b\)</span>。</p><p>　　假设无符号数<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>的二进制形式是<span class="math inline">\(\alpha\)</span>和<span class="math inline">\(\beta\)</span>。在计算<span class="math inline">\(\tau=\alpha-^u_w\beta\)</span>时，若<span class="math inline">\(\tau&lt;0\)</span>时，指令<code>CMP</code>会将CF置1，所以无符号数的比较会使用CF和ZF的组合。</p><h4 id="跳转指令">3.4.3 跳转指令</h4><p>　　<strong>跳转</strong>指令可以让指令切换到指定位置。在汇编代码中，跳转目标通常用<strong>标签</strong>指明。</p><table><thead><tr><th>指令</th><th>别名</th><th>跳转条件</th><th>描述</th></tr></thead><tbody><tr><td><code>jmp Label</code></td><td></td><td></td><td>直接跳转</td></tr><tr><td><code>jmp *Operand</code></td><td></td><td></td><td>间接跳转</td></tr><tr><td><code>je Label</code></td><td><code>jz</code></td><td><code>ZF</code></td><td>相等或为0</td></tr><tr><td><code>jne Label</code></td><td><code>jnz</code></td><td><code>~ZF</code></td><td>不等或非0</td></tr><tr><td><code>js Label</code></td><td></td><td><code>SF</code></td><td>为负</td></tr><tr><td><code>jns Label</code></td><td></td><td><code>~SF</code></td><td>非负</td></tr><tr><td><code>jg Label</code></td><td><code>jnle</code></td><td><code>~(SF ^ OF) &amp; ~ZF</code></td><td>大于 (有符号)</td></tr><tr><td><code>jge Label</code></td><td><code>jnl</code></td><td><code>~(SF ^ OF)</code></td><td>大于等于 (有符号)</td></tr><tr><td><code>jl Label</code></td><td><code>jnge</code></td><td><code>SF ^ OF</code></td><td>小于 (有符号)</td></tr><tr><td><code>jle Label</code></td><td><code>jng</code></td><td><code>(SF ^ OF) | ZF</code></td><td>小于等于 (有符号)</td></tr><tr><td><code>ja Label</code></td><td><code>jnbe</code></td><td><code>~CF &amp; ~ZF</code></td><td>大于 (无符号)</td></tr><tr><td><code>jae Label</code></td><td><code>jnb</code></td><td><code>~CF</code></td><td>大于等于 (无符号)</td></tr><tr><td><code>jb Label</code></td><td><code>jnae</code></td><td><code>CF</code></td><td>小于 (无符号)</td></tr><tr><td><code>jbe Label</code></td><td><code>jna</code></td><td><code>CF | ZF</code></td><td>小于等于 (无符号)</td></tr></tbody></table><p>　　指令<code>jmp</code>是无条件跳转指令，可以<strong>直接</strong>或<strong>间接</strong>跳转，例如，<code>jmp .L1</code>和<code>jmp *(%rax)</code>。其他跳转指令都是条件跳转指令，条件跳转只能是直接跳转。</p><p>　　跳转指令有2种编码方式。第1种编码方法是使用<strong>PC相对</strong>地址 (更常用)，即目标指令的地址相对跳转指令的下一条指令的偏移，偏移量可以编码为1、2或4B。第2种编码方法是使用绝对地址，用4B直接指定目标。汇编器和链接器会选择适当的跳转目的编码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	movq	%rdi, %rax</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L3:</span><br><span class="line">	sarq	%rax</span><br><span class="line">.L2:</span><br><span class="line">	testq	%rax, %rax</span><br><span class="line">	jg	.L3</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0:	48 89 f8		mov	%rdi, %rax</span><br><span class="line">3:	eb 03			jmp	8 &lt;loop+0x8&gt;</span><br><span class="line">5:	48 d1 f8		sar	%rax</span><br><span class="line">8:	48 85 c0		test	%rax, %rax</span><br><span class="line">b:	7f f8 			jg	5 &lt;loop+0x5&gt;</span><br><span class="line">d:	f3 c3 			repz retq</span><br></pre></td></tr></table></figure><p>　　这是根据同一C文件生成的汇编代码和反汇编代码。在反汇编代码中，第2行中跳转指令的跳转目标为<code>0x8</code>，第5行中跳转指令的跳转目标是<code>0x5</code>。第1个跳转指令的目标编码 (<span style="background-color:#ff0">单字节补码形式</span>) 是<code>0x3</code>，加上<code>0x5</code>得到下一条指令 (第4行) 的地址<code>0x8</code>。同样，第2个跳转指令的目标编码为<code>0xf8</code>，加上<code>0xd</code>得到下一条指令 (第3行) 的地址<code>0x5</code>。当执行PC相对寻址时，PC的值是跳转指令的下一条指令的地址而非跳转指令本身的地址，这可以追溯到早期的实现，当时的CPU会将更新PC作为执行下一条指令的第1步。</p><p>　　<code>rep; ret</code>是为了避免指令<code>ret</code>成为条件跳转指令的目标，若没有指令<code>rep</code> (表示空操作)，当分支不跳转时，指令<code>jg</code> (第7行) 会继续到<code>ret</code>指令。根据AMD的文档，当指令<code>ret</code>通过跳转指令到达时，CPU不能正确预测到指令<code>ret</code>的目的地。除了能使代码在AMD上运行更快外，这种组合不会改变其他行为。<code>repz retq</code>与之相同。</p><h4 id="用条件控制实现条件分支">3.4.4 用条件控制实现条件分支</h4><p>　　在汇编代码中实现条件分支的最常用的方式是结合有条件和无条件跳转指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> lt_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> ge_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">absdiff_se</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        lt_cnt++;</span><br><span class="line">        result = y - x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ge_cnt++;</span><br><span class="line">        result = x - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">gotodiff_se</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> x_ge_y;</span><br><span class="line">    &#125;</span><br><span class="line">    lt_cnt++;</span><br><span class="line">    result = y - x;</span><br><span class="line">x_ge_y:</span><br><span class="line">    ge_cnt++;</span><br><span class="line">    result = x - y;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">absdiff_se:</span><br><span class="line">	cmpq	%rsi, %rdi</span><br><span class="line">	jge	.L2</span><br><span class="line">	addq	$1, lt_cnt(%rip)</span><br><span class="line">	movq	%rsi, %rax</span><br><span class="line">	subq	%rdi, %rax</span><br><span class="line">	ret</span><br><span class="line">.L2:</span><br><span class="line">	addq	$1, ge_cnt(%rip)</span><br><span class="line">	movq	%rdi, %rax</span><br><span class="line">	subq	%rsi, %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><p>　　第1段代码是计算两数之差绝对值的C语言代码，这里会增加2个计数器，即<code>lt_cnt</code>和<code>ge_cnt</code>。第3段代码是GCC生成的汇编代码，第2段代码是汇编代码的C语言版本 (省略了全局变量的声明)，使用了类似汇编无条件跳转指令的<code>goto</code>，这种风格称为goto代码，这种编程风格并不好，因为它会使代码难以阅读和理解。</p><h4 id="用条件移动实现条件分支">3.4.5 用条件移动实现条件分支</h4><p>　　在汇编代码中实现条件分支的传统方式是<span style="background-color:#ff0">控制</span>的条件移动，当条件满足时，沿对应的路线执行；当条件不满足时，沿其他路径执行。这种机制简单而通用，但在现代CPU上可能非常低效。代替方案是<span style="background-color:#ff0">数据</span>的条件移动，计算条件语句的多种结果并根据条件选取其中之一，该方案会受到一些限制，但更符合现代CPU的性能特性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">absdiff</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        result = y - x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = x - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">cmovdiff</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> rval = y - x;</span><br><span class="line">    <span class="type">long</span> eval = x - y;</span><br><span class="line">    <span class="type">long</span> ntest = x &gt;= y;</span><br><span class="line">    <span class="keyword">if</span> (ntest)</span><br><span class="line">    &#123;</span><br><span class="line">        rval = eval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">absdiff:</span><br><span class="line">	movq	%rsi, %rax</span><br><span class="line">	subq	%rdi, %rax</span><br><span class="line">	movq	%rdi, %rdx</span><br><span class="line">	subq	%rsi, %rdx</span><br><span class="line">	cmpq	%rsi, %rdi</span><br><span class="line">	cmovge	%rdx, %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><p>　　第1段代码是计算两数之差的绝对值，第3段代码是数据的条件移动版本的汇编代码，第2段代码是汇编代码的C语言版本。第2段代码中<code>if</code>语句 (第6~9行) 对应第3段代码中的指令<code>cmp</code>和<code>cmovge</code> (第6~7行)。</p><p>　　CPU通过<strong>流水线</strong>来获取高性能。在流水线中，1条指令的处理要经过一系列阶段，每个阶段执行该过程的一小部分 (例如，从内存读取指令、确定指令类型、从内存读取数据、执行算术运算、将数据写入内存以及更新PC)。这种方式通过重叠连续指令的步骤来获取高性能，例如，从内存读取指令的同时执行前一条指令的算术运算。要做到这一点，要求能够<span style="background-color:#ff0">事先确定待执行的指令序列</span>，这样才能保证流水线里充满待执行的指令。当遇到条件分支 (即跳转) 时，只有当分支条件求值完成后，才能确定分支。CPU使用<strong>分支预测逻辑</strong>来预测分支，只有当预测可靠时 (90%的成功率)，流水线才会充满指令。当预测失误时，CPU会丢弃跳转指令后所有为指令已做的工作，再开始用从正确位置开始的指令去填充流水线。预测失误的代价较高，这会浪费大于15~30个时钟周期，导致程序性能严重下降。</p><p>　　以Intel Haswell CPU上运行函数<code>absdiff()</code>为例，使用传统方式实现条件分支时，<code>x &lt; y</code>的结果不可预测，此外，2个分支中的计算都只需要1个时钟周期，所以预测是否正确决定该函数的性能。对于包含条件分支的x86-64代码，当分支易于预测时，每次调用函数需要大约8个时钟周期；当分支难以预测时，每次调用函数需要大约17.5个时钟周期。假设预测失误的概率是<span class="math inline">\(p\)</span>。预测成功时，执行代码所需时间是<span class="math inline">\(T_{OK}\)</span>。预测失误的代价是<span class="math inline">\(T_{MP}\)</span>。 <span class="math display">\[ T_{avg}(p)=(1-p)T_{OK}+p(T_{OK}+T_{MP})=T_{OK}+pT_{MP} \]</span> 　　当<span class="math inline">\(p=\frac{1}{2}\)</span>，<span class="math inline">\(T_{OK}=8\)</span>，<span class="math inline">\(T_{ran}=17.5\)</span>时，<span class="math inline">\(T_{ran}=T_{avg}(p)=T_{OK}+\frac{T_{MP}}{2}\)</span>，故<span class="math inline">\(T_{MP}=19\)</span>。</p><table><thead><tr><th>指令</th><th>别名</th><th>移动条件</th><th>描述</th></tr></thead><tbody><tr><td><code>cmov S, R</code></td><td><code>cmovz</code></td><td><code>ZF</code></td><td>相等或为0</td></tr><tr><td><code>cmovne S, R</code></td><td><code>cmovnz</code></td><td><code>~ZF</code></td><td>不等或非0</td></tr><tr><td><code>cmovs S, R</code></td><td></td><td><code>SF</code></td><td>为负</td></tr><tr><td><code>cmovns S, R</code></td><td></td><td><code>~SF</code></td><td>非负</td></tr><tr><td><code>cmovg S, R</code></td><td><code>cmovnle</code></td><td><code>~(SF ^ OF) &amp; ~ZF</code></td><td>大于 (有符号)</td></tr><tr><td><code>cmovge S, R</code></td><td><code>cmovnl</code></td><td><code>~(SF ^ OF)</code></td><td>大于等于 (有符号)</td></tr><tr><td><code>cmovl S, R</code></td><td><code>cmovnge</code></td><td><code>SF ^ OF</code></td><td>小于 (有符号)</td></tr><tr><td><code>cmovle S, R</code></td><td><code>cmovlng</code></td><td><code>(SF ^ OF) | ZF</code></td><td>小于等于 (有符号)</td></tr><tr><td><code>cmova S, R</code></td><td><code>cmovnbe</code></td><td><code>~CF &amp; ~ZF</code></td><td>大于 (无符号)</td></tr><tr><td><code>cmovae S, R</code></td><td><code>cmovnb</code></td><td><code>~CF</code></td><td>大于等于 (无符号)</td></tr><tr><td><code>cmovb S, R</code></td><td><code>cmovnae</code></td><td><code>CF</code></td><td>小于 (无符号)</td></tr><tr><td><code>cmovbe S, R</code></td><td><code>cmovna</code></td><td><code>CF | ZF</code></td><td>小于等于 (无符号)</td></tr></tbody></table><p>　　条件移动指令都有2个操作数，即源寄存器或内存引用<code>S</code>和目的寄存器<code>R</code>，操作数可以是16、32或64位。条件移动指令没有指定操作数长度的后缀。不同于跳转指令和<code>SET</code>，条件移动指令的结果取决于条件码的值，只有当条件满足时才会进行移动。不同于条件跳转指令，CPU无需预测就可以执行条件移动指令，只需要检查条件码并根据情况进行移动。</p><p>　　并非所有的条件分支都可以用数据的条件移动来实现。由于无论结果如何，系统都会对所有分支进行计算。因此，当条件分支中的<span style="background-color:#ff0">任一</span>分支可能产生错误或副作用，就会出现非法的行为。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">cread</span><span class="params">(<span class="type">long</span> *xp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (xp ? *xp : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cread:</span><br><span class="line">	movq	(%rdi), %rax</span><br><span class="line">	testq	%rdi, %rdi</span><br><span class="line">	movl	$0, %edx</span><br><span class="line">	cmov	%rdx, %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><p>　　当第1段代码中的指针为空时，第2段代码这种实现是非法的，<code>movq</code>指令的间接引用会导致空指针错误。</p><p>　　使用数据的条件移动也并非总是能提高效率。若条件判断的计算很复杂，而当相应的条件不满足时，相关的工作就白费了。编译器必须在浪费的计算和分支预测失误之间取舍，但编译器没有具有足够的信息来决定，最后GCC还是选择<span style="background-color:#ff0">控制的条件移动</span>。</p><h4 id="循环">3.4.6 循环</h4><p>　　C语言提供了多种循环，即<code>do-while</code>、<code>while</code>和<code>for</code>。汇编没有对应的指令，但可以通过条件判断和跳转组合来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_do</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        result *= n;</span><br><span class="line">        n = n - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (n &gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_do_goto</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">loop:</span><br><span class="line">    result *= n;</span><br><span class="line">    n = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fact_do:</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">.L2:</span><br><span class="line">	imulq	%rdi, %rax</span><br><span class="line">	subq	$1, %rdi</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jg	.L2</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure><p>　　第1段代码是阶乘的C语言代码 (<code>do-while</code>版本)，第3段代码是GCC生成的汇编代码，第2段代码是汇编代码的C语言版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_while</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result *= n;</span><br><span class="line">        n = n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_while_jm_goto</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> test;</span><br><span class="line">loop:</span><br><span class="line">    result *= n;</span><br><span class="line">    n = n - <span class="number">1</span>;</span><br><span class="line">test:</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fact_while_jm_goto:</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L3:</span><br><span class="line">	imulq	%rdi, %rax</span><br><span class="line">	subq	$1, %rdi</span><br><span class="line">.L2:</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jg	.L3</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_while_gd_goto</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">loop:</span><br><span class="line">    result *= n;</span><br><span class="line">    n = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fact_while_gd_goto:</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jle	.L3</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">.L2:</span><br><span class="line">	imulq	%rdi, %rax</span><br><span class="line">	subq	$1, %rdi</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jne	.L2</span><br><span class="line">	rep; ret</span><br><span class="line">.L3:</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><p>　　第1段代码是阶乘的C语言代码 (<code>while</code>版本)，但GCC有2种编译方法。第1种编译方法是第3段代码 (对应的C语言代码是第2段)，称为jump to middle，先执行一个无条件跳转跳到循环结尾处的条件判断，以此来执行初始化的条件判断。第2种编译方法是第5段代码 (对应的C语言代码是第4段)，称为guarded-do，先进行条件判断，若不满足则跳过循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_for</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fact_for_jm_goto:</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	movl	$2, %edx</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L3:</span><br><span class="line">	imulq	%rdx, %rax</span><br><span class="line">	addq	$1, %rdx</span><br><span class="line">.L2:</span><br><span class="line">	cmpq	%rdi, %rdx</span><br><span class="line">	jle	.L3</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fact_for_gd_goto:</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jle	.L3</span><br><span class="line">	movl	$1, %edx</span><br><span class="line">	movl	$2, %eax</span><br><span class="line">.L2:</span><br><span class="line">	imulq	%rax, %rdx</span><br><span class="line">	addq	$1, %rax</span><br><span class="line">	cmpq	%rax, %rdi</span><br><span class="line">	jge	.L3</span><br><span class="line">	rep; ret</span><br><span class="line">.L3:</span><br><span class="line">	movl	$1, %edx</span><br><span class="line">	movl	$2, %eax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><p>　　C语言的<code>for</code>语句 (第1段代码) 也可以用jump to middle (第2段代码) 和guarded-do (第3段代码) 编译。</p><h4 id="多重分支">3.4.7 多重分支</h4><p>　　C语言中的<code>switch</code>语句提供基于1个整数索引值的<strong>多重分支</strong>，在处理有多个可能结果的判断时很有用。为了保证高效，在实现多重分支时会使用<strong>跳转表</strong>。跳转表是1个数组，表项<code>i</code>是代码段的地址，对应的代码段会实现<code>switch</code>索引值等于<code>i</code>时程序应采取的行动。相比一组很长的<code>if-else</code>，跳转表执行<code>switch</code>语句的时间与<code>case</code>的数量无关。GCC会根据<code>case</code>的数量和<code>case</code>值的范围跨度来编译<code>switch</code>语句。当<code>case</code>数量较多 (4个以上) 且值的范围跨度较小时，会使用跳转表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switch_eg</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n, <span class="type">long</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> val = x;</span><br><span class="line">    <span class="keyword">switch</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">        val *= <span class="number">13</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">102</span>:</span><br><span class="line">        val += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">103</span>:</span><br><span class="line">        val += <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">104</span>:`</span><br><span class="line">    <span class="keyword">case</span> <span class="number">106</span>:</span><br><span class="line">        val *= val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switch_eg_impl</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n, <span class="type">long</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> *jt[<span class="number">7</span>] = &#123;&amp;&amp;loc_A, &amp;&amp;loc_def, &amp;&amp;loc_B, &amp;&amp;loc_C, &amp;&amp;loc_D, &amp;&amp;loc_def, &amp;&amp;loc_D&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> index = n - <span class="number">100</span>;</span><br><span class="line">    <span class="type">long</span> val;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> loc_def;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> *jt[index];</span><br><span class="line">loc_A:</span><br><span class="line">    val = x * <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">loc_B:</span><br><span class="line">    x = x + <span class="number">10</span>;</span><br><span class="line">loc_C:</span><br><span class="line">    val = x + <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">loc_D:</span><br><span class="line">    val = x * x;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">loc_def:</span><br><span class="line">    val = <span class="number">0</span>;</span><br><span class="line">done:</span><br><span class="line">    *dest = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">switch_eg:</span><br><span class="line">	subq	$100, %rsi</span><br><span class="line">	cmpq	$6, %rsi</span><br><span class="line">	ja	.L8</span><br><span class="line">	jmp	*.L4(,%rsi,8)</span><br><span class="line">.L3:</span><br><span class="line">	leaq	(%rdi,%rdi,2), %rax</span><br><span class="line">	leaq	(%rdi,%rax,4), %rdi</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L5:</span><br><span class="line">	addq	$10, %rdi</span><br><span class="line">.L6:</span><br><span class="line">	addq	$11, %rdi</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L7:</span><br><span class="line">	imulq	%rdi, %rdi</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L8:</span><br><span class="line">	movl	$0, %edi</span><br><span class="line">.L2:</span><br><span class="line">	movq	%rdi, (%rdx)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><p>　　第1段代码是C语言<code>switch</code>语句的示例，这个示例中包括<code>case</code>跨过不连续的区域，多个标签都是同一<code>case</code>以及没有<code>break</code>结尾的<code>case</code>。第3段代码是GCC生成的汇编代码，第2段代码是汇编代码的C语言版本。原始的C语言代码中有针对值100、102~104和106的<code>case</code>，但<code>switch</code>变量<code>n</code>可以为任意值。GCC会先将<code>n</code>减100来将取值范围转移到0~6，然后创建新变量<code>index</code>，通过比较<code>index</code>和6来进行跳转。</p><p>　　在第2段代码中，数组<code>jt</code> (第10行) 就是跳转表，有7个表项，每个表项都是1个代码块的地址。表项由代码指针指明，由前缀<code>&amp;&amp;</code> (创建指向代码位置的指针) 加标签组成。GCC支持计算<code>goto</code>，这是对C语言的扩展。类似的操作在第3段代码中的第5行，<code>jmp</code>指令的操作数有前缀<code>*</code> (表示间接跳转)，并且操作数指向内存位置，其索引由寄存器<code>%rsi</code>给出，该寄存器保存<code>index</code>的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	.section .rodata</span><br><span class="line">	.align 8		# 地址按8字节对齐</span><br><span class="line">.L4:</span><br><span class="line">	.quad	.L3		# case 100: loc_A</span><br><span class="line">	.quad	.L8		# case 101: loc_def</span><br><span class="line">	.quad	.L5		# case 102: loc_B</span><br><span class="line">	.quad	.L6		# case 103: loc_C</span><br><span class="line">	.quad	.L7		# case 104: loc_D</span><br><span class="line">	.quad	.L8		# case 105: loc_def</span><br><span class="line">	.quad	.L7		# case 106: loc_D</span><br></pre></td></tr></table></figure><p>　　这是跳转表的汇编声明，在<code>.rodata</code> (read-only data) 的目标代码文件段中，其中有7个四字，每个四字的值都是对应的汇编代码标签 (例如，<code>.L3</code>) 的地址。标签<code>.L4</code>是这个区域的起始，该标签对应的地址会作为间接跳转 (汇编代码中的第5行) 的基址。</p><h3 id="过程">3.5 过程</h3><p>　　过程是软件中的重要抽象之一，它提供了1种封装代码的方式，用一组指定的参数和1个可选的返回值实现了某个功能。在不同编程语言中，过程的形式有多种，例如，函数、方法、子例程和处理函数。要提供过程的机器级支持，必须要处理很多不同的属性。</p><p>　　假设过程<code>P()</code>调用过程<code>Q()</code>，<code>Q()</code>执行后返回到<code>P()</code>，该过程至少包括以下机制中的1个：</p><p>　　● <strong>转移控制权</strong>。在进入过程<code>Q()</code>时，PC必须设置为<code>Q()</code>的代码的起始地址，然后在返回时，把PC设置为<code>P()</code>中对<code>Q()</code>的调用的下一条指令的地址。</p><p>　　● <strong>传递数据</strong>。<code>P()</code>必须能向<code>Q()</code>提供若干个参数，<code>Q()</code>必须能向<code>P()</code>返回1个值。</p><p>　　● <strong>分配和释放内存</strong>。在开始时，<code>Q()</code>可能需要为局部变量分配空间，而在返回前，必须释放这些空间。</p><p>　　当<code>Q()</code>执行时，<code>P()</code>以及调用链中所有直到<code>P()</code>的过程都会暂挂。当<code>Q()</code>运行时，仅需要为局部变量分配新的存储空间或设置对其他过程的调用。当<code>Q()</code>返回时，它分配的所有局部变量都可以释放。因此，程序可以用栈来管理其过程所需的存储空间，栈和PC存储着转移控制权、传递数据和分配内存所需的信息。当<code>P()</code>调用<code>Q()</code>时，控制权和数据信息会添加到栈顶。当<code>P()</code>返回时，这些信息会释放。</p><p>　　寄存器是唯一所有过程都共享的资源。虽然在给定时刻只有1个过程是活跃的，但仍需确保当过程调用其他过程时，被调用者不会覆盖调用者之后会使用的寄存器的值。为此，x86-64了采用了所有过程 (包括程序库) 都必须遵守的使用惯例。</p><p>　　按照惯例，寄存器<code>%rbx</code>、<code>%rbp</code>以及<code>%r12</code>~<code>%r15</code>是<strong>被调用者保存</strong>寄存器。当过程<code>P()</code>调用过程<code>Q()</code>时，<code>Q()</code>必须保存这些寄存器的值，维持它们的值在<code>Q()</code>返回<code>P()</code>时与<code>Q()</code>被调用时一致。过程<code>Q()</code>要维持寄存器的值不变，要么不改变寄存器的值，要么将寄存器的旧值压入栈中，改变寄存器的值，然后在返回前弹出旧值。所有其他寄存器 (除栈指针外) 是<strong>调用者保存</strong>寄存器，顾名思义，调用者在调用前需要先保存寄存器的值，所以所有过程都可以修改这类寄存器。</p><h4 id="运行时栈">3.5.1 运行时栈</h4><img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/general_stack_frame_structure.svg" title="general_stack_frame_structure"><p>　　当x86-64过程需要的存储空间超出寄存器能存储的空间时，就会在栈上分配空间，该部分称为过程的<strong>栈帧</strong>。当前正在执行的过程总是在栈顶。<span style="background-color:#ff0">大多数</span>过程的栈帧都是定长的，在过程的开始就已分配。</p><p>　　当过程<code>P()</code>调用过程<code>Q()</code>时，会把返回地址压入栈中，表示从<code>Q()</code>返回时<code>P()</code>继续执行的位置，这个返回地址存储的是与<code>P()</code>相关的状态，所以属于<code>P()</code>的栈帧。<code>Q()</code>的代码会扩展到当前栈的边界，分配它的栈帧所需的空间，这个空间可用于保存寄存器的值、分配局部变量的值和为其调用的过程设置参数。</p><table><colgroup><col style="width:36%"><col style="width:10%"><col style="width:10%"><col style="width:10%"><col style="width:10%"><col style="width:10%"><col style="width:10%"></colgroup><thead><tr><th>操作数大小 (单位是位)</th><th>参数1</th><th>参数2</th><th>参数3</th><th>参数4</th><th>参数5</th><th>参数6</th></tr></thead><tbody><tr><td>64</td><td><code>%rdi</code></td><td><code>%rsi</code></td><td><code>%rdx</code></td><td><code>%rcx</code></td><td><code>%r8</code></td><td><code>%r9</code></td></tr><tr><td>32</td><td><code>%edi</code></td><td><code>%esi</code></td><td><code>%edx</code></td><td><code>%ecx</code></td><td><code>%r8d</code></td><td><code>%r9d</code></td></tr><tr><td>16</td><td><code>%di</code></td><td><code>%si</code></td><td><code>%dx</code></td><td><code>%cx</code></td><td><code>%r8w</code></td><td><code>%r9w</code></td></tr><tr><td>8</td><td><code>%dil</code></td><td><code>%sil</code></td><td><code>%dl</code></td><td><code>%cl</code></td><td><code>%r8b</code></td><td><code>%r9b</code></td></tr></tbody></table><p>　　在x86-64中，可通过寄存器<span style="background-color:#ff0">最多传递6个</span>整型数据 (例如，整数和指针)。寄存器的使用有特定顺序，寄存器的选择取决于待传递的数据的数据类型的大小。若函数的参数超过6个，超出的部分需要用栈来传递，即把参数0~5复制到寄存器，把参数6~n压入栈 (参数6位于栈顶)。通过栈传递参数时，所有的数据的大小都需要向上舍入到<span style="background-color:#ff0">8的整数倍</span>，这部分参数需要在自己的栈帧中分配空间，称为<strong>参数构造区</strong>。</p><p>　　有时，局部数据必须存储在内存中：</p><p>　　● 寄存器不足以存储所有的本地数据。</p><p>　　● 对局部变量使用地址运算符<code>&amp;</code>，所以必须能够为其生成地址。</p><p>　　● 某些局部变量是数组或结构，所以必须能够通过数组或结构引用来访问它们。</p><p>　　一般情况下，过程通过减小栈指针来在栈上分配空间，该空间作为栈帧的一部分 (即<strong>局部变量</strong>)。</p><p>　　为了提高空间和时间使用率，x86-64仅分配自己所需的栈帧部分，例如，当过程的参数少于6个时，所有参数都可以通过寄存器传递。实际上，很多过程甚至不需要栈帧，例如，所有的局部变量都可以保存在寄存器且不调用其他过程的过程。</p><h4 id="转移控制权">3.5.2 转移控制权</h4><p>　　将控制权从过程<code>P()</code>转移到过程<code>Q()</code>仅需把PC设置为<code>Q()</code>的代码的起始位置。从<code>Q()</code>返回时，CPU需要记录<code>P()</code>继续执行的代码位置。在x86-64中，用指令<code>call Q</code>调用过程<code>Q()</code>时会记录该信息，该指令会把地址<code>A</code>压入栈中，并把PC设置为<code>Q()</code>的起始地址。压入的地址<code>A</code>称为返回地址，是指令<code>call</code>的下一条指令的地址。指令<code>ret</code>会从栈中弹出地址<code>A</code>并把PC设置为<code>A</code>。</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><code>call Label</code></td><td>过程调用</td></tr><tr><td><code>call *Operand</code></td><td>过程调用</td></tr><tr><td><code>ret</code></td><td>从过程调用中返回</td></tr></tbody></table><p>　　指令<code>call</code>有1个操作数，即被调过程的指令的起始地址。类似跳转，调用可以是直接，也可以是间接 (<code>*</code>加操作数指示符)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># leaf(long y)的反汇编代码</span><br><span class="line">0000000000400540 &lt;leaf&gt;:</span><br><span class="line">400540:	48 8d 47 02	lea	0x2(%rdi), %rax</span><br><span class="line">400544:	c3		retq</span><br><span class="line"></span><br><span class="line"># top(long x)的反汇编代码</span><br><span class="line">0000000000400545 &lt;top&gt;:</span><br><span class="line">400545:	48 83 ef 05	sub	$0x5, %rdi</span><br><span class="line">400549:	e8 f2 ff ff ff 	callq	400540 &lt;leaf&gt;</span><br><span class="line">40054e: 48 01 c0	add	%rax, %rax</span><br><span class="line">400551: c3		retq</span><br><span class="line"></span><br><span class="line"># 主函数调用top的反汇编代码</span><br><span class="line"># ...</span><br><span class="line">40055b: e8 e5 ff ff ff	callq	400545 &lt;top&gt;</span><br><span class="line">400560: 48 89 c2	mov	%rax, %rdx</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><table style="width:100%"><colgroup><col style="width:14%"><col style="width:10%"><col style="width:8%"><col style="width:8%"><col style="width:22%"><col style="width:14%"><col style="width:21%"></colgroup><thead><tr><th>PC</th><th>指令</th><th><code>%rdi</code></th><th><code>%rax</code></th><th><code>%rsp</code></th><th><code>*%rsp</code></th><th>描述</th></tr></thead><tbody><tr><td><code>0x40055b</code></td><td><code>callq</code></td><td>100</td><td></td><td><code>0x7fffffffe820</code></td><td></td><td>调用<code>top(100)</code></td></tr><tr><td><code>0x400545</code></td><td><code>sub</code></td><td>100</td><td></td><td><code>0x7fffffffe818</code></td><td><code>0x400560</code></td><td>进入<code>top</code></td></tr><tr><td><code>0x400549</code></td><td><code>callq</code></td><td>95</td><td></td><td><code>0x7fffffffe818</code></td><td><code>0x400560</code></td><td>调用<code>leaf(100)</code></td></tr><tr><td><code>0x400540</code></td><td><code>lea</code></td><td>95</td><td></td><td><code>0x7fffffffe810</code></td><td><code>0x40054e</code></td><td>进入<code>leaf</code></td></tr><tr><td><code>0x400544</code></td><td><code>retq</code></td><td></td><td>97</td><td><code>0x7fffffffe810</code></td><td><code>0x40054e</code></td><td><code>leaf</code>返回97</td></tr><tr><td><code>0x40054e</code></td><td><code>add</code></td><td></td><td>97</td><td><code>0x7fffffffe818</code></td><td><code>0x400560</code></td><td>继续<code>top</code></td></tr><tr><td><code>0x400551</code></td><td><code>retq</code></td><td></td><td>194</td><td><code>0x7fffffffe818</code></td><td><code>0x400560</code></td><td><code>top</code>返回194</td></tr><tr><td><code>0x400560</code></td><td><code>mov</code></td><td></td><td>194</td><td><code>0x7fffffffe820</code></td><td></td><td>继续主函数</td></tr></tbody></table><p>　　在这个示例中，主函数先调用<code>top(100)</code>，然后<code>top</code>调用<code>leaf(95)</code>。<code>leaf</code>向<code>top</code>返回97，然后<code>top</code>向主函数返回194。第3行将寄存器<code>%rax</code>设置为97，然后第4行返回，从栈中弹出<code>0x40054e</code>并将PC设置为这个弹出的值，控制权转移回<code>top</code>并将寄存器<code>%rax</code>置为194 (第11行)，最后第11行返回，它从栈中弹出<code>0x400560</code>并将PC设置为这个弹出的值。此时，<code>%rsp</code>也恢复为调用<code>top</code>前的值。</p><p>　　把返回地址压入栈的这种简单机制能让函数在之后返回到程序中正确的位置。C语言 (以及大多数编程语言) 标准的调用-返回机制刚好与栈提供的后进先出的内存管理方法吻合。</p><h4 id="传递数据">3.5.3 传递数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc</span><span class="params">(<span class="type">long</span> a1, <span class="type">long</span> *a1p, <span class="type">int</span> a2, <span class="type">int</span> *a2p, <span class="type">short</span> a3, <span class="type">short</span> *a3p, <span class="type">char</span> a4, <span class="type">char</span> *a4p)</span></span><br><span class="line">&#123;</span><br><span class="line">    *a1p += a1;</span><br><span class="line">    *a2p += a2;</span><br><span class="line">    *a3p += a3;</span><br><span class="line">    *a4p += a4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">proc:</span><br><span class="line">	movq	16(%rsp), %rax</span><br><span class="line">	addq	%rdi, (%rsi)</span><br><span class="line">	addl	%edx, (%rcx)</span><br><span class="line">	addw	%r8w, (%r9)</span><br><span class="line">	movl	8(%rsp), %edx</span><br><span class="line">	addb	%dl, (%rax)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/stack_frame_for_function_proc.svg" title="stack_frame_for_function_proc"><p>　　函数<code>proc()</code>有8个参数，包括不同长度的整型数和指向这些整型数的指针，其中前6个参数通过寄存器传递，后2个参数通过栈传递。作为过程调用的一部分，返回地址被压入栈中，所以后2个参数位于相对栈指针距离为8和16的位置。</p><h4 id="栈上的局部存储">3.5.4 栈上的局部存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">call_proc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> x1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x2 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">short</span> x3 = <span class="number">3</span>;</span><br><span class="line">    <span class="type">char</span> x4 = <span class="number">4</span>;</span><br><span class="line">    proc(x1, &amp;x1, x2, &amp;x2, x3, &amp;x3, x4, &amp;x4);</span><br><span class="line">    <span class="keyword">return</span> (x1 + x2) * (x3 - x4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">call_proc:</span><br><span class="line">	subq	$32, %rsp</span><br><span class="line">	movq	$1, 24(%rsp)</span><br><span class="line">	movl	$2, 20(%rsp)</span><br><span class="line">	movw	$3, 18(%rsp)</span><br><span class="line">	movb	$4, 17(%rsp)</span><br><span class="line">	leaq	17(%rsp), %rax</span><br><span class="line">	movq	%rax, 8(%rsp)</span><br><span class="line">	movl	$4, (%rsp)</span><br><span class="line">	leaq	18(%rsp), %r9</span><br><span class="line">	movl	$3, %r8d</span><br><span class="line">	leaq	20(%rsp), %rcx</span><br><span class="line">	movl	$2, %edx	</span><br><span class="line">	leaq	24(%rsp), %rsi</span><br><span class="line">	movl	$1, %edi</span><br><span class="line">	call	proc</span><br><span class="line">	movslq	20(%rsp), %rdx</span><br><span class="line">	addq	24(%rsp), %rdx</span><br><span class="line">	movswl	18(%rsp), %eax</span><br><span class="line">	movsbl	17(%rsp), %ecx</span><br><span class="line">	subl	%ecx, %eax</span><br><span class="line">	cltq</span><br><span class="line">	imulq	%rdx, %rax</span><br><span class="line">	addq	$32, %rsp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/stack_frame_for_function_call_proc.svg" title="stack_frame_for_function_call_proc"><p>　　函数<code>call_proc()</code>有4个局部变量，还需要向有8个参数的函数<code>proc()</code>传参。函数<code>call_proc()</code>的汇编代码中大部分代码 (第2~15行) 都是为调用函数<code>proc()</code>准备，包括为局部变量和函数参数分配空间以及将函数参数加载到寄存器。在栈帧上分配局部变量<code>x1</code> (相对栈指针偏移量为24)、<code>x2</code> (相对栈指针偏移量为20)、<code>x3</code> (相对栈指针偏移量为18) 和<code>x4</code> (相对栈指针偏移量为17)。用<code>leaq</code>指令生成指向这些变量的指针 (第7、10、12和14行)。参数7 (值为4) 和参数8 (指向<code>x4</code>的指针) 存储在相对栈指针偏移量为0和8的位置。</p><p>　　在调用函数<code>proc()</code>时，参数7和参数8的位置会变成相对栈指针偏移量为8和16的位置，因为返回地址已经被压入栈帧中。调用函数<code>proc()</code>完成后，会获取4个局部变量的值 (第17~20行) 并计算最终结果。在函数结束前，把栈指针加32来释放栈帧。</p><h4 id="寄存器中的局部存储空间">3.5.5 寄存器中的局部存储空间</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">P</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> u = Q(y);</span><br><span class="line">    <span class="type">long</span> v = Q(x);</span><br><span class="line">    <span class="keyword">return</span> u + v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">P:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	subq	$8, %rsp</span><br><span class="line">	movq	%rdi, %rbp</span><br><span class="line">	movq	%rsi, %rdi</span><br><span class="line">	call	Q</span><br><span class="line">	movq	%rax, %rbx</span><br><span class="line">	movq	%rbp, %rdi</span><br><span class="line">	call	Q</span><br><span class="line">	addq	%rbx, %rax</span><br><span class="line">	addq	$8, %rsp</span><br><span class="line">	popq	%rbx</span><br><span class="line">	popq	%rbp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><p>　　函数<code>P()</code>调用了2次函数<code>Q()</code>，第1次调用前，必须保存<code>x</code>的值。同样，第2次调用前，必须保存<code>Q(y)</code>的值。在汇编代码中，寄存器<code>%rbp</code>和<code>%rbx</code>分别保存<code>x</code>和<code>Q(y)</code> (第2~3行)，然后进行栈帧对齐 (第4行)。第1次调用<code>Q()</code>前，把<code>x</code>存入<code>%rbp</code> (第5行)，第2次调用<code>Q()</code>前，把上次调用的返回结果存入<code>%rbx</code> (第8行)。最后，把它们从栈帧中弹出 (第13~14行)，恢复这2个被调用者保存寄存器的值。</p><h4 id="递归">3.5.6 递归</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">rfact</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = n * rfact(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rfact:</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	movq	%rdi, %rbx</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	movq	$1, %rdi</span><br><span class="line">	jle	.L1</span><br><span class="line">	leaq	-1(%rdi), %rdi</span><br><span class="line">	call	rfact</span><br><span class="line">	imulq	%rbx, %rax</span><br><span class="line">.L1:</span><br><span class="line">	popq	%rbx</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><p>　　在函数<code>rfact()</code>的汇编代码中，寄存器<code>%rbx</code>用于保存参数<code>n</code>，先把已有的值压入栈帧 (第2行)，随后在返回前弹出 (第11行)。根据栈的特点和寄存器的保存规则，可以保证当递归调用<code>rfact(n - 1)</code>返回时，调用的结果会保存到寄存器<code>%rax</code>且参数<code>n</code>仍然在寄存器<code>%rbx</code>中。</p><p>　　递归调用与调用其他函数一样。栈的机制保证每次调用都有私有的状态信息 (保存的返回位置和被调用者保存寄存器的值) 存储空间。如果需要，它还可以提供局部变量的存储。栈的分配和释放规则很自然地与函数调用-返回的顺序匹配。这种实现函数调用和返回的方法更复杂的场景同样适用，包含相互递归调用 (例如，函数<code>P()</code>调用<code>Q()</code>，<code>Q()</code>再调用<code>P()</code>)。</p><h3 id="数组的分配和访问">3.6 数组的分配和访问</h3><p>　　C语言中的数组可用于将标量数据聚集成更大的数据类型。对于数据类型<code>T</code>和整型常数<code>N</code>，其对应数组的声明为<code>T A[N]</code>。在声明时，会先在内存中分配<span class="math inline">\(L\cdot N\)</span>字节的连续区域，<span class="math inline">\(L\)</span>是数据类型<code>T</code>的大小。然后，声明标识符<code>A</code>来作为指向数组起始位置的指针，其指针值为<span class="math inline">\(x_A\)</span>。可以用0到<span class="math inline">\(N-1\)</span>的整数索引来访问该数组元素。数组元素<code>i</code>的存储地址为<span class="math inline">\(x_A+L\cdot i\)</span>。</p><p>　　C语言允许指针运算，若<code>p</code>是指向类型是<code>T</code>的数据的指针，<code>p</code>的值为<span class="math inline">\(x_p\)</span>，则<code>p + i</code>的值为<span class="math inline">\(x_p+L\cdot i\)</span>。可以对数组和指针应用数组下标操作，数组引用<code>A[i]</code>等价于<code>*(A + i)</code>。</p><p>　　假设整型数组<code>E</code>的起始地址和整数索引<code>i</code>分别存储在寄存器<code>%rdx</code>和<code>%rcx</code>中。以下是一些与<code>E</code>有关的表达式以及对应的汇编代码实现，结果存储在寄存器<code>%eax</code> (若是数据) 或寄存器<code>%rax</code> (若是指针) 中。</p><table><colgroup><col style="width:21%"><col style="width:10%"><col style="width:21%"><col style="width:46%"></colgroup><thead><tr><th>表达式</th><th>类型</th><th>值</th><th>汇编代码</th></tr></thead><tbody><tr><td><code>E</code></td><td><code>int *</code></td><td><span class="math inline">\(x_E\)</span></td><td><code>movq %rdx, %rax</code></td></tr><tr><td><code>E[0]</code></td><td><code>int</code></td><td><span class="math inline">\(M[x_E]\)</span></td><td><code>movl (%rdx), %rax</code></td></tr><tr><td><code>E[i]</code></td><td><code>int</code></td><td><span class="math inline">\(M[x_E+4i]\)</span></td><td><code>movl (%rdx,%rcx,4), %eax</code></td></tr><tr><td><code>&amp;E[2]</code></td><td><code>int *</code></td><td><span class="math inline">\(x_E+8\)</span></td><td><code>leaq 8(%rdx), %rax</code></td></tr><tr><td><code>E + i - 1</code></td><td><code>int *</code></td><td><span class="math inline">\(x_E+4i-4\)</span></td><td><code>leaq -4(%rdx,%rcx,4), %rax</code></td></tr><tr><td><code>*(E + i - 3)</code></td><td><code>int</code></td><td><span class="math inline">\(M[x_E+4i-12]\)</span></td><td><code>movl -12(%rdx,%rcx,4), %eax</code></td></tr><tr><td><code>&amp;E[i] - E</code></td><td><code>long</code></td><td><span class="math inline">\(i\)</span></td><td><code>movq %rcx, %rax</code></td></tr></tbody></table><h4 id="嵌套数组">3.6.1 嵌套数组</h4><p>　　当创建嵌套数组时，数组的分配和引用一般原则也成立。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">row3_t</span>[<span class="number">3</span>];</span><br><span class="line"><span class="type">row3_t</span> A[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>　　这是二元数组的声明方式之一，数据类型<code>row3_t</code>定义为包含3个<code>int</code>的数组，数组<code>A</code>包含5个元素，所有元素都是12B，整个数组是60B。</p><p>　　访问多维数组时，GCC会生成代码来计算元素的偏移量，并以数组的起始地址为基址和以偏移量 (可能会伸缩) 为索引来执行数据移动指令。对于声明为<code>T D[R][C]</code>的数组，数组元素<code>D[i][j]</code>的地址为<span class="math inline">\(x_0+L(C\cdot i+j)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leaq	(%rsi,%rsi,2), %rax</span><br><span class="line">leaq	(%rdi,%rax,4), %rax</span><br><span class="line">movl	(%rax,%rdx,4), %eax</span><br></pre></td></tr></table></figure><p>　　这段代码会计算元素地址<span class="math inline">\(x_A+12i+4j=x_A+4(3i+j)\)</span>，使用了x86-64地址运算的伸缩和加法特性。其中<code>A[i][j]</code>是<span class="math inline">\(5\times 3\)</span>的整型数组，第1个元素的指针、<code>i</code>和<code>j</code>分别在寄存器<code>%rdi</code>、<code>%rsi</code>和<code>%rdx</code>中。</p><h4 id="定长数组">3.6.2 定长数组</h4><p>　　GCC能够优化定长数组上的操作代码，这里以优化等级<code>-O1</code>为例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 16</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> fix_matrix[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fix_prod_ele</span><span class="params">(fix_matrix A, fix_matrix B, <span class="type">long</span> i, <span class="type">long</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += A[i][j] * B[j][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fix_prod_ele_opt</span><span class="params">(fix_matrix A, fix_matrix B, <span class="type">long</span> i, <span class="type">long</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *Aptr = &amp;A[i][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> *Bptr = &amp;B[<span class="number">0</span>][k];</span><br><span class="line">    <span class="type">int</span> *Bend = &amp;B[N][k];</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        result += *Aptr * *Bptr;</span><br><span class="line">        Aptr++;</span><br><span class="line">        Bptr += N;</span><br><span class="line">    &#125; <span class="keyword">while</span> (Bptr != Bend);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fix_prod_ele:</span><br><span class="line">	salq	$6, %rdx</span><br><span class="line">	addq	%rdx, %rdi</span><br><span class="line">	leaq	(%rsi,%rcx,4), %rcx</span><br><span class="line">	leaq	1024(%rcx), %rsi</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">.L2:</span><br><span class="line">	movl	(%rdi), %edx</span><br><span class="line">	imull	(%rcx), %edx</span><br><span class="line">	addl	%edx, %eax</span><br><span class="line">	addq	$4, %rdi</span><br><span class="line">	addq	$64, %rcx</span><br><span class="line">	cmpq	%rsi, %rcx</span><br><span class="line">	jne	.L2</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure><p>　　第1段代码是计算矩阵<code>A</code>的行<code>i</code>和矩阵<code>B</code>的列<code>k</code>的内积的C语言版本，第3段代码是GCC生成的汇编代码，第2段代码是汇编代码的C语言版本。相比第1段代码，第3段代码省略了整数索引<code>j</code>，并把所有的数组引用都换成了指针间接引用，包括指向矩阵<code>A</code>的行<code>i</code>中元素的指针<code>Aptr</code>、指向矩阵<code>B</code>的列<code>k</code>中元素的指针<code>Bptr</code>以及终止循环的指针<code>Bend</code>。</p><h4 id="变长数组">3.6.3 变长数组</h4><p>　　过去，C语言仅支持大小在编译时就能确定的多维数组 (对第1维可能有些例外)。若需要实现变长数组，需要使用<code>malloc()</code>或<code>calloc()</code>等函数和行优先索引将多维数组映射到一维数组。ISO C99加入了允许数组维度是表达式的功能，维度在数组被分配时才计算出来，声明为<code>int A[expr1][expr2]</code>，它可以作为局部变量或函数的参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">var_ele</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> A[n][n], <span class="type">long</span> i, <span class="type">long</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> A[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这段代码会访问<span class="math inline">\(n\times n\)</span>数组的元素<code>A[i][j]</code>，参数<code>n</code>必须在参数<code>A[n][n]</code>之前，这样函数可以在遇到这个数组时计算出其维度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">var_prod_ele</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> A[n][n], <span class="type">int</span> B[n][n], <span class="type">long</span> i, <span class="type">long</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += A[i][j] * B[j][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">var_prod_ele</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> A[n][n], <span class="type">int</span> B[n][n], <span class="type">long</span> i, <span class="type">long</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> *Arow = A[i];</span><br><span class="line">    <span class="type">int</span> *Bptr = &amp;B[<span class="number">0</span>][k];</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += Arow[j] * *Bptr;</span><br><span class="line">        Bptr += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.L2:</span><br><span class="line">	movl	(%rsi,%rdx,4), %r8d</span><br><span class="line">	imull	(%rcx), %r8d</span><br><span class="line">	addl	%r8d, %eax</span><br><span class="line">	addq	$1, %rdx</span><br><span class="line">	addq	%r9, %rcx</span><br><span class="line">	cmpq	%rdi, %rax</span><br><span class="line">	jne	.L2</span><br></pre></td></tr></table></figure><p>　　第1段代码是计算<span class="math inline">\(n\times n\)</span>矩阵<code>A</code>的行<code>i</code>和<span class="math inline">\(n\times n\)</span>矩阵<code>B</code>的列<code>k</code>的内积的C语言版本，第3段代码是GCC生成的汇编代码 (仅节选了循环部分)，第2段代码是汇编代码的C语言版本。第2段代码中，保留了循环变量<code>j</code>来判断循环是否结束以及作为到<code>A</code>的行<code>i</code>的元素组成的数组的索引。第3段代码中，使用了伸缩后的值<code>4n</code> (存储在寄存器<code>%r9</code>) 来增加<code>Bptr</code>，也使用了值<code>n</code>来判断循环是否结束，C语言代码中并没有体现出需要这2个值，但是由于指针运算的伸缩才使用了它们。</p><p>　　若允许使用优化，GCC能够识别出程序访问多维数组时的步长，然后在生成代码时避免直接应用计算元素地址的等式而导致的乘法。不论生成基于指针的代码还是基于数组的代码，这些优化都能显著提供程序的性能。</p><h3 id="异质的数据结构">3.7 异质的数据结构</h3><p>　　C语言提供了2种将不同类型的对象组合起来创建数据类型的机制，即<strong>结构体</strong>和<strong>联合体</strong>。结构体允许将多个对象聚合到1个单元，用关键字<code>struct</code>声明。联合体允许用几种不同的类型来引用同一对象，用关键字<code>union</code>声明。</p><h4 id="结构体">3.7.1 结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/structure_rec.svg" title="structure_rec"><p>　　结构体<code>rec</code>包括2个<code>int</code>、1个由2个<code>int</code>组成的数组和1个<code>int</code>指针。数组<code>a</code>是嵌入到该结构体的。</p><p>　　在汇编代码中访问结构体的字段时，需要在结构体的地址上加上合适的偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r-&gt;p = &amp;r-&gt;a[r-&gt;i + r-&gt;j];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl	4(%rdi), %eax</span><br><span class="line">addl	(%rdi), %eax</span><br><span class="line">ctlq</span><br><span class="line">leaq	8(%rdi,%rax,4), %rax</span><br><span class="line">movq	%rax, 16(%rdi)</span><br></pre></td></tr></table></figure><p>　　<code>r</code>的类型是<code>struct rec *</code>，存储在寄存器<code>%rdi</code>中。在汇编代码中，第1~2行会将元素<code>r-&gt;i</code>加上元素<code>r-&gt;j</code>，字段<code>i</code>的偏移量是0，其地址是<code>r</code>。字段<code>j</code>的偏移量是4，其地址是<code>r + 4</code>。第4行会计算<code>&amp;r-&gt;a[r-&gt;i + r-&gt;j]</code>。第5行会将结果移动到<code>r-&gt;p</code>。</p><p>　　结构体的各个字段的选取完全是在编译时处理的。汇编代码不包含任何关于字段名称或声明的信息。</p><h4 id="联合体">3.7.2 联合体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　对于类型是<code>union U3 *</code>的指针<code>p</code>，<code>p-&gt;c</code>、<code>p-&gt;i[0]</code>和<code>p-&gt;v</code>引用的都是数据结构的起始地址。联合体的大小等于其<span style="background-color:#ff0">最大字段</span>的大小，所以<code>union U3</code>是8B。</p><p>　　在有些上下文中，联合体很有用。但是，它也能导致一些错误，因为它绕过了C语言的类型系统提供的安全措施。应用场景之一是事先知道数据结构中2个不同字段是互斥的，声明为联合体可以减少分配的空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    N_LEAF,</span><br><span class="line">    N_INTERNAL</span><br><span class="line">&#125; <span class="type">nodetype_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">nodetype_t</span> type;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">left</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">right</span>;</span></span><br><span class="line">        &#125; internal;</span><br><span class="line">        <span class="type">double</span> data[<span class="number">2</span>];</span><br><span class="line">    &#125; info;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　以二叉树为例，每个叶子节点都有2个<code>double</code>数据。每个内部节点都有指向2个子节点的指针，但没有数据。<code>type</code>是4B，<code>info.internal</code>或<code>info.data</code>是16B，加上用于数据对齐的4B，这个结构体共需24B。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">double2bits</span><span class="params">(<span class="type">double</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> u;</span><br><span class="line">    &#125; temp;</span><br><span class="line">    temp.d = d;</span><br><span class="line">    <span class="keyword">return</span> temp.u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　联合体还可以用于访问不同数据类型的位模式。在这段代码中，会以某种数据类型来存储联合体中的参数，又以其他数据类型来访问，最后<code>u</code>和<code>d</code>会有相同的位模式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">uu2double</span><span class="params">(<span class="type">unsigned</span> word0, <span class="type">unsigned</span> word1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">unsigned</span> u[<span class="number">2</span>];</span><br><span class="line">    &#125; temp;</span><br><span class="line">    temp.u[<span class="number">0</span>] = word0;</span><br><span class="line">    temp.u[<span class="number">1</span>] = word1;</span><br><span class="line">    <span class="keyword">return</span> temp.d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　当用联合体将各种不同大小的数据类型结合时，字节顺序会变得很重要。对于这段代码，在小端机器上时，<code>word0</code>是<code>d</code>的低4B，<code>word1</code>是<code>d</code>的高4B，而在大端机器上相反。</p><h4 id="数据对齐">3.7.3 数据对齐</h4><p>　　很多计算机系统都对基本数据类型的合法地址做出了限制，要求<span style="background-color:#ff0"><span class="math inline">\(K\)</span>字节的基本对象的地址必须是<span class="math inline">\(K\)</span>的整数倍</span>。这种对齐限制简化了在CPU和内存系统之间形成接口的硬件设计。虽然无论数据是否对齐，x86-64硬件都能正常工作。</p><table><thead><tr><th><span class="math inline">\(K\)</span></th><th>类型</th></tr></thead><tbody><tr><td>1</td><td><code>char</code></td></tr><tr><td>2</td><td><code>short</code></td></tr><tr><td>4</td><td><code>int</code>，<code>float</code></td></tr><tr><td>8</td><td><code>long</code>，<code>double</code>，<code>char *</code></td></tr></tbody></table><p>　　编译器会在汇编代码中加入用于指明数据对齐要求的汇编指示，例如，<code>.align 8</code>表示之后的数据的起始地址都是8的整数倍。</p><p>　　对于结构体，编译器可能需要在字段的分配中插入间隙来保证每个元素都满足其对齐要求，而结构本身也有对齐要求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/structure_s1_and_s2.svg" title="structure_s1_and_s2"><p>　　编译器在结构体<code>S1</code>和<code>S2</code>中都插入了3B的间隙来保证每个元素以及结构体的对齐。</p><p>　　对于大多数x86-64指令，数据对齐只会提升效率，并不会影响程序的行为。但是，当数据没有对齐时，某些型号的Intel和AMD CPU将无法正确执行部分用于实现多媒体操作的SSE指令，这些指令会对16B数据块进行操作。在SSE单元和内存之间移动数据的指令要求内存地址必须是16的整数倍，不满足此要求会导致异常 (默认是程序终止)。因此，编译器和运行时系统必须确保为了读写SSE寄存器而分配的内存满足16B对齐。较新版本的x86-64 CPU加入了AVX多媒体指令，这类指令除了提供SSE指令的超集，还去除了对齐要求。</p><h3 id="在机器级程序中结合控制和数据">3.8 在机器级程序中结合控制和数据</h3><p>　　指针能以统一的方式对不同数据结构的元素产生引用。每个指针都对应1个类型，该类型表明该指针指向的对象。<code>int *p</code>是指向<code>int</code>的指针，<code>char **cpp</code>指向的对象是指向<code>char</code>的指针。通常，若对象类型是<code>T</code>，其指针是<code>T *</code>。特殊的<code>void *</code>表示通用指针。每个指针都有1个值，该值是某个指定类型的对象的地址。特殊的<code>NULL</code> (0) 表示该指针没有指向任何位置。</p><p>　　将指针强制转换到其他类型时，仅改变其类型，不会改变其值。强制转换的效果之一是改变指针运算的伸缩。例如，若<code>p</code>是<code>char *</code>类型的指针，其值为<span class="math inline">\(p\)</span>，则<code>(int *)p + 7</code>的结果为<span class="math inline">\(p+28\)</span>。</p><p>　　指针也可以指向函数，函数指针的值是该函数机器代码表示中第1条指令的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> *p)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span> *);</span><br><span class="line">fp = fun;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> result = fp(<span class="number">3</span>, &amp;y);</span><br></pre></td></tr></table></figure><p>　　第1段代码是函数<code>fun()</code>的函数原型。第2段代码会先声明指针<code>fp</code>，然后将它赋值为函数<code>fun()</code>。第3段代码会用指针<code>fp</code>来调用函数<code>fun()</code>。</p><h4 id="gdb的使用">3.8.1 GDB的使用</h4><p>　　GNU的调试器GDB提供了很多有用的特性，支持机器级程序的运行时评估和分析。启动GDB的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb prog</span><br></pre></td></tr></table></figure><p>　　GDB的常规使用方法是在程序中有需要的地方设置断点，断点可以设置在函数入口后或某个地址处。程序在执行时，遇到断点会停止并将控制权返回给用户。在断点处，可以以各种方式查看各个寄存器和内存位置，也可以单步跟踪程序，还可以1次仅执行几条指令或前进到下一断点。</p><table><colgroup><col style="width:47%"><col style="width:52%"></colgroup><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>quit</code></td><td>退出GDB</td></tr><tr><td><code>run</code></td><td>运行程序 (在此给出命令行选项)</td></tr><tr><td><code>kill</code></td><td>停止程序</td></tr><tr><td><code>break multstore</code></td><td>在函数<code>multstore()</code>入口处设置断点</td></tr><tr><td><code>break *0400540</code></td><td>在地址<code>0x0400540</code>处设置断点</td></tr><tr><td><code>delete 1</code></td><td>删除断点1</td></tr><tr><td><code>delete</code></td><td>删除所有断点</td></tr><tr><td><code>stepi</code></td><td>执行1条指令</td></tr><tr><td><code>stepi 4</code></td><td>执行4条指令</td></tr><tr><td><code>nexti</code></td><td>类似于<code>stepi</code>，但以函数调用为单位</td></tr><tr><td><code>continue</code></td><td>继续执行</td></tr><tr><td><code>finish</code></td><td>运行到当前函数返回</td></tr><tr><td><code>disas</code></td><td>反汇编当前函数</td></tr><tr><td><code>disas multstore</code></td><td>反汇编函数<code>multstore()</code></td></tr><tr><td><code>disas 0x400544</code></td><td>反汇编地址位于<code>0x0400540</code>附近的函数</td></tr><tr><td><code>disas 0x400540, 0x40054d</code></td><td>反汇编地址在指定范围内的代码</td></tr><tr><td><code>print /x $rip</code></td><td>以十六进制输出PC的值</td></tr><tr><td><code>print $rax</code></td><td>以十进制输出寄存器<code>%rax</code>的值</td></tr><tr><td><code>print /x $rax</code></td><td>以十六进制输出寄存器<code>%rax</code>的值</td></tr><tr><td><code>print /t $rax</code></td><td>以二进制输出寄存器<code>%rax</code>的值</td></tr><tr><td><code>print 0x100</code></td><td>输出<code>0x100</code>的十进制表示</td></tr><tr><td><code>print /x 555</code></td><td>输出555的十六进制表示</td></tr><tr><td><code>print /x ($rsp+8)</code></td><td>以十六进制输出栈指针加8的内容</td></tr><tr><td><code>print *(long *) 0x7fffffffe818</code></td><td>输出地址是<code>0x7fffffffe818</code>的长整数</td></tr><tr><td><code>print *(long *) ($rsp + 8)</code></td><td>输出地址是栈指针加8的长整数</td></tr><tr><td><code>x/2g 0x7fffffffe818</code></td><td>检查地址始于<code>0x7fffffffe818</code>的双字</td></tr><tr><td><code>x/20b multstore</code></td><td>检查函数<code>multstore()</code>的前20B</td></tr><tr><td><code>info frame</code></td><td>当前栈帧的相关信息</td></tr><tr><td><code>info registers</code></td><td>所有寄存器的值</td></tr><tr><td><code>help</code></td><td>GDB的相关信息</td></tr></tbody></table><p>　　除了使用命令行接口来访问GDB，DDD也是选择之一，它是GDB的扩展，提供了图像用户界面。</p><h4 id="内存越界引用和缓存溢出">3.8.2 内存越界引用和缓存溢出</h4><p>　　C语言不会对数组引用进行边界检查，而且局部变量和状态信息都存储在栈中，这2种情况结合起来就能导致严重的程序错误。对越界的数组元素的写操作会损坏存储在栈中的状态信息，当程序使用这个已损坏的状态信息来重新加载寄存器或执行指令<code>ret</code>时，会导致严重的错误。</p><p>　　<strong>缓存溢出</strong>是常见的状态损坏之一，即在栈中分配字符数组来保存字符串时，字符串的长度超过了为数组分配的空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">char</span> *dest = s;</span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; c != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        *dest++ = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == EOF &amp;&amp; dest == s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　库函数<code>gets()</code>会从标准输入读取1行 (遇到<code>\n</code>或错误时停止)，然后将这个字符串复制到参数<code>s</code>指向的位置并在字符串结尾加上<code>null</code>。函数<code>echo()</code>会从标准输入读取1行并回显到标准输出。由于<code>buf</code>仅有8B，任何超过7B的字符串都会导致越界。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">echo:</span><br><span class="line">	subq	$24, %rsp</span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	call	gets</span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	call	puts</span><br><span class="line">	addq	$24, %rsp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/stack_organization_for_function_echo.svg" title="stack_organization_for_function_echo"><p>　　在函数<code>echo()</code>的汇编代码中，会先把栈指针减24 (第2行)。栈指针 (即<code>buf</code>) 会被复制到<code>%rdi</code>作为调用<code>gets()</code>和<code>puts</code>的参数。<code>buf</code>和返回地址之间的16B是未使用的。用户输入的字符不超过7个时，函数<code>gets()</code>返回的字符串能放入<code>buf</code>分配的空间中。输入的字符不超过23个时，不会有严重的后果，但超过后会损坏存储在返回地址的值，导致指令<code>ret</code> (第8行) 会跳转意想不到的位置。</p><p>　　在函数<code>echo()</code>中，更好的选择使用<code>fgets</code>函数，它包括1个参数来限制待读入的最大字节数。使用<code>gets()</code>或其他任何能导致溢出的函数通常都是不好的编程习惯，但很多常用的库函数 (包括<code>strcpy</code>、<code>strcat</code>和<code>sprintf</code>) 都不需要指定目标缓存的大小。</p><p>　　缓存溢出可用于让程序执行它本来不会执行的函数，这是常见的攻击方式之一。例如，给程序输入某个字符串，该字符串包含一些可执行代码的字节编码 (称为<strong>攻击代码</strong>) 和一些字节，这些字节能让指向攻击代码的指针覆盖返回地址，因此，执行指令<code>ret</code>会跳转到攻击代码。在某种攻击形式中，攻击代码会使用系统调用启动1个shell程序，给攻击者提供一组操作系统函数。在另一种攻击形式中，攻击代码会执行一些未授权的任务，修复对栈的损坏，然后再次执行指令<code>ret</code>，(表面上) 正常返回给调用者。</p><h4 id="对抗缓存溢出攻击">3.8.3 对抗缓存溢出攻击</h4><p>　　在系统中插入攻击代码时，既要插入代码，也要插入指向这段代码的指针，该指针也是攻击字符串的一部分，生成该指针需要知道这个字符串的栈地址。过去，程序的栈地址很容易预测。对于所有运行相同程序和操作系统版本组合的机器，栈位置是固定的。以传染病类比，许多系统都容易受到同一种病毒的攻击，这种现象称为<strong>安全单一化</strong>。</p><p>　　栈随机化的思想是使得栈的位置在程序每次运行时都有变化。实现方式是程序开始时，在栈上分配0~<span class="math inline">\(n\)</span>字节的随机大小的空间来了让后续栈的地址变化 (程序不会使用它)。<span class="math inline">\(n\)</span>需要足够大，才能保证栈地址的变化范围足够大，但又需要足够小，不至于浪费太多的空间。</p><p>　　在Linux中，栈随机化已经成为标准，它是<strong>地址空间布局随机化</strong>技术之一。采用ASLR，每次运行时程序的不同部分 (包括程序代码、库代码、栈、全局变量和堆数据) 都会加载到内存不同的区域。然而，可以通过暴力手段来克服随机化，常见方法之一是在实际的攻击代码前插入1段很长的<span style="background-color:#ff0">空操作</span>，执行这种指令除了使PC加1，没有其他效果。只要攻击者能够猜中这段序列中的某个地址，程序就会经过这个序列到达攻击代码，称为<span style="background-color:#ff0">空操作雪橇</span>。栈随机化和其他一些ASLR技术能够增加攻击难度，但并不能完全防御。</p><p>　　第2道防线是<strong>栈损坏检查</strong>。较新版本的GCC加入了<strong>栈保护者</strong>机制，其思想是在所有局部缓存和栈状态之间加入<span style="background-color:#ff0">金丝雀值</span> (也称为<span style="background-color:#ff0">哨兵值</span>)，该值每次运行时随机。在恢复寄存器状态和返回前，程序会检查金丝雀值是否改变，若改变，则程序异常终止。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">echo:</span><br><span class="line">	subq	$24, %rsp</span><br><span class="line">	movq	%fs:40, %rax</span><br><span class="line">	movq	%rax, 8(%rsp)</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	movq	%rax, 8(%rsp)</span><br><span class="line">	call	gets</span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	call	puts</span><br><span class="line">	movq	8(%rsp), %rax</span><br><span class="line">	xorq	%fs:40, %rax</span><br><span class="line">	je		.L2</span><br><span class="line">	call	__stack_chk_fail</span><br><span class="line">.L2:</span><br><span class="line">	addq	$24, %rsp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/stack_organization_for_function_echo_with_stack_protector_enabled.svg" title="stack_organization_for_function_echo_with_stack_protector_enabled"><p>　　栈溢出示例的代码使用了命令行选项<code>-fno-stack-protector</code>，这段代码没有使用该命令行选项。这个版本的函数会在内存中读取1个值 (第3行)，再把它放到存储到相对栈指针偏移量为8的位置。指令操作数<code>%fs:40</code>表示金丝雀值是通过<span style="background-color:#ff0">段寻址</span>从内存中读取的。将金丝雀值存储在特殊的段并标记为只读，这样攻击者就不能覆盖。在恢复寄存器状态和返回前，函数会将存储在栈位置的值和金丝雀值比较 (第11行)。若相等，指令<code>xorq</code>会得到0，函数会正常执行；否则，将会调用错误处理例程。</p><p>　　栈保护者能防止缓存溢出攻击损坏存储在程序栈上的状态。它只会带来很小的性能损失，GCC只在函数中有局部<code>char</code>类型缓存时，才会插入这样的代码。</p><p>　　第3段防线是消除攻击者向系统中插入可执行代码的能力。方法之一是限制存储可执行代码的内存区域。在常规程序中，只有用于存储编译器生成的代码的内存区域才需要是可执行的，其他部分可以被限制为只读和写。虚拟内存空间在逻辑上划分为<span style="background-color:#ff0">页</span>，每页通常是2048或4096B。硬件支持多种形式的内存保护，指示用户程序和操作系统内核允许的访问形式。很多系统允许控制3种访问形式，即读 (从内存读取)、写 (写入到内存) 和执行 (将内存的内容视为机器级代码)。</p><p>　　过去，x86-64体系结构将读和执行访问控制位作为1个1位的标志位，所以任何被标记位可读的页也是可执行的。栈必须是既可读又可写，所以栈的数据也是可执行的。有很多已经实现的机制可以让页可读的同时不可执行，但这种机制通常会带来严重的性能损失。后来，AMD为其64位CPU的内存保加入了<span style="background-color:#ff0">不执行</span>位，将读和执行访问模式分开，Intel也跟进了该特性。有了该特性后，实现页可读的同时不可执行就不再有性能损失。</p><p>　　有些类型的程序要求动态生成和执行代码的能力，例如，<span style="background-color:#ff0">即时</span>编译技术动态地为解释型语言 (例如，Java) 编写的程序生成代码来提供程序性能。</p><h4 id="变长栈帧">3.8.4 变长栈帧</h4><p>　　有些函数需要的局部存储是变长的，例如，声明局部变长数组或调用标准库函数<code>alloca()</code> (该函数类似函数<code>malloc()</code>，但该函数在运行时栈上分配空间，并且分配的空间会在返回时自动释放)。为了管理变长栈帧，x86-64使用寄存器<code>%rbp</code>作为<strong>帧指针</strong>，也称为<strong>基指针</strong>。帧指针是被调用者保存寄存器，所以需要先将其值保存在栈中并让帧指针指向该位置，在之后函数的整个执行过程中帧指针将一直指向该位置。对于固定长度的局部变量 (通常保存在与帧指针相邻且更靠近栈顶的位置)，可以通过其相对帧指针的偏移量来引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">vframe</span><span class="params">(<span class="type">long</span> n, <span class="type">long</span> idx, <span class="type">long</span> *q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> *p[n];</span><br><span class="line">    p[<span class="number">0</span>] = &amp;i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *p[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vframe:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	subq	$16, %rsp</span><br><span class="line">	leaq	22(,%rdi,8), %rax</span><br><span class="line">	andq	$-16, %rax</span><br><span class="line">	subq	%rax, %rsp</span><br><span class="line">	leaq	7(%rsp), %rax</span><br><span class="line">	shrq	$3, %rax</span><br><span class="line">	leaq	0(,%rax,8), %r8</span><br><span class="line">	movq	%r8, %rcx</span><br><span class="line"># ...</span><br><span class="line"></span><br><span class="line">.L3:</span><br><span class="line">	movq	%rdx, (%rcx,%rax,8)</span><br><span class="line">	addq	$1, %rax</span><br><span class="line">	movq	%rax, -8(%rbp)</span><br><span class="line">.L2:</span><br><span class="line">	movq	-8(%rbp), %rax</span><br><span class="line">	cmpq	%rdi, %rax</span><br><span class="line">	jl	.L3</span><br><span class="line"># ...</span><br><span class="line">	</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/stack_frame_for_function_vframe.svg" title="stack_frame_for_function_vframe"><p>　　第1段代码是包含变长数组的示例的C语言代码，第2段代码是GCC生成的汇编代码 (节选了部分)。第1段代码中，函数声明了包含<span class="math inline">\(n\)</span>个指针的局部数组<code>p</code>，<span class="math inline">\(n\)</span>由第1个参数给出，每次调用都可能不同，编译器无法确定该分配给该函数的栈帧空间。此外，该函数还有1个对局部变量<code>i</code>的地址引用，所以该变量必须存储在栈中。在执行该函数时，必须能够访问局部变量<code>i</code>和数组<code>p</code>中的元素。返回时，该函数必须释放该栈帧，并让栈指针指向返回地址。</p><p>　　第2段代码中，会先把帧指针的值压入栈并让帧指针指向栈顶 (第2~3行)。然后，在栈上分配16B，其中前8B存储局部变量<code>i</code>，而后8B未使用。接着，为数组<code>p</code>分配空间 (第5~11行)，<span class="math inline">\(s_1\)</span>是第4行代码执行后栈指针的值，<span class="math inline">\(s_2\)</span>是第7行代码执行后栈指针的值，<span class="math inline">\(p\)</span>是第10~11行中赋值给寄存器<code>%r8</code>和<code>%rcx</code>的值，用于引用数组<code>p</code>。第5行会通过指令<code>leaq</code>计算<span class="math inline">\(8n+22\)</span>，第6行会通过指令<code>andq</code>将结果向下舍入到最接近的16的整数倍，<span class="math inline">\(s_2\)</span>等于<span class="math inline">\(s_1\)</span>减该值。第8~10行会将<span class="math inline">\(s_2\)</span>向上舍入到最接近的8的整数倍。<span class="math inline">\(p\)</span>是8的整数倍，<span class="math inline">\(s_1\)</span>与<span class="math inline">\(s_2\)</span>的差值是16的整数倍，而可能存在的空间<span class="math inline">\(e_1\)</span>和<span class="math inline">\(e_2\)</span>正是为了保证这一点。变量<code>i</code>的地址是<code>-8(%rbp)</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq	%rbp, %rsp</span><br><span class="line">popq	%rbp</span><br></pre></td></tr></table></figure><p>　　指令<code>leave</code>用于释放栈帧，等价于这2条指令，即先将栈指针设置为保存帧指针值的位置并将弹出帧指针。</p><p>　　在较早的x86-64代码中，每个函数调用都会使用帧指针。后来，只有栈帧长度可变的情况才使用。过去，大多数编译器在生成IA32代码时会使用帧指针，较新版本的GCC放弃了这一惯例。</p><h3 id="浮点代码">3.9 浮点代码</h3><p>　　由于1997年推出的Pentium/MMX，Intel和AMD都推出了持续数代的用于支持图形和图像处理的媒体指令。这些指令本意是允许多个操作以并行模式执行 (即<strong>单指令多数据</strong>)。在这种模式中，对多个不同数据并行执行同一操作。后来，经过长足的发展，名称也发生了变化，从MMX到SSE再到AVX。每一代中，都有一些不同的版本。这些版本都会管理寄存器组的数据，这些寄存器在MMX中称为MM寄存器，SSE中称为XMM寄存器，AVX中称为YMN寄存器。MM寄存器是64位，XMM寄存器是128位，YMM寄存器是256位。因此，每个YMM寄存器可以存储8个32位值或4个64位值，这些值可以是整数或浮点数。</p><p>　　2000年推出的Pentium 4中使用了SSE2，至此，媒体指令开始包括通过XMM和YMM寄存器的低32位或64位中的单个值操作标量浮点数据的指令。这个标量模式提供了一组寄存器和指令，它们更类似于其他CPU支持浮点数的方式。所有能够执行x86-64代码的CPU都支持SSE2或更高的版本，因此，x86-64浮点数是基于SSE或AVX的，包括传递过程参数和返回值的规则。</p><p>　　这里的内容基于AVX2，即AVX的第2个版本，在2013年Core i7 Haswell CPU中使用。当给定<code>-mavx2</code>命令行选项时，GCC会生成AVX2代码。基于不同版本的SSE以及第1个版本的AVX的代码从概念上类似，不过指令名和格式有所不同。</p><img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/media_registers.svg" title="media_registers"><p>　　AVX浮点体系结构允许数据存储在16个YMM寄存器，它们的名称为<code>%ymm0</code>~<code>%ymm15</code>。每个YMM寄存器都是256位。当对标量数据操作时，这些寄存器仅保存浮点数，而且只使用低32 (对于<code>float</code>) 或64位 (对于<code>double</code>)。汇编代码用寄存器的SSE XMM寄存器名称<code>%xmm0</code>~<code>%xmm15</code>来引用它们，每个XMM寄存器都是对应的YMM寄存器的低128位。</p><p>　　寄存器<code>%xmm0</code>~<code>%xmm7</code>用于传递浮点参数，按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。寄存器<code>%xmm0</code>还用于返回浮点值。所有的XMM寄存器都是调用者保存，被调用者可以不用保存就覆盖这些寄存器。</p><p>　　当函数参数包含指针、整数和浮点数时，指针和整数通过整数寄存器传递，浮点数通过XMM寄存器传递，寄存器的分配取决于参数的类型和排列顺序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> x, <span class="type">double</span> y, <span class="type">long</span> z)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">f2</span><span class="params">(<span class="type">double</span> y, <span class="type">int</span> x, <span class="type">long</span> z)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">f3</span><span class="params">(<span class="type">float</span> x, <span class="type">double</span> *y, <span class="type">double</span> *z)</span>;</span><br></pre></td></tr></table></figure><p>　　函数<code>f1()</code>的参数<code>x</code>、<code>y</code>和<code>z</code>分别存储在寄存器<code>%edi</code>、<code>%xmm0</code>和<code>%rsi</code>，函数<code>f2()</code>和函数<code>f1()</code>的寄存器分配相同。函数<code>f3()</code>的参数<code>x</code>、<code>y</code>和<code>z</code>分别存储在寄存器<code>%xmm0</code>、<code>%rdi</code>和<code>%rsi</code>。</p><h4 id="浮点移动和转换操作">3.9.1 浮点移动和转换操作</h4><table><thead><tr><th>指令</th><th>源</th><th>目的</th><th>描述</th></tr></thead><tbody><tr><td><code>vmovss</code></td><td><span class="math inline">\(M_{32}\)</span></td><td><span class="math inline">\(X\)</span></td><td>移动单精度数</td></tr><tr><td><code>vmovss</code></td><td><span class="math inline">\(X\)</span></td><td><span class="math inline">\(M_{32}\)</span></td><td>移动单精度数</td></tr><tr><td><code>vmovsd</code></td><td><span class="math inline">\(M_{64}\)</span></td><td><span class="math inline">\(X\)</span></td><td>移动双精度数</td></tr><tr><td><code>vmovsd</code></td><td><span class="math inline">\(X\)</span></td><td><span class="math inline">\(M_{64}\)</span></td><td>移动双精度数</td></tr><tr><td><code>vmovaps</code></td><td><span class="math inline">\(X\)</span></td><td><span class="math inline">\(X\)</span></td><td>移动对齐且已封装的单精度数</td></tr><tr><td><code>vmovapd</code></td><td><span class="math inline">\(X\)</span></td><td><span class="math inline">\(X\)</span></td><td>移动对齐且已封装的双精度数</td></tr></tbody></table><p>　　引用内存的指令是<span style="background-color:#ff0">标量</span>指令，表示其操作数是单个值而非封装后的值。数据要么保存在内存中 (在表中用<span class="math inline">\(M_{32}\)</span>和<span class="math inline">\(M_{64}\)</span>表示)，要么保存在XMM寄存器中 (在表中用<span class="math inline">\(X\)</span>表示)。无论数据是否对齐，这些指令都能正确执行，不过代码优化规则建议32位内存满足4B对齐，64位数据满足8B对齐。内存引用的指定方式与整数数据移动指令相同，包括偏移量、基址寄存器、变址寄存器和伸缩因子的所有可能的组合。</p><p>　　GCC只用标量移动操作从内存移动数据到XMM寄存器或从XMM寄存器移动数据到内存。对于在两个XMM寄存器之间移动数据，GCC会使用指令<code>vmovaps</code>和<code>vmovapd</code>，程序复制整个寄存器还是只复制低位并不会影响程序功能，也不会影响执行速度，所以使用这些指令还是针对标量数据的指令并没有实质上的差别。指令名称中<code>a</code>表示对齐，当用于读写内存时，若地址不满足16B对齐，则会导致异常。</p><table><colgroup><col style="width:19%"><col style="width:14%"><col style="width:11%"><col style="width:53%"></colgroup><thead><tr><th>指令</th><th>源</th><th>目的</th><th>描述</th></tr></thead><tbody><tr><td><code>vcvttss2si</code></td><td><span class="math inline">\(X/M_{32}\)</span></td><td><span class="math inline">\(R_{32}\)</span></td><td>用截断的方法将单精度数转换成整数</td></tr><tr><td><code>vcvttsd2si</code></td><td><span class="math inline">\(X/M_{64}\)</span></td><td><span class="math inline">\(R_{32}\)</span></td><td>用截断的方法将双精度数转换成整数</td></tr><tr><td><code>vcvttss2siq</code></td><td><span class="math inline">\(X/M_{32}\)</span></td><td><span class="math inline">\(R_{64}\)</span></td><td>用截断的方法将单精度数转换成四字整数</td></tr><tr><td><code>vcvttsd2siq</code></td><td><span class="math inline">\(X/M_{64}\)</span></td><td><span class="math inline">\(R_{64}\)</span></td><td>用截断的方法将双精度数转换成四字整数</td></tr></tbody></table><p>　　浮点数转换整数指令有2个操作数，这类指令会把1个从XMM寄存器或内存中读出的浮点数进行<strong>截断</strong>，即向零舍入，然后将结果存入整数寄存器 (在表中用<span class="math inline">\(R_{32}\)</span>和<span class="math inline">\(R_{64}\)</span>表示)。</p><table><colgroup><col style="width:20%"><col style="width:25%"><col style="width:6%"><col style="width:6%"><col style="width:40%"></colgroup><thead><tr><th>指令</th><th>源1</th><th>源2</th><th>目的</th><th>描述</th></tr></thead><tbody><tr><td><code>vcvtsi2ss</code></td><td><span class="math inline">\(M_{32}/R_{32}\)</span></td><td><span class="math inline">\(X\)</span></td><td><span class="math inline">\(X\)</span></td><td>将整数转换成单精度数</td></tr><tr><td><code>vcvtsi2sd</code></td><td><span class="math inline">\(M_{32}/R_{32}\)</span></td><td><span class="math inline">\(X\)</span></td><td><span class="math inline">\(X\)</span></td><td>将整数转换成双精度数</td></tr><tr><td><code>vcvtsi2ssq</code></td><td><span class="math inline">\(M_{64}/R_{64}\)</span></td><td><span class="math inline">\(X\)</span></td><td><span class="math inline">\(X\)</span></td><td>将四字整数转换成单精度数</td></tr><tr><td><code>vcvtsi2sdq</code></td><td><span class="math inline">\(M_{64}/R_{64}\)</span></td><td><span class="math inline">\(X\)</span></td><td><span class="math inline">\(X\)</span></td><td>将四字整数转换成双精度数</td></tr></tbody></table><p>　　整数转换浮点数指令有3个操作数 (2个源和1个目的)，第1个操作数来自内存或整数寄存器，第2个操作数仅影响结果的高位，第3个操作数必须是XMM寄存器。在常见的使用场景中，第2个操作数和第3个操作数相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vunpcklps	%xmm0, %xmm0, %xmm0</span><br><span class="line">vcvtps2pd	%xmm0, %xmm0</span><br></pre></td></tr></table></figure><p>　　这2条指令会将单精度数转换为双精度数。指令<code>vunpckls</code>会交叉前2个寄存器的值并将结果放到第3个寄存器，若第1个寄存器的内容为字<span class="math inline">\([s_3,s_2,s_1,s_0]\)</span>，第2个寄存器的内容是字<span class="math inline">\([d_3,d_2,d_1,d_0]\)</span>，则第3个寄存器的内容是字<span class="math inline">\([s_1,d_1,s_0,d_0]\)</span>。指令<code>vcvtps2pd</code>会把第1个寄存器中的2个低位单精度值扩展成第2个寄存器的2个双精度值，得到结果<span class="math inline">\([dx_0,dx_0]\)</span>，而<span class="math inline">\(dx_0\)</span>就是转换后的双精度数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vmovddup	%xmm0, %xmm0</span><br><span class="line">vcvtpd2psx	%xmm0, %xmm0</span><br></pre></td></tr></table></figure><p>　　这2条指令会将双精度数转换为单精度数。若寄存器<code>%xmm0</code>保存着双精度值<span class="math inline">\([x_1,x_0]\)</span>，指令<code>vmovddup</code>会将它设置为<span class="math inline">\([x_0,x_0]\)</span>，指令<code>vcvtpd2psx</code>会把这2个值转换为单精度数，再打包到寄存器的低位一半，并将高位一半置0，得到结果<span class="math inline">\([0.0,0.0,x_0,x_0]\)</span>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">fcvt</span><span class="params">(<span class="type">int</span> i, <span class="type">float</span> *fp, <span class="type">double</span> *dp, <span class="type">long</span> *lp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f = *fp;</span><br><span class="line">    <span class="type">double</span> d = *dp;</span><br><span class="line">    <span class="type">long</span> l = *lp;</span><br><span class="line">    *lp = (<span class="type">long</span>)d;</span><br><span class="line">    *fp = (<span class="type">float</span>)i;</span><br><span class="line">    *dp = (<span class="type">double</span>)l;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fcvt:</span><br><span class="line">	vmovss	(%rsi), %xmm0</span><br><span class="line">	movq	(%rcx), %rax</span><br><span class="line">	vcvttsd2siq	(%rdx), %r8</span><br><span class="line">	movq	%r8, (%rcx)</span><br><span class="line">	vcvtsi2ss	%edi, %xmm1, %xmm1</span><br><span class="line">	vmovss	%xmm1, (%rsi)</span><br><span class="line">	vcvtsi2sdq	%rax, %xmm1, %xmm1</span><br><span class="line">	vmovsd	%xmm1, (%rdx)</span><br><span class="line">	vunpcklps	%xmm0, %xmm0, %xmm0</span><br><span class="line">	vcvtps2pd	%xmm0, %xmm0</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><p>　　函数<code>fvct()</code>的所有参数都是通过整数寄存器传递，结果通过寄存器<code>%xmm0</code>返回。</p><h4 id="浮点运算操作">3.9.2 浮点运算操作</h4><table><thead><tr><th>单精度数指令</th><th>双精度数指令</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td><code>vaddss</code></td><td><code>vaddsd</code></td><td><code>D</code> ← <code>S2 + S1</code></td><td>浮点加法</td></tr><tr><td><code>vsubss</code></td><td><code>vsubsd</code></td><td><code>D</code> ← <code>S2 - S1</code></td><td>浮点减法</td></tr><tr><td><code>vmulss</code></td><td><code>vmulsd</code></td><td><code>D</code> ← <code>S2 * S1</code></td><td>浮点乘法</td></tr><tr><td><code>vdivss</code></td><td><code>vdivsd</code></td><td><code>D</code> ← <code>S2 / S1</code></td><td>浮点除法</td></tr><tr><td><code>vmaxss</code></td><td><code>vmaxsd</code></td><td><code>D</code> ← <code>max(S2, S1)</code></td><td>浮点最大值</td></tr><tr><td><code>vminss</code></td><td><code>vminsd</code></td><td><code>D</code> ← <code>min(S2, S1)</code></td><td>浮点最小值</td></tr><tr><td><code>sqrtss</code></td><td><code>sqrtsd</code></td><td><code>D</code> ← <code>sqrt(S1)</code></td><td>浮点数平方根</td></tr></tbody></table><p>　　对于浮点运算指令，每条指令都有1或2个源操作数以及1个目的操作数。第1个源操作数<code>S1</code>可以是XMM寄存器或内存引用，第2个源操作数<code>S2</code>和目的操作数必须是XMM寄存器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">funct</span><span class="params">(<span class="type">double</span> a, <span class="type">float</span> x, <span class="type">double</span> b, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a * x - b / i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">funct:</span><br><span class="line">	vunpcklps	%xmm1, %xmm1, %xmm1</span><br><span class="line">	vcvtps2pd	%xmm1, %xmm1</span><br><span class="line">	vmulsd	%xmm0, %xmm1, %xmm0</span><br><span class="line">	vcvtsi2sd	%edi, %xmm1, %xmm1</span><br><span class="line">	vdivsd	%xmm1, %xmm2, %xmm2</span><br><span class="line">	vsubsd	%xmm2, %xmm0, %xmm0</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><p>　　函数<code>funct()</code>的参数<code>a</code>、<code>x</code>和<code>b</code>通过寄存器<code>%xmm0</code>~<code>%xmm2</code>传递，参数<code>i</code>通过寄存器<code>%edi</code>传递。第2~3行会将参数<code>x</code>转换为双精度数，第5行会将参数<code>i</code>转换为双精度数，最后结果通过寄存器<code>%xmm0</code>返回。</p><h4 id="浮点常数">3.9.3 浮点常数</h4><p>　　AVX浮点操作不能将立即数作为操作数。相反，编译器必须为所有的常量值分配并初始化空间。然后，从内存读取这些值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">cel2fahr</span><span class="params">(<span class="type">double</span> temp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.8</span> * temp + <span class="number">32.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cel2fahr:</span><br><span class="line">	vmulsd	.LC0(%rip), %xmm0, %xmm0</span><br><span class="line">	vaddsd	.LC1(%rip), %xmm0, %xmm0</span><br><span class="line">	ret</span><br><span class="line">.LC0:</span><br><span class="line">	.long	3435973837</span><br><span class="line">	.long	1073532108</span><br><span class="line">.LC1:</span><br><span class="line">	.long	0</span><br><span class="line">	.long	1077936128</span><br></pre></td></tr></table></figure><p>　　函数<code>cel2fahr()</code>从标签<code>.LC0</code>处读取值1.8，从标签<code>.LC1</code>处读取值32.0，这些标签里都是一对<code>.long</code>声明和十进制表示的值。对于标签<code>.LC0</code>，这2个值的十六进制是<code>0xcccccccd</code>和<code>0x3ffccccc</code>，因为机器是小端模式，第1个值给出低4B，第2个值给出高4B。从高位字节提取指数字段<code>0x3ff</code>，减去偏移值1023得到指数0。将2个值的小数位组合起来，得到小数字段<code>0xccccccccccccd</code>，二进制小数表示为0.8，加上隐含的1得到1.8。</p><h4 id="浮点位级操作和比较操作">3.9.4 浮点位级操作和比较操作</h4><table><thead><tr><th>单精度数指令</th><th>双精度数指令</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td><code>vxorps</code></td><td><code>vxorpd</code></td><td><code>D</code> ← <code>S2 ^ S1</code></td><td>位级异或</td></tr><tr><td><code>vandps</code></td><td><code>vandpd</code></td><td><code>D</code> ← <code>S2 &amp; S1</code></td><td>位级与</td></tr></tbody></table><p>　　浮点位级指令类似于整数位级指令在整数寄存器上的操作，这类指令作用于封装后的数据，即更新整个目的XMM寄存器，对2个源寄存器的所有位都执行指定的位级操作。</p><table><thead><tr><th>指令</th><th>基于</th><th>描述</th></tr></thead><tbody><tr><td><code>ucomiss S1, S2</code></td><td><code>S2 - S1</code></td><td>比较单精度数</td></tr><tr><td><code>ucomissd S1, S2</code></td><td><code>S2 - S1</code></td><td>比较双精度数</td></tr></tbody></table><p>　　浮点比较指令类似于整数比较指令，这类指令会比较操作数并设置条件码来表示它们的相对值。第1个参数可以是XMM寄存器或内存引用，第2个参数只能是XMM寄存器。</p><table><thead><tr><th>顺序为<code>S2 : S1</code></th><th>CF</th><th>ZF</th><th>PF</th></tr></thead><tbody><tr><td>无序</td><td>1</td><td>1</td><td>1</td></tr><tr><td><code>S2 &lt; S1</code></td><td>1</td><td>0</td><td>0</td></tr><tr><td><code>S2 = S1</code></td><td>0</td><td>1</td><td>0</td></tr><tr><td><code>S2 &gt; S1</code></td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>　　浮点比较指令会设置CF、ZF和PF。对于整数操作，当最近的算术或逻辑运算生成的值的最低位字节满足偶校验时 (该字节中有偶数个1)，会将PF置1。对于浮点比较，当操作数中有NaN时，会出现<span style="background-color:#ff0">无序</span>的情况，然后将PF置1。指令<code>jp</code> (jump on parity) 通常用于条件跳转，条件就是浮点比较结果为无序，除了这种情况，其他情况下，CF和ZF的值都与对应的无符号比较情况相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NEG,</span><br><span class="line">    ZERO,</span><br><span class="line">    POS,</span><br><span class="line">    OTHER</span><br><span class="line">&#125; <span class="type">range_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">range_t</span> <span class="title function_">find_range</span><span class="params">(<span class="type">float</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = NEG;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = ZERO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = POS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = OTHER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">find_range:</span><br><span class="line">	vxorps	%xmm1, %xmm1, %xmm1</span><br><span class="line">	vucomiss	%xmm0, %xmm1</span><br><span class="line">	ja	.L5</span><br><span class="line">	vucomiss	%xmm1, %xmm0</span><br><span class="line">	jp	.L8</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	je	.L3</span><br><span class="line">.L8:</span><br><span class="line">	vucomiss	.LCO(%rip), %xmm0</span><br><span class="line">	setbe	%al</span><br><span class="line">	movzbl	%al, %eax</span><br><span class="line">	addl	$2, %eax</span><br><span class="line">	ret</span><br><span class="line">.L5:</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">.L3:</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure><p>　　在函数<code>find_range()</code>的汇编代码中，会将<code>x</code>和<code>0.0</code>比较3次，即使1次就能获得所需信息。它还生成了2次浮点常数<code>0.0</code>，1次用于指令<code>vxorps</code>，1次从内存读取该值。</p><p>　　● 当<code>x &lt; 0.0</code>时，第4行的指令<code>ja</code>会选择跳转到结尾，返回值为<code>NEG</code> (0)。</p><p>　　● 当<code>x = 0.0</code>时，第4行的指令<code>ja</code>和第6行的指令<code>jp</code>都不会跳转，第8行的指令<code>je</code>会跳转，返回<code>ZERO</code> (1)。</p><p>　　● 当<code>x &gt; 0.0</code>时，这3个跳转指令都不会跳转。第11行的指令<code>setbe</code>会得到0，然后，第13行的指令<code>addl</code>会加2，返回<code>POS</code> (2)。</p><p>　　● 当<code>x = NaN</code>时，第6行的指令<code>jp</code>会跳转，第10行的指令<code>vucomiss</code>会设置CF和ZF，所以第11行的指令<code>setbe</code>得到1，然后，第13行的指令<code>addl</code>会加2，返回值为<code>OTHER</code> (3)。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2022/10/05/computer-systems-a-programmer's-perspective-3e-chpt-2/" rel="prev" title="《深入理解计算机系统 第3版》第2章 信息的表示与处理"><i class="fa fa-angle-left"></i> 《深入理解计算机系统 第3版》第2章 信息的表示与处理</a></div><div class="post-nav-item"><a href="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/" rel="next" title="《深入理解计算机系统 第3版》第4章 处理器体系架构">《深入理解计算机系统 第3版》第4章 处理器体系架构 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script></body></html>