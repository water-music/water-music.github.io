<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><link rel="canonical" href="http://example.com/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/","path":"2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/","title":"《深入理解计算机系统 第3版》第9章 虚拟内存"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《深入理解计算机系统 第3版》第9章 虚拟内存 |</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E7%9A%84%E7%A9%BA%E9%97%B4"><span class="nav-text">9.1 虚拟内存作为缓存的空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="nav-text">9.2 虚拟内存作为内存管理的工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="nav-text">9.3 虚拟内存作为内存保护的工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-text">9.4 地址转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8tlb%E5%8A%A0%E9%80%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-text">9.4.1 用TLB加速地址转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-text">9.4.2 多级页表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-text">9.4.3 端到端的地址转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6intel-core-i7linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="nav-text">9.5 案例研究：Intel Core i7&#x2F;Linux内存系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#core-i7%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-text">9.5.1 Core i7地址转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="nav-text">9.5.2 Linux虚拟内存系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="nav-text">9.5.2.1 Linux虚拟内存区域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#linux%E7%BC%BA%E9%A1%B5%E5%A4%84%E7%90%86"><span class="nav-text">9.5.2.2 Linux缺页处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-text">9.6 内存映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%8D%E7%9C%8B%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1"><span class="nav-text">9.6.1 再看共享对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%8D%E7%9C%8B%E5%87%BD%E6%95%B0fork%E5%92%8Cexecve"><span class="nav-text">9.6.2 再看函数fork()和execve()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0mmap%E8%BF%9B%E8%A1%8C%E7%94%A8%E6%88%B7%E7%BA%A7%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-text">9.6.3 使用函数mmap()进行用户级内存映射</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-text">9.7 动态内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0malloc%E5%92%8Cfree"><span class="nav-text">9.7.1 函数malloc和free</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E8%A6%81%E6%B1%82%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="nav-text">9.7.2 分配器的要求和目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="nav-text">9.7.3 隐式空闲链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E7%A9%BA%E9%97%B2%E5%9D%97"><span class="nav-text">9.7.4 合并空闲块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-text">9.7.5 实现简单的分配器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B8%B8%E6%95%B0%E5%92%8C%E5%AE%8F"><span class="nav-text">9.7.5.1 操作空闲链表的基本常数和宏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%9D%E5%A7%8B%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="nav-text">9.7.5.2 创建初始空闲链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E5%92%8C%E5%90%88%E5%B9%B6%E5%9D%97"><span class="nav-text">9.7.5.3 释放和合并块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%9D%97"><span class="nav-text">9.7.5.4 分配块</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="nav-text">9.7.6 显式空闲链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%A6%BB%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="nav-text">9.7.7 分离空闲链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%88%86%E7%A6%BB%E5%AD%98%E5%82%A8"><span class="nav-text">9.7.7.1 简单分离存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E7%A6%BB%E9%80%82%E9%85%8D"><span class="nav-text">9.7.7.2 分离适配</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">9.8 垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text">9.8.1 标记-清除垃圾回收器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BF%9D%E5%AE%88%E5%BC%8F%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4"><span class="nav-text">9.8.2 C程序的保守式标记-清除</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E9%94%99%E8%AF%AF"><span class="nav-text">9.9 C程序中常见的内存相关错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%9D%8F%E6%8C%87%E9%92%88"><span class="nav-text">9.9.1 间接使用坏指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%86%85%E5%AD%98"><span class="nav-text">9.9.2 读未初始化的内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="nav-text">9.9.3 栈缓冲区溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%87%E8%AE%BE%E6%8C%87%E9%92%88%E4%B8%8E%E5%85%B6%E6%8C%87%E5%90%91%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E7%9B%B8%E5%90%8C"><span class="nav-text">9.9.4 假设指针与其指向的对象大小相同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%B7%AE1%E9%94%99%E8%AF%AF"><span class="nav-text">9.9.5 相差1错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%8C%87%E9%92%88%E8%80%8C%E9%9D%9E%E5%85%B6%E6%8C%87%E5%90%91%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">9.9.6 引用指针而非其指向的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AF%E8%A7%A3%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="nav-text">9.9.7 误解指针运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-text">9.9.8 引用不存在的变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%A9%BA%E9%97%B2%E5%A0%86%E5%9D%97%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-text">9.9.9 引用空闲堆块中的数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-text">9.9.10 内存泄漏</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《深入理解计算机系统 第3版》第9章 虚拟内存 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《深入理解计算机系统 第3版》第9章 虚拟内存</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-08-02 00:00:00" itemprop="dateCreated datePublished" datetime="2023-08-02T00:00:00+08:00">2023-08-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-11-26 00:00:00" itemprop="dateModified" datetime="2023-11-26T00:00:00+08:00">2023-11-26</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/computer-system/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>32k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　虚拟内存诞生于20世纪60年代初期，远在CPU和内存之间的差距加大导致出现SRAM缓存之前。因此，虚拟内存系统使用了和SRAM缓存不同的术语，尽管它们的许多概念是相似的。在虚拟内存的习惯说法中，块称为<strong>页</strong>。在磁盘和内存之间传输页称为<strong>交换</strong>或<strong>页面调度</strong>，页<strong>换入</strong> (也称为<strong>页面调入</strong>) 或<strong>换出</strong> (也称为<strong>页面调出</strong>) 到磁盘中。现代操作系统都是使用<strong>按需页面调度</strong>，即只有当发生未命中时才换入页面。</p><p>　　在虚拟内存中，DRAM缓存未命中称为<strong>缺页</strong>。</p><p>　　<strong>地址空间</strong>是非负整数地址的有序集合<span class="math inline">\(\{0,1,2...\}\)</span>。<strong>线性地址空间</strong>中的整数是连续的。</p><p>　　计算机系统的内存被组织为由<span class="math inline">\(M\)</span>个连续的单字节大小的单元组成的数组。每个字节都有唯一的<strong>物理地址</strong>。第1个字节的地址为0，第2个字节的地址为1，依此类推。CPU访问内存的最自然的方式是使用PA，这种寻址方式称为<strong>物理寻址</strong>。系统中有<strong>物理地址空间</strong>对应这<span class="math inline">\(M\)</span>个字节。</p><p>　　以<span class="math inline">\(n\)</span>位线性地址空间为例，CPU从<span class="math inline">\(N=2^n\)</span>个地址的地址空间中生成<strong>虚拟地址</strong>，这个地址空间称为<strong>虚拟地址空间</strong><span class="math inline">\(\{0,1,2,..,N-1\}\)</span>。现代系统通常支持32位或64位虚拟地址空间。</p><p>　　内存中的每个字节都有1个来自虚拟地址空间的VA和1个来自物理地址空间的PA。</p><p>　　DEC PDP-11/70等早期的系统支持比物理内存更小的虚拟地址空间。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/a_system_that_uses_physical_addressing.svg" title="a_system_that_uses_physical_addressing"><p>　　这个示例的背景是加载1条指令，该指令读PA4处的4B字。当CPU执行该指令时，会生成有效PA并通过内存总线传递给内存。内存取出PA4处的4B字并将它返回给CPU。CPU会将该字存放在某个寄存器中。</p><span id="more"></span><p>　　早期计算机使用物理寻址，而且数组信号处理器、嵌入式微控制器和Cray超级计算机等系统还在使用这种寻址方式。现代CPU使用<strong>虚拟寻址</strong>。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/a_system_that_uses_virtual_addressing.svg" title="a_system_that_uses_virtual_addressing"><p>　　使用虚拟寻址时，CPU通过VA来访问内存，该VA在传递给内存前会先转换为对应的PA。将VA转换为PA的过程称为<strong>地址转换</strong>。地址转换需要CPU硬件和操作系统共同来实现。CPU芯片上的<strong>内存管理单元</strong>通过存放在内存中的查询表来动态转换VA，该表的内容由操作系统管理。</p><p>　　Linux中的函数<code>getrusage()</code>可以监测缺页的数量以及很多其他信息。</p><h3 id="虚拟内存作为缓存的空间">9.1 虚拟内存作为缓存的空间</h3><p>　　和存储器层次结构中其他缓存一样，磁盘上的数据被划分成块，这些块作为磁盘和内存之间的传输单元。为了应对这种情况，虚拟内存系统通过将虚拟内存划分为称为<strong>虚拟页</strong>的固定大小的块。每个虚拟页的大小<span class="math inline">\(P=2^p\)</span>字节。同样，物理内存被划分为<strong>物理页</strong> (也称为<strong>页帧</strong>)，大小也是<span class="math inline">\(P\)</span>字节。</p><p>　　虚拟页的集合分为3个不相交的子集，即<span style="background-color:#ff0">未分配</span>的页集合 (虚拟内存系统还未分配或创建的页)、<span style="background-color:#ff0">已缓存</span>的页集合 (当前已缓存在物理内存中的已分配的页) 和<span style="background-color:#ff0">未缓存</span>的页集合 (未缓存在物理内存中的已分配的页)。未分配的页没有与任何数据关联，所以不占用任何磁盘空间。</p><p>　　在存储器层次结构中，SRAM用于L1、L2和L3缓存，DRAM用于内存。DRAM缓存未命中的代价比SRAM缓存未命中的代价大得多。此外，读磁盘扇区的首个字节的开销比读这个扇区中连续的字节的开销大得多。因此，VP比较大，通常是4KB~2MB。</p><p>　　由于DRAM缓存未命中的代价很大，所以它是全相联的，即任何VP都可以放置在任何PP中。未命中的替换策略也很重要，因为替换错误的VP的代价很高。因此，与硬件对SRAM缓存使用的替换策略相比，操作系统对DRAM缓存使用的替换策略更复杂。此外，磁盘的存取时间很长，所以DRAM缓存使用回写。</p><p>　　虚拟内存可能看似效率很低 (因为其严重的未命中代价)，由于局部性，虚拟内存的性能并不差。</p><p>　　尽管在整个运行过程中程序引用的页总数可能超过物理内存，但局部性保证了程序将趋于在较小的活动页集合上进行，这个集合称为<strong>工作集</strong>或<strong>常驻集</strong>。在初始化后 (将工作集调度到内存)，之后对该工作集的引用都会命中，而不会产生额外的磁盘流量。只要程序有良好的时间局部性，虚拟内存就能有不错的性能。但实际中并非总是如此，若工作集的大小超过了物理内存，程序会出现<strong>抖动</strong>，即页面不断地调入调出。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/how_a_virtual_memory_system_uses_main_memory_as_a_cache.svg" title="how_a_virtual_memory_system_uses_main_memory_as_a_cache"><p>　　这个示例中的虚拟内存有8个VP。VP0和3还为被分配，所以在磁盘上不存在。VP1、4和6缓存在物理内存中。VP2、5和7已经被分配但未被缓存在内存中。</p><p>　　同缓存一样，虚拟内存系统必须判断VP是否缓存在DRAM中。若已缓存，则需要确定存放VP的PP；若未缓存，则需要判断VP在磁盘中的位置，在物理内存中选择牺牲页并将VP复制到DRAM中替换牺牲页。这些功能需要硬件和软件共同完成，包括操作系统、MMU中的地址转换硬件和存放在物理内存中的称为<strong>页表</strong>的数据结构。</p><p>　　页表是<strong>页表条目</strong>组成的数组。每个VP在页表中的1个固定偏移处都有对应的PTE。这里为了展示，将PTE假设为由1位<span style="background-color:#ff0">有效位</span>和<span class="math inline">\(n\)</span>位地址字段组成。有效位指明该VP当前是否缓存在DRAM中。当设置了有效位时，表示该VP对应的PP已缓存，地址字段就是DRAM中该VP对应的PP的起始地址。当未设置有效位时，若地址字段不为空，则地址字段就是磁盘上该VP的起始地址；若地址字段为空，则表示该VP还未被分配。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/page_table.svg" title="page_table"><p>　　这个示例中展示了有8个VP和4个PP的系统的页表。VP1、2、4和7缓存在DRAM中。VP0和5还未被分配。VP3和6已经被分配但未被缓存。</p><p>　　若CPU需要读VP2中的某个字，而VP2缓存在DRAM中，则地址转换硬件会将该字的VA作为索引来定位PTE2并从内存中读它。因为设置了有效位，地址转移硬件会使用PTE中的地址字段来生成该字的PA。</p><p>　　若CPU需要读VP3中的某个字，而VP3未缓存，则地址转换硬件会从内存中读取PTE3，从有效位推断VP3未缓存并触发缺页异常。缺页异常会调用内核中的缺页异常处理程序，该程序会选择牺牲页，这里假设选择了存放在PP3中的VP4。若VP4已修改，则内核会将进行回写 (将VP4复制回磁盘)。无论如何，内核都会修改VP4的PTE来指明VP4不再缓存在内存。然后，内核从磁盘复制VP3到内存中的PP3，更新PTE3，然后返回。当从缺页异常处理程序返回时，会重启导致缺页的指令。</p><p>　　若调用函数<code>malloc()</code>来分配VP5，分配过程是在磁盘上创建空间并更新PTE5使之指向磁盘上新创建的页。</p><h3 id="虚拟内存作为内存管理的工具">9.2 虚拟内存作为内存管理的工具</h3><p>　　操作系统会每个进程都提供独立的页表，即独立的虚拟地址空间。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/how_virtual_memory_provides_processes_with_separate_address_spaces.svg" title="how_virtual_memory_provides_processes_with_separate_address_spaces"><p>　　在这个示例中，进程<code>i</code>的页表将VP1映射到PP2，将VP2映射到PP7。同样，进程<code>j</code>的页表将VP1映射PP7，将VP2映射PP10。多个VP可以映射到同一共享PP上。</p><p>　　按需页面调度和独立的虚拟地址空间的结合对系统中内存的使用和管理有深远的影响，尤其是虚拟内存简化了<span style="background-color:#ff0">链接</span>、<span style="background-color:#ff0">加载</span>、<span style="background-color:#ff0">代码和数据的共享</span>以及<span style="background-color:#ff0">程序的内存分配</span>。</p><p>　　● 独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放的物理内存位置。对于64位地址空间，代码段总是从虚拟地址<code>0x400000</code>开始。数据段在代码段之后 (中间有段对齐间隔)，栈在用户地址空间地址值最大的部分并向低地址增长，这样的一致性极大地简化了链接器的设计和实现，允许链接器生成完成链接的可执行文件，这些可执行文件独立于物理内存中代码和数据的最终位置。</p><p>　　● 虚拟内存让加载可执行文件和共享库很容易。为了把目标文件中的<code>.text</code>节和<code>.data</code>节加载到新创建进程中，Linux加载器会为代码段和数据段分配VP并将它们标记为无效 (即未被缓存)，然后将PTE指向目标文件中合适的位置。这里，加载器并不会立即从磁盘复制数据到内存。在每个页初次被引用时 (CPU取指令或正在执行的指令引用内存位置)，虚拟内存系统会按需自动调入数据页。</p><p>　　● 独立地址空间为操作系统提供了用于管理用户进程或操作系统自身间的共享的一致性机制。通常，每个进程都有私有的代码、数据、堆和栈区域，操作系统创建页表来将对应的VP映射到不连续的PP。在某些情况下，进程需要共享代码和数据。例如，每个进程必须调用相同的操作系统内核代码，而每个C程序都会调用C标准库中的函数，操作系统通过将不同进程中合适的VP映射到相同PP来实现多个进程共享这部分代码的副本。</p><p>　　● 虚拟内存为用户进程提供了简单的分配额外内存的机制。若运行在用户进程中的程序请求额外的空间 (通过调用函数<code>malloc()</code>等)，则操作系统会分配<span class="math inline">\(k\)</span>个连续的VP并将它们映射到<span class="math inline">\(k\)</span>个不连续的PP (由于页表的工作方式，操作系统无需分配<span class="math inline">\(k\)</span>个连续的PP)。</p><h3 id="虚拟内存作为内存保护的工具">9.3 虚拟内存作为内存保护的工具</h3><p>　　现代计算机系统必须为操作系统提供控制内存访问的方法。不应该允许用户进程写它的只读代码，也不应该允许它访问内核中代码和数据结构，还不应该允许它访问其他进程的私有内存和写任何与其他进程共享的VP (除非所有的共享者通过显式的进程间通信系统调用来允许)。</p><p>　　独立的地址空间使得区分不同进程的私有内存很容易，但地址转换机制可以自然地扩展到提供更好的访问控制。每次CPU生成地址时，地址转换硬件都会读PTE，所以可以在PTE上添加一些额外的权限位来控制对VP的访问。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/using_virtual_memory_to_provide_page-level_memory_protection.svg" title="using_virtual_memory_to_provide_page-level_memory_protection"><p>　　在这个示例中，每个PTE中添加了3个权限位。<code>SUP</code>位表示是否只能在内核 (超级用户) 模式下访问该页。<code>READ</code>位和<code>WRITE</code>位表示该页的读和写权限。例如，若进程<code>i</code>运行在用户模式下，则它有VP0的读权限以及VP1的读和写权限。</p><p>　　若指令违反了这些权限，CPU会触发一般保护故障，将控制权转移给内核中的异常处理程序。</p><h3 id="地址转换">9.4 地址转换</h3><p>　　地址转换是<span class="math inline">\(N\)</span>个元素的虚拟地址空间中的元素和<span class="math inline">\(M\)</span>个元素的物理地址空间中的元素间的映射。 <span class="math display">\[ MAP: VAS\rightarrow PAS \cup \emptyset \]</span> <span class="math display">\[ MAP(A) = \begin{cases} A&#39; &amp;&amp; {若虚拟地址A处的数据在物理地址A&#39;处}\\[2px] \emptyset &amp;&amp; {若虚拟地址A处的数据不在物理内存中}\end{cases} \]</span></p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/address_translation_with_a_page_table.svg" title="address_translation_with_a_page_table"><p>　　CPU中的称为<strong>页表基址寄存器</strong>的控制寄存器指向当前页表。<span class="math inline">\(n\)</span>位的VA包括<span class="math inline">\(p\)</span>位的<strong>虚拟页偏移</strong>和<span class="math inline">\(n-p\)</span>位的<strong>虚拟页号</strong>。MMU通过VPN来选择对应的PTE，VPN0对应PTE0，VPN1对应PTE1，依此类推。将PTE中的<strong>物理页号</strong>和VA中的VPO连接起来得到PA (PPO和VPO相同)。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/operational_view_of_page_hits_and_page_faults.svg" title="operational_view_of_page_hits_and_page_faults"><p>　　页命中仅需硬件就可以完成，如图a所示。</p><p>　　1) CPU生成VA并发送给MMU。</p><p>　　2) MMU生成PTE地址并从缓存/内存请求对应的PTE。</p><p>　　3) 缓存/内存向MMU返回请求的PTE。</p><p>　　4) MMU生成PA并发送给缓存/内存。</p><p>　　5) 缓存/内存返回请求的数据给CPU。</p><p>　　缺页处理需要硬件和操作系统内核共同完成，如图b所示。</p><p>　　1~3步同页命中的1~3步相同。</p><p>　　4) PTE中的有效位为0，所以MMU触发异常，将控制权转移给缺页异常处理程序。</p><p>　　5) 缺页异常处理程序确定物理内存中的牺牲页，若该页已被修改，则进行回写。</p><p>　　6) 缺页异常处理程序调入新页并更新内存中的PTE。</p><p>　　7) 从缺页异常处理程序返回到原来的程序并再次执行导致缺页的指令。CPU重新发送VA给MMU，此时该VA已缓存，所以会命中，内存会将请求的数据返回给CPU。</p><p>　　在同时使用虚拟内存和SRAM缓存的系统中，都有应使用VA还是PA来访问SRAM缓存的问题，大多数系统是选择物理寻址。物理寻址让多个进程同时在缓存中有存储块以及共享来自同一VP的块很简单。此外，缓存无需处理访问权限的问题，因为访问权限控制是地址转换的一部分。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/integrating_virtual_memory_with_a_physically_addressed_cache.svg" title="integrating_virtual_memory_with_a_physically_addressed_cache"><p>　　结合虚拟内存和物理寻址的缓存的主要思路是让地址转换在查找缓存前执行。此外，PTE可以缓存，就像数据一样。</p><h4 id="用tlb加速地址转换">9.4.1 用TLB加速地址转换</h4><p>　　每次CPU生成VA，MMU必须查阅PTE来将其转换为PA。在最差的情况下，还需要从内存中读取1次数据，开销是几十到几百个周期。若PTE刚好在L1缓存中，则开销就下降到1或2个周期。然而，很多系统通过在MMU加入称为<strong>转换后备缓存区</strong>的PTE缓存来消除这样的开销。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/components_of_a_virtual_address_that_are_used_to_access_the_tlb.svg" title="components_of_a_virtual_address_that_are_used_to_access_the_tlb"><p>　　TLB是虚拟寻址的较小的缓存，其中的每行都保存着1个由单个PTE组成的块。TLB通常有很高的相联度。用于组选择和行匹配的索引和标识字段来自VA中的VPN。若TLB有<span class="math inline">\(T=2^t\)</span>个组，则TLBI由VPN的低<span class="math inline">\(t\)</span>位组成，TLBT由VPN中的剩余位组成。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/operational_view_of_a_tlb_hit_and_miss.svg" title="operational_view_of_a_tlb_hit_and_miss"><p>　　所有的地址转换步骤是由CPU芯片上的MMU执行，所以很快，如图a所示。</p><p>　　1) CPU生成VA。</p><p>　　2 &amp; 3) MMU从TLB中取出相应的PTE。</p><p>　　4) MMU将该VA转换为PA并发送给缓存/内存。</p><p>　　5) 缓存/内存将请求的数据返回给CPU。</p><p>　　当TLB未命中时，MMU必须从L1缓存中取出对应的PTE，如图b所示。取出的PTE会存放在TLB中，可能会覆盖其中的1个条目。</p><h4 id="多级页表">9.4.2 多级页表</h4><p>　　到目前为止的情况都是假设只用1个页表来进行地址转换。对于有32位地址空间、4KB的页和4B的PTE的系统，即使程序引用的只是虚拟地址空间中很小的一部分，还是需要4MB的页表驻留在内存中。对于地址空间为64位的系统，问题将变得更复杂。</p><p>　　压缩页表的常用方法是使用<span style="background-color:#ff0">层次结构的页表</span>。假设32位虚拟地址空间被分为4KB的页，每个PTE都是4B。此外，还假设内存的前<span class="math inline">\(2K\)</span>个页分配给代码和数据，接下来的<span class="math inline">\(6K\)</span>未分配，再接下来的<span class="math inline">\(1023\)</span>个页也未分配，最后1个页分配给用户栈。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/a_two-level_page_table_hierarchy.svg" title="a_two-level_page_table_hierarchy"><p>　　1级页表中的每个PTE负责映射虚拟地址空间中的4MB的<span style="background-color:#ff0">片</span>，这里的片都是由1024个连续的页组成。例如，PTE0映射第1片，PTE1映射到接下来的片，依此类推。若地址空间为4GB，1024个PTE足以覆盖整个空间。若片<span class="math inline">\(i\)</span>中的每个页都未被分配，那么1级PTE<span class="math inline">\(i\)</span>就为空。</p><p>　　2级页表中的每个PTE负责映射4KB的VP。1级页表和2级页表的PTE都是4B，所以1级页表、2级页表和页的大小都是相同的。</p><p>　　这种方法从2个方面减少了内存要求。首先，若1级页表中的某个PTE为空，则对应的2级页表就不会存在。这表示巨大的潜在节约，因为对于常规程序，4GB的虚拟地址空间中的大部分都是未被分配的。其次，只有1级页表才需要常驻内存。虚拟内存系统可以在需要时创建、调入或调出2级页表，这样减少了内存的压力。只有最常使用的2级页表才需要缓存在内存中。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/address_translation_with_k-level_page_table.svg" title="address_translation_with_k-level_page_table"><p>　　对于使用<span class="math inline">\(k\)</span>级页表的地址转换，VA划分为<span class="math inline">\(k\)</span>个VPN和1个VPO。VPN<span class="math inline">\(i\)</span>是到<span class="math inline">\(i\)</span>级页表的索引，其中<span class="math inline">\(1\leqslant i\leqslant k\)</span>。<span class="math inline">\(j\)</span>级页表中的每个PTE都指向<span class="math inline">\(j+1\)</span>级中的某个页表的基址，其中<span class="math inline">\(1\leqslant j\leqslant k-1\)</span>。<span class="math inline">\(k\)</span>级页表中的每个PTE包含某个PP的PPN或某个磁盘块的地址。为了生成PA，在确定PPN前，MMU必须访问<span class="math inline">\(k\)</span>个PTE。对于仅有1级的页表结构，PPO和VPO是相同的。</p><p>　　访问<span class="math inline">\(k\)</span>个PTE时，看似开销很大。由于不同层级上页表的PTE已缓存，所以多级页表的地址转换并不会比单级页表的地址转换慢很多。</p><h4 id="端到端的地址转换">9.4.3 端到端的地址转换</h4><p>　　以有TLB和L1数据缓存的系统为例，为了保证可管理性，做出如下假设：</p><p>　　● 内存是按字节寻址的。</p><p>　　● 内存访问是针对<span style="background-color:#ff0">1B的字</span>。</p><p>　　● VA是14位。</p><p>　　● PA是12位。</p><p>　　● 页大小是64B。</p><p>　　● TLB是4路组相联的，共有16个条目。</p><p>　　● L1数据缓存是物理寻址且直接映射的，行大小是4B，共有16个组。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/tlb,page_table,and_cache_for_small_memory_system.svg" title="tlb,page_table,and_cache_for_small_memory_system"><p>　　每个页都是<span class="math inline">\(2^6=64\)</span>B，所以VA和PA的低6位分别是VPO和PPO。VA的高8位作为VPN。PA的高6位作为PPN。</p><p>　　TLB通过VPN的位进行虚拟寻址。因为TLB有4个组，所以VPN的低2位作为TLBI。VPN的高6位作为TLBT，用于区分映射到同一TLB组的VPN。</p><p>　　页表是单级页表，共有<span class="math inline">\(2^8=256\)</span>个PTE。这里只展示前16个PTE，为了方便，用索引它的VPN来作为标识 (实际中VPN并不存储在内存中)。<code>-</code>表示无效PTE的PPN。</p><p>　　直接映射的缓存通过PA中的字段来寻址。每个块都是4B，所以PA中的低2位作为缓存偏移。共有16组，所以PA中接下来的4位用于表示缓存索引，最后6位作为缓存标识。</p><p>　　以CPU执行读<code>0x03D4</code>处的字节的加载指令为例，MMU从虚拟地址中提取VPN<code>0x0F</code>，检查TLB来判断它是否已缓存PTE<code>0x0F</code>的副本。TLB从VPN中提取TLBI<code>0x03</code>和TLBT<code>0x3</code>。组<code>0x3</code>中的第2个条目匹配，所以命中，然后将缓存的PPN<code>0x0D</code>返回给MMU。</p><p>　　现在MMU能够生成PA，通过来自PTE的PPN<code>0x0D</code>和来自VA的VPO<code>0x14</code>连接起来得到PA<code>0x354</code>。然后，MMU将PA发送给缓存，缓存从PA中提取CO<code>0x0</code>、CI<code>0x5</code>和CT<code>0x0D</code>。</p><p>　　组<code>0x5</code>中的标识与CT匹配，所以缓存命中，读出CO处的数据字节<code>0x36</code>并返回给MMU，MMU返回给CPU。</p><p>　　转换过程中还有其他可能。例如，若TLB未命中，则MMU必须从页表中的PTE中提取PPN。若得到PTE是无效的，则会出现缺页，内核必须调入合适的页并重新加载这条指令。另一种可能是PTE是有效的，但是所需的内存块未缓存在缓存中。</p><h3 id="案例研究intel-core-i7linux内存系统">9.5 案例研究：Intel Core i7/Linux内存系统</h3><p>　　以运行Linux的Intel Core i7为例，虽然底层的Haswell微体系架构完全支持64位虚拟和物理地址空间，但Core i7的实现仅支持48位 (256TB) 虚拟地址空间、52位 (4PB) 物理地址空间以及32位 (4GB) 虚拟和物理地址空间的兼容模式。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/the_intel_core_i7_memory_system.svg" title="the_intel_core_i7_memory_system"><p>　　Core i7内存系统的<strong>处理器封装</strong>包括4个核以及所有核共享的L3缓存和DDR3存储控制器。每个核包括1个层次结构的TLB、1个层次结构的数据和指令缓存以及1组高速点到点链路。高速点到点链路基于QuickPath技术，可以让核与其他核以及外部I/O桥直接通信。TLB是虚拟寻址且4路组相联。L1、L2和L3缓存是物理寻址，块大小是64B。L1和L2缓存是8路组相联，L3缓存是16路组相联。页大小可以在启动时配置为4KB和4MB。Linux使用的是4KB页。</p><h4 id="core-i7地址转换">9.5.1 Core i7地址转换</h4><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/summary_of_core_i7_address_translation.svg" title="summary_of_core_i7_address_translation"><p>　　Core i7采用4级页表层次结构。每个进程都有私有页表层次结构。当Linux进程运行时，虽然Core i7体系结构允许页表调度，但与已分配的页关联的页表都会驻留在内存中。CR3控制寄存器指向1级页表的起始处。CR3的值是每个进程上下文中的一部分，每次上下文切换时，CR3的值都会恢复。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/format_of_level_1,level_2,and_level_3_pte.svg" title="format_of_level_1,level_2,and_level_3_pte"><p>　　对于1~3级PTE，当P=1时 (Linux中总是如此)，页表物理基址包含40位PPN，它指向对应页表的起始处。此外，这里还要求页表按4KB对齐。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/format_of_level_4_pte.svg" title="format_of_level_4_pte"><p>　　对于4级PTE，当P=1时，页表物理基址包括40位PPN，它指向物理内存中某页的基址。此外，这里还要求PP按4KB对齐。</p><p>　　PTE有3个权限位来控制页的访问。R/W位表示页的内容是只读还是可读写的。U/S位表示能否在用户模式下访问页。XD (禁止执行) 位是64位系统中引入的，表示禁止从页中取指令，这是重要的新特性，通过限制只能执行只读代码段，使得操作系统内核降低了缓冲区溢出攻击的风险。</p><p>　　当MMU转换VA时，还会更新2个缺页异常处理程序会用到的位。每次访问页时，MMU会设置A位，称为<strong>引用位</strong>。内核可以用这个引用位来实现页替换算法。每次写页后，MMU会设置D位，称为<strong>修改位</strong>或<strong>脏位</strong>。修改位表示内核在复制替换页前是否需要回写牺牲页。内核可以通过调用特殊的内核指令来清除引用位。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/core_i7_page_table_translation.svg" title="core_i7_page_table_translation"><p>　　通过页表将VA转换为PA时，36位VPN会划分为4个9位的部分，每部分用作1个页表的偏移。CR3寄存器包含1级页表的PA。VPN1提供到1级PTE的偏移，该1级PTE包含2级页表的基址。VPN2提供到2级PTE的偏移，依此类推。</p><p>　　地址转换分为MMU将VA转换为PA和将PA发送给L1缓存。实际的硬件实现允许这2个步骤部分重叠，所以也加速了L1缓存的访问。例如，对于页大小为4KB的Core i7，因为8路组相联且物理寻址的L1缓存有64个组和64B的块，PA有6位CI和6位CO，这12位刚好组成PPO，而PPO和VPO完全相同。因此，当MMU向TLB请求PTE时，L1缓存正在通过VPO查找对应的组并读出这个组里的8个标识和对应的数据。当MMU从TLB得到PPN时，缓存已准备好尝试把这个PPN和8个标识进行匹配。</p><h4 id="linux虚拟内存系统">9.5.2 Linux虚拟内存系统</h4><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/the_virtual_memory_of_a_linux_process.svg" title="the_virtual_memory_of_a_linux_process"><p>　　内核虚拟内存包含内核中的代码和数据结构。内核虚拟内存的某些区域会映射到所有进程共享的PP，例如，每个进程共享的代码和全局数据结构。Linux也会将一组连续的VP (大小为系统中DRAM的总大小) 映射到一组连续的PP，这为内核提供了便利的方法来访问物理内存中任何特定的位置，例如，当需要访问页表或在映射到特定物理内存位置的设备上执行内存映射的I/O操作时。</p><p>　　内核虚拟内存中的其他区域包含每个进程都不同的数据，例如，页表、内核在进程的上下文中执行代码时使用的栈以及记录虚拟地址空间当前组织的各种数据结构。</p><h5 id="linux虚拟内存区域">9.5.2.1 Linux虚拟内存区域</h5><p>　　Linux将虚拟内存组织为<strong>区域</strong> (也称为<strong>段</strong>) 集合。1个区域就是已存在 (已分配) 的虚拟内存的连续片，其中的页以某种方式相关联。例如，代码段、数据段、堆、共享库段以及用户栈都是不同的区域。每个存在的VP都保存在某个区域中，而不属于任何区域的VP是不存在的，并且不能被引用。区域允许虚拟地址空间有间隙。内核不用记录不存在的VP，这样的VP不占用内存、磁盘或内核本身的资源。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/how_linux_organizes_virtual_memory.svg" title="how_linux_organizes_virtual_memory"><p>　　内核为每个进程维护独立的任务结构<code>task_struct</code>。任务结构中的元素包含或指向内核运行该进程所需的所有信息，例如，PID、指向用户栈的指针、可执行文件的名称和PC。</p><p>　　任务结构中的1个条目指向<code>mm_struct</code>，它描述虚拟内存的当前状态。<code>pgd</code>指向1级页表 (页全局目录) 的基址。<code>mmap()</code>指向由区域结构<code>vm_area_struct</code>组成的链表，其中的每个区域结构都描述当前虚拟地址空间的某个区域。当内核运行进程时，会将该进程的<code>pgd</code>放入CR3寄存器中。</p><p>　　区域结构包含以下字段：</p><p>　　● <code>vm_start</code>指向该区域的起始处。</p><p>　　● <code>vm_end</code>指向该区域的结束处。</p><p>　　● <code>vm_prot</code>描述该区域包含的所有页的读写权限。</p><p>　　● <code>vm_flags</code>表示该区域的页 (还有其他信息) 是与其他进程共享还是该进程私有。</p><p>　　● <code>vm_next</code>指向链表中的下一个区域结构。</p><h5 id="linux缺页处理">9.5.2.2 Linux缺页处理</h5><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/linux_page_fault_handling.svg" title="linux_page_fault_handling"><p>　　若MMU转换VA时触发了缺页，则会导致控制权转移到缺页异常处理程序，缺页异常处理程序会执行以下步骤：</p><p>　　1) <span style="background-color:#ff0">判断该VA是否在某个区域结构定义的区域内</span>。因此，缺页异常处理程序会搜索区域结构链表，将该VA和每个区域结构中的<code>vm_start</code>和<code>vm_end</code>进行匹配。若没有匹配项，则触发段故障，从而终止该进程。进程可以创建任意数量的虚拟内存区域，所以顺序搜索区域结构链表的代价可能很大。在实际中，Linux会使用某些这里没有显示的字段在链表中生成树并在树上进行搜索。</p><p>　　2) <span style="background-color:#ff0">判断进程对该区域内的页是否有足够的访问权限</span>。若试图进行的访问不合法 (写只读的页和在用户模式下读内核虚拟内存等)，则缺页异常处理程序会触发保护故障，从而终止该进程。</p><p>　　3) <span style="background-color:#ff0">内核确定该缺页是对合法的VA进行合法操作导致的</span>。接下来就是常规的缺页处理，选择牺牲页，若牺牲页被修改过，则进行回写，然后进行页面调度。当从缺页异常处理程序返回时，CPU会重新执行导致缺页的指令，然后MMU正常转换VA。</p><h3 id="内存映射">9.6 内存映射</h3><p>　　Linux通过将虚拟内存区域与磁盘上的对象关联来初始化该虚拟内存区域的内容，该过程称为<strong>内存映射</strong>。Linux提供了系统调用<code>mmap()</code>来允许程序进行内存映射。虚拟内存区域可以映射到<span style="background-color:#ff0">Linux文件系统中的普通文件</span>和<span style="background-color:#ff0">匿名文件</span>的对象。</p><p>　　● 1个区域可以映射到1个普通磁盘文件的连续部分，例如，1个可执行文件。<strong>文件区</strong>被分为页大小的片，每个片都包含1个VP的初始内容。因为按需页面调度，只有当CPU首次引用VP时 (发送在该VP地址空间范围内的VA)，该VP才会调入物理内存。若区域比文件区大，则会用0来填充该区域剩余的部分。</p><p>　　● 1个区域也可以映射到1个匿名文件。匿名文件由内核创建，其内容全是二进制0。当CPU首次引用映射到匿名文件的区域内的VP时，内核会在物理内存中选择牺牲页，若牺牲页被修改过，则将牺牲页回写，用二进制0覆盖牺牲页并更新页表。这里磁盘和内存之间没有实际的数据传输。因此，映射到匿名文件的区域的页也称为<strong>请求二进制0的页</strong>。</p><p>　　一旦VP初始化，它就在内核维护的<strong>交换文件</strong>之间进行交换，交换文件也称为<strong>交换区域</strong>或<strong>交换空间</strong>。交换空间限制着当前运行的进程能够分配的VP总数。</p><h4 id="再看共享对象">9.6.1 再看共享对象</h4><p>　　对象可以映射到虚拟内存的某个区域，要么作为共享对象，要么作为私有对象。共享对象映射的虚拟内存区域称为<strong>共享区域</strong>，同样，也有<strong>私有区域</strong>。</p><p>　　若进程将共享对象映射到它的虚拟内存的某个区域，则进程对该区域的写操作对其他把该共享对象映射到其虚拟内存的进程是可见的。此外，这些变化也会反映在磁盘的原始对象上。</p><p>　　对于映射到私有对象的区域，进程对该区域的修改对其他进程是不可见的，而且进程对该区域的写操作不会反映在磁盘的原始对象上。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/a_shared_object.svg" title="a_shared_object"><p>　　在这个示例中，进程1将共享对象映射到它的虚拟内存的某个区域中，然后进程2也将同一共享对象映射到它的虚拟内存的某个区域中 (并不一定与进程1的VP相同)。因为每个对象有唯一的文件名，内核可以快速判断进程1已经映射该共享对象并将进程2的PTE指向合适的PP。即使共享对象映射到多个共享区域，物理内存只需存放共享对象的1个副本。这里为了方便，将PP显示为连续的，但一般情况下并非如此。</p><p>　　私有对象使用<strong>写时复制</strong>的技术来映射到虚拟内存中。私有对象的开始生命周期的方式基本与共享对象相同，在物理内存中只保存私有对象的1个副本。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/a_private_copy-on-write_object.svg" title="a_private_copy-on-write_object"><p>　　在这个示例中，2个进程将私有对象映射到虚拟内存的不同区域，但是共享该对象的同一物理副本。对于每个进程，对应私有区域的PTE都是只读，且区域结构为<span style="background-color:#ff0">私有写时复制</span>。当进程写私有区域的页时，写操作会触发保护故障。故障处理程序会在物理内存中创建该页的副本，更新PTE来指向该副本，然后恢复该页的写权限。当从故障处理程序返回时，CPU重新执行写操作，写操作在副本上正常执行。</p><p>　　通过尽可能地推迟创建私有对象的副本，写时复制充分利用了物理内存。</p><h4 id="再看函数fork和execve">9.6.2 再看函数<code>fork()</code>和<code>execve()</code></h4><p>　　当进程调用函数<code>fork()</code>时，内核会为子进程创建各种数据结构并分配唯一的PID。为了给子进程创建虚拟内存，会复制父进程的<code>mm_struct</code>、区域结构和页表。最后，将这2个进程的所有页都设置为只读并将这2个进程中的所有区域结构都设置为私有写时复制。</p><p>　　当函数<code>fork()</code>从子进程返回时，子进程当前的虚拟内存与调用函数<code>fork()</code>时的虚拟内存相同。然后，当这2个进程之一执行写操作时，写时复制机制会创建新页。因此，这为每个进程保留了私有地址空间。</p><p>　　假设当前进程执行<code>execve("a.out", NULL, NULL)</code>，函数<code>execve()</code>会在当前进程中加载并运行可执行文件<code>a.out</code>中包含的程序，然后用该程序代替当前程序。加载并运行可执行文件<code>a.out</code>需要如下步骤：</p><p>　　1) <span style="background-color:#ff0">删除已存在的用户区域</span>。删除当前进程VA的用户部分中的已存在的区域结构。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/how_the_loader_maps_the_areas_to_the_user_address_space.svg" title="how_the_loader_maps_the_areas_to_the_user_address_space"><p>　　2) <span style="background-color:#ff0">映射私有区域</span>。为新程序的代码、数据、<code>bss</code>和栈区域创建新区域结构，这些新区域都是私有写时复制的。代码和数据区域映射到文件<code>a.out</code>的<code>.text</code>节和<code>.data</code>节。<code>bss</code>区域是请求二进制0的，映射到匿名文件，其大小包含在文件<code>a.out</code>中。栈和堆区域也是请求二进制0的，初始长度为0。</p><p>　　3) <span style="background-color:#ff0">映射共享区域</span>。若程序<code>a.out</code>与<code>libc.so</code>等共享库链接，则这些共享库会动态链接到该程序，然后映射到用户虚拟地址空间中的共享区域。</p><p>　　4) <span style="background-color:#ff0">设置PC</span>。函数<code>execve()</code>做的最后1件事就是设置当前进程上下文中的PC，使之指向代码区域的入口点。下次调度该进程时，它将从该入口点执行。</p><h4 id="使用函数mmap进行用户级内存映射">9.6.3 使用函数<code>mmap()</code>进行用户级内存映射</h4><p>　　Linux进程可以通过函数<code>mmap()</code>来创建新虚拟内存区域并将对象映射到该区域中。函数<code>munmap()</code>可以删除虚拟内存区域。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>; <span class="comment">/* 若成功则返回指向映射区域的指针，若出错则返回MAP_FAILED(-1) */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>mmap()</code>会让内核创建新虚拟内存区域 (尽量从地址<code>start</code>开始)，然后将文件描述符<code>fd</code>指定的对象的1个连续的片映射到该区域。连续的对象片的大小为<code>length</code>字节，从文件开始处偏移为<code>offset</code>字节开始。地址<code>start</code>仅仅是1个暗示，通常定义为<code>NULL</code>。</p><p>　　参数<code>prot</code>包含描述新映射的虚拟内存区域的访问权限位，即对应的区域结构中的<code>vm_prot</code>。</p><p>　　● <code>PROT_EXEC</code>表示该区域内的页由CPU能执行的指令组成。</p><p>　　● <code>PROT_READ</code>表示该区域内的页可读。</p><p>　　● <code>PROT_WRITE</code>表示该区域内的页可写。</p><p>　　● <code>PROT_NONE</code>表示该区域内的页不能被访问。</p><p>　　参数<code>flags</code>由描述映射对象类型的位组成。若设置为<code>MAP_ANON</code>，则映射的对象是匿名对象，而对应的VP是请求二进制0的；若设置为<code>MAP_PRIVATE</code>，则映射的对象是私有写时复制的；若设置为<code>MAP_SHARED</code>，则映射的对象是共享对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bufp = Mmap(<span class="literal">NULL</span>, size, PROT_READ, MAP_PRIVATE | MAP_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>　　这段代码会创建<code>size</code>字节的只读、私有和请求二进制0的虚拟内存区域。若调用成功，则<code>bufp</code>会包含新区域的地址。</p><p>　　函数<code>munmap()</code>会删除从地址<code>start</code>开始的<code>length</code>字节的区域。之后对已删除区域的引用会导致段故障。</p><h3 id="动态内存分配">9.7 动态内存分配</h3><p>　　虽然可以通过底层的函数<code>mmap()</code>和<code>munmap()</code>来创建和删除虚拟内存区域，但是C语言的<strong>动态内存分配器</strong>更方便且有更好的可移植性。</p><p>　　动态内存分配器维护着<span style="background-color:#ff0">堆</span>。各个系统之间的细节不同，但是不失通用性，这里假设堆是请求二进制0的区域，它紧接着未初始化数据区，并向高地址增长。内核为每个进程维护着指向堆顶部的变量<code>brk</code>。</p><p>　　分配器将堆维护为由大小不同的块组成的集合。每个块是1个连续的<span style="background-color:#ff0">虚拟内存片</span>。块要么是已分配的，要么是空闲的。已分配的块显式地保留为应用程序使用。空闲块可用来分配。空闲块会一直保持空闲，直到显式地被应用程序分配。已分配的块会一直保持已分配，直到被释放，这种释放要么由应用程序显式执行，要么由内存分配器隐式执行。</p><p>　　分配器有2种形式，两者都要求应用程序显式地分配块，不同之处在于由负责释放已分配的块的实体。</p><p>　　● <span style="background-color:#ff0">显式分配器</span>要求应用程序显式地释放所有已分配的块。C语言通过函数<code>malloc()</code>来分配块并通过函数<code>free()</code>来释放块。C++中的操作符<code>new</code>和<code>delete</code>与C中的函数<code>malloc()</code>和<code>free()</code>类似。</p><p>　　● <span style="background-color:#ff0">隐式分配器</span>要求分配器检测到已分配的块不再被使用时，就释放该块。隐式分配器也称为<strong>垃圾回收器</strong>，自动释放未使用的已分配的块称为<strong>垃圾回收</strong>。Lisp、ML和Java等高级语言通过垃圾回收来释放已分配的块。</p><p>　　程序使用动态内存分配最重要的原因是经常<span style="background-color:#ff0">到运行时才知道某些数据结构的大小</span>。</p><h4 id="函数malloc和free">9.7.1 函数malloc和free</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>; <span class="comment">/* 若成功则返回指向分配块的指针，若失败则返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><p>　　函数<code>malloc()</code>返回指向大小至少为<code>size</code>字节的内存块，这个块会为可能包含在这个块内的任何数据对象类型进行对齐。实际上，对齐取决于代码是在32位模式还是64位模式编译。在32位模式中，函数<code>malloc()</code>返回块的地址总是8的倍数；在64位模式中，该地址总是16的倍数。</p><p>　　若函数<code>malloc()</code>出错 (请求的内存块比可用的虚拟内存更大等)，则会返回<code>NULL</code>并设置<code>errno</code>。函数<code>malloc()</code>不会初始化返回的块。若需要返回已初始化的块，则可以使用函数<code>calloc()</code>，该函数是基于函数<code>malloc()</code>的瘦包装函数，会将分配的块初始化为0。若需要改变之前分配的块的大小，则可以使用函数<code>realloc()</code>。</p><p>　　函数<code>free()</code>会释放参数<code>ptr</code>指向的块。参数<code>ptr</code>必须指向通过函数<code>malloc()</code>、<code>calloc()</code>或<code>realloc()</code>得到的已分配的块的起始处。否则，函数<code>free()</code>的行为将是未定义的。此外，函数<code>free()</code>不会返回，所以即使出错也不会有反馈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> incr)</span>; <span class="comment">/* 若成功则返回brk的旧值，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>sbrk()</code>通过将内核的<code>brk</code>指针增加<code>incr</code>来扩展或收缩堆。若成功，则会返回<code>brk</code>的旧值；若出错，则返回-1并将<code>errno</code>置为<code>ENOMEM</code>。若<code>incr</code>为0，则返回<code>brk</code>的当前值；若<code>incr</code>小于0，则返回值指向新堆顶向上<code>incr</code>字节处。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/allocating_and_freeing_blocks_with_function_malloc_and_free.svg" title="allocating_and_freeing_blocks_with_function_malloc_and_free"><p>　　这个示例展示了通过函数<code>malloc()</code>和<code>free()</code>管理16字且双字对齐的堆 (这里的字为4B)，每个方框代表1个字。图a会请求4字的块，函数<code>malloc()</code>会从空闲块前部分配4字的块。图b会请求5字的块，函数<code>malloc()</code>会从空闲块前部分配6字的块 (为了对齐)。图c会请求6字的块，函数<code>malloc()</code>会从空闲块前部分配6字的块。图d会释放图b中分配的6字的块，但指针<code>p2</code>仍然指向释放后的块。图e会请求2字的块，函数<code>malloc()</code>会从图d释放的块的前部分配2字的块。</p><h4 id="分配器的要求和目标">9.7.2 分配器的要求和目标</h4><p>　　显式分配器必须在以下约束条件下工作：</p><p>　　● <span style="background-color:#ff0">处理任意请求序列</span>。程序可以有任意的分配请求和释放请求序列，只要满足约束条件 (每个释放请求必须对应1个当前已分配的块，这个块由之前的分配请求获得)。因此，分配器不可以假设分配请求和释放请求的顺序。</p><p>　　● <span style="background-color:#ff0">立即响应请求</span>。分配器必须立即响应分配请求。因此，不允许分配器为了提高性能重新排列或缓存请求。</p><p>　　● <span style="background-color:#ff0">只使用堆</span>。为了保证分配器是可扩展的，分配器使用的任何非标量数据结构必须保存在堆里。</p><p>　　● <span style="background-color:#ff0">块对齐</span>。分配器必须对齐块使得可以保存任何类型的数据对象。</p><p>　　● <span style="background-color:#ff0">不修改已分配的块</span>。分配器只能操作或修改空闲块。因此，压缩已分配的块等技术是不允许使用的。</p><p>　　在这些限制条件下，分配器的编写者需要试图实现<span style="background-color:#ff0">吞吐率最大化</span>和<span style="background-color:#ff0">内存利用率最大化</span>，而这2个性能目标通常是冲突的。</p><p>　　吞吐率定义为每个单位时间里完成的请求数，可以通过最小化分配请求和释放请求所需的时间来最大化吞吐率。然而，最差情况下分配请求所需的时间与空闲块的数量呈线性关系，释放请求所需的时间是常数。</p><p>　　衡量堆利用率的最有用的标准是<strong>峰值利用率</strong>。对于<span class="math inline">\(n\)</span>个请求的序列<span class="math inline">\(R_o,R_1,...,R_k,..,R_{n-1}\)</span>，若程序请求<span class="math inline">\(p\)</span>字节的块，则得到的已分配的块的<strong>有效载荷</strong>是<span class="math inline">\(p\)</span>字节。在请求<span class="math inline">\(R_k\)</span>完成后，<strong>聚合有效载荷</strong>表示为<span class="math inline">\(P_k\)</span>，即当前已分配的块的有效载荷总和。堆的当前大小 (单调非递减) 表示为<span class="math inline">\(H_k\)</span>。前<span class="math inline">\(k+1\)</span>个请求的峰值利用率表示为<span class="math inline">\(U_k\)</span>。 <span class="math display">\[ U_k=\frac{max_{i\leqslant k}P_i}{H_k} \]</span> 　　这里可以将前<span class="math inline">\(k+1\)</span>个请求的利用率峰值表示为<span class="math inline">\(H_k\)</span>，则可以在<span class="math inline">\(U_k\)</span>的定义中放宽单调非递减的条件并且允许堆扩展和收缩。</p><p>　　<strong>碎片</strong>是导致堆利用率低的主要原因之一。当未使用的内存不能满足分配请求时，就会出现这种情况。碎片分为<strong>外部碎片</strong>和<strong>内部碎片</strong>。</p><p>　　内部碎片在已分配的块比有效载荷大时出现，很多原因都能造成该问题。例如，分配器的实现可能对分配的块有最小值要求或者分配器为了保证对齐。内部碎片的量化很简单，就是所有已分配的块大小和其有效载荷之间的差的总和，所以内部碎片的数量只取决于之前请求的模式和分配器的实现。</p><p>　　外部碎片在空闲块总和能满足某个分配请求，但没有单独的空闲块能满足该分配请求时出现。外部碎片的量化不仅取决于之前请求的模式和分配器的实现，还取决于未来请求的模式。因此，分配器通常采用启发式策略，尽量维持少量的大空闲块而非大量的的小空闲块。</p><h4 id="隐式空闲链表">9.7.3 隐式空闲链表</h4><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/format_of_a_simple_heap_block.svg" title="format_of_a_simple_heap_block"><p>　　简单的堆块由<span style="background-color:#ff0">1个字的首部</span>、<span style="background-color:#ff0">有效载荷</span>和<span style="background-color:#ff0">可选的填充部分</span>组成。</p><p>　　首部描述该块的大小 (包括首部、有效载荷和填充部分) 和分配状态 (已分配或空闲)。若加上双字对齐的约束条件，则块大小必须8的整数倍，即块大小字段的低3位必须是0。因此，只需要首部的高29位就可以表示块大小，低3位可以表示其他信息，在这种情况下，用最低位表示该块的分配状态。首部后就是调用函数<code>malloc()</code>时请求的有效载荷。填充部分可用于分配器策略、解决外部碎片问题和保证对齐。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/organizing_the_heap_with_an_implicit_free_list.svg" title="organizing_the_heap_with_an_implicit_free_list"><p>　　若堆由简单的堆块组成，则可以将堆组织为连续的已分配的块和空闲块的序列，这种结构称为<strong>隐式空闲链表</strong>，因为空闲块通过首部中块大小字段隐式地连接。分配器可以通过遍历堆中所有的块来遍历整个空闲块的集合。此外，需要某种特殊标记的结束块，这里使用的是分配状态为已分配但块大小是0的<strong>终止首部</strong>。</p><p>　　隐式空闲链表的优点是简单，缺点是不低的操作成本。例如，对于搜索空闲块，搜索所需时间与堆中块的数量呈线性关系。</p><p>　　当程序请求<span class="math inline">\(k\)</span>字节的块时，分配器会搜索满足请求的空闲块，搜索方式由<strong>放置策略</strong>决定。常见的策略包括<strong>首次适配</strong>、<strong>下次适配</strong>和<strong>最佳适配</strong>。首次适配会从头开始搜索空闲链表，选择首个合适的空闲块。下次适配类似首次适配，但是从上一次查询结束的地方开始搜索。最佳适配会检查每个空闲块并选择合适的最小空闲块。</p><p>　　● 首次适配的优点是趋向于将大的空闲块保留在链表的后面，缺点是趋向于在链表的前面留下小碎片，这增加了对较大块的搜索时间。</p><p>　　● 下次适配由Donald Knuth作为首次适配的替代而提出 (若上次在一些空闲块中已发现了匹配项，则下次很可能在剩余块中发现匹配项)。下次适配明显比首次适配更快，尤其是链表的前面布满很多小碎片时。但是，一些研究表明，下次适配的内存利用率比首次适配低很多。</p><p>　　● 最佳适配的内存利用率比首次适配和下次适配的更高。但是，对于隐式空闲链表等简单空闲链表，最佳适配需要对堆进行彻底的搜索。</p><p>　　在找到匹配的空闲块后，必须使用另一个策略决定从该空闲块中分配的空间。选择之一是直接使用整个空闲块，但这会导致内部碎片。若放置策略倾向于选择最佳的匹配项，则由此导致的内部碎片是可以接受的；若相反，则会导致分配器将空闲块分为2部分，第1部分作为已分配的块，第2部分作为新的空闲块。</p><p>　　若分配器无法为请求找到合适的块，解决方法之一就是合并内存中物理上相邻的空闲块来生成更大的空闲块，若这样仍然无法生成足够大的块或空闲块已最大程度地合并，则分配器会通过调用函数<code>sbrk()</code>来向内核请求额外的堆内存，然后将额外的内存转换为大的空闲块并插入空闲链表，最后在新的空闲块中分配请求的块。</p><p>　　当分配器释放已分配的块时，可能有其他空闲块与这个新释放的块相邻。这些相邻的空闲块可能导致<strong>假碎片</strong>，即有很多可用的空闲块被分割为小到无法使用的空闲块。</p><h4 id="合并空闲块">9.7.4 合并空闲块</h4><p>　　为了解决假碎片的问题，分配器必须合并相邻的空闲块，这个过程称为<strong>合并</strong>。分配器可以选择<strong>立即合并</strong>，即每次释放块时，就立即合并所有相邻的空闲块。立即合并可以在常数时间内完成，但对于某些请求模式，立即合并会导致抖动，即块会反复地合并再分割。分配器也可以选择<strong>延迟合并</strong>，即等待一段时间后再合并空闲块，例如，分配器可以将合并推迟到某些分配请求失败时，然后扫描整个堆并合并空闲块。</p><p>　　假设待释放的块为<span style="background-color:#ff0">当前块</span>，合并当前块的下一个块很简单，由于当前块的首部指向下一个块的首部，只需检查当前块的首部就能判断下一个块是否空闲。若下一个块为空闲块，则将它的大小直接加到当前块的大小上，这2个块会在常数时间内合并。合并当前块的前一个块更复杂，对于隐式空闲链表，需要搜索整个链表来获取前一个块的位置，所以每次调用函数<code>free()</code>需要的时间与堆的大小呈线性关系。即使使用更复杂的空闲链表组织，搜索时间也不会是常数。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/format_of_a_heap_block_with_a_boundary_tag.svg" title="format_of_a_heap_block_with_a_boundary_tag"><p>　　Donald Knuth提出了<strong>边界标记</strong>，可以在常数时间内将当前块与前一个块合并。基本思想是在每个块的结尾添加<strong>脚部</strong> (即边界标记)，脚部是首部的副本。分配器可以通过检查前一个块的脚部来确定其起始处和分配状态。</p><p>　　边界标记有1个潜在的缺点，就是要求每个块都有首部和脚部，在程序运行较长时间后，会显著增加内存开销。例如，某个图像应用通过反复调用函数<code>malloc()</code>和<code>free()</code>来动态地创建和释放图形节点且每个图像节点都是2个字，那么首部和脚部将占用每个已分配的块的一半空间。解决方法就是<span style="background-color:#ff0">已分配的块不添加脚部</span>，因为只有相邻的块都是空闲块时，才能合并 (才需要使用脚部)。</p><h4 id="实现简单的分配器">9.7.5 实现简单的分配器</h4><p>　　这里将实现基于隐式空闲链表和边界标记的简单分配器。此外，块的最大值为<span class="math inline">\(2^{32}=4\)</span>GB。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* memlib.c (内存系统模型) */</span></span><br><span class="line"><span class="comment">/* 私有全局变量 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mem_heap;     <span class="comment">/* 指向堆的第1个字节的指针 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mem_brk;      <span class="comment">/* 指向堆的最后1个字节加1的指针 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mem_max_addr; <span class="comment">/* 堆的最大地址加1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化内存系统模型</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    mem_heap = (<span class="type">char</span> *)Malloc(MAX_HEAP);</span><br><span class="line">    mem_brk = (<span class="type">char</span> *)mem_heap;</span><br><span class="line">    mem_max_addr = (<span class="type">char</span> *)(mem_heap + MAX_HEAP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数sbrk的简单模型，将堆扩展incr字节并返回新区域的起始地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param incr 堆扩展的字节数 (不能为负)</span></span><br><span class="line"><span class="comment"> * @return void* 新区域的起始地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mem_sbrk</span><span class="params">(<span class="type">int</span> incr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *old_brk = mem_brk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((incr &lt; <span class="number">0</span>) || ((mem_brk + incr) &gt; mem_max_addr))</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ERROR: mem_sbrk failed. Ran out of memory...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mem_brk += incr;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)old_brk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<code>memlib.c</code>提供的内存系统模型的目的是允许在不干涉系统层<code>malloc</code>包的情况下运行分配器。</p><p>　　函数<code>mem_init()</code>会将堆可用的虚拟内存建模为双字对齐的字节数组。<code>mem_heap</code>和<code>mem_brk</code>之间的字节表示已分配的虚拟内存。<code>mem_brk</code>后的字节表示未分配的虚拟内存。分配器通过调用函数<code>mem_sbrk()</code>来请求额外的堆内存，该函数与函数<code>sbrk()</code>的接口相同且语义也相同，唯一区别是函数<code>mem_sbrk()</code>会拒接收缩堆的请求。</p><p>　　分配器在源文件<code>mm.c</code>中，用户可以编译和链接该源文件到指定的程序中。分配器输出以下3个函数到程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">mm_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><p>　　函数<code>mm_init()</code>会初始化分配器，若成功，则返回0；若出错，则返回-1。函数<code>mm_malloc()</code>和<code>mm_free()</code>与对应的系统级函数有相同的接口和语义。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/invariant_form_of_the_implicit_free_list.svg" title="invariant_form_of_the_implicit_free_list"><p>　　分配器使用的是带有边界标记的堆块。<span style="background-color:#ff0">块的最小值为16B</span>。空闲链表组织为隐式空闲链表。第1个字是用于双字对齐的 (未使用) 填充字。填充字后是<strong>序言块</strong>，这是8B的已分配的块，仅由首部和脚部组成。序言块在初始化时创建且永不释放。序言块后是若干个通过调用函数<code>malloc()</code>和<code>free()</code>得到的普通块。堆总是以<strong>结尾块</strong>结尾，这个块是0B的已分配的块，仅由首部组成。序言块和结尾块用于合并时消除边界条件。分配器使用私有全局变量<code>heap_listp</code>指向序言块 (作为优化，可以将其指向序言块的下一个块)。</p><h5 id="操作空闲链表的基本常数和宏">9.7.5.1 操作空闲链表的基本常数和宏</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mm.c */</span></span><br><span class="line"><span class="comment">/* 基本常量和宏 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4             <span class="comment">/* 字、首部和脚部的大小 (字节) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8             <span class="comment">/* 双字的大小 (字节) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12) <span class="comment">/* 堆扩展时扩展部分的大小 (字节) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x) &gt; (y) ? (x) : (y));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将大小字段和分配状态标志位打包成1个字 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读写地址p处的字 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p) (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val) (*(unsigned int *)(p) = (val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读地址p的大小字段和分配状态标志位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p) (GET(p) &amp; -0x7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取块指针bp指向的块的首部和脚部的地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp) ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取块指针bp指向的块的后继块和前驱块的地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span></span><br></pre></td></tr></table></figure><p>　　第3~5行是分配器会使用的基本参数和宏，即字的大小<code>WSIZE</code>、双字的大小<code>DSIZE</code>以及初始块和堆扩展时扩展部分的大小<code>CHUNKSIZE</code>。</p><p>　　第10行的宏<code>PACK</code>会将大小字段和分配状态标志位结合起来并返回，可以用于赋值给首部和脚部。</p><p>　　第13行的宏<code>GET</code>会读取并返回参数<code>p</code>指向的字，这里的强制类型转换很重要。参数<code>p</code>是<code>void *</code>类型，不能直接进行间接引用。第14行的宏<code>PUT</code>会将参数<code>val</code>存放在参数<code>p</code>指向的字中。</p><p>　　第16~17行的宏<code>GET_SIZE</code>和<code>GET_ALLOC</code>会从地址<code>p</code>处的首部或脚部分配返回大小字段和分配状态标志位。</p><p>　　其余的宏都是对<span style="background-color:#ff0">块指针</span><code>bp</code>进行操作，块指针指向有效载荷的第1个字节。对于块指针指向的块，宏<code>HDRP</code>和<code>FTRP</code>分别返回指向的该块的首部和脚部的指针，宏<code>NEXT_BLKP</code>和<code>PREV_BLKP</code>分别返回指向该块的后继块和前驱块的指针。</p><h5 id="创建初始空闲链表">9.7.5.2 创建初始空闲链表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mm.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief (私有) 用新空闲块扩展堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param words	扩展的字数</span></span><br><span class="line"><span class="comment"> * @return void*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配偶数个字以保证对齐 */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化空闲块的首部、脚部以及结尾块的首部 */</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));         <span class="comment">/* 空闲块首部 */</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));         <span class="comment">/* 空闲块脚部 */</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>)); <span class="comment">/* 新结尾块首部 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若相邻的块是空闲块则合并 */</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建有1个初始空闲块的堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 创建初始空堆 */</span></span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PUT(heap_listp, <span class="number">0</span>);                          <span class="comment">/* 用于对齐的填充部分 */</span></span><br><span class="line">    PUT(heap_listp + WSIZE, PACK(DSIZE, <span class="number">1</span>));     <span class="comment">/* 序言块首部 */</span></span><br><span class="line">    PUT(heap_listp + <span class="number">2</span> * WSIZE, PACK(DSIZE, <span class="number">1</span>)); <span class="comment">/* 序言块脚部 */</span></span><br><span class="line">    PUT(heap_listp + <span class="number">3</span> * WSIZE, PACK(<span class="number">0</span>, <span class="number">1</span>));     <span class="comment">/* 结尾块首部 */</span></span><br><span class="line">    heap_listp += <span class="number">2</span> * WSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用1个CHUNKSIZE字节的空闲块扩展空堆 */</span></span><br><span class="line">    <span class="keyword">if</span> (extend_heap(CHUNKSIZE / WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在调用函数<code>mm_malloc()</code>或<code>mm_free()</code>前，应用程序必须通过调用函数<code>mm_init()</code>来初始化堆。</p><p>　　函数<code>mm_init()</code>会从内存系统获取4个字并初始化它们来创建空的空闲链表 (第37~45行)，然后调用函数<code>extend_heap()</code>。函数<code>extend_heap()</code>会将堆扩展<code>CHUNKSIZE</code>字节并创建初始空闲块。此时，分配器已初始化，可以接收来自应用程序的分配和释放请求。</p><p>　　函数<code>extend_heap()</code>会在2种不同的环境中被调用，即初始化堆和当<code>mm_malloc()</code>不能找到合适的匹配块时。为了保证对齐，函数<code>extend_heap()</code>会将请求大小向上舍入为最接近的双字的整数倍，然后向内存请求额外的堆空间 (第14~18行)。</p><p>　　在第21~26行中，堆开始于双字对齐的边界，每次调用函数<code>heap_extend()</code>都返回大小是双字的整数倍的块。因此，每次调用函数<code>mem_sbrk()</code>都会返回双字对齐的内存片，紧跟在结尾块首部后面。结尾块首部会变为新空闲块的首部 (第21行) 且该片的最后1个字变为新的结尾块首部 (第23行)。最后，因为可能出现相邻的块都是空闲块的情况，所以调用函数<code>coalesce()</code>来合并空闲块，该函数会返回指向合并后的块的块指针 (第26行)。</p><h5 id="释放和合并块">9.7.5.3 释放和合并块</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mm.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 通过边界标记将指定的空闲块和所有相邻的空闲块合并</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param bp 指向空闲块的块指针</span></span><br><span class="line"><span class="comment"> * @return void*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放块并进行合并</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param bp 块指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　应用程序可以通过调用函数<code>mm_free()</code>来释放块并合并与之相邻的空闲块。函数<code>coalesce()</code>会合并空闲块。</p><h5 id="分配块">9.7.5.4 分配块</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mm.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief (私有) 首次适配搜索</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param asize 块大小</span></span><br><span class="line"><span class="comment"> * @return void* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *bp;</span><br><span class="line">    <span class="keyword">for</span> (bp = heap_listp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp))))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief (私有) 放置块，当剩余部分不小于16B时进行分割</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param bp 块指针</span></span><br><span class="line"><span class="comment"> * @param asize 块大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">void</span> *bp, <span class="type">size_t</span> asize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">if</span> ((csize - asize) &gt;= (<span class="number">2</span> * DSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(bp), PACK(csize - asize, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize - asize, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从空闲链表分配块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param size 分配的块的大小</span></span><br><span class="line"><span class="comment"> * @return void*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> asize;</span><br><span class="line">    <span class="type">size_t</span> extendsize;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略空请求 */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调整块大小 */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        asize = <span class="number">2</span> * DSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        asize = DSIZE * ((size + <span class="number">2</span> * DSIZE - <span class="number">1</span>) / DSIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 寻找合适的空闲块 */</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若找不到合适的空闲块，则分配更多的空间来满足请求 */</span></span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　应用程序可以调用函数<code>mm_malloc()</code>来向内存请求<code>size</code>字节的块。在检查请求是否为空后，分配器必须调整请求块的大小来为首部和脚部保留空间并保证双字对齐。第64~67行保证块最少有16B，其中8B用于对齐，另外8B用于存放首部和脚部。对于超过8B的请求，会加上开销字节并向上舍入到最接近的8的整数倍 (第70行)。</p><p>　　分配器调整了块大小后，会搜索空闲链表来寻找合适的空闲块 (第74行)。若有合适的块，则分配器会为请求块分配空间并可选地分割出多余的部分 (第76行)，然后返回指向新分配的块的指针；若没有合适的块，则用新空闲块来扩展堆 (第81~85行) 并可选地分割这个块 (第86行)，然后返回指向新分配的块的指针。</p><h4 id="显式空闲链表">9.7.6 显式空闲链表</h4><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/format_of_heap_blocks_that_use_doubly_linked_free_lists.svg" title="format_of_heap_blocks_that_use_doubly_linked_free_lists"><p>　　对于隐式空闲链表，块分配与堆块的数量呈线性关系，所以这种结构不合适通用分配器。更好的方法是将空闲块组织为某种形式的<strong>显式空闲链表</strong>。空闲块不需要有效载荷，所以实现显式空闲链表的指针可以存放在空闲块的有效载荷中。例如，堆可以组织成双向空闲链表，每个空闲块中到包含前驱和后继指针。</p><p>　　使用双向链表，可以让首次适配所需的时间从块总数的线性时间减少到空闲块数量的线性时间。不过，释放块所需时间可以是线性的，也可以是常数，这取决于空闲链表中块的排序策略。</p><p>　　可以用<span style="background-color:#ff0">先进后出</span>顺序来维护链表，将新释放的块放在链表的开始处。使用LIFO顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放块可以在常数时间内完成，若使用边界标记，则合并也可以在常数时间内完成。也可以用<span style="background-color:#ff0">地址顺序</span>来维护链表， 其中链表的每个块的地址都小于其后继块的地址。在这种情况下，释放块需要线性时间来定位前驱块。但是，用地址顺序的首次适配比LIFO顺序的首次适配有更高的内存利用率。</p><p>　　显式链表的缺点是空闲块必须足够大以包含所需的指针、首部和可能的脚部，这就导致了更大的块最小值，也潜在地提高了内部碎片的比例。</p><h4 id="分离空闲链表">9.7.7 分离空闲链表</h4><p>　　使用单向空闲块链表的分配器需要与空闲块呈线性关系的时间来分配块。可以通过<strong>分离存储</strong>来减少分配时间，即维护多个空闲链表，每个链表中的块有大致相等的大小。常规思路是将所有可能的块大小分成一些等价类，称为<strong>大小类</strong>。有很多方式来定义大小类。</p><p>　　可以根据2的幂来划分块大小： <span class="math display">\[ \{1\},\{2\},\{3,4\},\{5\sim8\},...,\{1025\sim2048\},\{2049\sim4096\},\{4097\sim\infty\} \]</span> 　　也可以将较小的块分配到单独的大小类中，而较大的块按照2的幂分类： <span class="math display">\[ \{1\},\{2\},\{3\},...,\{1023\},\{1024\},\{1025\sim2048\},\{2049\sim4096\},\{4097\sim\infty\} \]</span> 　　分配器维护着空闲链表数组，每个大小类1个数组，按照大小升序排列。当分配器需要大小为<span class="math inline">\(n\)</span>的块时，会搜索对应的空闲链表。若不能找到合适的块，则搜索下一个链表，依此类推。</p><p>　　动态存储分配的相关文献描述了数十种分离存储的方法，主要区别在于它们如何定义大小类、何时进行合并、何时向操作系统请求额外的堆内存和是否允许分割等。这里仅介绍<strong>简单分离存储</strong>和<strong>分离适配</strong>。</p><h5 id="简单分离存储">9.7.7.1 简单分离存储</h5><p>　　对于简单分离存储，每个大小类的空闲链表包含大小相等的块，每个块的大小就是这个大小类中最大元素的大小。例如，某个大小类定义为<span class="math inline">\(\{17\sim32\}\)</span>，则这个类的空闲链表全由大小为32的块组成。</p><p>　　为了分配指定大小的块，需要检查相应的空闲链表，若链表非空，则分配其中第1块的全部，空闲块不会分割以满足分配请求；若链表为空，则分配器向操作系统请求固定大小的额外内存片 (通常是页大小的整数倍)，将这个片分成大小相等的块并将这些块链接起来形成新的空闲链表。对于释放块，分配器只需将这个块插入到对应的空闲链表的前部。</p><p>　　简单分离存储的优点很多。分配和释放块都能在很快的常数时间内完成，而且每个片中的块都大小相等，不分割，不合并，这意味着每个块只有很少的内存开销。由于每个片中的块都大小相等，则已分配的块的大小能从它的地址中推断出来。因为没有合并，所以已分配的块的首部不需要分配状态标志位，即已分配的块不需要首部，而且也不需要脚部。因为分配和释放操作都是在空闲链表的起始处操作，所以链表只需要是单向的。每个空闲块都需要的字段是1个字的后继指针，所以块的最小值就是1个字。</p><p>　　简单分离存储的缺点是很容易产生碎片。因为不会分割空闲块，所以可能产生内部碎片。由于不会合并空闲块，某些引用模式会产生很多的外部碎片。例如，应用程序先向第1个大小类发送大量的分配和释放请求，然后向第2个大小类发送大量的分配和释放请求，然后向第3个大小类发送大量的分配和释放请求，依此类推。对于每个大小类，分配器会向操作系统请求大量永远不会回收的内存，因为不会合并空闲块，应用程序不再请求大小类的块后，该大小类的块将不再被使用。</p><h5 id="分离适配">9.7.7.2 分离适配</h5><p>　　对于分离适配，分配器维护着空闲链表的数组。每个空闲链表都与1个大小类关联且被组织为某种类型的显式或隐式链表。每个链表包含潜在的大小不同的块，这些块的大小是大小类的成员。有多种不同的分离适配器，这里只介绍比较简单的版本。</p><p>　　为了分配块，必须确定请求的大小类，对适当的空闲链表进行首次适配来查找合适的块。若找到合适的块，则可选地分割并将剩余部分插入到合适的空闲链表中；若找不到合适的块，则搜索下一个更大的大小类的空闲链表，依此类推，直到找到合适的块。若空闲链表中没有合适的块，则向操作系统请求额外的堆内存，从这个新的堆内存中分配块，将剩余部分插入到合适的空闲链表中。对于释放块，需要合并并将结果插入到合适的空闲链表中。</p><p>　　分离适配是很多分配器的常用选择，C语言中的<code>malloc</code>包就使用这种方法，因为这种方法既快速，又有较高的内存利用率。搜索时间减少了，因为搜索限定在堆的某个部分而非整个堆。内存利用率提高了，因为对分离空闲链表的首次适配搜索的内存利用率近似于对整个堆的最佳适配搜索的内存利用率。</p><p>　　<strong>伙伴系统</strong>就是分离适配的特例之一，其中每个大小类都是2的幂。基本思路是对于大小是<span class="math inline">\(2^m\)</span>个字的堆，为每个块大小<span class="math inline">\(2^k\)</span>维护1个分离空闲链表，其中<span class="math inline">\(0\leqslant k\leqslant m\)</span>。请求块向上舍入到最接近的2的幂。开始时，只有1个大小为<span class="math inline">\(2^m\)</span>个字的空闲块。</p><p>　　对于分配大小为<span class="math inline">\(2^k\)</span>的块，需要找到第1个可用且大小为<span class="math inline">\(2^j\)</span>的块，其中<span class="math inline">\(k \leqslant j \leqslant m\)</span>。若<span class="math inline">\(j=k\)</span>，则直接完成；否则，递归地二分这个块，直到<span class="math inline">\(j=k\)</span>。在进行分割时，每个剩余的半块 (也称为<strong>伙伴</strong>) 会插入到对应的空闲链表中。释放大小为<span class="math inline">\(2^k\)</span>的块后，需要一直合并空闲的伙伴，直到碰到已分配的伙伴。</p><p>　　通过给定地址和块大小可以计算出它的伙伴的地址，因为两者的地址只有1位不同。例如，大小为32B的块的地址为<span class="math inline">\(xxx...x00000\)</span>，其伙伴的地址为<span class="math inline">\(xxx...x10000\)</span>。</p><p>　　伙伴系统的优点是快速搜索和快速合并，缺点是块大小是2的幂的要求可能产生大量内部碎片。因此，伙伴系统分配器不适合通用目的应用程序，只适合那些块大小为2的幂的应用程序。</p><h3 id="垃圾回收">9.8 垃圾回收</h3><p>　　在C语言中的<code>malloc</code>包等显式分配器中，程序调用函数<code>malloc()</code>和<code>free()</code>来分配和释放堆块。程序需要负责释放所有不再需要的已分配的块。未能释放的已分配的块是常见的编程错误之一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">garbage</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)Malloc(<span class="number">15213</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* 数组p此时已成为垃圾 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在这个示例中，在函数<code>garbage()</code>返回前应该释放<code>p</code>，这个块会在程序的生命周期内一直保持已分配状态。</p><p>　　<strong>垃圾回收器</strong>是动态存储分配器，它自动释放程序不再需要的已分配的块，这些块称为<strong>垃圾</strong>。自动回收堆内存的过程称为<strong>垃圾回收</strong>。在支持垃圾回收的系统中，程序显式分配堆块，无需显式释放它们。</p><p>　　垃圾回收可以追溯到John McCarthy于20世纪60年代早期在MIT开发的Lisp系统，它是Java、ML、Perl和Mathematica等现代语言系统中的重要部分之一，而且它仍然是重要且活跃的研究领域之一。相关文献描述了大量的垃圾回收方法，这里仅介绍John McCarthy独创的标记-清除算法。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/garbage_collector's_view_of_memory_as_a_directed_graph.svg" title="garbage_collector" alt="s_view_of_memory_as_a_directed_graph"><p>　　如图所示，垃圾回收器将内存视为<span style="background-color:#ff0">有向可达图</span>。该图的节点分为<strong>根节点</strong>和<strong>堆节点</strong>。堆节点对应堆中已分配的块。有向边<span class="math inline">\(p \rightarrow q\)</span>表示块<span class="math inline">\(p\)</span>中的某个位置指向块<span class="math inline">\(q\)</span>中的某个位置。根节点对应那些不在堆中且包含指向堆的指针的位置，这些位置可以是寄存器、栈里的变量或虚拟内存中读写数据区域中的全局变量。</p><p>　　当存在任意1条从根节点出发并到达<span class="math inline">\(p\)</span>的有向路径时，则节点<span class="math inline">\(p\)</span>是<span style="background-color:#ff0">可达</span>的。不可达的节点对应垃圾，是不能再次为程序所用。垃圾回收器负责维护可达图的某种表示，通过释放不可达的节点并将其返回给空闲链表来定期回收垃圾。</p><p>　　ML和Java等语言的垃圾回收器对程序如何创建和使用指针有严格的控制，可以维护可达图的精确表示，从而可以回收所有垃圾。C和C++等语言通常不能维护可达图的精确表示，这样的回收器也称为<strong>保守式垃圾回收器</strong>。保守式垃圾回收器是保守的，因为每个可达的节点都会被标记为可达，而一些不可达的节点也会被标记为可达。</p><p>　　回收器可以按需提供服务，也可以作为和应用程序并行的独立线程来不断地更新可达图和回收垃圾。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/integrating_a_conservative_garbage_collector_and_a_c_malloc_package.svg" title="integrating_a_conservative_garbage_collector_and_a_c_malloc_package"><p>　　将保守式垃圾回收器加入到C语言的<code>malloc</code>包后，当需要堆空间时，应用程序会用常规方式调用函数<code>malloc()</code>。若函数<code>malloc()</code>找不到合适的块，则调用垃圾回收器来回收一些垃圾到空闲链表。回收器识别垃圾块并通过调用函数<code>free()</code>来将它们返回给堆。关键思想是回收器代替应用程序去调用函数<code>free()</code>。当从回收器返回时，函数<code>malloc()</code>重新寻找合适的块。若仍然找不到，则会向操作系统请求内存。最后，函数<code>malloc()</code>返回指向请求块的指针 (若成功) 或空指针 (若失败)。</p><h4 id="标记-清除垃圾回收器">9.8.1 标记-清除垃圾回收器</h4><p>　　标记-清除垃圾回收器包括<span style="background-color:#ff0">标记阶段</span>和<span style="background-color:#ff0">清除阶段</span>。标记阶段标记出所有根节点可达且已分配的节点，随后的清除阶段释放每个未被标记且已分配的节点。块首部中空闲的低位中的1位通常用于表示这个块是否被标记。</p><p>　　这里对标记-清除的描述会假设使用以下函数 (其中<code>ptr</code>定义为<code>typedef void *ptr</code>) ：</p><p>　　● <code>ptr isPtr(ptr p)</code>会判断<code>p</code>是否指向已分配的块的某个字。若是，则返回指向该块的起始处的指针<code>b</code>；否则，返回<code>NULL</code>。</p><p>　　● <code>int blockMarked(ptr b)</code>会判断<code>b</code>是否被标记。若是，则返回<code>true</code>。</p><p>　　● <code>int blockAllocated(ptr b)</code>会判断<code>b</code>是否已分配。若是，则返回<code>true</code>。</p><p>　　● <code>void markBlock(ptr b)</code>会标记块<code>b</code>。</p><p>　　● <code>int length(b)</code>会返回块<code>b</code>的长度 (不包括首部)，单位是字。</p><p>　　● <code>void unmarkBlock(ptr b)</code>会取消块<code>b</code>的标记。</p><p>　　● <code>ptr nextBlock(ptr b)</code>会返回堆中块<code>b</code>的后继块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 伪代码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mark</span><span class="params">(ptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((b = isPtr(p)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (blockMarked(b))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    markBlock(b);</span><br><span class="line">    len = lenght(b);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mark(b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sweep</span><span class="params">(ptr b, ptr end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (b &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (blockMarked(b))</span><br><span class="line">        &#123;</span><br><span class="line">            unmarkBlock(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (bloackAllocated(b))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        b = nextBlock(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　标记阶段会为每个根节点调用1次函数<code>mark()</code>。若<code>p</code>不指向已分配且未标记的堆块，则函数<code>mark()</code>立即返回；否则，它会标记该块并对块中的每个字递归地调用自己。每次调用函数<code>mark()</code>都会标记某个根节点的所有未标记且可达的后继节点。在标记阶段的最后，任何未标记且已分配的块被认为是不可达的 (即垃圾)，会在清除阶段被回收。</p><p>　　清除阶段会调用1次函数<code>sweep()</code>。函数<code>sweep()</code>会进行循环，释放遇到的所有未标记且已分配的块。</p><img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/mark&sweep_example.svg" title="mark&amp;sweep_example"><p>　　在这个示例中，块边界用粗线表示。每个方块对应内存中的1个字。每个块都有1个字的首部，要么是未标记的，要么是已标记的。开始时，堆中有6个未标记且已分配的块。块3包含指向块1的指针。块4包含指向块3和块6的指针。根节点指向块4，所以在标记阶段后，块1、块3、块4和块6会被标记 (可达)，块2和块5不会被标记 (不可达)。在清除阶段后，块2和块5会被回收到空闲链表。</p><h4 id="c程序的保守式标记-清除">9.8.2 C程序的保守式标记-清除</h4><p>　　标记-清除看似适合C程序的垃圾回收，因为它可以直接工作，而无需移动任何块。但是，C语言在实现函数<code>isPtr()</code>时会遇到一些问题。首先，C语言不会用任何信息来标记内存位置，所以无法判断函数<code>isPtr()</code>的入参<code>p</code>是否是指针。其次，即使知道<code>p</code>是指针，也无法判断<code>p</code>是否指向某个已分配的块的有效载荷中的某个位置。</p><p>　　对于第1个问题的解决方法是将已分配的块集合维护成平衡二叉树，该树的左子树中的所有块必须放在较小的地址处，右子树中的所有块放在较大的地址处。这需要在每个已分配的块的首部加入<code>left</code>和<code>right</code>字段，这2个字段指向某个已分配的块的首部。函数<code>isPtr(ptr p)</code>通过树来对已分配的块进行二分查找，每次通过首部的大小字段来判断<code>p</code>是否在这个块的范围内。</p><p>　　平衡二叉树会标记所有根节点可达的节点，这是必要的保证，因为应用程序的用户当然不会想过早地把已分配的块返回给空闲链表。然后，这种方法从某种意义上是保守的，因为它可能不正确地标记了实际不可达的块，所以它可能不会释放某些垃圾。</p><p>　　C程序的标记-清除必须是保守的，其根本原因在于C语言不会用任何信息来标记内存位置。因此，<code>int</code>和<code>float</code>等标量可以伪装成指针。例如，若某个可达的已分配的块的有效载荷中包含1个<code>int</code>，其值碰巧对应某个其他已分配的块<code>b</code>的有效载荷中的某个地址。对回收器而言，无法判断这个数据是<code>int</code>还是指针。因此，分配器必须保守地将块<code>b</code>标记为可达。</p><h3 id="c程序中常见的内存相关错误">9.9 C程序中常见的内存相关错误</h3><p>　　对于C程序员，管理和使用虚拟内存可能是困难且容易出错的，因为内存相关错误经常在时间和空间上与错误源有一段距离后才表现出来。</p><h4 id="间接使用坏指针">9.9.1 间接使用坏指针</h4><p>　　在进程的虚拟地址空间中有较大的空区域，没有映射到任何有意义的数据，若试图间接引用指向该区域的指针，则操作系统会以段故障中止程序。此外，虚拟内存的某些区域是只读，若试图写这些区域，则会以保护故障中止程序。</p><p>　　函数<code>scanf()</code>错误是间接引用坏指针的经典错误之一。若需要通过函数<code>scanf()</code>从<code>stdin</code>读整数到变量。正确的方法是将传递给函数<code>scanf()</code>格式串和<span style="background-color:#ff0">变量的地址</span>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val);</span><br></pre></td></tr></table></figure><p>　　但有时，很容传递<code>val</code>而非其地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, val);</span><br></pre></td></tr></table></figure><p>　　在这种情况下，函数<code>scanf()</code>会将<code>val</code>的值解释为地址并试图写该地址。在最好的情况下，程序会立即以异常中止。在最差的情况下，<code>val</code>的值刚好对应虚拟内存中的某个可读写区域，于是就会覆盖该区域的值，这通常会在一段时间才会造成严重后果。</p><h4 id="读未初始化的内存">9.9.2 读未初始化的内存</h4><p>　　虽然<code>bss</code>区域总是被加载器初始化为0，但是堆内存却不是这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">matvec</span><span class="params">(<span class="type">int</span> **A, <span class="type">int</span> *x, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> *y = (<span class="type">int</span> *)Malloc(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            y[i] += A[i][j] * x[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在这个示例中，会错误地假设数组<code>y</code>被初始化为0。正确的实现方式是显式地将<code>y[i]</code>设置为0或使用函数<code>calloc()</code>。</p><h4 id="栈缓冲区溢出">9.9.3 栈缓冲区溢出</h4><p>　　在不检查输入字符串的长度情况下，直接将其写到栈的目标缓冲区会导致<span style="background-color:#ff0">缓冲区溢出</span>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bufoverflow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在这个示例中，函数<code>gets()</code>会复制任意长度的字符串到缓冲区，这会导致缓冲区溢出，应使用函数<code>fgets()</code>，该函数会限制输入字符串的长度。</p><h4 id="假设指针与其指向的对象大小相同">9.9.4 假设指针与其指向的对象大小相同</h4><p>　　假设指针与其指向的对象大小相同是常见的错误之一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **<span class="title function_">markArray1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> **A = (<span class="type">int</span> **)Malloc(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = (<span class="type">int</span> *)Malloc(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会创建包含<code>n</code>个指针的数组，其中的每个指针都指向包含<code>m</code>个<code>int</code>的数组。但在第4行中，实际创建的是<code>int</code>数组。</p><p>　　这个示例在<code>int</code>长度和指针长度相同的机器上可以正常运行，但在Core i7等指针长度大于<code>int</code>长度的机器上运行会导致第5~8行的循环越界。因为这些字中的某个字很可能是已分配的块的脚部，所以这个错误不会立即出现，直到之后释放该块时，此时，分配器的合并会出错且没有任何明显的原因。这也是 "在远处起作用" 的示例，这类 "在远处起作用" 通常与内存相关错误有关。</p><h4 id="相差1错误">9.9.5 相差1错误</h4><p>　　<strong>相差1</strong>错误是另一种常见的导致覆盖错误的原因。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **<span class="title function_">markArray2</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> **A = (<span class="type">int</span> **)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会创建包含<code>n</code>个指针的数组，其中的每个指针都指向包含<code>m</code>个<code>int</code>的数组。第5~8行会试图初始化该数组的<code>n + 1</code>个元素，这个过程会覆盖数组后面的某个内存位置。</p><h4 id="引用指针而非其指向的对象">9.9.6 引用指针而非其指向的对象</h4><p>　　若不太注意C操作符的优先级和结合性，可能会错误地将指针作为指针指向的内容来操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">binheapDelete</span><span class="params">(<span class="type">int</span> **binheap, <span class="type">int</span> *size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *packet = binheap[<span class="number">0</span>];</span><br><span class="line">    binheap[<span class="number">0</span>] = binheap[*size - <span class="number">1</span>];</span><br><span class="line">    *size--; <span class="comment">/* 这里应该是(*size)-- */</span></span><br><span class="line">    heapify(binheap, *size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> packet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会删除包含<code>*size</code>项的二叉堆里的第1项，然后对剩下的<code>*size - 1</code>项重新建堆。第5行是为了减少<code>size</code>指向的值，但是一元运算符<code>--</code>和<code>*</code>的优先级相同并从右到左关联，所以减少的就是指针的值。若足够幸运，程序会立即中止，但更有可能发生的是程序在运行较长时间后才会产生不正确的结果。</p><h4 id="误解指针运算">9.9.7 误解指针运算</h4><p>　　忘记了指针的算术操作是以它们指向的对象的大小作为单位来进行是常见错误之一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">search</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (*p &amp;&amp; *p != val)</span><br><span class="line">    &#123;</span><br><span class="line">        p += <span class="keyword">sizeof</span>(<span class="type">int</span>); <span class="comment">/* 应该是p++ */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会扫描<code>int</code>数组并返回指向第1个<code>val</code>的指针。第5行中会把指针加4，就导致函数会错误地扫描数组中的每4个整数。</p><h4 id="引用不存在的变量">9.9.8 引用不存在的变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">stackref</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">return</span> &amp;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会返回指针，该指针指向随后会弹出栈帧的局部变量。尽管<code>p</code>指向合法的内存地址，但已经不再指向合法的变量。当之后程序调用其他函数时，函数<code>stackref()</code>原本的栈帧会被重用来作为其他函数的栈帧。再后来，若程序分配某个值给<code>*p</code>，则可能实际会修改另一个函数的栈帧的某个条目。</p><h4 id="引用空闲堆块中的数据">9.9.9 引用空闲堆块中的数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">heapref</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> *x, *y;</span><br><span class="line">    x = (<span class="type">int</span> *)Malloc(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">    y = (<span class="type">int</span> *)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        y[i] = x[i]++; <span class="comment">/* x[i]在空闲块中 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在这个示例中，第5行分配了整数数组<code>x</code>，在第7行释放了<code>x</code>，但又在第11行引用<code>x</code>，此时，<code>x</code>可能是某个已分配的块的一部分，一段时间后，<code>y</code>的值有问题才会显现出来。</p><h4 id="内存泄漏">9.9.10 内存泄漏</h4><p>　　内存泄漏是缓慢且隐性的问题，当忘记释放已分配的块时，就会出现这个问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *x = (<span class="type">int</span> *)Malloc(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　若某个程序经常调用该示例，则堆里会有很多垃圾，在最差的情况下，会占用整个虚拟地址空间。对于守护进程和服务器等程序，内存泄漏是很严重的问题，因为这类程序通常不会终止。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/" rel="prev" title="《深入理解计算机系统 第3版》第8章 异常控制流"><i class="fa fa-angle-left"></i> 《深入理解计算机系统 第3版》第8章 异常控制流</a></div><div class="post-nav-item"><a href="/2023/08/16/computer-systems-a-programmer's-perspective-3e-chpt-10/" rel="next" title="《深入理解计算机系统 第3版》第10章 系统级I/O">《深入理解计算机系统 第3版》第10章 系统级I/O <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script></body></html>