<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《计算机网络-自顶向下方法 第7版》附录</title>
    <url>/2022/09/12/computer-networking-a-top-down-approach-7e-appx/</url>
    <content><![CDATA[<h3 id="a.1-常见应用及其协议">A.1 常见应用及其协议</h3>
<table>
<thead>
<tr>
<th style="text-align: center;">应用</th>
<th style="text-align: center;">应用层协议</th>
<th style="text-align: center;">传输层协议和端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">电子邮件</td>
<td style="text-align: center;">SMTP</td>
<td style="text-align: center;">TCP:25/465/587/2525</td>
</tr>
<tr>
<td style="text-align: center;">远程终端访问</td>
<td style="text-align: center;">Telnet</td>
<td style="text-align: center;">TCP:23</td>
</tr>
<tr>
<td style="text-align: center;">Web</td>
<td style="text-align: center;">HTTP</td>
<td style="text-align: center;">TCP:80</td>
</tr>
<tr>
<td style="text-align: center;">文件传输</td>
<td style="text-align: center;">FTP</td>
<td style="text-align: center;">TCP:20/21</td>
</tr>
<tr>
<td style="text-align: center;">远程文件服务器</td>
<td style="text-align: center;">NFS</td>
<td style="text-align: center;">UDP:2049</td>
</tr>
<tr>
<td style="text-align: center;">流式多媒体</td>
<td style="text-align: center;">通常专用</td>
<td style="text-align: center;">TCP/UDP</td>
</tr>
<tr>
<td style="text-align: center;">互联网电话</td>
<td style="text-align: center;">通常专用</td>
<td style="text-align: center;">TCP/UDP</td>
</tr>
<tr>
<td style="text-align: center;">网络管理</td>
<td style="text-align: center;">SNMP</td>
<td style="text-align: center;">UDP:161/162</td>
</tr>
<tr>
<td style="text-align: center;">域名系统</td>
<td style="text-align: center;">DNS</td>
<td style="text-align: center;">UDP:53</td>
</tr>
<tr>
<td style="text-align: center;">SSH隧道</td>
<td style="text-align: center;">SSH</td>
<td style="text-align: center;">TCP:22</td>
</tr>
<tr>
<td style="text-align: center;">DHCP</td>
<td style="text-align: center;">BOOTP</td>
<td style="text-align: center;">UDP:67 (服务器) /68 (客户端)</td>
</tr>
<tr>
<td style="text-align: center;">BGP</td>
<td style="text-align: center;">BGP</td>
<td style="text-align: center;">TCP:179</td>
</tr>
<tr>
<td style="text-align: center;">OpenFlow</td>
<td style="text-align: center;">OpenFlow</td>
<td style="text-align: center;">TCP:6653</td>
</tr>
<tr>
<td style="text-align: center;">网络管理</td>
<td style="text-align: center;">SNMP</td>
<td style="text-align: center;">UDP:161/162/163或
(D)TLS:10161/10162</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h3 id="a.2-专业术语">A.2 专业术语</h3>
<blockquote>
<p><strong>access point (AP)</strong> 访问接入点</p>
<p><strong>active scanning</strong> 主动扫描</p>
<p><strong>ad hoc network</strong> 自组织网络</p>
<p><strong>advanced audio coding (AAC)</strong> 高级音频编码</p>
<p><strong>acknowledgment (ACK)</strong> 确认</p>
<p><strong>active optical network terminator (AON)</strong>
主动光纤网络</p>
<p><strong>active queue management (AQM)</strong> 主动队列算法</p>
<p><strong>additive increase,multiplicative decrease (AIMD)</strong>
加性增、乘性减</p>
<p><strong>address aggregation</strong> 地址聚合</p>
<p><strong>address lease time</strong> 地址租用期</p>
<p><strong>address resolution protocol (ARP)</strong> 地址解析协议</p>
<p><strong>advanced encryption standard (AES)</strong> 高级加密标准</p>
<p><strong>agent discovery</strong> 代理发现</p>
<p><strong>agent solicitation</strong> 代理请求</p>
<p><strong>aggregator</strong> 聚合器</p>
<p><strong>alternating bit protocol</strong> 比特交替协议</p>
<p><strong>anchor </strong> 锚</p>
<p><strong>anycast</strong> 任播</p>
<p><strong>application programming interface (API)</strong>
应用程序编程接口</p>
<p><strong>assured forwarding (AF)</strong> 确保转发</p>
<p><strong>asymmetric encryption</strong> 非对称加密</p>
<p><strong>asynchronous transfer mode (ATM)</strong> 异步传输模式</p>
<p><strong>atomic aggregate</strong> 原子聚合</p>
<p><strong>authentication key</strong> 认证密钥</p>
<p><strong>authentication header (AH)</strong> 认证首部</p>
<p><strong>authentication protocol (AP)</strong> 认证协议</p>
<p><strong>automatic repeat request (ARQ)</strong> 自动重传请求</p>
<p><strong>autonomous system (AS)</strong> 自治系统</p>
<p><strong>available bite rate (ABR)</strong> 可用比特率</p>
<p><strong>average throughput</strong> 平均吞吐量</p>
<p><strong>bandwidth</strong> 带宽</p>
<p><strong>bandwidth provisioning</strong> 带宽供给</p>
<p><strong>bandwidth sensitive application</strong> 带宽敏感的应用</p>
<p><strong>base station</strong> 基站</p>
<p><strong>base station controller (BSC)</strong> 基站控制器</p>
<p><strong>base station system (BSS)</strong> 基站系统</p>
<p><strong>base transceiver station (BTS)</strong> 基站收发台</p>
<p><strong>basic service set (BSS)</strong> 基本服务集</p>
<p><strong>beacon frame</strong> 信标帧</p>
<p><strong>Berkeley Internet Name Domain (BIND/NAMED)</strong>
DNS服务器软件</p>
<p><strong>best effort delivery service</strong> 尽力而为交付服务</p>
<p><strong>best effort service</strong> 尽力而为服务</p>
<p><strong>BGP attribute</strong> BGP属性</p>
<p><strong>BGP speaker</strong> BGP发言者</p>
<p><strong>blade</strong> 刀片</p>
<p><strong>block cipher</strong> 块加密</p>
<p><strong>bidirectional data transfer</strong> 双向/全双工数据传输</p>
<p><strong>binary exponential back off</strong> 二进制指数退避</p>
<p><strong>bit error ratio (BER)</strong> 比特差错率</p>
<p><strong>bootstrap protocol (BOOTP)</strong> 引导程序协议</p>
<p><strong>border gateway protocol (BGP)</strong> 边界网关协议</p>
<p><strong>border router</strong> 边界路由器</p>
<p><strong>botnet</strong> 僵尸网络</p>
<p><strong>bottleneck link</strong> 瓶颈链路</p>
<p><strong>bring home</strong> 客邀</p>
<p><strong>broadcast</strong> 广播</p>
<p><strong>cable internet access</strong> 电缆互联网接入</p>
<p><strong>cable modern</strong> 电缆调制解调器</p>
<p><strong>cable modern termination system (CMTS)</strong>
电缆调制解调器终端系统</p>
<p><strong>call admission control (CAC)</strong> 呼叫准入控制</p>
<p><strong>call setup</strong> 呼叫建立</p>
<p><strong>canonical hostname</strong> 规范主机名</p>
<p><strong>care-of address (COA)</strong> 转交地址</p>
<p><strong>carrier sense multiple access (CSMA)</strong>
载波侦听多路访问</p>
<p><strong>carrier sense multiple access with collision avoidance
(CSMA/CA)</strong> 带有碰撞避免的载波侦听多路访问</p>
<p><strong>carrier sense multiple access with collision detection
(CSMA/CD)</strong> 带有碰撞检测的载波侦听多路访问</p>
<p><strong>Caesar cipher</strong> 凯撒密码</p>
<p><strong>cellular</strong> 蜂窝</p>
<p><strong>centralized routing algorithm</strong> 集中式路由选择算法</p>
<p><strong>certificate</strong> 证书</p>
<p><strong>certification authority (CA)</strong> 认证中心</p>
<p><strong>channel partitioning protocol</strong> 信道划分协议</p>
<p><strong>channel propagation delay</strong> 信道传播时延</p>
<p><strong>chipping rate</strong> 码片速率</p>
<p><strong>choke packet</strong> 抑制分组</p>
<p><strong>chosen-plaintext attack</strong> 选择明文攻击</p>
<p><strong>cipher block chaining (CBC)</strong> 密码块链接</p>
<p><strong>ciphertext</strong> 密文</p>
<p><strong>ciphertext-only attack</strong> 唯密文攻击</p>
<p><strong>circuit</strong> 电路</p>
<p><strong>circuit switching</strong> 电路交换</p>
<p><strong>class of service (COS)</strong> 服务分类</p>
<p><strong>classful addressing</strong> 分类编制</p>
<p><strong>classless interdomain routing (CIDR)</strong>
无类别域间路由选择</p>
<p><strong>clear to send (CTS)</strong> 允许发送</p>
<p><strong>client</strong> 客户端</p>
<p><strong>cluster selection strategy</strong> 集群选择策略</p>
<p><strong>code division multiple access (CDMA)</strong> 码分多址</p>
<p><strong>communication link</strong> 通信链路</p>
<p><strong>congestion avoidance</strong> 拥塞避免</p>
<p><strong>congestion control</strong> 拥塞控制</p>
<p><strong>congestion window reduced (CWR)</strong> 拥塞窗口减少</p>
<p><strong>congestion window (cwnd)</strong> 拥塞窗口</p>
<p><strong>collision detection</strong> 碰撞检测</p>
<p><strong>compact disk (CD)</strong> 光盘</p>
<p><strong>connection oriented</strong> 面向连接的</p>
<p><strong>content distribution network (CDN)</strong> 内容分发网络</p>
<p><strong>content provider network</strong> 内容提供商网络</p>
<p><strong>contention period (CP)</strong> 竞争周期</p>
<p><strong>contention window (CW)</strong> 竞争窗口</p>
<p><strong>contention-free period (CFP)</strong> 无竞争周期</p>
<p><strong>control plane</strong> 控制平面</p>
<p><strong>convergence</strong> 收敛</p>
<p><strong>correspondent</strong> 通信者</p>
<p><strong>correspondent agent</strong> 通信者代理</p>
<p><strong>count to infinity</strong> 无穷计数</p>
<p><strong>countdown timer</strong> 倒数计时器</p>
<p><strong>cryptographic hash function</strong> 密码散列函数</p>
<p><strong>cumulative acknowledgement</strong> 累积确认</p>
<p><strong>customer</strong> 客户</p>
<p><strong>cyclic redundancy check (CRC)</strong> 循环冗余校验</p>
<p><strong>data center</strong> 数据中心</p>
<p><strong>data center network</strong> 数据中心网络</p>
<p><strong>data center TCP (DCTCP)</strong> 数据中心TCP</p>
<p><strong>data encryption standard (DES)</strong> 数据加密标准</p>
<p><strong>data over cable service interface specification
(DOCSIS)</strong> 有线电缆数据服务接口规范</p>
<p><strong>data plane</strong> 数据平面</p>
<p><strong>datagram</strong> 数据报</p>
<p><strong>datagram congestion control protocol (DCCP)</strong>
数据报拥塞控制协议</p>
<p><strong>decentralized routing algorithm</strong>
分布式路由选择算法</p>
<p><strong>deep packet inspection (DPI)</strong> 深度分组检测</p>
<p><strong>default gateway</strong> 默认网关</p>
<p><strong>delay,throughput,reliability (DTR)</strong>
延迟、吞吐量、可靠性</p>
<p><strong>denial of service (DOS)</strong> 拒绝服务</p>
<p><strong>demilitarized zone (DMZ)</strong> 隔离区</p>
<p><strong>demultiplexing</strong> 多路分解</p>
<p><strong>destination options</strong> 目的选项</p>
<p><strong>destination port number field</strong> 目的端口号字段</p>
<p><strong>DHCP decline message</strong> DHCP拒绝报文</p>
<p><strong>DHCP discover message</strong> DHCP发现报文</p>
<p><strong>DHCP Inform message</strong> DHCP信息报文</p>
<p><strong>DHCP offer message</strong> DHCP提供报文</p>
<p><strong>DHCP release message</strong> DHCP释放报文</p>
<p><strong>DHCP request message</strong> DHCP请求报文</p>
<p><strong>differentiated service (diffserv, DS)</strong> 区分服务</p>
<p><strong>digital subscriber line (DSL)</strong> 数字用户线</p>
<p><strong>digital signature</strong> 数字签名</p>
<p><strong>direct sequence wideband CDMA (DS-WCDMA)</strong>
直接序列宽带码分多址</p>
<p><strong>distance vector (DV)</strong> 距离向量</p>
<p><strong>distinguished name (DN)</strong> 专用名称</p>
<p><strong>distributed application</strong> 分布式应用程序</p>
<p><strong>distributed coordination function (DCF)</strong>
分布式协调功能</p>
<p><strong>distributed interframe space (DIFS)</strong>
分布式帧间间隔</p>
<p><strong>distribution time</strong> 分发时间</p>
<p><strong>DNS caching</strong> DNS缓存</p>
<p><strong>don't fragment (DF)</strong> 禁止分片</p>
<p><strong>domain name system (DNS)</strong> 域名系统</p>
<p><strong>dotted-decimal notation</strong> 点分十进制表示法</p>
<p><strong>drop tail</strong> 弃尾</p>
<p><strong>duplicate data packet</strong> 冗余数据分组</p>
<p><strong>dynamic adaptive streaming over HTTP (DASH)</strong>
HTTP动态自适应流</p>
<p><strong>dynamic host configuration protocol (DHCP)</strong>
动态主机配置协议</p>
<p><strong>dynamic routing algorithm</strong> 动态路由选择算法</p>
<p><strong>ECN Echo (ECE)</strong> 显式拥塞提醒回应</p>
<p><strong>edge router</strong> 边缘路由器</p>
<p><strong>encapsulating security payload (ESP)</strong>
封装安全有效载荷</p>
<p><strong>encapsulation</strong> 封装</p>
<p><strong>encrypted master secret (EMS)</strong> 加密主密钥</p>
<p><strong>end system</strong> 端系统</p>
<p><strong>end-end principle</strong> 端到端原则</p>
<p><strong>end-point authentication</strong> 端点认证</p>
<p><strong>end-to-end connection</strong> 端到端连接</p>
<p><strong>enhanced distributed channel access (EDCA)</strong>
增强分布式信道接入</p>
<p><strong>enhanced packet core (EPC)</strong> 增强分组核</p>
<p><strong>enter deep</strong> 深入</p>
<p><strong>elastic application</strong> 弹性应用</p>
<p><strong>event based programming</strong> 基于事件的编程</p>
<p><strong>error detection and correction (EDC)</strong>
差错检测和纠错</p>
<p><strong>expedited forwarding (EF)</strong> 加速转发</p>
<p><strong>explicit congestion notification (ECN)</strong>
显式拥塞通知</p>
<p><strong>extend simple mail transfer protocol (ESMTP)</strong>
扩展简单邮件传输协议</p>
<p><strong>extended interframe space (EIFS)</strong> 扩展帧间间隔</p>
<p><strong>extensible authentication protocol (EAP)</strong>
可扩展认证协议</p>
<p><strong>external BGP (EBGP)</strong> 外部BGP</p>
<p><strong>exponential weighted moving average (EWMA)</strong>
指数加权移动平均</p>
<p><strong>fast recovery</strong> 快速恢复</p>
<p><strong>fast retransmit</strong> 快速重传</p>
<p><strong>flooding</strong> 泛洪</p>
<p><strong>flow control service</strong> 流量控制协议</p>
<p><strong>flow table</strong> 流表</p>
<p><strong>fiber to the home (FTTH)</strong> 光纤到户</p>
<p><strong>file transfer protocol (FTP)</strong> 文件传输协议</p>
<p><strong>filtering</strong> 过滤</p>
<p><strong>finite state machine (FSM)</strong> 有限状态机</p>
<p><strong>firewall</strong> 防火墙</p>
<p><strong>first come first service (FCFS)</strong> 先来先服务</p>
<p><strong>first input first output (FIFO)</strong> 先进先出</p>
<p><strong>foreign address</strong> 外部地址</p>
<p><strong>foreign agent</strong> 外部代理</p>
<p><strong>foreign network</strong> 外部网络</p>
<p><strong>forward error correction (FEC)</strong> 前向纠错</p>
<p><strong>forwarding</strong> 转发</p>
<p><strong>forwarding equivalence class (FEC)</strong> 转发等价类</p>
<p><strong>forwarding table</strong> 转发表</p>
<p><strong>fragment</strong> 片</p>
<p><strong>frame</strong> 帧</p>
<p><strong>frame check sequence (FCS)</strong> 帧校验序列</p>
<p><strong>frequency division multiple access (FDMA)</strong>
频分多址</p>
<p><strong>frequency-division multiplexing (FDM)</strong> 频分复用</p>
<p><strong>frequency-hopping spread spectrum (FHSS)</strong>
跳频扩频</p>
<p><strong>full duplex service</strong> 全双工服务</p>
<p><strong>gateway router</strong> 网关路由器</p>
<p><strong>gateway GRPS support node (GGSN)</strong>
网关GRPS支持节点</p>
<p><strong>gateway mobile services switching center (GMSC)</strong>
网关移动交换中心</p>
<p><strong>general packet radio service (GRPS)</strong>
通用分组无线服务</p>
<p><strong>geographically closest</strong> 地理上最近</p>
<p><strong>geostationary satellite</strong> 同步卫星</p>
<p><strong>gigabit ethernet</strong> 吉比特/千兆以太网</p>
<p><strong>global system for mobile communications (GSM)</strong>
全球移动通信系统</p>
<p><strong>go-back-n (GBN)</strong> 回退N步</p>
<p><strong>guided media</strong> 导引型媒体</p>
<p><strong>hand off</strong> 切换</p>
<p><strong>hash-based message authentication code (HMAC)</strong>
散列报文认证码</p>
<p><strong>head of the line (HOL)</strong> 线路前部</p>
<p><strong>header line</strong> 首部行</p>
<p><strong>high-level data link control (HDLC)</strong>
高级数据链路控制</p>
<p><strong>high speed packet access (HSPA)</strong> 高速分组接入</p>
<p><strong>home agent</strong> 移动代理</p>
<p><strong>home location register (HLR)</strong> 归属位置寄存器</p>
<p><strong>home network</strong> 归属网络</p>
<p><strong>home subscriber server (HSS)</strong> 归属用户服务器</p>
<p><strong>hop by hop options</strong> 逐跳选项</p>
<p><strong>host</strong> 主机</p>
<p><strong>host aliasing</strong> 主机别名</p>
<p><strong>hostname</strong> 主机名</p>
<p><strong>hot potato routing</strong> 热土豆路由选择</p>
<p><strong>hub</strong> 集线器</p>
<p><strong>hybrid coordination function (HCF)</strong> 混合协调功能</p>
<p><strong>hybrid fiber coax (HFC)</strong> 混合光纤同轴</p>
<p><strong>hyper text transfer protocol (HTTP)</strong>
超文本传输协议</p>
<p><strong>infrastructure mode</strong> 基础设施模式</p>
<p><strong>ingress port</strong> 输入端口</p>
<p><strong>initial sequence number (ISN)</strong> 初始序号</p>
<p><strong>initialization vector (IV)</strong> 初始向量</p>
<p><strong>input port</strong> 输入端口</p>
<p><strong>instantaneous throughput</strong> 瞬时吞吐量</p>
<p><strong>interframe spacing (IFS)</strong> 帧间间隔</p>
<p><strong>interleave</strong> 交错</p>
<p><strong>intermediate system to intermediate system (IS-IS)</strong>
中间系统到中间系统</p>
<p><strong>internal BGP (IBGP)</strong> 内部BGP</p>
<p><strong>internal router</strong> 内部路由器</p>
<p><strong>international telecommunication union (ITU)</strong>
国际电信联盟</p>
<p><strong>internet control message protocol (ICMP)</strong>
互联网控制报文协议</p>
<p><strong>internet corporation for assigned names and numbers
(ICANN)</strong> 互联网名称与数字地址分配机构</p>
<p><strong>internet exchange point (IXP)</strong> 互联网交换点</p>
<p><strong>internet engineering task force (IETF)</strong>
互联网工程任务组</p>
<p><strong>internet group management protocol (IGMP)</strong>
互联网组管理协议</p>
<p><strong>internet key exchange (IKE)</strong> 互联网密钥交换</p>
<p><strong>internet mail access protocol (IMAP)</strong>
互联网邮件访问协议</p>
<p><strong>internet protocol (IP) </strong>网际协议</p>
<p><strong>internet protocol security (IPsec)</strong>
互联网安全协议</p>
<p><strong>internet service provider (ISP)</strong> 互联网服务提供商</p>
<p><strong>internet standard</strong> 互联网标准</p>
<p><strong>inter-autonomous system routing protocol</strong>
自治系统间路由选择协议</p>
<p><strong>intra-autonomous system routing protocol</strong>
自治系统内部路由选择协议</p>
<p><strong>intrusion detection system (IDS)</strong> 入侵检测系统</p>
<p><strong>intrusion prevention system (IPS)</strong> 入侵防御系统</p>
<p><strong>IP spoofing</strong> IP哄骗</p>
<p><strong>jitter</strong> 抖动</p>
<p><strong>key distribution center (KDC)</strong> 密钥分发中心</p>
<p><strong>key-signing party</strong> 密钥签署方</p>
<p><strong>label switching path (LSP)</strong> 标签交换路径</p>
<p><strong>label switching router (LSR)</strong> 标签交换路由器</p>
<p><strong>layer</strong> 分层</p>
<p><strong>least cost path</strong> 最低成本路径</p>
<p><strong>lightweight directory access protocol (LDAP)</strong>
轻型目录访问协议</p>
<p><strong>link layer switch</strong> 链路层交换机</p>
<p><strong>link state (LS)</strong> 链路状态</p>
<p><strong>link state advertisement (LSA)</strong> 链路状态通告</p>
<p><strong>link-scheduling discipline</strong> 链路调度规则</p>
<p><strong>known-plaintext attack</strong> 已知明文攻击</p>
<p><strong>load distribution</strong> 负载分配</p>
<p><strong>load insensitive algorithm</strong> 负载迟钝算法</p>
<p><strong>load sensitive algorithm</strong> 负载敏感算法</p>
<p><strong>local area network (LAN)</strong> 局域网</p>
<p><strong>local preference (LOCAL_PREF)</strong> 本地优先级</p>
<p><strong>logic communication</strong> 逻辑通信</p>
<p><strong>long term evolution (LTE)</strong> 长期演进</p>
<p><strong>longest prefix matching rule</strong> 最长前缀匹配规则</p>
<p><strong>loss tolerant application</strong> 容忍丢失的应用</p>
<p><strong>low earth orbiting (LEO)</strong> 近地轨道</p>
<p><strong>mail server aliasing</strong> 邮件服务别名</p>
<p><strong>managed device</strong> 被管设备</p>
<p><strong>managed object</strong> 被管对象</p>
<p><strong>management information base (MIB)</strong> 管理信息库</p>
<p><strong>managing server</strong> 管理服务器</p>
<p><strong>manifest file</strong> 告示文件</p>
<p><strong>malware</strong> 恶意软件</p>
<p><strong>master secret (MS)</strong> 主密钥</p>
<p><strong>maximum segment size (MSS)</strong> 最大报文段长度</p>
<p><strong>maximum transmission unit (MTU)</strong> 最大传输单元</p>
<p><strong>message</strong> 报文</p>
<p><strong>message authentication code (MAC)</strong> 报文认证码</p>
<p><strong>message integrity</strong> 报文完整性</p>
<p><strong>meter</strong> 计量</p>
<p><strong>modular data center (MDC)</strong> 模块化数据中心</p>
<p><strong>mobile ac hoc network (MANET)</strong> 移动自组织网络</p>
<p><strong>mobile station roaming number (MSRN)</strong>
移动站点漫游号</p>
<p><strong>mobility management entity (MME)</strong> 移动性管理实体</p>
<p><strong>mobile switching center (MSC)</strong> 移动交换中心</p>
<p><strong>monoalphabetic cipher</strong> 单表替换密码</p>
<p><strong>more fragment (MF)</strong> 还有分片</p>
<p><strong>multicast OSPF (MOSPF)</strong> 多播OSPF</p>
<p><strong>multipath propagation</strong> 多径传播</p>
<p><strong>multiple access</strong> 多路访问</p>
<p><strong>multiple input multiple output (MIMO)</strong>
多输入多输出</p>
<p><strong>multiprotocol label switching (MPLS)</strong>
多协议标签交换</p>
<p><strong>multi-exit discriminator (MED/MULTI_EXIT_DISC)</strong>
多出口鉴别器</p>
<p><strong>multi-home</strong> 多宿</p>
<p><strong>multi-homed access ISP</strong> 多宿接入ISP</p>
<p><strong>must be zero (MBZ)</strong> 必须为零</p>
<p><strong>NAT translation table</strong> NAT转换表</p>
<p><strong>media access control (MAC)</strong> 媒体访问控制</p>
<p><strong>mesh</strong> 网状</p>
<p><strong>negative acknowledgment (NAK)</strong> 否定确认</p>
<p><strong>net file system (NFS)</strong> 网络文件系统</p>
<p><strong>network address translation (NAT)</strong> 网络地址转换</p>
<p><strong>network allocation vector (NAV)</strong> 网络分配向量</p>
<p><strong>network architecture</strong> 网络体系结构</p>
<p><strong>network control server (NCS)</strong> 网络控制服务器</p>
<p><strong>network dimensioning</strong> 网络定制</p>
<p><strong>network functions virtualization (NFV)</strong>
网络功能虚拟化</p>
<p><strong>network information base (NIB)</strong> 网络信息数据库</p>
<p><strong>network interface card (NIC)</strong> 网络接口卡</p>
<p><strong>network management agent</strong> 网络管理代理</p>
<p><strong>network management protocol</strong> 网络管理协议</p>
<p><strong>network operations center (NOC)</strong> 网络运营中心</p>
<p><strong>network service model</strong> 网络服务模型</p>
<p><strong>nodal processing delay</strong> 节点处理时延</p>
<p><strong>nonce</strong> 不重数</p>
<p><strong>nonce sum (NS)</strong> 随机数和</p>
<p><strong>non-persistent connection</strong> 非持续连接</p>
<p><strong>non-preemptive priority queueing</strong>
非抢占式优先级排队</p>
<p><strong>offered load</strong> 供给载荷</p>
<p><strong>open network operating system (ONOS)</strong>
开放网络操作系统</p>
<p><strong>open shortest path first (OSPF)</strong>
开放式最短路径优先</p>
<p><strong>open system interconnection reference model (OSI
model)</strong> 开放式系统互联网通信参考模型</p>
<p><strong>OpenFlow agent (OFA)</strong> OpenFlow代理</p>
<p><strong>OpenFlow controller (OFC)</strong> OpenFlow控制器</p>
<p><strong>optical Carrier (OC)</strong> 光载波</p>
<p><strong>optical line terminator (OLT)</strong> 光纤线路端连接器</p>
<p><strong>optical network terminator (ONT)</strong> 光纤网络终端</p>
<p><strong>optional non-transitive</strong> 可选非传递</p>
<p><strong>optional transitive</strong> 可选传递</p>
<p><strong>orthogonal frequency division multiplexing (OFDM)</strong>
正交频分复用</p>
<p><strong>output buffer</strong> 输出缓存</p>
<p><strong>output port</strong> 输出端口</p>
<p><strong>output queue</strong> 输出队列</p>
<p><strong>packet</strong> 分组</p>
<p><strong>packet data network gateway (P-GW)</strong>
分组数据网络网关</p>
<p><strong>packet loss</strong> 分组丢包</p>
<p><strong>packet sniffer</strong> 分组嗅探器</p>
<p><strong>packet switch</strong> 分组交换机</p>
<p><strong>packet switching</strong> 分组交换</p>
<p><strong>paging</strong> 寻呼</p>
<p><strong>pairwise master key (PMK)</strong> 成对主密钥</p>
<p><strong>parity bit</strong> 奇偶校验位</p>
<p><strong>passive optical network (PON)</strong> 被动光纤网络</p>
<p><strong>passive scanning</strong> 被动扫描</p>
<p><strong>path</strong> 路径</p>
<p><strong>path loss</strong> 路径损耗</p>
<p><strong>payload field</strong> 有效载荷字段</p>
<p><strong>peer</strong> 对等</p>
<p><strong>peer to peer (P2P)</strong> 点对点</p>
<p><strong>penultimate hop popping (PHP)</strong> 倒数第二跳弹出</p>
<p><strong>per-hop behavior (PHB)</strong> 每跳行为</p>
<p><strong>prefetch</strong> 预取</p>
<p><strong>permanent address</strong> 永久地址</p>
<p><strong>persistent connection</strong> 持续连接</p>
<p><strong>personal area network (PAN)</strong> 个人局域网</p>
<p><strong>per-router control</strong> 每路由器控制</p>
<p><strong>plug and play protocol</strong> 即插即用协议</p>
<p><strong>piconet</strong> 微微网</p>
<p><strong>piggyback</strong> 捎带</p>
<p><strong>pipelining</strong> 流水线</p>
<p><strong>playback attack</strong> 重放攻击</p>
<p><strong>point coordination function (PCF)</strong> 点协调功能</p>
<p><strong>point coordinator</strong> 点协调器</p>
<p><strong>point of presence (POP)</strong> 存在点</p>
<p><strong>point to point</strong> 点对点</p>
<p><strong>point to point protocol (PPP)</strong> 点对点协议</p>
<p><strong>poisoned reverse</strong> 毒性逆转</p>
<p><strong>polling protocol</strong> 轮询协议</p>
<p><strong>polyalphabetic encryption</strong> 多表替换密码</p>
<p><strong>post office protocol-version 3 (POP3)</strong> 第三版邮局</p>
<p><strong>precedence</strong> 优先级</p>
<p><strong>prefix</strong> 前缀</p>
<p><strong>pre-master secret (PMS)</strong> 前主密钥</p>
<p><strong>priority queueing</strong> 优先级排队</p>
<p><strong>propagation delay</strong> 传播时延</p>
<p><strong>protocol</strong> 协议</p>
<p><strong>protocol data unit (PDU)</strong> 协议数据单元</p>
<p><strong>provider</strong> 提供商</p>
<p><strong>physical medium</strong> 物理媒体</p>
<p><strong>quantization</strong> 量化</p>
<p><strong>public land mobile network (PLMD)</strong>
公共陆地移动网络</p>
<p><strong>public key</strong> 公钥</p>
<p><strong>public key certification</strong> 公钥认证</p>
<p><strong>public key infrastructure (PKI)</strong> 公钥基础设施</p>
<p><strong>public switched telephone network (PSTN)</strong>
公共交换电话网络</p>
<p><strong>pull protocol</strong> 拉协议</p>
<p><strong>pulse code modulation (PCM)</strong> 脉冲编码调制</p>
<p><strong>push protocol</strong> 推协议</p>
<p><strong>quality of service (QOS)</strong> 服务质量</p>
<p><strong>queuing delay</strong> 排队时延</p>
<p><strong>quick UDP internet connection (QUIC)</strong>
快速UDP互联网连接</p>
<p><strong>radio access network (RAN)</strong> 无线接入网络</p>
<p><strong>radio network controller (RNC)</strong> 无线网络控制器</p>
<p><strong>random access protocol</strong> 随机接入协议</p>
<p><strong>random early detection (RED)</strong> 随机早期检测</p>
<p><strong>rarest first</strong> 最稀缺优先</p>
<p><strong>real time measurement</strong> 实时测量</p>
<p><strong>real-time streaming protocol (RTSP)</strong>
实时流传输协议</p>
<p><strong>real-time transport protocol (RTP)</strong> 实时传输协议</p>
<p><strong>reliable data transfer (RDT)</strong> 可靠数据传输</p>
<p><strong>repeater</strong> 中继器</p>
<p><strong>representational state transfer (REST)</strong>
表征状态传递</p>
<p><strong>request for comment (RFC)</strong> 请求评论</p>
<p><strong>request line</strong> 请求行</p>
<p><strong>request to send (RTS)</strong> 允许发送</p>
<p><strong>resource record (RR)</strong> 资源记录</p>
<p><strong>resource reservation protocol (RSVP)</strong>
资源预留协议</p>
<p><strong>retransmission time out (RTO)</strong> 重传超时时间</p>
<p><strong>reverse address resolution protocol (RARP)</strong>
反向地址解析协议</p>
<p><strong>round robin (RR) queueing</strong> 循环排队</p>
<p><strong>round trip time (RTT)</strong> 往返时间</p>
<p><strong>route</strong> 路径</p>
<p><strong>route aggregation</strong> 路由聚合</p>
<p><strong>route summarization</strong> 路由摘要</p>
<p><strong>router</strong> 路由器</p>
<p><strong>routing</strong> 路由选择</p>
<p><strong>routing loop</strong> 路由选择环路</p>
<p><strong>routing table</strong> 路由选择表</p>
<p><strong>routing processor</strong> 路由选择处理器</p>
<p><strong>security hash algorithm (SHA)</strong> 安全散列算法</p>
<p><strong>secure shell (SSH)</strong> 安全外壳</p>
<p><strong>secure socket layer (SSL)</strong> 安全套接字层</p>
<p><strong>security association (SA)</strong> 安全联盟</p>
<p><strong>security association database (SAD)</strong>
安全联盟数据库</p>
<p><strong>security parameter index (SPI)</strong> 安全参数索引</p>
<p><strong>security policy database (SPD)</strong> 安全策略数据库</p>
<p><strong>segment</strong> 报文段</p>
<p><strong>selective acknowledgement (SACK)</strong> 选择性确认</p>
<p><strong>selective repeat (SR)</strong> 选择重传</p>
<p><strong>self clocking</strong> 自计时的</p>
<p><strong>sequence number</strong> 序号</p>
<p><strong>service abstraction layer (SAL)</strong> 服务抽象层</p>
<p><strong>service set identifier (SSID)</strong> 服务集标识符</p>
<p><strong>serving GRPS support node (SGSN)</strong>
服务GRPS支持节点</p>
<p><strong>serving gateway (S-GW)</strong> 服务网关</p>
<p><strong>session initialization protocol (SIP)</strong>
会话发起协议</p>
<p><strong>session key</strong> 会话密钥</p>
<p><strong>shared medium</strong> 共享媒体</p>
<p><strong>short interframe spacing (SIFS)</strong> 短帧间间隔</p>
<p><strong>shortest path</strong> 最短路径</p>
<p><strong>signal-to-noise ratio (SNR)</strong> 信噪比</p>
<p><strong>silent period</strong> 静默期</p>
<p><strong>simple mail transfer protocol (SMTP)</strong>
简单邮件传输协议</p>
<p><strong>simple network management protocol (SNMP)</strong>
简单网络管理协议</p>
<p><strong>sliding-window protocol</strong> 滑动窗口协议</p>
<p><strong>slow start</strong> 慢启动</p>
<p><strong>slow start threshold (ssthresh)</strong> 慢启动阈值</p>
<p><strong>socket</strong> 套接字</p>
<p><strong>slot</strong> 时隙</p>
<p><strong>software defined network (SDN)</strong> 软件定义网络</p>
<p><strong>source port number field</strong> 源端口号字段</p>
<p><strong>source quench</strong> 源抑制</p>
<p><strong>spanning tree protocol (STP)</strong> 生成树协议</p>
<p><strong>splitter</strong> 分配器</p>
<p><strong>stateless protocol</strong> 无状态协议</p>
<p><strong>static routing algorithm</strong> 静态路由选择算法</p>
<p><strong>stop and wait</strong> 停等</p>
<p><strong>store and forward transmission</strong> 存储转发传输</p>
<p><strong>stream cipher</strong> 流加密</p>
<p><strong>stream control transmission protocol (SCTP)</strong>
流控制传输协议</p>
<p><strong>structure of management information (SMI)</strong>
管理信息结构</p>
<p><strong>stub network</strong> 存根网络</p>
<p><strong>subnet mask</strong> 子网掩码</p>
<p><strong>switching fabric</strong> 交换结构</p>
<p><strong>switch poisoning</strong> 交换机毒化</p>
<p><strong>symmetrical encryption</strong> 对称加密</p>
<p><strong>synchronization source identifier (SSRC)</strong>
同步源标识符</p>
<p><strong>tag protocol identifier (TPID)</strong> 标签协议标识符</p>
<p><strong>taking-turns protocol</strong> 轮流协议</p>
<p><strong>TCP friendly rate control (TFRC)</strong> TCP友好速率控制</p>
<p><strong>TCP splitting</strong> TCP分岔</p>
<p><strong>temporal key (TK)</strong> 临时密钥</p>
<p><strong>ternary content addressable memory (TCAM)</strong>
三态内容寻址存储器</p>
<p><strong>three way handshake</strong> 三次握手</p>
<p><strong>time division multiple access (TDMA)</strong> 时分多址</p>
<p><strong>time division multiplexing (TDM)</strong> 时分复用</p>
<p><strong>time frame</strong> 时间帧</p>
<p><strong>time to live (TTL)</strong> 生存时间</p>
<p><strong>tit for tat</strong> 一报还一报</p>
<p><strong>token passing protocol</strong> 令牌传递协议</p>
<p><strong>top down approach</strong> 自顶向下方方法</p>
<p><strong>top level domain (TLD)</strong> 顶级域</p>
<p><strong>top of rack (TOR)</strong> 机架式</p>
<p><strong>torrent</strong> 洪流</p>
<p><strong>total nodal delay</strong> 节点总时延</p>
<p><strong>tagged</strong> 有标记的</p>
<p><strong>tracker</strong> 追踪器</p>
<p><strong>traffic engineering (TE)</strong> 流量工程</p>
<p><strong>traffic intensity</strong> 流量强度</p>
<p><strong>traffic volume</strong> 通信容量</p>
<p><strong>transmission control protocol (TCP)</strong> 传输控制协议</p>
<p><strong>transmission delay</strong> 传输时延</p>
<p><strong>transmission rate</strong> 传输速率</p>
<p><strong>transport layer security (TLS)</strong> 安全传输层</p>
<p><strong>trap message</strong> 陷阱报文</p>
<p><strong>triangle routing</strong> 三角路由选择</p>
<p><strong>truncation attack</strong> 截断攻击</p>
<p><strong>tunnel</strong> 隧道</p>
<p><strong>tunneling</strong> 建立隧道</p>
<p><strong>two dimensional parity</strong> 二维奇偶检验</p>
<p><strong>type of service (TOP)</strong> 服务类型</p>
<p><strong>unchoked</strong> 疏通</p>
<p><strong>unguided media</strong> 非导引型媒体</p>
<p><strong>unidirectional data transfer</strong> 单向/半双工数据传输</p>
<p><strong>universal mobile telecommunications service (UMTS)</strong>
通用移动通信系统</p>
<p><strong>universal terrestrial radio access network (UTRAN)</strong>
通用陆地无线接入网络</p>
<p><strong>unreliable service</strong> 不可靠服务</p>
<p><strong>unshielded twisted pair (UTP)</strong> 无屏蔽双绞线</p>
<p><strong>untagged</strong> 无标记的</p>
<p><strong>user agent</strong> 用户代理</p>
<p><strong>user datagram protocol (UDP)</strong> 用户数据报协议</p>
<p><strong>user equipment (UE)</strong> 用户设备</p>
<p><strong>utilization</strong> 利用率</p>
<p><strong>vehicular ad hoc network (VANET)</strong> 车载自组织网络</p>
<p><strong>VLAN trunking</strong> 虚拟局域网中继/干道</p>
<p><strong>virtual local area network (VLAN)</strong> 虚拟局域网</p>
<p><strong>virtual private network (VPN)</strong> 虚拟专用网络</p>
<p><strong>visited network</strong> 被访网络</p>
<p><strong>voice over IP (VOIP)</strong> IP语音</p>
<p><strong>weighted fair queueing (WFQ)</strong> 加权公平排队</p>
<p><strong>well-known discretionary</strong> 公认任意</p>
<p><strong>well-known mandatory</strong> 公认必遵</p>
<p><strong>well-known port number</strong> 周知端口号</p>
<p><strong>WiFi jungle</strong> WiFi丛林</p>
<p><strong>wired equivalent privacy (WEP)</strong> 有线等效保密</p>
<p><strong>wireless communication link</strong> 无线通信链路</p>
<p><strong>wireless local area network (WLAN)</strong> 无线局域网</p>
<p><strong>wireless personal area network (WPAN)</strong>
无线个人局域网</p>
<p><strong>wireless distribution system (WDS)</strong>
无线分布式系统</p>
<p><strong>visitor location register (VLR)</strong> 访问者位置寄存器</p>
<p><strong>work-conserving queuing</strong> 保持工作排队</p>
<p><strong>world interoperability for microwave access (WiMAX)</strong>
全球微波接入互操作性</p>
<p><strong>zero configuration protocol</strong> 零配置协议</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法 第7版》第1章 计算机网络和互联网</title>
    <url>/2022/05/15/computer-networking-a-top-down-approach-7e-chpt-1/</url>
    <content><![CDATA[<h3 id="互联网">1.1 互联网</h3>
<p>　　与互联网连接的设备称为<strong>主机</strong>(因为容纳/运行应用程序)或<strong>端系统</strong>(因为位于互联网的边缘)。</p>
<p>　　主机分为<strong>客户端</strong>和<strong>服务器</strong>。</p>
<p>　　端系统彼此交换<strong>报文</strong>。端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>连接到一起。</p>
<p>　　通信链路的<strong>传输速率</strong>的单位是<span
class="math inline">\(bit/s\)</span>。一台端系统向另一台端系统发送报文时，发送端将报文分段并为每段加上首部字节，由此形成的信息包称为<strong>分组</strong>。</p>
<p>　　交换机主要包括<strong>路由器</strong>和<strong>链路层交换机</strong>。链路层交换机通常用于接入网中，而路由器通常用于网络核心中。从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的<strong>路径</strong>。</p>
<p>　　端系统通过<strong>互联网服务提供商</strong>接入互联网。</p>
<p>　　端系统、分组交换机和其他互联网部件都要运行一系列<strong>协议</strong>，这些协议控制互联网中信息的接收和发送。<strong>IP</strong>协议定义了在路由器和端系统之间发送和接收的分组格式。互联网的主要协议统称为<strong>TCP/IP</strong>。</p>
<p>　　<strong>协议</strong>定义了两个或多个通信实体之间交换的报文的格式和顺序，以及发送/接收一条报文或其他事件所采取的动作。</p>
<p>　　<strong>互联网标准</strong>由<strong>互联网工程任务组</strong>研发，其标准文档称为<strong>请求评论</strong>。</p>
<p>　　应用程序涉及多个相互交换数据的端系统称为<strong>分布式应用程序</strong>。</p>
<p>　　与互联网相连的端系统提供了一个<strong>套接字接口</strong>，该接口规定了运行在端系统上的程序请求互联网基础设施向运行在另一个端系统上的特定目的地程序交付数据的方式。</p>
<p>　　ICANN负责分配IP地址，分配AS号，管理DNS根服务器，分配域名以及解决域名纷争。</p>
<span id="more"></span>
<h3 id="网络边缘">1.2 网络边缘</h3>
<p>　　<strong>接入网</strong>指将端系统物理连接到其边缘路由器的网络。<strong>边缘路由器</strong>是端系统到任何其他远程端系统的路径上的第一台路由器。</p>
<p>　　家庭接入：DSL、电缆、FTTH、拨号和卫星</p>
<p>　　企业/家庭接入：以太网和WiFi</p>
<p>　　广域无线接入：3G/4G/5G和LTE</p>
<p>　　<strong>物理媒体</strong>包括<strong>导引型媒体</strong>(电波沿着固态媒体传播)和<strong>非导引型媒体</strong>(电波在空气或外层空间传播)。</p>
<h3 id="网络核心">1.3 网络核心</h3>
<p>　　通过网络链路和交换机移动数据有两种基本方法：<strong>分组交换</strong>和<strong>电路交换</strong>。</p>
<p>　　在电路交换的网络中，端系统间通信会话期间，<span
style="background-color: yellow">预留</span>了端系统间沿路径通信所需要的资源(缓存和链路传输速率)，而在分组交换的网络中<span
style="background-color: yellow">不会预留</span>这些资源。</p>
<h4 id="分组交换">1.3.1 分组交换</h4>
<p>　　多数分组交换机在链路的输入的使用<strong>存储转发传输</strong>机制。存储转发传输是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p>
<img src="/2022/05/15/computer-networking-a-top-down-approach-7e-chpt-1/store-and-forward_packet_switching.svg" class="" title="store-and-forward_packet_switching">
<p>　　若有<span class="math inline">\(N\)</span>条速率均为<span
class="math inline">\(R\)</span>的链路组成的路径，其中有<span
class="math inline">\(N-1\)</span>台路由器且所有分组的长度都为<span
class="math inline">\(L\)</span>，则端到端时延为<span
class="math inline">\(d_{端到端}=N\frac{L}{R}\)</span>。</p>
<p>　　对于每条相连的链路，分组交换机有一个用来存储路由器准备发往该链路的分组的<strong>输出缓存/队列</strong>。</p>
<img src="/2022/05/15/computer-networking-a-top-down-approach-7e-chpt-1/packet_switching.svg" class="" title="packet_switching">
<p>　　分组需要承受输出缓存的<strong>排队时延</strong>。</p>
<p>　　由于缓存空间是有限的，一个到达的分组可能发现该缓存已被其他待传输的分组完全占满，此时刚到达的分组或已经排队的分组其中之一将被丢弃，称为<strong>分组丢失/丢包</strong>。</p>
<p>　　每个端系统都有IP地址，分组的首部中包含了目的地的IP地址。</p>
<p>　　每台路由器具有一个将目的IP地址(一部分)映射成输出链路的<strong>转发表</strong>。</p>
<h4 id="电路交换">1.3.2 电路交换</h4>
<p>　　链路中的电路是通过<strong>频分复用</strong>或<strong>时分复用</strong>来实现的。</p>
<p>　　对于频分复用，链路的频谱由跨越链路创建的所有连接共享。在连接期间链路为每条连接专用一个频段，该频段的宽度称为<strong>带宽</strong>。</p>
<p>　　对于时分复用，时间被划分为固定期间的帧，称为<strong>时间帧</strong>，并且每个时间帧又被划分为固定数量的<strong>时隙</strong>。当网络跨越一条链路创建一条连接时，网络会为这个连接分配一个时隙，通常时隙的长度能够传输单个帧。</p>
<img src="/2022/05/15/computer-networking-a-top-down-approach-7e-chpt-1/fdm_and_tdm.svg" class="" title="fdm_and_tdm">
<h4 id="网络的网络">1.3.3 网络的网络</h4>
<p>　　因为接入ISP向全球传输ISP付费，故接入ISP可视为<strong>客户</strong>，而全球传输ISP可视为<strong>提供商</strong>。</p>
<p>　　在任何给定的区域，可能有一个<strong>区域ISP</strong>，每个区域ISP则与<strong>第一层ISP连接</strong>。</p>
<p>　　任何ISP(除了第一层ISP)可以选择<strong>多宿</strong>。</p>
<p>　　位于相同等级结构层次的邻近一对ISP能够<strong>对等</strong>。</p>
<p>　　<strong>互联网交换点</strong>是一个汇合点，多个ISP能够在这里一起对等。</p>
<img src="/2022/05/15/computer-networking-a-top-down-approach-7e-chpt-1/interconnection_of_isps.svg" class="" title="interconnection_of_isps">
<h3 id="分组交换网">1.4 分组交换网</h3>
<p>　　当分组从一个节点/主机/路由器沿着路径到后继节点/主机/路由器，该节点在沿途的每个节点承受了几种不同类型的时延，其中最重要的是<strong>节点处理时延</strong>、<strong>排队时延</strong>、<strong>传输时延</strong>和<strong>传播时延</strong>，这些时延的总和是<strong>节点总时延</strong>。若用<span
class="math inline">\(d_{proc}\)</span>、<span
class="math inline">\(d_{queue}\)</span>、<span
class="math inline">\(d_{trans}\)</span>、<span
class="math inline">\(d_{prop}\)</span>、<span
class="math inline">\(d_{nodal}\)</span>分别表示处理时延、排队时延、传输时延、传播时延和节点总时延，则<span
class="math inline">\(d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}\)</span>。</p>
<img src="/2022/05/15/computer-networking-a-top-down-approach-7e-chpt-1/total_nodal_delay_of_router.svg" class="" title="total_nodal_delay_of_router">
<p>　　检查分组首部和决定将该分组导向何处所需要的时间是<strong>处理时延</strong>的一部分。</p>
<p>　　在队列中，当分组在链路上等待传输时，需要经受<strong>排队时延</strong>。</p>
<p>　　<strong>传输时延</strong>是路由器推出分组所需的时间，可表示为<span
class="math inline">\(\frac{L}{R}\)</span>，<span
class="math inline">\(L\)</span>表示分组的长度，<span
class="math inline">\(R(b/s)\)</span>表示链路的传输速率，即从队列中推出<span
class="math inline">\(1b\)</span>的速率。</p>
<p>　　<span
class="math inline">\(\frac{L\alpha}{R}\)</span>是<strong>流量强度</strong>，其中<span
class="math inline">\(\alpha(pkt/s)\)</span>表示分组到达队列的平均速率。流量强度主要用于衡量排队时延，设计系统时流量强度不能大于1。</p>
<p>　　<span
class="math inline">\(1b\)</span>从一个路由器到另一个路由器所需的时间是<strong>传播时延</strong>。</p>
<p>　　源主机和目的主机之间有<span
class="math inline">\(N-1\)</span>台路由器，网络通畅(排队时延可以忽略)，节点时延累加起来，得到端到端时延：
<span class="math display">\[
\begin{align}
d_{end-end}&amp;=N(d_{proc}+d_{trans}+d_{prop})\\[3px]
&amp;=N(d_{proc}+\frac{L}{R}+d_{prop})
\end{align}
\]</span></p>
<p>　　<strong>吞吐量</strong>是进程交互比特的速率。</p>
<h3 id="协议层次及其服务模型">1.5 协议层次及其服务模型</h3>
<p>　　某层的<strong>服务模型</strong>是该层向上一层提供的服务。</p>
<p>　　各层的所有协议被称为<strong>协议栈</strong>。</p>
<img src="/2022/05/15/computer-networking-a-top-down-approach-7e-chpt-1/internet_protocol_stack_and_osi_reference_model.svg" class="" title="internet_protocol_stack_and_osi_reference_model">
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 45%" />
<col style="width: 40%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>功能</th>
<th>主要协议</th>
<th>分组名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>存留网络应用程序及其应用层协议</td>
<td>HTTP、SMTP、FTP、DNS、DHCP、SNMP和NFS等</td>
<td>报文</td>
</tr>
<tr>
<td>传输层</td>
<td>应用程序之间传输应用层报文</td>
<td>TCP、UDP、DCCP、DCTCP、TRFC、SCTP和QUIC等</td>
<td>报文段</td>
</tr>
<tr>
<td>网络层</td>
<td>也称为IP层，将数据报从一台主机移动到另一台主机</td>
<td>IP等</td>
<td>数据报</td>
</tr>
<tr>
<td>链路层</td>
<td>沿着路径将数据报传递给下一个节点</td>
<td>以太网、WiFi和DOCSIS等</td>
<td>帧</td>
</tr>
<tr>
<td>物理层</td>
<td>将帧中的一个个比特从一个节点移动到下一个节点</td>
<td></td>
<td>比特</td>
</tr>
</tbody>
</table>
<p>　　<strong>网络体系结构</strong>是通信系统的整体设计，其广泛采用OSI模型。</p>
<p>　　相比互联网协议栈，OSI模型多出表示层和会话层。</p>
<p>　　表示层的作用是使通信的应用程序能够解释交换数据的含义。这些服务包括数据压缩、数据加密和数据描述。</p>
<p>　　会话层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。</p>
<img src="/2022/05/15/computer-networking-a-top-down-approach-7e-chpt-1/encapsulation.svg" class="" title="encapsulation">
<p>　　在每一层，分组包括首部字段和<strong>有效载荷字段</strong>(通常是上一层的分组)。</p>
<h3 id="网络安全">1.6 网络安全</h3>
<p>　　<strong>病毒</strong>是一种需要某种形式的用户交互来感染用户设备的恶意软件。</p>
<p>　　<strong>蠕虫</strong>是一种无须任何明显用户交互就能进入设备的恶意软件。</p>
<p>　　<strong>Dos攻击</strong>包括<span
style="background-color: yellow">弱点攻击</span>(发送特殊的报文来控制或宕机)、<span
style="background-color: yellow">带宽洪泛</span>(发送大量分组)和<span
style="background-color: yellow">连接洪泛</span>(创建大量TCP连接)。</p>
<p>　　用来观察执行协议实体之间交换的报文的基本工具被称为<strong>分组嗅探器</strong>。</p>
<p>　　<strong>IP哄骗</strong>指将具有虚假源地址的分组注入互联网。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法 第7版》第2章 应用层</title>
    <url>/2022/05/22/computer-networking-a-top-down-approach-7e-chpt-2/</url>
    <content><![CDATA[<p>　　<strong>套接字</strong>是应用程序进程和传输层协议之间的接口。一个进程可以有多个套接字。</p>
<p>　　应用程序开发者可以通过套接字控制应用层的一切，但是对传输层的控制仅限于选择协议和设定几个传输层参数。应用程序体系结构通常使用客户端/服务器体系结构和对等体系结构。</p>
<p>　　当进程向另一台主机的进程发送分组时需要定义目的主机的地址和目的主机中接收进程的标识符。</p>
<p>　　传输层为应用层提供的服务可分为四类：<span
style="background-color: yellow">可靠数据传输</span>、<span
style="background-color: yellow">吞吐量</span>、<span
style="background-color: yellow">定时</span>和<span
style="background-color: yellow">安全性</span>。</p>
<p>　　<strong>带宽敏感的应用</strong>具有吞吐量要求，而<strong>弹性应用</strong>能够根据可用的带宽尽可能多或少地使用。</p>
<p>　　<strong>应用层协议</strong>定义了运行在不同端系统上的应用程序进程如何相互传递报文：</p>
<p>　　● 交互的报文类型。</p>
<p>　　● 各种报文类型的语法。</p>
<p>　　● 字段的语义。</p>
<p>　　● 确定一个进程何时以及如何发送报文，对报文的响应规则。</p>
<p>　　Web的应用层协议是<strong>HTTP</strong>。</p>
<p>　　一张未压缩/数字编码的图像有像素阵列组成，每个像素由一些比特编码来表示亮度或颜色。</p>
<p>　　视频是一系列图像以每秒24或30张图像来展现。视频能被压缩，故可以比特率来权衡视频质量。</p>
<p>　　在<strong>HTTP动态自适应流</strong>中，视频编码为比特率不同的多个版本，每个版本都有一个不同的URL，每个版本的URL和比特率都存在HTTP服务器中的<strong>告示文件</strong>中。DASH运行客户端自由地切换版本。</p>
<span id="more"></span>
<h3 id="http">2.1 HTTP</h3>
<p>　　HTTP服务器不保存关于客户端的任何信息，故HTTP是一个<strong>无状态协议</strong>。为了识别客户端，HTTP使用了cookie。</p>
<p>　　<strong>持续连接</strong>指一个TCP可以传输多个HTTP请求和响应。<strong>非持续连接</strong>指一个TCP只能传输一个HTTP请求/响应对。HTTP默认使用持续连接，但也能配置为非持续连接。</p>
<p>　　<strong>Web缓存器</strong>，也称为<strong>代理服务器</strong>，能够代表Web服务器来满足HTTP请求的网络实体。</p>
<p>　　HTTP的<strong>条件GET</strong>机制可以解决Web缓存器缓存的数据陈旧的问题。</p>
<p>　　HTTP主要是一个<strong>拉协议</strong>，TCP连接是由接收端发起。</p>
<h4 id="http请求报文">2.1.1 HTTP请求报文</h4>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/somedir/page.html</span> <span class="meta">HTTP/2</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.test.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate, br</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br></pre></td></tr></table></figure>
<p>　　HTTP请求报文的第一行是<strong>请求行</strong>。请求行包括方法字段、URL字段和HTTP版本字段。</p>
<p>　　HTTP请求报文第一行之后的行是<strong>首部行</strong>。</p>
<img src="/2022/05/22/computer-networking-a-top-down-approach-7e-chpt-2/http_request_message_format.svg" class="" title="http_request_message_format">
<h4 id="http响应报文">2.1.2 HTTP响应报文</h4>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/2</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">content-type</span><span class="punctuation">: </span>text/javascript; charset=utf-8</span><br><span class="line"><span class="attribute">content-encoding</span><span class="punctuation">: </span>br</span><br><span class="line"><span class="attribute">last-modified</span><span class="punctuation">: </span>Wed, 03 Nov 2021 01:12:45 GMT</span><br><span class="line"><span class="attribute">server</span><span class="punctuation">: </span>Windows-Azure-Blob/1.0 Microsoft-HTTPAPI/2.0</span><br></pre></td></tr></table></figure>
<p>　　HTTP响应报文的第一行是<strong>状态行</strong>。状态行包括协议版本字段、状态码字段和相应状态字段。</p>
<p>　　HTTP响应报文第一行之后的行是<strong>首部行</strong>。</p>
<img src="/2022/05/22/computer-networking-a-top-down-approach-7e-chpt-2/http_response_message_format.svg" class="" title="http_response_message_format">
<h4 id="条件get">2.1.3 条件GET</h4>
<p>　　如果请求报文是GET方法且请求报文的首部行包括<code>If-modified-since</code>，该请求报文就是<strong>条件GET</strong>请求报文。</p>
<img src="/2022/05/22/computer-networking-a-top-down-approach-7e-chpt-2/conditional_get.svg" class="" title="conditional_get">
<p>　　第三步中<code>If-modified-since</code>的值等于第二步中<code>last-modified</code>的值，这表示Web服务器仅当指定日期之后该对象修改后才发送该对象，若该对象在指定日期后没被修改，则第四步中Web服务器向Web缓存器发送的响应报文中状态码为304且没有对象，表示Web缓存器可以转发缓存的该对象的副本。</p>
<h3 id="电子邮件">2.2 电子邮件</h3>
<p>　　互联网电子邮件系统由<strong>用户代理</strong>、<strong>邮件服务器</strong>和<strong>简单邮件传输协议</strong>组成。</p>
<img src="/2022/05/22/computer-networking-a-top-down-approach-7e-chpt-2/email_protocols_and_their_communicating_entities.svg" class="" title="email_protocols_and_their_communicating_entities">
<p>　　1) 发件方调用用户代理撰写内容并发送邮件。</p>
<p>　　2)
发件方的用户代理把报文发给发件方的邮件服务器，在这里报文被放在报文队列里。</p>
<p>　　3)
发件方邮件服务器上的SMTP客户端创建一个到收件方邮件服务器上的SMTP服务器的TCP连接。</p>
<p>　　4) 经过初始SMTP握手后，SMTP客户端通过TCP连接发送报文。</p>
<p>　　5)
收件方邮件服务器的SMTP服务器接收到报文并将报文投入到收件方的邮箱。</p>
<p>　　6) 收件方调用用户代理查看邮件。</p>
<h4 id="smtp">2.2.1 SMTP</h4>
<p>　　SMTP是互联网电子邮件中主要的应用层协议。它限制了邮件的报文(不只是首部)只能采用7位ASCII表示，若报文包含非7位ASCII字符或二进制数据，需要进行7位ASCII编码。</p>
<p>　　SMTP是<strong>推协议</strong>，TCP连接是发送端发起的。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">S: 220 client</span><br><span class="line">C: EHLO server</span><br><span class="line">S: 250 from | 250 PIPELINING | 250 SIZE 12345</span><br><span class="line">C: AUTH XOAUTH2 oauth</span><br><span class="line">S: 235 2.7.0 Accepted</span><br><span class="line">C: MAIL FROM: &lt;client@email.com&gt; </span><br><span class="line">S: 250 OK</span><br><span class="line">C: RCPT TO: &lt;server@email.com&gt;</span><br><span class="line">S: 250 OK</span><br><span class="line">C: DATA</span><br><span class="line">S: 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</span><br><span class="line">C: DATA fragment,content</span><br><span class="line">S: 250 OK: queued as.</span><br><span class="line">C: QUIT</span><br><span class="line">S: 221 Bye</span><br></pre></td></tr></table></figure>
<p>　　SMTP协议中客户端发送了5条命令：<code>HELO</code>/<code>EHLO</code>(HELLO缩写，ESMTP版本)、<code>MAIL FROM</code>、<code>RCPT TO</code>、<code>DATA</code>以及<code>QUIT</code>。</p>
<p>　　ESMTP相比SMTP，在发送邮件时<span
style="background-color: yellow">需要验证用户账户</span>。</p>
<h4 id="电子邮件-1">2.2.2 电子邮件</h4>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">From: from@email.com</span><br><span class="line">To: to@email.com</span><br><span class="line">Subject: subject</span><br></pre></td></tr></table></figure>
<p>　　邮件报文的首部行包括环境信息，必须包含一个<code>From</code>和一个<code>To</code>，可能包含<code>Subject</code>以及其他可选首部行。</p>
<p>　　在用户代理建立一个到邮件服务器110端口上的TCP连接后，POP3按照3个阶段进行工作：授权、事务处理以及更新。</p>
<p>　　●
授权阶段需要用户代理以明文形式发送用户名和密码来认证，主要命令有<code>user &lt;username&gt;</code>和<code>pass &lt;password&gt;</code>。</p>
<p>　　●
事务处理阶段中用户代理可以取回报文，也可以添加/取消报文删除标记，主要命令有<code>list</code>、<code>retr</code>和<code>dele</code>。</p>
<p>　　●
更新阶段在用户代理发出<code>quit</code>命令并结束会话后，邮件服务器会删除那些被标记的报文。</p>
<p>　　POP3会话期间，邮件服务器会保留一些状态信息，但是在会话中不会携带这些信息。</p>
<p>　　IMAP使用了TCP连接的143端口。相比POP3，IMAP把报文和文件夹联系起来并且提供了创建/修改/删除文件夹和获取报文某些部分的命令。</p>
<h3 id="dns">2.3 DNS</h3>
<p>　　主机可以用<strong>主机名</strong>和<strong>IP地址</strong>来进行识别。</p>
<p>　　一台名为a.com的主机，可能还有别名b.com和c.com，此时a.com是<strong>规范主机名</strong>。</p>
<p>　　<strong>域名系统</strong>是一个由分层的<strong>DNS服务器</strong>实现的分布式数据库，一个让主机查询分布式数据库的应用层协议。主要用于将主机名解析为IP地址，也提供<strong>主机别名</strong>、<strong>邮件服务器别名</strong>和<strong>负载分配</strong>服务。</p>
<h4 id="dns工作原理">2.3.1 DNS工作原理</h4>
<p>　　DNS服务器主要分为<strong>根DNS服务器</strong>、<strong>顶级域DNS服务器</strong>、<strong>权威DNS服务器</strong>和<strong>本地DNS服务器</strong>。</p>
<p>　　● 根DNS服务器提供顶级域DNS服务器的IP地址。</p>
<p>　　●
每个顶级域<sup>【如com、org、net、edu和gov等】</sup>和国家的顶级域<sup>【如uk、fr、ca和cn等】</sup>都有顶级域DNS服务器(集群)。顶级域DNS服务器提供权威DNS服务器的IP地址。</p>
<p>　　●
互联网上具有公共可访问主机的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名称映射为IP地址。</p>
<p>　　● 每个ISP都有一个本地DNS服务器/默认名称服务器。</p>
<img src="/2022/05/22/computer-networking-a-top-down-approach-7e-chpt-2/interaction_of_the_various_dns_servsers.svg" class="" title="interaction_of_the_various_dns_servsers">
<p>　　一般情况下，从请求主机到本地DNS服务器的查询是<strong>递归查询</strong>，其余的查询是<strong>迭代查询</strong>。</p>
<p>　　为了降低时延并减少报文数量，<strong>DNS缓存</strong>广泛使用，因此在大部分DNS查询中根DNS服务器都被绕过。</p>
<h4 id="dns报文">2.3.2 DNS报文</h4>
<p>　　<strong>资源记录</strong>提供了主机名到IP地址的映射，格式为<code>(Name, Value, Type, TTL)</code>。</p>
<p>　　●
<code>Type = A</code>时，<code>Name</code>是主机名，<code>Value</code>是主机名对应的IP地址。</p>
<p>　　●
<code>Type = NS</code>时，<code>Name</code>是域名，<code>Value</code>是能够获取该域名中主机IP地址的权威DNS服务器的主机名。</p>
<p>　　●
<code>Type = CNAME</code>时，<code>Value</code>是别名为<code>Name</code>的主机的规范主机名。</p>
<p>　　●
<code>Type = MX</code>时，<code>Value</code>是别名为<code>Name</code>的邮件服务器的规范主机名。</p>
<p>　　对于某个主机名，若DNS服务器是它的权威DNS服务器，则该DNS服务器会有一条包含该主机名的A型记录。若DNS服务器不是它的权威服务器，则该DNS服务器会有一条该主机名所属域名的NS型记录和一条包含该NS型记录中<code>Value</code>的A型记录，还可能会有一条包含该主机名的A型记录。</p>
<img src="/2022/05/22/computer-networking-a-top-down-approach-7e-chpt-2/dns_message_format.svg" class="" title="dns_message_format">
<p>　　DNS报文分为查询和应答报文，报文格式相同。</p>
<p>　　●
在首部区域，第一个字段占16位，用于标识该查询，该字段会被复制到应答报文中来匹配请求。第二个字段有若干1位的标志位。0/1标识查询/应答报文。若请求的是权威DNS服务器则应答报文会设置权威标志位。若客户端在DNS服务器没有资源记录时希望它执行递归查询则会设置希望递归标志位。若DNS服务器支持递归查询则会在应答报文设置递归可用标志位。剩下四个字段表示后四个区域数据的数量。</p>
<p>　　●
问题区域包名称字段和类型字段，名称字段是待查询的主机名称，类型字段对应资源记录中的类型字段。</p>
<p>　　● 应答区域可以包含多条资源记录。</p>
<p>　　● 权威区域包含其他权威DNS服务器的资源记录。</p>
<p>　　● 附加信息区域包含其他有用的资源记录。</p>
<h3 id="p2p文件分发">2.4 P2P文件分发</h3>
<p>　　<strong>分发时间</strong>是所有<span
class="math inline">\(n\)</span>个对等方得到<span
class="math inline">\(f(b)\)</span>文件的副本所需时间。</p>
<img src="/2022/05/22/computer-networking-a-top-down-approach-7e-chpt-2/file_distribution.svg" class="" title="file_distribution">
<p>　　<span
class="math inline">\(D_{cs}\)</span>表示C/S体系结构的分发时间，其中服务器需要上传<span
class="math inline">\(n\)</span>个大小为<span
class="math inline">\(f(b)\)</span>文件的副本，<span
class="math inline">\(D_c\)</span>表示客户端下载所需时间，<span
class="math inline">\(d_{min}\)</span>表示客户端最低下载速度，<span
class="math inline">\(D_S\)</span>表示服务器上传所需时间，<span
class="math inline">\(u_s\)</span>表示服务器的上传速度，则 <span
class="math display">\[
\begin{align}
D_{cs}&amp;\geqslant max\{D_c,D_s\}\\[3px]
&amp;\geqslant max\{\frac{f}{d_{min}},\frac{nf}{u_s}\}
\end{align}
\]</span> 　　<span
class="math inline">\(D_{P2P}\)</span>表示P2P体系结构的分发时间，分发开始时只有服务器有文件，分发一次后可由对等方来分发，则
<span class="math display">\[
\begin{align}
D_{P2P}&amp;\geqslant max\{D_c,D_s,\frac{nf}{u_{total}}\}\\[3px]
&amp;\geqslant
max\{\frac{f}{d_{min}},\frac{f}{u_s},\frac{nf}{u_s+\sum_{i=1}^{n}u_i}\}
\end{align}
\]</span></p>
<p>　　参与文件分发的所有对等方集合称为<strong>洪流</strong>。洪流中的对等方彼此下载固定大小的文件块，通常是<span
class="math inline">\(256KB\)</span>。每个洪流具有一个基础设施节点，称为<strong>追踪器</strong>。当有对等方加入洪流时需要向追踪器注册并周期性地通知是否在洪流中。</p>
<img src="/2022/05/22/computer-networking-a-top-down-approach-7e-chpt-2/file_distribution_with_bittorrent.svg" class="" title="file_distribution_with_bittorrent">
<p>　　与对等方建立TCP连接的其他对等方称为该对等方的<strong>邻居/邻近对等方</strong>。</p>
<p>　　<strong>最稀缺优先</strong>即优先请求本身没有且邻居中副本最少的块，这样可以大致地均衡每个块在洪流中的副本量。</p>
<p>　　对等方优先响应那些当前能够以<span
style="background-color: yellow">最高速率</span>提供副本的邻居。对等方会每十秒进行速率测量并确定速率前四的邻居，这四个邻居会被<strong>疏通</strong>。此外，每三十秒会随机再选择一个邻居进行交换，如果彼此都能满足，则继续交换。除了这五个邻居，其他邻居将被阻塞，即无法从该对等方获取块。这种机制被称为<strong>一报还一报</strong>。</p>
<h3 id="cdn">2.5 CDN</h3>
<p>　　<strong>内容分发网络</strong>分布在多个地理位置的服务器上，并且将用户请求重定向到一个时延更低的CDN。</p>
<p>　　CDN分为<strong>专用CDN</strong>和<strong>第三方CDN</strong>，专用CDN由内容提供商自身拥有，第三方CDN分发多个内容提供商的内容。</p>
<p>　　CDN通常采用<strong>深入</strong>和<strong>客邀</strong>这两种安置原则。</p>
<p>　　●
深入原则由Akamai首创，该原则通过在遍及全球的接入ISP中部署服务器集群来深入到ISP的接入网中。其目标是靠近端系统，通过减少端系统和CDN集群之间的链路和路由器来减少时延和提供吞吐量，但也带来了较高的维护管理成本。</p>
<p>　　●
客邀原则被Limelight和很多其他CDN公司采用，该原则通过在少量的关键位置(通常是互联网交换点)建立大量集群来客邀ISP。相比深入，客邀的维护管理成本更低，但时延较高且吞吐量较低。</p>
<img src="/2022/05/22/computer-networking-a-top-down-approach-7e-chpt-2/dns_redirects_a_request_to_a_cdn_server.svg" class="" title="dns_redirects_a_request_to_a_cdn_server">
<p>　　大多数CDN利用DNS来截获和重定向请求。</p>
<p>　　1) 客户端访问某Web网页。</p>
<p>　　2) 客户端访问该Web下的某个资源时，发送了对应的DNS请求。</p>
<p>　　3)
本地DNS服务器将DNS请求中继到该Web的权威DNS服务器，权威DNS服务器返回了CDN域下的主机名。</p>
<p>　　4)
本地DNS服务器通过CDN域下的主机名向CDN权威DNS服务器发送DNS请求，CDN权威DNS服务器返回了CDN服务器的IP地址。</p>
<p>　　5) 本地DNS服务器将IP地址返回给客户端。</p>
<p>　　6) 客户端通过IP地址与CDN服务器建立TCP连接并发送HTTP请求。</p>
<p>　　CDN部署的核心都是<strong>集群选择策略</strong>，即动态地将请求重定向到CDN中的某个服务器集群/数据中心。</p>
<p>　　较简单的选择策略是将请求重定向到(距离DNS服务器)<span
style="background-color: yellow">地理上最近</span>的集群。另一种选择策略是对DNS服务器和集群之间进行周期性的时延以及丢包<span
style="background-color: yellow">实时测量</span>来选择。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法 第7版》第3章 传输层</title>
    <url>/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/</url>
    <content><![CDATA[<p>　　网络层提供了主机之间的逻辑通信，传输层提供不同主机的进程之间的逻辑通信。</p>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/transport_layer_multiplexing_and_demultiplexing.svg" class="" title="transport_layer_multiplexing_and_demultiplexing">
<p>　　传输层的<strong>多路复用</strong>与<strong>多路分解</strong>指将主机间交付延伸到进程间交付。</p>
<p>　　●
多路复用指在不同套接字中收集数据块，为每个数据块附加首部信息并封装从而生成报文段，再将报文段传递到网络层。</p>
<p>　　● 多路分解指将传输层报文段解封并提取数据交付到正确的套接字。</p>
<p>　　多路复用需要<strong>源端口号字段</strong>(套接字的唯一标识符)和<strong>目的端口号字段</strong>(报文段中标识目标套接字的字段)。</p>
<p>　　端口号的长度是16位。0~1023之间的端口称为<strong>周知端口号</strong>。</p>
<p>　　<strong>序号</strong>用于为从发送端发往接收端的分组按序编号。</p>
<p>　　<strong>校验和</strong>用于分组的差错检测。</p>
<span id="more"></span>
<h3 id="udp">3.1 UDP</h3>
<p>　　UDP在发送报文段前传输层实体间没有握手，故UDP是<span
style="background-color: yellow">无连接</span>的。</p>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/udp_segment_format.svg" class="" title="udp_segment_format">
<p>　　UDP首部包括16位<strong>源端口</strong>、16位<strong>目的端口</strong>、16位<strong>长度</strong>和16位<strong>校验和</strong>。</p>
<p>　　● 长度字段即报文段中的字节数(首部+有效载荷)。</p>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/checksum_of_udp.svg" class="" title="checksum_of_udp">
<p>　　发送端在计算校验和时需要先加上伪首部并将校验和字段置0，将伪首部、首部和有效载荷转换成16位二进制(不足部分填充0)并求和，求和时需要回卷(如果进位到第17位则将结果加1)，将和取反得到校验和，最后发送端设置校验和并去掉伪首部。接收端计算校验和方式类似于发送端(不需要将校验和置0)，最后结果全为1则说明数据无误，否则警告。伪首部包括源IP地址、目的IP地址、填充0的保留字段、传输层协议号以及报文长度。</p>
<p>　　由于无法确保链路的可靠和内存中的差错检测，UDP在端到端基础上的传输层进行差错检测，这种设计被称为<strong>端到端原则</strong>，即同一功能的实现成本在底层相比上层可能更高。</p>
<h3 id="可靠数据传输">3.2 可靠数据传输</h3>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/reliable_data_transfer.svg" class="" title="reliable_data_transfer">
<h4 id="rdt1.0">3.2.1 rdt1.0</h4>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/fsm_of_rdt1.0.svg" class="" title="fsm_of_rdt1.0">
<p>　　rdt1.0协议指经完全可靠信道的可靠数据传输，故接收端不需要提供任何反馈信息给发送端。此外，该协议的数据单元与分组无异，所有分组都是发送端到接收端。</p>
<p>　　FSM的初始状态用虚线表示。发送端和接收端的FSM都只有一个状态，故变迁必定是从一个状态返回到本身。</p>
<p>　　发送端只通过<code>rdt_send(data)</code>从上层接收数据，经由<code>make_pkt(data)</code>产生一个包含该数据的分组，并将分组发送到信道中。接收端通过<code>rdt_rcv(packet)</code>从底层信道接收一个分组，经由<code>extract(packet,data)</code>取出数据，并通过<code>deliver_data(data)</code>将数据传输给上层。</p>
<h4 id="rdt2.0">3.2.2 rdt2.0</h4>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/fsm_of_rdt2.0.svg" class="" title="fsm_of_rdt2.0.0">
<p>　　rdt2.0相比rdt1.0，加入了差错检测和<strong>肯定/否定确认</strong>。肯定/否定确认用于让发送端知道分组被正确接收或接收有误需要重传，因此rdt2.0称为<strong>自动重传请求</strong>协议。自动重传请求协议还需要<span
style="background-color: yellow">差错检测</span>、<span
style="background-color: yellow">接收端反馈</span>(用1位来表示，0是NAK，1是ACK)和<span
style="background-color: yellow">重传</span>来处理比特差错的情况。</p>
<p>　　当发送端等待ACK/NCK时不能从上层获取数据或发送分组，故rdt2.0称为<strong>停等</strong>协议。</p>
<p>　　发送端有两个状态。在左边的状态中，发送端正在等待上层调用。当出现<code>rdt_send(data)</code>时，发送端将通过<code>make_pkt(data,checksum)</code>产生一个包含数据和校验和的分组，经由<code>udt_send(sndpkt)</code>发送该分组。在右边的状态中，发送端正在等待接收端回传的ACK/NAK。若收到ACK分组，即<code>rdt_rcv(rcvpkt) &amp;&amp; isACK(rcvpkt)</code>，发送端会回到等待上层调用的状态。若收到NAK分组，即<code>rdt_rcv(rcvpkt) &amp;&amp; isNAK(rcvpkt)</code>，发送端会重传分组并等待接收回传的ACK/NAK。</p>
<p>　　接收端只有一个状态。当分组到达时，接收端回传ACK/NAK，即<code>rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt)</code>或<code>rdt_rcv(rcvpkt) &amp;&amp; corrupt(rcvpkt)</code>。</p>
<p>　　但是rdt2.0忽视了ACK/NAK分组受损的情况，解决这一问题的简单方法就是添加一个新字段来表示发送数据分组的序号。</p>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/fsm_of_rdt2.1.svg" class="" title="fsm_of_rdt2.1">
<p>　　rdt2.1是rdt2.0的修订版，rdt2.1的发送端和接收端FSM的状态数都是以前的两倍，因为需要反映出目前分组的序号。rdt2.1使用了接收端到发送端的ACK/NAK。当收到乱序的分组时，接收端回传ACK。当收到受损的分组时，接收端回传NAK。</p>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/fsm_of_rdt2.2.svg" class="" title="fsm_of_rdt2.2">
<p>　　rdt2.2相比rdt2.1，rdt2.2无NAK，而是对上一次正确接收的分组回传ACK。发送端收<strong>冗余ACK</strong>后，就知道了接收端没有正确接收到冗余ACK对应的分组后的分组。因此，ACK报文需要一个序号字段。</p>
<h4 id="rdt3.0">3.2.3 rdt3.0</h4>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/fsm_of_rdt3.0_sender.svg" class="" title="fsm_of_rdt3.0_sender">
<p>　　rdt3.0是用于具有比特差错的丢包信道的协议。通过在发送端中加入<strong>倒数计时器</strong>来解决超时/丢包问题，接收端与rdt2.2相同。</p>
<p>　　因为分组序号在0和1之间交替，rdt3.0也被称为<strong>比特交替协议</strong>。</p>
<h4 id="流水线可靠数据传输协议">3.2.4 流水线可靠数据传输协议</h4>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/stop-and-wait_and_pipelined_sending.svg" class="" title="stop-and-wait_and_pipelined_sending">
<p>　　停等协议存在一定的性能问题，简单的解决方式就是不使用停等，允许发送方发送多个分组而无须等待。因为许多从发送端到接收端的分组可以被看出是填充到一条流水线，故这种技术被称为<strong>流水线</strong>。</p>
<p>　　流水线需要可靠数据传输协议增加序号的范围和发送/接收端缓存分组，而这些取决于差错恢复。流水线的差错恢复包括<strong>回退N步</strong>和<strong>选择重传</strong>。</p>
<h4 id="回退n步">3.2.5 回退N步</h4>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/sender_view_of_sequence_numbers_in_gbn.svg" class="" title="sender_view_of_sequence_numbers_in_gbn">
<p>　　随着协议的运行，该窗口的序号空间向前滑动，<span
class="math inline">\(N\)</span>称为窗口长度，故GBN也称为滑动窗口协议。</p>
<p>　　<span
class="math inline">\(base\)</span>表示最早待确认的分组的序号，<span
class="math inline">\(nextseqnum\)</span>表示最早的待发送的分组的序号。<span
class="math inline">\([0,base-1]\)</span>表示已被确认的分组，<span
class="math inline">\([base,nextseqnum-1]\)</span>表示待确认的分组，<span
class="math inline">\([nextseqnum,base+N-1]\)</span>表示待发送的分组，<span
class="math inline">\([base+N,+\infty)\)</span>表示不可用的分组，直到当前流水线中待确认的分组确认。</p>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/extended_fsm_of_gbn.svg" class="" title="s">
<p>　　发送端必须响应<span
style="background-color: yellow">上层的调用</span>、<span
style="background-color: yellow">接收ACK</span>和<span
style="background-color: yellow">处理超时</span>。</p>
<p>　　当上层调用<code>rdt_send</code>时，发送端先检测发送窗口是否已满。若窗口未满则产生一个分组发送并更新对应的变量，否则反馈上层。不存在待确认分组的情况下首次发送分组时会设置一个计时器。当收到ACK但仍存在待确认的分组时，计时器将重置。当不存在待确认的分组时停止计时器。</p>
<p>　　接收端用<span
class="math inline">\(expectedseqnum\)</span>来表示按序待接收的分组的序号。</p>
<p>　　接收端对序号为<span
class="math inline">\(n\)</span>的分组使用<strong>累积确认</strong>的方式，表明已正确收到序号小于等于<span
class="math inline">\(n\)</span>的所有分组。</p>
<p>　　当接收端收到序号为<span
class="math inline">\(n\)</span>的分组且上次交付给上层的分组的序号是<span
class="math inline">\(n-1\)</span>时会对分组<span
class="math inline">\(n\)</span>回传ACK，否则丢弃该分组并对最近交付给上层的分组回传ACK。</p>
<p>　　接收端会丢失所有乱序分组，因为这些分组还会重传。</p>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/gbn_operation.svg" class="" title="gbn_operation">
<h4 id="选择重传">3.2.6 选择重传</h4>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/sender_and_receiver_views_of_sequence_numbers_in_sr.svg" class="" title="sender_and_receiver_views_of_sequence_numbers_in_sr">
<p>　　发送端会收到窗口内某些分组的ACK，重传那些在接收端丢失/受损的分组。</p>
<p>　　接收端将确认一个正确接收的分组而不管是否按序，乱序的分组将被缓存，当所有的乱序分组都被接收后再一起交付给上层。</p>
<p>　　当上层调用<code>rdt_send</code>时，发送端检测可用于分组的序号是否在窗口内。若在窗口内则产生一个分组发送，否则反馈上层。每个分组都有一个计时器。当收到ACK时，若ACK对应的分组序号在窗口内则将该分组标记为已确认，若ACK对应的分组序号等于<span
class="math inline">\(send\_base\)</span>则将窗口移动至待确认的最小序号处。窗口移动后且窗口内存在待发送的分组，这些分组将被发送。</p>
<p>　　对接收端，<span style="background-color: yellow">序号在<span
class="math inline">\([rcv\_base-N,rcv\_base+N-1]\)</span>内的分组将被正确接收</span>。若接收分组的序号在窗口内将回传ACK，分组首次接收时缓存该分组。若接收分组的序号等于<span
class="math inline">\(rcv\_base\)</span>，则该分组以及缓存中序号始于该分组的序号且连续的所有分组将交付给上层。若接收分组的序号在<span
class="math inline">\([rcv\_base-N,rcv\_base-1]\)</span>，则<span
style="background-color: yellow">必须</span>回传一个ACK，无论该分组是否已被确认。</p>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/sr_operation.svg" class="" title="sr_operation">
<p>　　SR问题在于发送端/接收端之间缺乏同步，唯一能确定的是只有信道中收到的分组/ACK。</p>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/problem_of_sr.svg" class="" title="problem_of_sr">
<p>　　SR的窗口长度必须小于等于序号去重后的数量的一半。</p>
<p>　　若信道是单段物理连接时，信道中的分组不会重新排序。若信道是网络时，信道中的分组可能会重新排序，体现在即使发送端和接收端的当前窗口都不包含序号<code>x</code>，但信道中可能出现序号为<code>x</code>的分组/ACK的副本。信道中的分组重新排序可视为缓存这些分组并在未来的<span
style="background-color: yellow">任何时间</span>自发地发出这些分组。由于序号可以重复，这种序号重复的分组应该避免出现，实际中通常是确保在发送端确定之前发送的序号<code>x</code>的分组不会出现在网络前，都不会使用序号<code>x</code>，这通过设置分组的<strong>生存时间</strong>(一般不超过3分钟)来实现。</p>
<h3 id="拥塞控制原理">3.3 拥塞控制原理</h3>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/two_senders_and_a_router_with_infinite_buffers.svg" class="" title="two_senders_and_a_router_with_infinite_buffers">
<p>　　<span
class="math inline">\(\lambda_{in}(B/s)\)</span>表示应用层通过套接字发送初始报文到传输层的速率，<span
class="math inline">\(\lambda_{out}(B/s)\)</span>表示应用层接收报文的速率。</p>
<p>　　分组通过一台路由器在容量为<span
class="math inline">\(R\)</span>的共享式输出链路上传输，忽略添加底层首部信息的开销、差错恢复、流量控制和拥塞控制，显然<span
class="math inline">\(\lambda_{out} \leqslant \frac{R}{2}\)</span>
。时延的增长率随着<span
class="math inline">\(\lambda_{in}\)</span>增长，<span
class="math inline">\(\lambda_{in}\)</span>达到<span
class="math inline">\(\frac{R}{2}\)</span>时时延无穷大。这里体现了<span
style="background-color: yellow">拥塞的代价之一：当分组的到达速率接近链路容量时，分组承受巨大的排队时延</span>。</p>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/two_senders_with_retransmissions_and_a_router_with_finite_buffers.svg" class="" title="two_senders_with_retransmissions_and_a_router_with_finite_buffers">
<p>　　<span
class="math inline">\(\lambda^{&#39;}_{in}(B/s)\)</span>表示传输层发送初始报文段和重传报文段到网络层的速率，称为<strong>供给载荷</strong>。</p>
<p>　　假设发送端能确定路由器的可用缓存并根据情况发送分组，故不会丢包，<span
class="math inline">\(\lambda_{in}=\lambda^{&#39;}_{in}\)</span>，连接的吞吐量为<span
class="math inline">\(\lambda^{&#39;}_{in}\)</span>。在这种情况下，主机平均发送速率不能超过<span
class="math inline">\(\frac{R}{2}\)</span>。</p>
<p>　　假设发送端仅确定分组丢失后下才重传，当<span
class="math inline">\(\lambda_{in}^{&#39;}=\frac{R}{2}\)</span>时从平均角度有<span
class="math inline">\(\lambda_{in}=\lambda_{out}=\frac{R}{3}\)</span>。这里体现了<span
style="background-color: yellow">拥塞的代价之一：发送端必须重传因缓存溢出而丢失的分组</span>。</p>
<p>　　假设发送端重传因排队时延超时但未丢失的分组，初始分组和重传的分组可能都会到达接收端，接收端只需要一个这样的分组。当<span
class="math inline">\(\lambda_{in}^{&#39;}=\frac{R}{2}\)</span>时从平均角度(每个分组转发两次)有<span
class="math inline">\(\lambda_{in}=\lambda_{out}=\frac{R}{4}\)</span>。这里体现了<span
style="background-color: yellow">拥塞的代价之一：发送方因较大的时延进行了不必要的重传而占用路由器额外的链路带宽</span>。</p>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/four_senders_with_retransmissions,routers_with_finite_buffers.svg" class="" title="four_senders_with_retransmissions,routers_with_finite_buffers">
<p>　　当<span
class="math inline">\(\lambda_{in}\)</span>较小时，路由器缓存比较充足，吞吐量大致等于供给载荷，<span
class="math inline">\(\lambda_{out}\)</span>随着<span
class="math inline">\(\lambda_{in}\)</span>增大而增大。当<span
class="math inline">\(\lambda_{in}\)</span>较大时，对于R2，主机B发送的分组的到达速率高于主机A发送的分组的到达速率，这会导致主机A发送的分组因缓存溢出而丢失。</p>
<p>　　若考虑网络资源的浪费，当分组在第二跳及之后的路由器丢失时，之前路由器的转发工作毫无意义。这里体现<span
style="background-color: yellow">拥塞的代价之一：分组丢失时转发过该分组的上游路由器因转发而使用的传输容量被浪费</span>。</p>
<p>　　根据网络层是否为传输层提供了显式支持可将拥塞控制分为<span
style="background-color: yellow">端到端拥塞控制</span>和<span
style="background-color: yellow">网络辅助拥塞控制</span>。</p>
<p>　　在端到端拥塞控制中，网络层<span
style="background-color: yellow">没有</span>为传输层提供显示支持。即使网络中存在拥塞，端系统也必须通过对丢包和时延等网络行为的观察来确定是否拥塞。</p>
<p>　　在网络辅助的拥塞控制中，路由器向发送端提供关于的拥塞状态的显示反馈信息。拥塞信息反馈到发送端通常有两种方式，一种是路由器直接发送关于拥塞状态的分组给发送端，此时该分组称为<strong>抑制分组</strong>。另一种方式更通用，TCP、DCCP和DCTCP都有使用。路由器更新<span
style="background-color: yellow">由发送端到接收端的数据报头部中的ECN字段</span>(包含2位)来表示出现拥塞。若接收端收到分组的标志位表示出现拥塞则会通知发送端，故这种方式至少需要一个完整的往返周期。</p>
<h3 id="tcp">3.4 TCP</h3>
<p>　　在进程发送数据之前，进程间必须握手，即相互发送一些预备报文段来设置确保数据传输的参数，故TCP是<strong>面向连接的</strong>。</p>
<p>　　TCP连接只能有一个客户端和一个服务器，故TCP是<strong>点对点</strong>的。</p>
<p>　　进程间建立TCP连接后，双方都可以发送/接收报文段，故TCP是<strong>全双工服务</strong>。</p>
<p>　　TCP根据ACK到达的速率来调节拥塞窗口，故TCP是<strong>自计时</strong>的。</p>
<p>　　客户端先发送一个特殊的报文段，服务器用另一个特殊报文段来响应，最后，客户端用第三个特殊报文段作为响应，这种建立连接的过程被称为<strong>三次握手</strong>。前2个报文段不承载有效载荷，第三个报文段可以承载有效载荷。</p>
<p>　　TCP双方都有接收缓存、发送缓存和几个变量。当TCP连接收到正确且按序的数据后，会将数据放入接收缓存，对应的应用会从该缓存中读取数据(但并非立即读取)，若不能及时读取而收到的数据过多且过快，接收缓存可能溢出。</p>
<p>　　TCP会使用<strong>重传计时器</strong>、<strong>坚持计时器</strong>、<strong>保活计时器</strong>和<strong>时间等待计时器</strong>这四种计时器。重传计时器用于报文段重传。坚持计时器用于防止双方的死锁。保活计时器用于在长连接中断开无响应的连接。时间等待计时器用于四次握手断开连接前的等待。</p>
<p>　　<strong>最大传输单元</strong>指从源到目的地所有链路上发送的最大链路层帧的有效载荷(即IP数据报)。<strong>最大报文段长度</strong>是报文段中有效载荷的最大长度。最大传输单元一般是<span
class="math inline">\(1500B\)</span>，TCP/IP首部的长度一般是<span
class="math inline">\(40B\)</span>，故TCP报文段最大长度一般是<span
class="math inline">\(1460B\)</span>。</p>
<p>　　当收到按序报文段时，若序号在按序报文段之前的报文段都已经确认，则等待下一个按序报文段最多500ms，超时则发送ACK。若还存在另一个按序报文段待确认，则立即发送单个累积ACK来确认这两个报文段。</p>
<p>　　当收到序号在按序报文段之后的报文段时则立即发送冗余ACK。</p>
<p>　　当<span
style="background-color: yellow">超时或收到3个冗余ACK</span>时时，表示出现了丢包。一旦收到3个冗余ACK，TCP就执行<strong>快速重传</strong>。</p>
<h4 id="tcp报文段">3.4.1 TCP报文段</h4>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/tcp_segment_format.svg" class="" title="tcp_segment_format">
<p>　　TCP报文段包括16位<strong>源端口</strong>、16位<strong>目的端口</strong>、32位<strong>序号</strong>、32位<strong>确认序号</strong>、4位<strong>首部长度</strong>、3位保留字段、9个标志位、16位<strong>窗口长度</strong>、16位<strong>校验和</strong>、16位<strong>紧急指针</strong>以及最多<span
class="math inline">\(40B\)</span>的的选项字段。</p>
<p>　　TCP将数据看成一个无结构且有序的字节流，通过字节流确定序号，序号是<span
style="background-color: yellow">报文段首字节的编号</span>。初始序号一般随机。</p>
<p>　　确认号是<span
style="background-color: yellow">下一次按序应接收报文段首字节的编号</span>。TCP只确认报文段有效载荷中到第一个丢失字节为止的字节，故TCP提供<strong>累积确认</strong>。当有效载荷为空时吗，确认号被<strong>捎带</strong>在报文段中。</p>
<p>　　9个标志位中第2、3位标志位用于显式拥塞控制，若发送端至接收端链路中的某个路由器出现拥塞，当数据报达到该路由器后，路由器将数据报头部中的ECN字段置1，接收端收到数据报后将ACK报文段头部中的<code>ECE</code>置1来通知发送端链路出现拥塞，发送端像快速重传一样对<code>ECE</code>为1的ACK回应ACK，发送端在下一个报文段中将<code>CWR</code>置1来通知接收端拥塞窗口已缩减。</p>
<p>　　●
<strong>NS/N</strong>通常用于防止标记数据包被意外或恶意地隐藏。</p>
<p>　　● <strong>CWR/C</strong>为1时通知对方拥塞窗口已缩减。</p>
<p>　　● <strong>ECE/E</strong>为1时通知对方链路出现拥塞。</p>
<p>　　●
<strong>Urgent/URG/U</strong>为1时表示高优先级报文段，紧急指针生效。</p>
<p>　　●
<strong>ACK/A</strong>为1时表示确认序号生效，报文段成功接收。</p>
<p>　　●
<strong>Push/PSH/P</strong>为1时表示应该立即将该报文段交给应用层而不用等待缓存区填满。</p>
<p>　　● <strong>Reset/RST/R</strong>为1时表示重置连接。</p>
<p>　　●
<strong>Synchronization/SYN/S</strong>为1时表示三次握手中建立连接。</p>
<p>　　● <strong>Finish/FIN/F</strong>为1时表示四次挥手中断开连接。</p>
<p>　　选项字段包括8位Kind、可变的Length以及可变的Info。</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 35%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr>
<th>Kind字段值</th>
<th>Length字段值</th>
<th>Info字段长度</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td></td>
<td>选项表结束(EOP)</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td></td>
<td>空操作(NOP)</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td><span class="math inline">\(2B\)</span></td>
<td>最大报文段长度(MSS)</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td><span class="math inline">\(1B\)</span></td>
<td>窗口扩大系数(WSOPT)</td>
<td>窗口长度扩展</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td></td>
<td>选择性确认(SACK-Premitted)</td>
<td>表示支持SACK</td>
</tr>
<tr>
<td>5</td>
<td>可变</td>
<td></td>
<td>选择性确认(SACK)</td>
<td>收到的乱序数据</td>
</tr>
<tr>
<td>8</td>
<td>10</td>
<td></td>
<td>TSPOT</td>
<td>时间戳</td>
</tr>
<tr>
<td>19</td>
<td>18</td>
<td></td>
<td>TCP-MD5</td>
<td>MD5认证</td>
</tr>
<tr>
<td>28</td>
<td>4</td>
<td></td>
<td>User Timeout(UTO)</td>
<td>超时时间</td>
</tr>
<tr>
<td>29</td>
<td>可变</td>
<td></td>
<td>TCP-AO</td>
<td>认证算法</td>
</tr>
<tr>
<td>253/254</td>
<td>可变</td>
<td></td>
<td>Experimental</td>
<td>保留</td>
</tr>
</tbody>
</table>
<p>　　窗口长度用于流量控制服务。</p>
<p>　　校验和的计算类似于UDP的校验和。</p>
<h4 id="连接管理">3.4.2 连接管理</h4>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/three-way_handshake.svg" class="" title="three-way_handshake">
<p>　　1)
客户端向服务器发送<strong>SYN</strong>(报文段)，即报文段的有效载荷为空，<code>SYN</code>为1，客户端进入<code>SYN_SENT</code>。</p>
<p>　　2)
服务器收到SYN后为该连接分配TCP缓存和变量，再向客户端发送<strong>SYNACK</strong>(报文段)，即ACK报文段的<code>SYN</code>为1，最后服务器进入<code>SYN_RCVD</code>。</p>
<p>　　3)
客户端收到SYNACK后该连接分配TCP缓存和变量，再向服务器发送ACK，此时连接已建立，<code>SYN</code>置为0，最后客户端进入<code>ESTABLISHED</code>。服务器收到ACK后进入<code>ESTABLISHED</code>。</p>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/four-way_handshake.svg" class="" title="four-way_handshake">
<p>　　1)
客户端向服务器发送<strong>FIN</strong>(报文段)，即报文段的有效载荷为空，<code>FIN</code>为1，客户端进入<code>FIN_WAIT_1</code>。</p>
<p>　　2)
服务器收到FIN后发送ACK并进入<code>CLOSE_WAIT</code>。客户端收到ACK后进入<code>FIN_WAIT_2</code>。</p>
<p>　　3) 服务器向客户端发送FIN并进入<code>LAST_ACK</code>。</p>
<p>　　4)
客户端收到FIN后发送ACK并进入<code>TIME_wAIT</code>，同时设置时间等待计时器，计时结束后释放资源(包括端口号)并进入<code>CLOSED</code>。服务器收到ACK后释放资源并进入<code>CLOSED</code>。</p>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/tcp_state.svg" class="" title="tcp_state">
<p>　　在TCP连接的生命周期中，运行在每台主机的TCP协议会在各种<strong>TCP状态</strong>间变迁。</p>
<h4 id="超时">3.4.3 超时</h4>
<p>　　<span
class="math inline">\(SampleRTT\)</span>表示报文段从发送(交付给IP)到收到该报文段的确认所需时间。TCP不会为重传的报文段测量<span
class="math inline">\(SampleRTT\)</span>，仅仅为只需要传输一次的报文段测量。</p>
<p>　　<span class="math inline">\(EstimatedRTT\)</span>表示<span
class="math inline">\(SampleRTT\)</span>的平均值，其中<span
class="math inline">\(\alpha\)</span>一般取<span
class="math inline">\(\frac{1}{8}\)</span>。 <span
class="math display">\[
EstimatedRTT=(1-\alpha)\times EstimatedRTT+ \alpha \times SampleRTT
\]</span> 　　<span class="math inline">\(DevRTT\)</span>表示<span
class="math inline">\(SampleRTT\)</span>偏离<span
class="math inline">\(EstimatedRTT\)</span>的程度，其中<span
class="math inline">\(\beta\)</span>一般取<span
class="math inline">\(\frac{1}{4}\)</span>。 <span
class="math display">\[
DevRTT=(1-\beta)\times DevRTT+\beta \times |SampleRTT-EstimatedRTT|
\]</span> 　　<span class="math inline">\(EstimatedRTT\)</span>和<span
class="math inline">\(DevRTT\)</span>的计算方式是<strong>指数加权移动平均</strong>。</p>
<p>　　<span
class="math inline">\(TimeoutInterval\)</span>表示超时时间。 <span
class="math display">\[
TimeoutInterval=EstimatedRTT+4\times DevRTT
\]</span></p>
<h4 id="流量控制">3.4.4 流量控制</h4>
<p>　　TCP用<strong>流量控制服务</strong>来使发送端的发送速率和接收端的读取速率相匹配，主要通过让<span
style="background-color: yellow">发送端</span>维护<strong>接收窗口</strong>(表示接收端可用缓存空间)的变量来实现。</p>
<p>　　<span
class="math inline">\(RevBuffer\)</span>表示接收端的接收缓存的大小。<span
class="math inline">\(LastByteRead\)</span>表示接收端在接收缓存中读取的数据流的最后一个字节的编号。<span
class="math inline">\(LastByteRcvd\)</span>表示接收端缓存至接收缓存的数据流的最后一个字节的编号。<span
class="math inline">\(rwnd\)</span>表示接收窗口。 <span
class="math display">\[
rwnd=RcvBuffer-[LastByteRcvd-LastByteRead]
\]</span> 　　接收端将报文段中窗口长度字段设置为<span
class="math inline">\(rwnd\)</span>来告知发送端可用缓存空间。</p>
<p>　　<span
class="math inline">\(LastByteSent-LastByteAcked\)</span>表示发送端待确认的数据量。
<span class="math display">\[
LastByteSent-LastByteAcked\leqslant rwnd
\]</span> <img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/tcp_flow_control.svg" class="" title="tcp_flow_control"></p>
<p>　　当发送端收到窗口长度为0的ACK时，会设置坚持计时器并发送一个有效载荷为<span
class="math inline">\(1B\)</span>的探测报文段，若计时器超时或收到窗口长度为0的ACK时会再次发送同样的报文段并重置计时器，否则继续发送有效载荷为有效数据的报文段。</p>
<h4 id="tcp拥塞控制">3.4.5 TCP拥塞控制</h4>
<p>　　网络层不向端系统提供显式的网络拥塞反馈，故TCP只能使用端到端拥塞控制。</p>
<p>　　TCP发送端比接收端多1个变量，即<strong>拥塞窗口</strong>，用来限制发送速率。发送端未被确认的数据不能超过接收窗口与拥塞窗口的最小值。
<span class="math display">\[
LastByteSent-LastByteAcked \leqslant min\{cwnd,rwnd\}
\]</span>
　　假设接收窗口足够大、忽略丢包与时延以及发送端总有数据需要发送，<span
style="background-color: yellow">发送速率大致等于<span
class="math inline">\(\frac{cwnd}{RTT}(B/s)\)</span></span>。</p>
<p>　　当某路径出现拥塞时，该路径上部分路由器的缓存会溢出并导致某个数据包丢失，此时发送端可以确定该路径出现了拥塞。</p>
<p>　　<span
style="background-color: yellow">带宽探测：丢包表示出现了拥塞，应该降低发送速率。当未确认报文段的ACK到达时应该提高发送速率。</span></p>
<h5 id="tcp拥塞控制算法">3.4.5.1 TCP拥塞控制算法</h5>
<p>　　TCP拥塞控制算法包括<strong>慢启动</strong>、<strong>拥塞避免</strong>和<strong>快速恢复</strong>。</p>
<p>　　TCP拥塞控制被称为<strong>加性增、乘性减</strong>拥塞控制方式。加性增指在拥塞避免阶段<span
class="math inline">\(cwnd\)</span>的线性增加，乘性减指进入快速恢复阶段时<span
class="math inline">\(cwnd\)</span>的减半，若结果不是整数则向下取整。</p>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/fsm_of_tcp_congestion_control.svg" class="" title="fsm_of_tcp_congestion_control">
<p>　　在慢启动阶段，<span
class="math inline">\(cwnd\)</span>的初始值是<span
class="math inline">\(MSS\)</span>，<span
class="math inline">\(ssthresh\)</span>的初始值是<span
class="math inline">\(64KB\)</span>。每当报文段首次确认<span
class="math inline">\(cwnd\)</span>就增加<span
class="math inline">\(MSS\)</span>，即指数级增长。若出现超时导致的丢包，发送端令<span
class="math inline">\(ssthresh=\frac{cwnd}{2}\)</span>，<span
class="math inline">\(cwnd=MSS\)</span>并重新开始慢启动。当<span
class="math inline">\(cwnd \geqslant
ssthresh\)</span>时发送端结束慢启动并进入拥塞避免阶段。当收到3个冗余ACK时，发送端结束慢启动并令<span
class="math inline">\(ssthresh=\frac{cwnd}{2}\)</span>，<span
class="math inline">\(cwnd=\frac{ssthresh}{2}+3MSS\)</span>，然后执行快速重传，最后进入快速恢复阶段。</p>
<p>　　在不考虑处理时间的情况下，客户端发送请求到远程数据中心并收到响应大致需要<span
class="math inline">\(4RTT\)</span>，其中建立TCP需要<span
class="math inline">\(RTT\)</span>，慢启动阶段需要<span
class="math inline">\(3RTT\)</span>。显然，当<span
class="math inline">\(RTT\)</span>较大时，时延也较大。可以使用<strong>TCP分岔</strong>解决这一问题，即通过CDN将请求转发至邻近客户端且与远程数据中心有很大窗口的连接的前端服务器，在这种情况下响应所需时间大致是<span
class="math inline">\(4RTT_{FE}+RTT_{BE}+处理时间\)</span>，其中<span
class="math inline">\(RTT_{FE}\)</span>表示客户端与前端服务器的往返时间，<span
class="math inline">\(RTT_{BE}\)</span>表示前端服务器与远程数据中心的往返时间。当前端服务器与客户端足够近，就可以忽略<span
class="math inline">\(RTT_{FE}\)</span>，此时响应所需时间大致等于<span
class="math inline">\(RTT\)</span>。</p>
<p>　　在拥塞避免阶段，每个<span
class="math inline">\(RTT\)</span>内<span
class="math inline">\(cwnd\)</span>仅增加<span
class="math inline">\(MSS\)</span>。通用实现方法是若<span
class="math inline">\(RTT\)</span>内发送了<span
class="math inline">\(n\)</span>个报文段，在此期间每个报文段首次确认时<span
class="math inline">\(cwnd\)</span>增加<span
class="math inline">\(\frac{cwnd}{n}\)</span>。超时和3个冗余ACK的情况同慢启动。</p>
<p>　　在快速恢复阶段，每收到一个冗余ACK，<span
class="math inline">\(cwnd\)</span>增加<span
class="math inline">\(MSS\)</span>。当收到了新报文段的首次ACK，发送端会结束快速恢复阶段并进入拥塞避免阶段。当出现超时导致的丢包时发送端会结束快速恢复并令<span
class="math inline">\(ssthresh=\frac{cwnd}{2}\)</span>，<span
class="math inline">\(cwnd=MSS\)</span>，然后进入慢启动阶段。</p>
<img src="/2022/06/10/computer-networking-a-top-down-approach-7e-chpt-3/evolution_of_tcp_congestion_window.svg" class="" title="evolution_of_tcp_congestion_window">
<p>　　TCP的较新版本<strong>TCP
Reno</strong>的快速恢复阶段符合上述情况。但TCP的早期版本<strong>TCP
Tahoe</strong>在快速恢复阶段只要出现丢包都会结束快速恢复并令<span
class="math inline">\(ssthresh=\frac{cwnd}{2}\)</span>，<span
class="math inline">\(cwnd=MSS\)</span>，然后进入慢启动阶段。</p>
<p>　　TCP
Vegas试图在维持较好吞吐量同时避免拥塞，通过测量RTT来衡量拥塞程度，根据拥塞程度线性地降低发送速率。TCP
Vegas提供了慢启动、拥塞避免、快速恢复、快速重传和SACK。</p>
<h5 id="平均吞吐量">3.4.5.2 平均吞吐量</h5>
<p>　　当计算一个吞吐量较大的连接的平均吞吐量时，因为慢启动阶段和快速恢复阶段通常很短，都可以忽略，故可以认为该连接处于拥塞避免阶段。在一个RTT内，窗口长度是<span
class="math inline">\(w(B)\)</span>，吞吐量大约是<span
class="math inline">\(\frac{w}{RTT}\)</span>。在出现丢包之前，每个RTT内<span
class="math inline">\(w=w+MSS\)</span>。用<span
class="math inline">\(W\)</span>表示出现丢包时<span
class="math inline">\(w\)</span>的值。</p>
<p>　　若在一段时间内吞吐量从<span
class="math inline">\(\frac{W}{2RTT}\)</span>线性增长到<span
class="math inline">\(\frac{W}{RTT}\)</span>，丢包仅出现了一次且发生在最后。
<span class="math display">\[
\begin{align}
Segment_{total}&amp;=\frac{W}{2RTT}\times RTT+\frac{W+2}{2RTT}\times
RTT+\cdots +\frac{W}{RTT}\times RTT\\[3px]
&amp;=(\frac{W}{4}+\frac{W}{2}) \times (\frac{W}{4}+\frac{1}{2})\\[3px]
&amp;=\frac{3W^2}{8}+\frac{3W}{4}
\end{align}
\]</span> 　　丢包率<span
class="math inline">\(L=\frac{Segment_{loss}}{Segment_{total}}\)</span>。
<span class="math display">\[
\begin{align}
L&amp;=\frac{1}{Segment_{total}}\\[3px]
&amp;=\frac{1}{\frac{3W^2}{8}+\frac{3W}{4}}\\[3px]
&amp;=\frac{8}{3W^2+6W}
\end{align}
\]</span> 　　由于<span
class="math inline">\({3W^2}&gt;&gt;{6W}\)</span>，<span
class="math inline">\(6W\)</span>可以忽略，故<span
class="math inline">\(W \approx
\sqrt{\frac{8}{3L}}\)</span>。由于增长是线性，平均吞吐量是<span
class="math inline">\(\frac{3W}{4RTT}(MSS)\)</span>。 <span
class="math display">\[
\begin{align}
平均吞吐量&amp;=\frac{\sqrt{6}MSS}{2RTT\sqrt{L}}\\[3px]
&amp;\approx \frac{1.22\times MSS}{RTT\sqrt{L}}
\end{align}
\]</span></p>
<h5 id="公平性">3.4.5.3 公平性</h5>
<p>　　<strong>瓶颈链路</strong>指沿着某连接路径上的每条连接都不拥塞且相比该链路的传输容量都具有足够的传输容量。</p>
<p>　　假设<span
class="math inline">\(K\)</span>条TCP连接每条的端到端路径不同，但是都经过一段传输速率为<span
class="math inline">\(R(b/s)\)</span>的瓶颈链路。若每条连接都在传输一个大文件且无UDP流量通过该链路，而且每条连接的平均传输速率接近<span
class="math inline">\(\frac{R}{K}\)</span>，则认为该拥塞控制机制是<strong>公平</strong>的。在这种理想情况下，当所有连接的RTT相同时才能平等共享带宽，实际中这些条件不能都满足，具有较小RTT的连接可以更快地扩大拥塞窗口。</p>
<p>　　UDP并没有内置的拥塞控制机制，UDP是不公平的，UDP可能抑制TCP。</p>
<p>　　当一个应用使用多条并行TCP连接时，对单条TCP连接可能是公平的，但对应用并不公平。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法 第7版》第6章 无线网络和移动网络</title>
    <url>/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/</url>
    <content><![CDATA[<p>　　无线网络包括<strong>无线主机</strong>、<strong>无线链路</strong>、<strong>基站</strong>和<strong>网络基础设施</strong>。主机通过无线通信链路连接到基站或无线主机，这里的连接指的是主机位于基站的无线通信范围内且主机通过基站来中继到更大的网络。</p>
<p>　　连接到基站的主机通常以<strong>基础设施模式</strong>运行，因为所有传统网络服务都是由主机通过连接到基站的网络提供。在<strong>自组织网络</strong>中，无线主机没有可连接的此类基础设施，主机本身必须提供这些传统网络服务。</p>
<p>　　当移动主机超出当前基站的范围并进入去其他基站的范围时，它会更改连接点，这个过程称为<strong>切换</strong>。</p>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/part_of_wireless_network_standards.svg" class="" title="part_of_wireless_network_standards">
<p>　　无线网络可以按基站与主机通信时经过单跳还是多跳以及网络中是否存在基础设施进行分类。</p>
<p>　　●
<strong>单跳且基于基础设施</strong>的无线网络中有1个连接到更大的有线网络的基站，该基站与无线主机之间的所有通信都仅经过单跳。</p>
<p>　　●
<strong>单跳且无基础设施</strong>的无线网络中的节点可以协调其他节点的传输。</p>
<p>　　●
<strong>多跳且基于基础设施</strong>的无线网络中有1个有线连接到更大的网络的基站，为了通过基站通信，其中部分节点需要通过其他节点中继它们的通信。</p>
<p>　　●
<strong>多跳且无基础设施</strong>的无线网络中没有基站，节点可能需要其他节点中继。若节点是移动的则称为<strong>移动自组织网络</strong>。若移动节点是车载的则称为<strong>车载自组织网络</strong>。</p>
<p>　　<strong>蜂窝</strong>(技术)是蜂窝网覆盖的区域被划分为称为<strong>小区</strong>或<strong>蜂窝</strong>的多个地理覆盖区域。每个蜂窝包含1个<strong>基站收发台</strong>，BTS负责向其蜂窝中的移动设备发送/接收信号。</p>
<p>　　对于TCP，比特差错或切换导致的报文段丢失不应该减小拥塞窗口，可以通过<span
style="background-color: yellow">本地恢复</span>、<span
style="background-color: yellow">让TCP双方知晓无线链路</span>、<span
style="background-color: yellow">拆分连接</span>来处理这个问题。本地恢复中的目标是在比特差错发生的时间和位置将其恢复，主要通过ARQ或FEC等实现。让TCP双方知晓无线链路的目标是区分有线网络的拥塞和其它两者并仅对拥塞进行拥塞控制。拆分连接常用于蜂窝网络，将连接分成无线部分和有线部分，无线部分使用标准TCP或带有差错恢复的UDP。</p>
<span id="more"></span>
<h3 id="无线链路和网络特征">6.1 无线链路和网络特征</h3>
<p>　　相比有线链路，无线链路存在<strong>信号强度的衰减</strong>、<strong>其他源的干扰</strong>以及<strong>多径传播</strong>。</p>
<p>　　●
电磁波穿过物体时信号强度会衰减。随着传播距离的增加，电磁波信号强度也会降低，称为<strong>路径损耗</strong>。</p>
<p>　　●
同一频段的电磁波将互相干扰，此外，环境中的其他电磁波也会导致干扰。</p>
<p>　　●
当部分电磁波在物体或地面上反射时，在发送端和接收端之间经过了不同长度的路径，称为<strong>多径传播</strong>，这样会导致接收端收到的信号模糊。</p>
<p>　　无线链路相比有线链路更容易出现比特差错，因此无线链路不仅采用了CRC编码，还使用了链路层ARQ协议来重传受损的帧。</p>
<p>　　接收端收到的电磁信号是发送端传输的初始信号的退化形式(信号衰减和多径传播等)和环境中的噪声(干扰信号)的结合。<strong>信噪比</strong>是收到的信号和噪声强度的相对值，即以10为底信号振幅与噪声振幅之比的对数的20倍。</p>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/ber_and_transmission_rate_and_snr.svg" class="" title="ber_and_transmission_rate_and_snr">
<p>　　对于给定的调制技术，SNR越高，BER越低，发送端可以通过增加传输速率来增加SNR，进而降低BER。增加传输速率会消耗更大的能量而且可能干扰其他发送端的传输，传输功率达到某个阈值时收益将微乎其微。</p>
<p>　　对于给定的SNR，传输速率越高，BER越高。</p>
<p>　　物理层调制技术的动态选择可用于适配信道条件的调制技术。</p>
<h3 id="ieee-802无线协议">6.2 IEEE 802无线协议</h3>
<p>　　在IEEE
802.11(WiFi)协议族中有几个WLAN技术的802.11标准。它们都使用了CSMA/CA协议，链路层帧结构相同，可以通过降低传输速率来增加传输距离，而且向后兼容。</p>
<table>
<thead>
<tr>
<th>标准</th>
<th>频率范围(Hz)</th>
<th>最高传输速率(<span class="math inline">\(Mb/s\)</span>)</th>
</tr>
</thead>
<tbody>
<tr>
<td>802.11b</td>
<td>2.4G</td>
<td>11</td>
</tr>
<tr>
<td>802.11a</td>
<td>5G</td>
<td>54</td>
</tr>
<tr>
<td>802.11g</td>
<td>2.4G</td>
<td>54</td>
</tr>
<tr>
<td>802.11n</td>
<td>2.5~5G</td>
<td>450</td>
</tr>
<tr>
<td>802.11ac</td>
<td>5G</td>
<td>1300</td>
</tr>
</tbody>
</table>
<p>　　802.11设备工作在<span
style="background-color: yellow">2.4G~2.485G(称为2.4GHz)</span>和<span
style="background-color: yellow">5.1~5.8GHz(5GHz)</span>这两个不同的频段。2.4GHz是无须许可的频段，802.11设备可能与2.4GHz电话或微波炉竞争。在5GHz频段，802.11WLAN在给定功率时传输距离更短且更容易受到多径传播的影响。802.11n和802.11ac使用多输入多输出(MIMO)天线，即发送端和接收端都有两个或多个天线用来发送/接收不同的信号。802.11ac基站可以同时向多个基站发送信号，并使用智能天线自适应成型波束向目的地传输，这样减少了干扰并增加了给定速率下的传输距离。</p>
<p>　　除了802.11，其他两个802无线协议是使用802.15.1的蓝牙以及使用802.15.4的ZigBee。802.15.1是低功率、小范围、小速率的电缆代替技术，因此802.15.1也称为<strong>无线个人局域网</strong>。802.15.4服务于低功率、低数据率和低工作周期的应用，例如，物联网设备。</p>
<h4 id="体系结构">6.2.1 802.11体系结构</h4>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/802.11_wlan_architecture.svg" class="" title="802.11_wlan_architecture">
<p>　　802.11体系结构的基本构建块是<strong>基本服务集</strong>。BSS包含若干个无线主机和1个称为<strong>接入点</strong>的中央基站。在常规的家庭网络中，1个AP和1个路由器(通常集成为1个单元)将BSS连接到互联网。</p>
<p>　　类似于以太网设备，每个802.11无线主机都有MAC地址，该地址存储在设备适配器(802.11网络接口卡)的固件中。每个AP的无线接口也有1个MAC地址。</p>
<p>　　部署AP的WLAN称为<strong>基础设施WLAN</strong>，基础设施指AP以及互联AP和路由器的有线以太网。802.11设备能将组成1个自组织网络，该网络无中央控制且与外部没有连接。</p>
<p>　　在802.11WLAN体系结构中，每个无线主机都需要与AP相连才能发送/接收网络层数据报。</p>
<p>　　在安装AP时会为AP分配1或2个字的<strong>服务集标识符</strong>和1个信道号。802.11在2.4Ghz~2.485Ghz的频段内运行，在这个85MHz的频段内，802.11定义了11个部分重叠的信道，2个信道只有被4个或更多信道隔开时才不会有重叠，因此信道1、6和11的唯一的3个不重叠信道集合，同一个网络里可以安装3个802.11b的AP并为这些AP分配信道1、6和11，然后将每个AP都连接到同一交换机上。2个不同ISP在同一区域都设置了AP且使用了相同的信道，若2个AP同时接收则会导致其中之一丢弃地址错误的帧，若2个AP同时发送则会导致碰撞。</p>
<p>　　<strong>WiFi丛林</strong>指无线主机能从至少2个AP接收到足够强的信号的任何物理位置。无线主机需要与AP<strong>关联</strong>才能加入AP所属子网并访问互联网，关联表示无线主机与AP建立一条虚拟链路。</p>
<p>　　802.11标准中AP会定期发送<strong>信标帧</strong>，每个信标帧包含AP的SSID和MAC地址。无线主机会扫描11个信道来获悉信标帧以及发送的AP。802.11标准并没有指定AP关联的算法，该算法由无线主机中的802.11固件和软件设计者决定。通常，设备会选择接收到的信标帧信号强度最高的AP，显然信号强度并不是决定设备接收性能的唯一AP特性。</p>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/active_and_passive_scanning.svg" class="" title="active_and_passive_scanning">
<p>　　无线主机通过向无线主机范围内所有的AP广播探测请求帧来<strong>主动扫描</strong>，也能通过扫描信道和侦听信标帧来<strong>被动扫描</strong>。无线主机选择AP后，向AP发送关联请求帧，AP响应关联响应帧。一旦与AP关联，无线主机将加入AP所属子网。</p>
<p>　　为了创建与特定AP的关联，无线主机可能需要向AP认证自身。802.11WLAN为认证和访问提供了多种选择，例如，基于主机的MAC地址和使用账户和密码，这两种方式中，AP通常与认证服务器通信，使用诸如RADIUS或DIAMETER之类的协议在无线主机与认证服务器之间中继信息。分离认证服务器和AP使得认证服务器可以为多个AP服务，将认证和访问的决策集中在单个服务器中，并降低AP成本和复杂度。</p>
<h4 id="mac协议">6.2.2 802.11MAC协议</h4>
<p>　　802.11的载波侦听分为物理侦听和虚拟侦听，主要使用虚拟侦听。802.11使用<strong>网络分配向量</strong>来实现虚拟侦听，NAV是一个微秒计时器，用来指示预计使用信道的时间，当NAV不为0时则表示信道忙碌。由于各种原因，帧可能无法完整地达到目的地，因此使用了类似于rdt2.0中ACK的<strong>链路层确认</strong>。</p>
<p>　　802.11MAC协议中帧间都有<strong>帧间间隔</strong>。一般情况下，发送帧前需要等待<strong>分布式帧间间隔</strong>，发送ACK帧前需要等待<strong>短帧帧间间隔</strong>，重传帧时需要等待<strong>扩展帧间间隔</strong>。SIFS是固定值，DIFS=SIFS+2slot
time。t(ACK)表示最低速率传输ACK所需时间，则EIFS=time(ACK)+SIFS+DIFS。</p>
<p>　　802.11MAC协议包括<strong>分布式协调功能</strong>、<strong>点协调功能</strong>和<strong>混合协调功能</strong>三种工作模式，其中DCF是PCF和HCF的基础，PCF是可选项，HCF提供QOS的支持。DCF采用竞争的方式接入信道，PCF采用统一分配的方式接入信道，HCF在DCF的基础上加入了QOS的支持。</p>
<p>　　●
DCF是站点共享信道的接入方式，接入方式是CSMA/CA，还加入了可选的短<strong>请求发送</strong>控制帧和短<strong>允许发送</strong>控制帧来避免长数据帧的碰撞。</p>
<p>　　●
PCF中需要1个站点作为<strong>点协调器</strong>，点协调器周期性地发送信标帧来广播WLAN的网络标识和管理参数，其他站点根据管理参数来设置NAV。由于信标帧通过DCF发送，点协调器必须参与信道竞争。PCF只能在<strong>非竞争期</strong>工作，其机制类似于轮流协议中的轮询协议，点协调器轮询其他节点，轮询的节点才能传输帧，帧的长度受到限制。</p>
<p>　　●
HCF类似于PCF，但可以在<strong>竞争期</strong>工作且支持QOS。</p>
<p>　　802.11并未实现碰撞检测，因为碰撞检测需要同时传输和侦听，由于接收信号的强度通常远小于发送信号的强度，实现碰撞检测成本较高。即使网络适配器可以同时传输和侦听(并在检测到碰撞时时中止传输)，由于隐藏终端和信号衰减的问题，网络适配器依然无法检测到所有碰撞。</p>
<p>　　当源站点有帧待发送时需要先侦听信道，当信道空闲后需要等待DIFS，若在此期间未侦听到信号就发送帧，否则源站点像CSMA/CD一样使用二进制指数退避算法计算退避时间并启动<strong>退避计时器</strong>，不同的是基本退避时间为1个时隙，退避时间的随机区间为[0,CW<span
class="math inline">\(\times\)</span>slot
time)，CW是<strong>竞争窗口</strong>，最小值是<span
class="math inline">\(2^4-1\)</span>，最大值是<span
class="math inline">\(2^{10}-1\)</span>。侦听到的信道空闲时间至少为1时隙时，计时器才会减1(时隙)。若在退避时间内侦听到信号则暂停计时器，然后会重新等待到信道空闲并在下一个DIFS后再次启动计时器(计时器时间是剩下的时间)，计时器为0时发送帧。若至少2个站点选择了相同的退避时间则可能导致碰撞，碰撞后CW会变为原来的2倍加1。当AP收到通过CRC的帧时，它会等待SIFS后响应1个ACK帧。若源站点等待ACK帧超时则会等待EIFS后重传，在给定次数的重传后依然未收到ACK帧则丢弃帧。</p>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/hidden_terminal.svg" class="" title="hidden_terminal">
<p>　　无线主机H1和H2都在AP的范围内且都与AP关联，但由于信号衰减，两个无线主机对AP不隐藏，但是对彼此隐藏。若H1正在传输帧时，H2也要传输帧，这会导致碰撞，因此H1和H2的整个传输期间，信道都被浪费。</p>
<p>　　为了避免隐藏终端导致的问题，802.11协议允许无线主机使用RTS帧和CTS帧来预约信道的访问。类似于TCP建立连接，当源站点有数据帧要发送时，可以先向AP发送一个RTS帧来指示传输数据帧和ACK帧所需的总时间，能够侦听到源站点信号的站点会进入NAV静默状态。当AP收到RTS帧后通过广播CTS帧来响应，这样既给了源站点明确的发送权限，也指示了其他站点在预约时间内不要发送，其他所有节点也进入NAV静默状态。若等待CTS帧超时则像发送普通数据帧一样使用二进制指数退避算法来计算退避时间并等待然后重传。</p>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/collision_avoidance_using_rts_and_cts_frames.svg" class="" title="collision_avoidance_using_rts_and_cts_frames">
<p>　　尽管RTS和CTS帧有助于减少碰撞，但也引入了延迟并消耗信道资源，因此，RTS和CTS帧仅用于长数据帧的传输信道预约。实际上可以为每个无线站点设置RTS阈值，当帧的长度超过阈值时才使用RTS/CTS帧，默认阈值一般是<span
class="math inline">\(2347B\)</span>，即不使用。除了解决隐藏终端，RTS和CTS帧体现了<span
style="background-color: yellow">用短帧的碰撞来避免长帧的碰撞</span>。</p>
<h4 id="帧">6.2.3 802.11帧</h4>
<p>　　802.11帧分为<strong>数据帧</strong>、<strong>控制帧</strong>和<strong>管理帧</strong>。数据帧用于传输数据，控制帧通常与数据中配合使用。负责区域的清空、信道的获取、载波侦听的维护和响应数据。管理帧用于加入或退出WLAN以及处理基站之间的转移。</p>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/802.11_frame_format.svg" class="" title="802.11_frame_format">
<p>　　802.11帧包括<span
class="math inline">\(2B\)</span><strong>帧控制</strong>、<span
class="math inline">\(2B\)</span><strong>持续期或ID</strong>、<span
class="math inline">\(6B\)</span><strong>地址1</strong>、<span
class="math inline">\(6B\)</span><strong>地址2</strong>、<span
class="math inline">\(6B\)</span><strong>地址3</strong>、<span
class="math inline">\(2B\)</span><strong>序号控制</strong>、<span
class="math inline">\(6B\)</span><strong>地址4</strong>、最多<span
class="math inline">\(2312B\)</span>的有效载荷以及<span
class="math inline">\(4B\)</span>CRC。</p>
<p>　　帧控制包括帧的类型信息和一些控制位。</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 16%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr>
<th>帧控制字段</th>
<th>长度(单位是<span class="math inline">\(b\)</span>)</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>protocol version</td>
<td>2</td>
<td>802.11协议版本，目前只有一个版本，该字段值为0</td>
</tr>
<tr>
<td>type</td>
<td>2</td>
<td>值为00时表示管理帧，值为01时表示控制帧，值为10时表示数据帧，值为11保留</td>
</tr>
<tr>
<td>subtype</td>
<td>4</td>
<td>具体的802.11帧类型信息</td>
</tr>
<tr>
<td>to DS</td>
<td>1</td>
<td>值为1时表示帧发送到无线工作站(例如，AP)</td>
</tr>
<tr>
<td>from DS</td>
<td>1</td>
<td>值为1时表示帧由无线工作站(例如，AP)发送</td>
</tr>
<tr>
<td>more flag</td>
<td>1</td>
<td>类似于IPv4数据报中的分片标志位</td>
</tr>
<tr>
<td>retry</td>
<td>1</td>
<td>值为1时表示重传帧</td>
</tr>
<tr>
<td>power management</td>
<td>1</td>
<td>值为1时发送完本帧后进入省电模式</td>
</tr>
<tr>
<td>more data</td>
<td>1</td>
<td>仅用于管理帧，控制帧的该字段值为0</td>
</tr>
<tr>
<td>protected frame</td>
<td>1</td>
<td>值为1时表示有效载荷已加密</td>
</tr>
<tr>
<td>order</td>
<td>1</td>
<td>值为1时表示帧按序传输</td>
</tr>
</tbody>
</table>
<p>　　持续期用于记录NAV的值。当最后一位为0时用于设置NAV，例如，RTS和CTS帧中会设置这个值来指示其他站点在指定时间内不要发送帧。</p>
<p>　　地址1表示接收端(接收端不一定是目的地)的MAC地址。</p>
<p>　　地址2表示发送端(发送端不一定是源)的MAC地址。</p>
<p>　　地址3用于基站和传输系统的过滤，具体用法取决于网络类型。例如，1台路由器需要向某个BSS中的某台无线主机发送帧，但是路由器并不知道它需要通过AP到达无线主机，路由器发送目的MAC地址为无线主机的<span
style="background-color: yellow">以太帧</span>到AP。AP收到以太网帧后将其<span
style="background-color: yellow">转换为802.11帧</span>，该802.11帧的地址1是无线主机的MAC地址，地址2是自身地址，地址3是路由器发送数据报接口的MAC地址。</p>
<p>　　序号控制类似于rdt2.0中的序号。</p>
<p>　　地址4仅在无线分布式系统中使用。</p>
<h4 id="蓝牙和zigbee">6.2.4 蓝牙和ZigBee</h4>
<p>　　802.15.1的链路层和物理层基于早期的PAN蓝牙规范。802.15.1以TDM方式在2.4GHz频段上运行，时隙是625<span
class="math inline">\(\mu
s\)</span>。在每个时隙中，发送端在79个信道中的一个上进行传输，信道以已知但伪随机的方式跳频，称为<strong>跳频扩频</strong>。802.15.1可提供最高<span
class="math inline">\(4Mb/s\)</span>的传输速率。</p>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/bluetooth_piconet.svg" class="" title="bluetooth_piconet">
<p>　　802.15.1网络是自组织网络，802.15.1设备首先组织成最多八个活动设备的<strong>微微网</strong>，这些设备之一被指定为主设备，其他设备充当从设备。主设备管理微微网，因为它的时钟决定微微网的时间，它可以在每个奇数时隙中传输，而从设备只能在主设备前一时隙与它通信后才能传输。除了从设备，微微网还可以容纳最多255个停放设备，停放设备只能在主设备将其状态变更为活动后才能通信。</p>
<p>　　ZigBee定义了<span class="math inline">\(20Kb/s\)</span>、<span
class="math inline">\(40Kb/s\)</span>、<span
class="math inline">\(100Kb/s\)</span>和<span
class="math inline">\(250Kb/s\)</span>的信道速率，具体取决于信道的频率。在ZigBee网络中，多个相对简化功能的设备在单个全功能设备的控制下运行，并且多个全功能设备还能够配置为一个网状网络，全功能设备在它们之间路由帧。</p>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/802.15.4_super_frame_format.svg" class="" title="802.15.4_super_frame_format">
<p>　　单个全功能设备使用信标帧以时隙方式控制多个简化功能的设备。ZigBee网络将时间划分为若干个超帧，每个超帧以信标帧开始。信标帧将超帧划分为活跃期(此期间内设备可以传输)和非活跃期(此期间内设备可以休眠来节能)。活跃期由16个时隙组成，其中部分由使用CSMA/CA随机接入方式的设备使用，其余部分由控制器分配特定的设备来给这些设备提供有保障的信道接入。</p>
<h3 id="蜂窝互联网接入">6.3 蜂窝互联网接入</h3>
<p>　　最早的几代蜂窝主要服务于语音流量。第1代(1G)是专为纯语音通信设计的模拟<strong>频分多址</strong>系统。最初的2G系统也是为语音而设计的，后来扩展了对数据(互联网)的支持(2.5G)。3G系统支持语音和数据，但更强调数据能力和更高速的无线接入链路。4G系统基于LTE，其特点是全IP核心网络并以<span
class="math inline">\(Mb/s\)</span>速率提供语音和数据服务。</p>
<p>　　2G蜂窝系统的GSM标准使用组合的FDM/TDM(无线)作为空中接口。对于组合FDM/TDM系统，若将信道划分为<span
class="math inline">\(F\)</span>个子信道且时间划分为<span
class="math inline">\(T\)</span>个时隙，则该信道能够支持<span
class="math inline">\(F\cdot
T\)</span>个并发呼叫。GSM系统由200kHz的频段组成，每个频段支持8个TDM呼叫。GSM以<span
class="math inline">\(13Kb/s\)</span>和<span
class="math inline">\(12.2Kb/s\)</span>编码语音。</p>
<p>　　单个GSM网络的<strong>基站控制器</strong>通常会为数十个BTS提供服务。BSC的作用是为移动设备分配BTS无线电信道，执行<strong>寻呼</strong>(查找移动设备所在的蜂窝)。基站控制器及其受控的BTS共同构成一个GSM<strong>基站系统</strong>。</p>
<p>　　<strong>移动交换中心</strong>在用户授权和计费、呼叫建立和断开以及切换中发挥着决定性作用。单个MSC通常最多包含5个BSC，因此每个MSC大约有20万用户。蜂窝提供商的网络有多个MSC，其中称为网关MSC的特殊的MSC将提供商的蜂窝网络连接到更大的公共电话网络。</p>
<p>　　<strong>通用分组无线服务</strong>是2G网络中的一种早期蜂窝数据服务，基于GSM的无线分组交换技术，提供端到端且广域的无线IP连接。</p>
<h4 id="g蜂窝网">6.3.1 3G蜂窝网</h4>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/3g_network_architecture.svg" class="" title="3g_network_architecture">
<p>　　相比2G，3G
UMTS不再使用GSM的FDMA/TDMA方案，而是在TDMA时隙内使用<strong>直接序列宽带码分多址</strong>，类似于DOCSIS。与WCDMA规范相关的数据服务称为<strong>高速分组接入</strong>。</p>
<p>　　3G核心蜂窝数据网络将无线接入网络连接到互联网。鉴于现有蜂窝语音网络存在大量现有基础设施，因此3G保持现有核心GSM蜂窝语音网络不变，同时添加额外的蜂窝数据功能到现有的蜂窝语音网络。</p>
<p>　　3G核心网络中有<strong>服务GRRS支持节点</strong>和<strong>网关GRPS支持节点</strong>这两种节点。SGSN负责向与其连接的无线接入网中的移动节点发送/接收数据报。SGSN与同一区域的蜂窝语音网络的MSC交互，提供用户授权和切换，维护活跃移动节点的蜂窝信息，并在无线接入网络中的移动节点和GGSN间转发数据报。GGSN充当网关，将多个SGSN连接到互联网。因此，GGSN是源自移动节点的数据报进入互联网之前经过的最后一个3G基础设施。对外界而言，GGSN无异于其他网关路由器。GGSN网络内3G节点的移动性对外隐藏。</p>
<p>　　3G<strong>无线接入网络</strong>是移动节点接触的无线首跳网络。<strong>无线网络控制器</strong>(又称为Node
B)通常控制多个蜂窝的BTS。每个蜂窝的移动节点和BTS之间通过无线链路连接。RNC通过MSC连接到连接到电路交换蜂窝语音网络，并通过SGSN连接到互联网。3G蜂窝语音服务和数据服务虽然使用不同的核心网络，但它们共享第一跳和最后一跳无线接入网络。</p>
<h4 id="g蜂窝网-1">6.3.2 4G蜂窝网</h4>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/4g_network_architecture.svg" class="" title="4g_network_architecture">
<p>　　相比3G，4G使用了<strong>全IP核心网络</strong>(语音和流量全都承载在IP数据报中)和增强的无线接入网络，而且4G对数据平面和控制平面进行了分离。</p>
<p>　　<strong>eNodeB</strong>是2G的基站和3G的RNC的逻辑后代。在控制平面中，eNodeB代表UE来处理注册和移动信令流量。在数据平面中，eNodeB负责在UE和P-GW之间转发数据报。UE数据报在eNodeB中封装并通过4G网络的全IP增强分组核以隧道形式传输到P-GW。eNodeB与P-GW之间的隧道类似于IPv6中IPv4迁移到IPv6的隧道，这些隧道可能具有相关的QOS保证。</p>
<p>　　<strong>分组数据网络网关</strong>为UE分配IP地址并保证QOS的执行。作为隧道端点，它负责封装和解封装发给UE和来自UE的数据报。</p>
<p>　　<strong>服务网关</strong>是数据平面移动锚点，即所有UE流量都将通过。S-GW还负责收费/计费以及合法的流量拦截。</p>
<p>　　<strong>归属用户服务器</strong>容纳包括漫游接入能力、QOS配置文件和认证信道的UE信息，它从UE归属蜂窝提供商获得这些信息。</p>
<p>　　<strong>移动性管理实体</strong>代表驻留在其控制的蜂窝中的UE执行连接和移动性管理，它从HHS接收UE订阅信息。</p>
<p>　　LTE在下行信道使用组合FDM/TDM，称为<strong>正交频分复用</strong>。在LTE中，每个活跃移动节点在若干个信道频率中被分配若干个0.5<span
class="math inline">\(ms\)</span>时隙。分配的时隙越多，移动节点能够获取的传输速率越高。移动节点之间的时隙(重)分配可以每1<span
class="math inline">\(ms\)</span>执行1次。</p>
<p>　　LTE标准没有规定分配移动节点特定的时隙。允许那些移动节点在特定频率上的给定时隙中进行传输由LET设备供应商或网络运营商提供的调度算法决定。使用机会调度，将物理层协议与发送端和接收端之间的信道条件相互匹配，并根据信道条件选择分组将发送到达接收端，使RNC能够充分利用无线链路。此外，用户的优先级和约定的服务级别可用于调度下行分组传输。高级LTE通过向移动节点分配聚合信道提供数百<span
class="math inline">\(Mb/s\)</span>的下行带宽。</p>
<p>　　另一种4G无线技术是使用802.16的WiMAX。</p>
<h3 id="移动管理">6.4 移动管理</h3>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/initial_elements_of_a_mobile_network_architecture.svg" class="" title="initial_elements_of_a_mobile_network_architecture">
<p>　　在网络环境中，1个移动节点的永久归属地称为<strong>归属网络</strong>。归属网络内代表移动节点执行移动管理的实体称为<strong>归属代理</strong>。移动节点当前所在的网络称为<strong>外部网络</strong>或<strong>被访网络</strong>，外部网络中帮助移动节点实现移动管理的实体称为<strong>外部代理</strong>。会话开始时移动节点所在外部网络的外部代理称为<strong>锚外部代理</strong>。将与移动节点通信的实体称为<strong>通信者</strong>。</p>
<p>　　当移动节点驻留在外部网络中时，所有发往该节点永久地址的流量需要路由到外部网络。为了实现这一点，一种方法是外部网络向所有其他网络通告移动节点驻留在其网络中，这通常可以通过交换域内和域间路由选择信息实现，而且只需要对现有路由选择基础设施进行少量改动即可。外部网络只需向它的邻居通告有1条特定的路由可以到达该移动节点的永久地址。类似于DV算法，作为更新路由选择信息和转发表的1个流程，这些邻居在整个网络传播此路由信息。当移动节点离开该外部网络并加入另一个外部网络是，新外部网络将通告1条通向该移动节点的新路由，而旧外部网络将撤销与该移动节点相关的路由选择信息。而实际中采用了另一种方法，将移动功能从网络核心转移到网络边缘，主要通过移动节点的归属网络来实现。</p>
<p>　　外部代理放置于外部网络的边缘路由器上，外部代理的作用之一是为移动节点创建1个所谓的<strong>转交地址</strong>，COA的网络部分与外部网络CIDR的网络部分相同。因此1个移动节点可与永久地址以及COA关联。外部代理的另一个作用是通知归属代理移动节点驻留在其网络中且具有给定的COA。移动节点可以(通过DHCP等协议)获取外部网络的COA并通知给归属代理。</p>
<h4 id="移动节点的间接路由选择">6.4.1 移动节点的间接路由选择</h4>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/indirect_routing_to_a_mobile_node.svg" class="" title="indirect_routing_to_a_mobile_node">
<p>　　在<strong>间接路由选择</strong>中，通信者是将数据报寻址到移动节点的永久地址并将数据报发送到网络中，但并不知道移动节点是驻留在归属网络还是外部网络。这些数据报首先路由到移动节点的归属网络。归属代理收到数据报后将其转发给外部代理，然后外部代理在转发给移动节点。若移动节点需要发送数据报给通信者，可以直接发送给通信者。</p>
<p>　　为了确保通信者发送的数据报的完好无损以及对移动节点隐藏数据报经过了归属代理的转发，可以建立类似于IPv4迁移到IPv6的隧道，即归属代理将通信者的数据报再次封装。归属代理将移动节点的COA作为封装后的数据报的目的IP地址来将数据报路由到外部网络。外部代理收到封装的数据报后拆封再将原始数据报转发给移动节点。</p>
<p>　　间接路由选择需要<span
style="background-color: yellow">移动节点到外部代理的协议</span>、<span
style="background-color: yellow">外部代理到归属代理的注册协议</span>、<span
style="background-color: yellow">归属代理数据报封装协议</span>以及<span
style="background-color: yellow">外部代理拆封协议</span>这些网络层新功能。当移动节点连接到外部网络时需要向外部代理注册，离开时也需要注销。此外，外部代理将向归属代理注册移动节点的COA，当移动节点离开网络不需要显式注销COA，因为移动节点再次连接新网络时，新COA的注册会完成注销。</p>
<p>　　间接路由选择存在<strong>三角路由选择</strong>问题，即发往移动节点的数据报需要先发送到归属代理再发送到外部网络。最坏的情况是移动节点与通信者在同一外部网络，但数据报还是需要先发往归属代理再回到该外部网络。</p>
<h4 id="移动节点的直接路由选择">6.4.2 移动节点的直接路由选择</h4>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/direct_routing_to_a_mobile_node.svg" class="" title="direct_routing_to_a_mobile_node">
<p>　　<strong>直接路由选择</strong>解决了三角路由选择问题，但是在通信者所在的网络中加入了<strong>通信者代理</strong>，通信者代理需要先获取移动节点COA，这可以通过向归属代理查询来完成。通信者代理通过隧道将数据报发送移动节点的COA，外部代理收到数据报后再拆封并转发给移动节点。</p>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/mobile_transfer_between_networks_with_direct_routing.svg" class="" title="mobile_transfer_between_networks_with_direct_routing">
<p>　　直接路由选择需要<span
style="background-color: yellow">移动节点定位协议</span>来查询归属代理并获得移动节点的COA。通信者代理仅在会话开始时查询归属并代理获得移动节点的COA，这样会导致会话过程中数据无法在移动节点切换外部网络后路由选择到新外部网络。一种解决方法是创建1个协议来告知通信者切换网络后的COA，GSM实践中采用了另一种方法，当移动节点移动到另一个外部网络后，移动节点向新的外部代理注册，新的外部代理再向锚外部代理提供移动节点新COA。当锚外部代理收到发往已离开该外部网络的移动节点的数据报后，它使用新COA再次封装数据报并转发给移动节点。若移动节点再次移动到另一个外部网络，则新外部代理将联系锚外部代理提供新COA。</p>
<h3 id="移动ip">6.5 移动IP</h3>
<p>　　移动IP标准由<strong>代理发现</strong>、<strong>向归属代理注册</strong>、<strong>数据报的间接路由选择</strong>组成。</p>
<p>　　加入新网络(外部网络或归属网络)的移动节点，它都必须知道相应的外部代理或归属代理的身份。实际上，正是具有新IP地址的的外部代理才允许移动节点的网络层知道自身已进入新的外部网络，称为<strong>代理发现</strong>。代理发现可以通过<strong>代理通告</strong>或<strong>代理请求</strong>实现。</p>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/icmp_router_discovery_message_with_mobility_agent_advertisement_extension.svg" class="" title="icmp_router_discovery_message_with_mobility_agent_advertisement_extension">
<p>　　借助代理通告，外部代理或归属代理使用扩展ICMP路由器发现报文来通告其服务。外部代理或归属代理周期性地在所有连接的链路上广播ICMP报文(type=9)。</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 18%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr>
<th>字段名称</th>
<th>字段长度(单位是<span class="math inline">\(b\)</span>)</th>
<th>字段描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Router IP address</td>
<td>32</td>
<td>发送该报文的代理的IP地址</td>
</tr>
<tr>
<td>type</td>
<td>8</td>
<td>值固定为16</td>
</tr>
<tr>
<td>length</td>
<td>8</td>
<td>值为6+4N，N表示COA的个数</td>
</tr>
<tr>
<td>sequence number</td>
<td>16</td>
<td>代理启动后的第1个通告序列号必须是0，之后每次加1，但0xFFFF之后必须是256，这样可以区分序列号减小是由于重启还是达到序列号最大值</td>
</tr>
<tr>
<td>registration lifetime</td>
<td>16</td>
<td>注册的最大生命周期(以秒为单位)，0xFFFF表示无穷大</td>
</tr>
<tr>
<td>registration required(R)</td>
<td>1</td>
<td>此网络中的移动节点必须向外部代理注册。若移动节点无法(使用DHCP)在外部网络中获取COA且无法承担自身外部代理的功能，则无需向外地代理注册</td>
</tr>
<tr>
<td>busy(B)</td>
<td>1</td>
<td>代理不再接受新移动节点的注册</td>
</tr>
<tr>
<td>home agent(H)</td>
<td>1</td>
<td>代理为它所在网络的归属代理</td>
</tr>
<tr>
<td>foreign agent(F)</td>
<td>1</td>
<td>代理为它所在网络的外部代理</td>
</tr>
<tr>
<td>minimal encapsulation(M)</td>
<td>1</td>
<td>隧道支持最小封装</td>
</tr>
<tr>
<td>GRE encapsulation(G)</td>
<td>1</td>
<td>隧道支持GRE</td>
</tr>
<tr>
<td>reserved(r)</td>
<td>1</td>
<td>值固定为0</td>
</tr>
<tr>
<td>reverse tunneling(T)</td>
<td>1</td>
<td>支持反向隧道</td>
</tr>
<tr>
<td>U</td>
<td>1</td>
<td>支持UDP</td>
</tr>
<tr>
<td>X</td>
<td>1</td>
<td>支持撤销注册</td>
</tr>
<tr>
<td>I</td>
<td>1</td>
<td>支持区域注册</td>
</tr>
<tr>
<td>COA address</td>
<td>32N</td>
<td>外部代理提供COA列表，移动节点选择1个作为其COA</td>
</tr>
</tbody>
</table>
<p>　　移动节点可以通过代理请求直接广播ICMP报文(type=10)，收到该报文的代理将<span
style="background-color: yellow">单播</span>1个代理通告。</p>
<p>　　一旦移动节点收到COA，则必须向归属代理注册该地址，这可以通过外部代理(外部代理向归属代理注册该地址)或直接自行注册，这里考虑前者。</p>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/agent_advertisement_and_mobile_ip_registration.svg" class="" title="agent_advertisement_and_mobile_ip_registration">
<p>　　1)
当收到代理通告后，移动节点向外部代理发送移动代理注册报文。注册报文由UDP数据报承载并发送到434端口，包括选择的COA、归属代理的IP地址、移动节点的永久IP地址、请求注册的生命周期以及1个64位的注册标识。</p>
<p>　　2)
外部代理收到注册报文后记录移动节点的永久IP地址，将注册请求报文再封装并以隧道的形式发送给归属代理，报文同样由UDP数据报承载并发送到434端口。</p>
<p>　　3)
归属代理收到注册请求并检测其真实性和正确性。归属代理将移动节点永久IP地址和COA绑定，然后将注册响应再封装并以隧道的形式发送给外部代理，报文中包括归属代理的IP地址、移动节点的永久IP地址、实际注册生命周期以及请求的注册标识。</p>
<p>　　4) 外部代理收到再封装的注册响应后拆封并转发给移动节点。</p>
<h3 id="蜂窝网络中的移动性">6.6 蜂窝网络中的移动性</h3>
<p>　　在GSM中移动设备的归属网络称为该移动设备的<strong>归属公共陆地移动网络</strong>，这里简称为<strong>归属网络</strong>，而移动设备当前所在的PLMN简称为<strong>被访网络</strong>。</p>
<p>　　归属网络维护1个称为<strong>归属位置寄存器</strong>的数据库，其中包含该网络中每个移动设备的永久手机号码和概要信息以及用户当前位置的信息，因此当移动设备漫游到另一个提供商的蜂窝网络中，HLR中包含足够的信息来获取移动设备被呼叫时应该路由选择到的被访网络的的IP地址。当移动设备被呼叫时，通信者会联系归属网络中1个称为<strong>网关移动交换中心</strong>的交换机，这里简称为<strong>归属MSC</strong>。</p>
<p>　　被访网络维护1个称为<strong>访问者位置寄存器</strong>的数据库，其中包含该网络中每个移动设备的表项，VLR表项因此随着移动设备加入或退出网络而新增或删除。VLR通常与MSC位于同一位置，MSC协调到达或离开被访网络的呼叫建立。</p>
<p>　　在实际中，提供商的蜂窝网络作为其用户的归属网络以及其他提供商的蜂窝网络的用户的被访网络。</p>
<h4 id="移动设备呼叫的路由选择">6.6.1 移动设备呼叫的路由选择</h4>
<p>　　当移动设备切换或进入新VLR覆盖的被访网络时，必须和VLR交换信令报文来向被访网络注册。被访网络的VLR再向移动设备的HLR发送位置更新请求报文来告知HLR可用于联系移动设备的<strong>移动站点漫游号</strong>(简称为<strong>漫游号</strong>)或VLR地址，VLR从HLR获取移动设备的信息并确定被访网络应向移动设备提供对应的服务(如果有)。MSRN的功能类似于COA，对通信者和移动设备都隐藏。</p>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/place_a_call_to_a_mobile_user_with_indirect_routing.svg" class="" title="place_a_call_to_a_mobile_user_with_indirect_routing">
<p>　　与移动IP一样，GSM采用了间接路由选择，先将通信者的呼叫路由选择到移动节点的归属网络，再到被访网络。</p>
<p>　　1)
通信者拨打移动设备的电话号码。呼叫通过<strong>公共交换电话网络</strong>到达移动设备的归属MSC。</p>
<p>　　2)
归属MSC收到呼叫后查询HLR来确定移动设备的位置。在最简单的情况下，HLR返回MSRN。若HLR中没有MSRN则返回VLR在被访网络中的地址。</p>
<p>　　3)
归属MSC获得MSRN后，通过PSTN到达被访网络的MSC建立第2段呼叫来完成呼叫。</p>
<h4 id="gsm中的切换">6.6.2 GSM中的切换</h4>
<p>　　呼叫过程中的切换不仅导致移动设备关联新基站，而且导致呼叫从网络中的交换点重新路由选择到新基站。</p>
<p>　　在与基站关联时，移动设备会定期测量关联基站的信标信号强度与其他基站的信标信号强度，结果以每秒1或2次的频率报告给关联基站，关联基站根据测量结果、附近蜂窝的移动设备负载以及其他因素来切换。GSM标准中没有规定执行切换的具体算法。</p>
<img src="/2022/08/11/computer-networking-a-top-down-approach-7e-chpt-6/handoff_between_base_stations_with_a_common_msc.svg" class="" title="handoff_between_base_stations_with_a_common_msc">
<p>　　1) 旧BS通知被访MSC移动设备将执行切换和切换后的BS(组)。</p>
<p>　　2)
被访MSC发起到新BS的路径建立，分配承载重新路由选择的呼叫所需的资源以及用信令告知新BS切换即将发生。</p>
<p>　　3) 新BS分配并激活1个无线信道供移动设备使用。</p>
<p>　　4)
新BS向被访MSC和旧BS发送信令通知已建立被访MSC到新BS路径并且应该通知移动设备即将发生的切换。新BS提供移动设备与新BS关联所需的所有信息。</p>
<p>　　5)
移动设备被告知它应该执行切换。之前移动设备并不知道网络以及为切换做好所有底层工作。</p>
<p>　　6) 移动设备和新BS交换若干个报文来完全激活新BS中的信道。</p>
<p>　　7)
移动设备向新BS发送1个切换完成报文，然后该报文被转发到被访MSC。被访MSC通过新BS将正在进行的呼叫重新路由到移动设备。</p>
<p>　　8) 到旧BS的路径分配的资源随后释放。</p>
<p>　　GSM中定义了类似于锚外部代理的<strong>锚MSC</strong>，锚MSC是呼叫开始时移动设备的被访MSC，它在整个呼叫持续过程中保持不变。无论移动设备在呼叫的过程中转移多少次，呼叫都是从归属MSC路由选择到锚MSC再到移动设备当前的被访MSC，因此，通信者和移动设备间最多有3个MSC。除了保持锚MSC到当前被访MSC的单MSC跳，另一种方法是直接将移动设备被访MSC链接起来(出现在IS-41蜂窝网络中)，每当移动设备移动到新MSC后，让旧MSC将呼叫转发给新MSC。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法 第7版》第4章 网络层</title>
    <url>/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/</url>
    <content><![CDATA[<p>　　网络层提供的服务是<strong>尽力而为服务</strong>。</p>
<p>　　<strong>转发</strong>是指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。转发所需时间通常为几纳秒，故通过硬件实现。</p>
<p>　　<strong>路由选择</strong>是指确定数据报从源到目的地的端到端路径的网络范围处理过程。路由选择所需时间通常为几秒，故通过软件来实现。</p>
<p>　　网络层可以分为<strong>数据平面</strong>和<strong>控制平面</strong>。</p>
<p>　　● 数据平面即<span
style="background-color: yellow">路由器的功能</span>，用于从路由器的输入链路向输出链路转发分组，包括传统的<span
style="background-color: yellow">IP地址转发</span>和<span
style="background-color: yellow">通用转发</span>。两者都采用匹配加动作的模式，匹配是匹配分组，动作是匹配之后的动作，区别在于IP地址转发是根据IP地址匹配，而通用转发是根据协议栈对多个首部字段进行匹配。</p>
<p>　　● 控制平面即<span
style="background-color: yellow">网络范围的逻辑</span>，用于协调路由器间的转发动作，使得分组最终沿着源主机和目的主机之间的路径进行端到端传输。可以通过传统的<strong>每路由器控制</strong>(每台都有转发和路由选择功能，每台路由器还有一个路由选择组件，该组件与其他路由器中的路由组件通信以计算转发表的值)和<strong>SDN控制</strong>(逻辑集中控制器计算并分发转发表给每台路由器)来构建控制平面。</p>
<p>　　<strong>网络服务模型</strong>定义了分组在发送端与接收端之间的端到端传输特性。</p>
<p>　　主机与物理链路之间的边界称为<strong>接口</strong>。路由器与其任意一条链路之间的边界也称为接口，例如，输入端口或输出端口。在技术层面上，一个IP地址与一个接口相关，而不是与包括该接口的主机/路由器相关。在公网中，除NAT接口之外的每台主机/路由器的每个接口都必须有个公网IP地址。</p>
<p>　　IP地址一般划分为网络地址和主机地址。主机地址不能全为0/1，主机地址全为0的地址是网络地址，主机地址全为1的地址是广播地址。</p>
<p>　　<strong>子网掩码</strong>用来区分IP地址的网络地址和主机地址，故必须与IP地址结合使用。</p>
<p>　　<strong>IP广播</strong>分为<strong>受限广播</strong>和<strong>直接广播</strong>。受限广播中发送数据报时不会进行路由选择，而是被广播到所属<span
style="background-color: yellow">物理网络</span>上的所有主机，<strong>受限广播IP地址</strong>全为1。直接广播中发送数据报时进行路由选择并广播到所属网络的所有主机，<strong>直接广播IP地址</strong>的主机地址全为1。IP广播地址除了受限广播地址和直接广播地址，还有<strong>指向子网的广播IP地址</strong>(主机地址全为1)以及<strong>指向所有子网的广播IP地址</strong>(子网地址和主机地址去全为1)。</p>
<p>　　第一跳路由器的IP地址称为<strong>默认网关</strong>。</p>
<span id="more"></span>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/nat.svg" class="" title="nat">
<p>　　<strong>网络地址转换</strong>是将数据报中的IP地址转换成另一个IP地址，主要用于实现内网访问公网的功能。</p>
<p>　　在互联网中每个<strong>自治系统</strong>由一组受相同管理控制的路由器组成，通常在一个ISP中的路由器以及互联它们的链路构成一个自治系统。自治系统由全局唯一的AS号(ASN)所标识。在同一自治系统中的路由器运行相同的路由选择算法并有彼此的信息。</p>
<p>　　在一个自治系统内运行的路由选择协议称为<strong>自治系统内部路由选择协议</strong>。自治系统间的路由选择协议称为<strong>自治系统间路由选择协议</strong>。两者的差别主要体现在策略、规模以及性能这三个方面。</p>
<p>　　●
从策略的角度，AS内部都在同一管理控制下，策略在AS内部路由选择中起着微不足道的作用；AS间路由选择承载了路径属性并提供路由信息的受控分布，以便能做出基于策略的路由选择决策。</p>
<p>　　●
从规模的角度，规模不是AS内部路由选择的关注重点，但它是AS间路由选择协议的关键问题。</p>
<p>　　●
从性能的角度，AS内部路由选择协议注重路由的性能；AS间路由选择是面向策略的，因此所选路由的性能是次要问题。</p>
<p>　　互联网中所有AS运行相同的AS间路由选择协议，即<strong>边界网关协议</strong>，边界网关协议还常用于实现<strong>IP任播</strong>。</p>
<p>　　<strong>存根网络</strong>又称为桩网络或末端网络，指仅有一条(默认)路径连接到其他网络。</p>
<p>　　<strong>网络功能虚拟化</strong>指将用服务器、交换机和存储设备来代替复杂的中间盒。</p>
<h3 id="路由器">4.1 路由器</h3>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/router_architecture.svg" class="" title="router_architecture">
<p>　　线路终端的功能是结束传入物理链路的物理层功能。</p>
<p>　　数据链路处理的功能是与位于传入链路远端的数据链路层交互的数据链路层功能。</p>
<p>　　当一条链路是双向时，输入端口和输出端口通常成对出现在同一线路卡上。</p>
<h4 id="ip地址转发">4.1.1 IP地址转发</h4>
<p>　　每台路由器都有<strong>转发表</strong>。路由选择处理器通过路由选择协议与其他路由器中的路由选择处理器交互来计算/更新转发表。在SDN路由器中，路由选择处理器用来接收远程控制器计算的转发表项并更新转发表。</p>
<p>　　路由选择处理器经过独立总线将转发表复制到线路卡。通过转发表的副本，每个输入端口就可以本地完成转发，避免了集中式处理的瓶颈。</p>
<p>　　路由器根据分组目的地址的<strong>前缀</strong>与转发表中的表项进行匹配。当有多个匹配项时，路由器使用<strong>最长前缀匹配规则</strong>。</p>
<p>　　可以使用<strong>三态内容寻址存储器</strong>来保证查询转发表所需时间维持在一个常数内。</p>
<p>　　找到分组的输出端口后，分组就可以进入交换结构了，但如果该输出端口已被占用，分组可能在进入交换结构前暂时阻塞。</p>
<h4 id="交换结构">4.1.2 交换结构</h4>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/three_switching_techniques.svg" class="" title="three_switching_techniques">
<p>　　● <span
style="background-color: yellow">经内存交换</span>：最简单、最早的路由器是传统的计算机，输入端口与输出端口之间的交换是在CPU(路由选择处理器)的直接控制下完成的。输入/输出端口的功能就像传统操作系统中的I/O设备一样。当分组到达到达一个输入端口时，该端口先通过中断方式向路由选择控制器发送信号，该分组从输入端口复制到内存，路由选择处理器从分组首部中获取IP，查询转发表获取输出端口并将分组复制到输出端口的缓存中。若内存每秒能读/写<span
class="math inline">\(B\)</span>个分组，则总转发吞吐量必定小于<span
class="math inline">\(\frac{B}{2}\)</span>，因为共享系统总线每次仅能执行一个内存读/写。</p>
<p>　　● <span
style="background-color: yellow">经总线交换</span>：输入端口经一根共享总线将分组直接传输到输出端口，不需要路由选择控制器的干预。输入端口预先为分组指定一个交换机内部标签(仅用来跨越总线)并指示输出端口。每个输出端口都能收到该分组，但只有指定的输出端口才能保存该分组，指定的输出端口保存分组后去掉标签。每次仅有一个分组能跨域总线，故分组有时需要等待，导致路由器的带宽受限于总线速率。</p>
<p>　　● <span
style="background-color: yellow">经互联网络交换</span>：纵横式交换机是由<span
class="math inline">\(2N\)</span>条总线构成的互联网络，包括<span
class="math inline">\(N\)</span>个输入端口和<span
class="math inline">\(N\)</span>个输出端口。每条垂直的总线与每条水平的总线交叉，交叉点通过交换结构控制器实现随时开启/闭合。纵横式交换机是<strong>非阻塞</strong>的，只有两个或以上的分组同时转发到同一个输出端口，分组不会阻塞，否则会出现分组等待。</p>
<p>　　部分现代路由器也通过内存进行交换，不过转发表的查找和将分组存储进适当的内存存储位置是由输入线路卡来处理。</p>
<p>　　更复杂的互联网络使用多级交换元素来使多个分组同时转发到同一输出端口时无需等待。例如，在三级非阻塞交换策略中，输入/输出端口连接到<span
class="math inline">\(N\)</span>个交换结构，输入端口将分组分成<span
class="math inline">\(K\)</span>个较小的块并通过<span
class="math inline">\(N\)</span>个交换结构发送这<span
class="math inline">\(K\)</span>个块到指定输出端口，输出端口再将这<span
class="math inline">\(K\)</span>个块组装成原本的分组。</p>
<h4 id="排队">4.1.3 排队</h4>
<p>　　假设纵横式交换机有<span
class="math inline">\(N\)</span>个输入端口和<span
class="math inline">\(N\)</span>个输出端口且输入线路与输入线路速率相同，都为<span
class="math inline">\(R_{line}(packet/s)\)</span>。此外，所有分组具有相同的固定长度，以同步的方式到达输入端口且采用FCFS方式，即所有链路发送/接收分组的时间相等。用<span
class="math inline">\(R_{switch}\)</span>表示分组从输入端口传输到输出端口的速率并假设<span
class="math inline">\(R_{switch}=N\times R_{line}\)</span>。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/hol_blocking.svg" class="" title="hol_blocking">
<p>　　一个输入队列中排队的分组阻塞后，队列中该分组之后的分组也会阻塞，这种情况称为<strong>线路前部阻塞</strong>。由于HOL阻塞，当输入链路分组的到达速率达到其容量的<span
class="math inline">\(58\%\)</span>时，在某些假设前提下，输入端口的队列长度将无限制地增大。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/output_port_queueing.svg" class="" title="output_port_queueing">
<p>　　当没有足够缓存时，要么丢弃到达的分组(即弃尾策略)，要么删除排队中的分组。在某些情况下，在缓存填满之前便丢弃分组或在其首部加上标记，这可以向发送端反馈拥塞信号，这种策略称为<strong>主动队列管理</strong>策略。RED算法是最广泛研究与实现的AQM算法之一。</p>
<p>　　<span class="math inline">\(B\)</span>表示缓存容量，<span
class="math inline">\(C\)</span>表示链路容量，通常<span
class="math inline">\(B=RTT\times
C\)</span>，大量(N条)TCP流量经过同一链路时<span
class="math inline">\(B=\frac{RTT\times C}{\sqrt{N}}\)</span>。</p>
<h4 id="链路分组调度">4.1.4 链路分组调度</h4>
<p>　　<strong>链路分组调度</strong>指排队分组在链路上传输的方式。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/fifo_or_fcfs_queueing_model.svg" class="" title="fifo_or_fcfs_queueing_model">
<p>　　FIFO/FCFS调度规则按照分组到达输出链路队列的顺序来传输分组。当链路正忙于传输其他分组时，到达链路输出队列的分组需要排队等待传输。若缓存不足则需要丢弃分组。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/priority_queueing_model.svg" class="" title="priority_queueing_model">
<p>　　在<strong>优先级排队</strong>规则下，到达输出链路的分组被分类放入输出队列的优先级类队列，每个类通常都有对应的队列。当传输分组时，从优先级最高且非空的队列中选择分组进行传输。<span
style="background-color: yellow">同一优先级</span>队列的分组采用FIFO方式。在非抢占式优先级排队规则下，一旦分组开始传输就不能打断。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/weighted_fair_queueing_model.svg" class="" title="weighted_fair_queueing_model">
<p>　　在<strong>循环排队</strong>规则下，分组会被分类，但是类之间不存在严格的优先级，循环调度器在这些类之间轮流提供服务。在<strong>保持工作排队</strong>规则下，有分组待传输时不会允许链路空闲，当指定类里不存在分组时，会立即检查循环序列中的下一个类。<strong>加权公平排队</strong>就是循环排队的一种通用实现方式，它也是保持工作队列。</p>
<p>　　WFQ与循环排队的不同之处在于每个类在任何时间间隔内可能收到<span
style="background-color: yellow">不同数量</span>的服务。对于WFQ，若有<span
class="math inline">\(n\)</span>个类存在分组待传输，类<span
class="math inline">\(i\)</span>的权值为<span
class="math inline">\(w_i\)</span>，即使所有类都有分组排队，类<span
class="math inline">\(i\)</span>总能保证至少<span
class="math inline">\(\frac{w_i}{\sum_{j=1}^{n}{w_j}}\times
R\)</span>的吞吐量。</p>
<h3 id="网际协议">4.2 网际协议</h3>
<h4 id="ipv4数据报">4.2.1 IPv4数据报</h4>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/ipv4_datagram_format.svg" class="" title="ipv4_datagram_format">
<p>　　IPv4数据报包括4位<strong>版本(号)</strong>、4位<strong>首部长度</strong>、8位<strong>服务类型</strong>(3位优先级、4位服务类型子字段和1位必须为零)、16位<strong>数据报长度</strong>、16位<strong>标识</strong>、3个<strong>标志位</strong>、13位<strong>片偏移</strong>、8位<strong>生存时间</strong>、8位<strong>上层协议</strong>、16位<strong>首部检验和</strong>、32位<strong>源IP地址</strong>、32位<strong>目的IP地址</strong>、最多<span
class="math inline">\(40B\)</span>的<strong>可选项</strong>和有效载荷。</p>
<p>　　版本规定了IP协议版本。由于不同版本的IP协议数据报格式不同，需要版本字段来确定。</p>
<p>　　首部长度<span style="background-color: yellow">以<span
class="math inline">\(4B\)</span>为单位</span>表示首部长度。</p>
<p>　　服务类型用来区分不同类型的数据报。前3位是优先级字段，第4位到第6位是DTR字段，第4位到第7位是服务类型子字段，最后一位必须为零。服务类型子字段最多只能有1位为1。</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>000</td>
<td>routine</td>
<td>默认</td>
</tr>
<tr>
<td>001</td>
<td>priority</td>
<td>数据业务</td>
</tr>
<tr>
<td>010</td>
<td>immediate</td>
<td>数据业务</td>
</tr>
<tr>
<td>011</td>
<td>flash</td>
<td>语音控制数据</td>
</tr>
<tr>
<td>100</td>
<td>flash override</td>
<td>视频会议或视频流</td>
</tr>
<tr>
<td>101</td>
<td>critic</td>
<td>语音数据</td>
</tr>
<tr>
<td>110</td>
<td>internetwork control</td>
<td>网络控制数据</td>
</tr>
<tr>
<td>111</td>
<td>network control</td>
<td>网络控制数据</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>服务类型子字段</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>normal service</td>
</tr>
<tr>
<td>1000</td>
<td>minimize delay</td>
</tr>
<tr>
<td>0100</td>
<td>maximize throughout</td>
</tr>
<tr>
<td>0010</td>
<td>maximize reliability</td>
</tr>
<tr>
<td>0001</td>
<td>minimize monetary cost</td>
</tr>
</tbody>
</table>
<p>　　生存时间表示数据报能经过的最大路由器数量，每当路由器处理数据报时该字段值减1，当该字段值为0时丢弃该数据报。</p>
<p>　　由于源到目的地路径的上的每段链路使用的链路层协议可能不同，不同协议的最大传输单元可能不同，所以可能需要将数据报分成多个较小的数据报并封装成合适的链路层帧，这些较小的数据报称为<strong>片</strong>。片到达目的地后需要重组成原始数据报再交给传输层。重组过程在端系统完成，因为组装会增加协议复杂性和降低路由器的性能。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/ipv4_datagram_fragmentation.svg" class="" title="ipv4_datagram_fragmentation">
<p>　　标识、标志位以及片偏移用于分片和重组。标识是数据报的唯一值，分片时会复制到各个片中。3个标志位中第1位是保留位，第2位是禁止分片标志位，第3位是还有分片标志。DF为1时表示不能分片，MF为1时表示不是最后一个片。片偏移<span
style="background-color: yellow">以<span
class="math inline">\(8B\)</span>为单位</span>表示片在原始数据报中的相对位置。</p>
<p>　　上层协议表示传输层所用协议的协议号。1表示ICMP，2表示IGMP，6表示TCP，17表示UDP，89表示OSPF。</p>
<p>　　首部校验和<span
style="background-color: yellow">仅用来校验数据报中的首部</span>，计算方式类似于UDP的校验和。由于每次经过路由器时首部中的某些字段会改变，所以需要重新计算。</p>
<h4 id="ipv4编址">4.2.2 IPv4编址</h4>
<p>　　每个IPv4地址长度是32位，因此共有<span
class="math inline">\(2^{32}\)</span>个可能的IP地址。IP地址通常使用<strong>点分十进制表示法</strong>。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/ipv4_classful_addressing.svg" class="" title="ipv4_classful_addressing">
<p>　　IPv4<strong>分类编制</strong>包括A、B、C三类普通地址以及D、E两类特殊地址。A类地址一般用于大型网络，B类地址一般用于中型网络，C型地址一般用于小型网络，D类地址是多播地址，E类地址是保留地址。</p>
<p>　　互联网的地址分配策略称为<strong>无类别域间路由选择</strong>。CIDR不在使用分类编址，IP地址表示为<code>a.b.c.d/x</code>。<code>x</code>表示网络地址所占的位数，该部分称为该地址的<strong>前缀</strong>，剩余的几位则表示主机地址。其地址掩码依然是子网掩码。使用单个网络前缀通告多个网络称为<strong>地址聚合</strong>或<strong>路由聚合</strong>或<strong>路由摘要</strong>。</p>
<h4 id="dhcp">4.2.3 DHCP</h4>
<p>　　<strong>动态主机配置协议</strong>允许主机自动获得IP地址、子网掩码、默认网关以及本地DNS服务器地址，故也称为<strong>即插即用协议</strong>或<strong>零配置协议</strong>。DHCP是C/S体系结构，客户端即新到达的主机，若子网没有DHCP服务器则会由一个通常是路由器的DHCP中继代理，中继代理能够获取DHCP服务器。</p>
<p>　　DHCP分配IP地址包括<strong>人工配置</strong>、<strong>自动配置</strong>和<strong>动态配置</strong>。人工配置即管理员手动分配。自动配置即服务器为首次连接网络的客户端分配一个永久IP地址，客户端一直使用该IP地址。动态配置即按服务器为首次连接网络的客户端分配一个期限IP地址，到期后停止使用或续约。</p>
<p>　　DHCP租约表包括<strong>静态租约表</strong>和<strong>动态租约表</strong>，分别对应静态租约存储文件和周期存储文件。静态租约表中的IP地址不能重复使用。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/dhcp_message_format.svg" class="" title="dhcp_message_format">
<p>　　DHCP属于<strong>引导程序协议</strong>，DHCP报文格式符合BOOTP报文格式。</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 16%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr>
<th>字段</th>
<th>长度(单位是B)</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>op</td>
<td>1</td>
<td>报文类型，1表请求报文，2表示响应报文</td>
</tr>
<tr>
<td>htype</td>
<td>1</td>
<td>客户端硬件地址类型，1表示以太网地址</td>
</tr>
<tr>
<td>hlen</td>
<td>1</td>
<td>客户端硬件地址长度</td>
</tr>
<tr>
<td>hops</td>
<td>1</td>
<td>跳数，客户端置0</td>
</tr>
<tr>
<td>xid</td>
<td>4</td>
<td>报文的唯一值</td>
</tr>
<tr>
<td>secs</td>
<td>2</td>
<td>客户端获取到IP地址或续约成功到现在所消耗的时间，若未获得IP地址则为0</td>
</tr>
<tr>
<td>flags</td>
<td>2</td>
<td>DHCP仅用到了第一位，0表示单播的方式，1表示广播的方式，其余位保留</td>
</tr>
<tr>
<td>ciaddr</td>
<td>4</td>
<td>客户端IP地址</td>
</tr>
<tr>
<td>yiaddr</td>
<td>4</td>
<td>服务器分配给客户端的IP地址</td>
</tr>
<tr>
<td>siaddr</td>
<td>4</td>
<td>服务器IP地址</td>
</tr>
<tr>
<td>giaddr</td>
<td>4</td>
<td>网关IP地址</td>
</tr>
<tr>
<td>chaddr</td>
<td>16</td>
<td>客户端硬件地址</td>
</tr>
<tr>
<td>sname</td>
<td>64</td>
<td>服务器主机名，全为0则表示没有</td>
</tr>
<tr>
<td>file</td>
<td>128</td>
<td>引导文件名，全为0则表示没有</td>
</tr>
<tr>
<td>vender</td>
<td>可变</td>
<td>采用CLV模式，对于DHCP，必须以固定值01100011 10000010 01010011
01100011开头，表示Magic cookie，即之后是vender</td>
</tr>
</tbody>
</table>
<p>　　DHCP有8种报文，根据<code>Optiont(53)</code>可以区分，即<strong>DHCP发现报文</strong>、<strong>DHCP提供报文</strong>、<strong>DHCP请求报文</strong>、<strong>DHCP
ACK报文</strong>、<strong>DHCP
NAK报文</strong>、<strong>DHCP拒绝报文</strong>、<strong>DHCP释放报文</strong>和<strong>DHCP信息报文</strong>。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/dhcp_client_server_interaction.svg" class="" title="dhcp_client_server_interaction">
<p>　　1)
DHCP服务器发现。新到达的DHCP客户端首先需要寻找DHCP服务器。DHCP客户端以广播的方式发送DHCP发现报文，报文段封装成数据报时源IP地址是<code>0.0.0.0</code>，目的IP地址使用广播地址。</p>
<p>　　2)
DHCP服务器提供。所有收到DHCP发现报文的DHCP服务器发送包括发现报文的事务ID、推荐IP地址、子网掩码以及IP<strong>地址租用期</strong>的DHCP提供报文来响应，报文段封装成数据报时目的IP地址使用广播地址，因为子网中可能存在多个新到达的DHCP客户端。若为静态租用则匹配硬件地址，若为动态租约则检测DHCP发现报文中是否包含有效<code>yiaddr</code>，有则进一步检测是否可用，否则从IP地址池中分配一个最小可用的IP地址。</p>
<p>　　3)
DHCP请求。DHCP客户端可能会收到多个DHCP提供报文，DHCP客户端选择一个并发送包含配置参数的DHCP请求报文来响应。报文段封装成数据报时源IP地址是<code>0.0.0.0</code>，目的IP地址使用广播地址。</p>
<p>　　4) DHCP
ACK/NAK。DHCP服务器根据客户端的状态进行响应，若客户端处于<code>selecting</code>则验证<code>yiaddr</code>和<code>siaddr</code>是否匹配，若客户端处于<code>init_reboot</code>则验证<code>yiaddr</code>是否匹配，若客户端处于<code>renewing/rebinding</code>则验证<code>ciaddr</code>是否匹配，若都不匹配以单播的方式发送DHCP
NAK报文，否则发送DHCP ACK报文。</p>
<p>　　● 当客户端的IP地址租期到<span
class="math inline">\(\frac{1}{2}\)</span>，客户端会以单播的方式向原服务器发送DHCP请求报文，若收到DHCP
ACK报文则续租成功并更新租期，最多可重发3次，分别在4s、8s和16s后。</p>
<p>　　● 当客户端的IP地址租期到<span
class="math inline">\(\frac{7}{8}\)</span>，客户端会以广播的方式向所有服务器发送DHCP请求报文，若收到DHCP
ACK报文则更新租约，最多可重发3次，分别在4s、8s和16s后。</p>
<p>　　租约到期则重新开始【发现-提供-请求-确认】这4个步骤。</p>
<p>　　若客户端收到DHCP
ACK报文后，向网络发送3个此IP地址的ARP解析请求以执行冲突检测。若出现冲突，客户端向服务器发送DHCP拒绝报文来重新获取IP地址，服务器会将租约表中关于客户端硬件地址置空并保持该IP地址一段时间。若客户端<span
style="background-color: yellow">不再需要当前IP地址或租约到期</span>，向服务器发送DHCP释放报文。若客户端需要获取租约的详细信息，可以向服务器发送DHCP信息报文，服务器会以DHCP
ACK报文响应。</p>
<h4 id="ipv6">4.2.4 IPv6</h4>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/ipv6_datagram_format.svg" class="" title="ipv6_datagram_format">
<p>　　IPv6数据报包括8位<strong>版本(号)</strong>、8位<strong>流量类别</strong>、16位<strong>流标签</strong>、16位<strong>有效载荷长度</strong>、8位<strong>下个首部</strong>、8位<strong>跳限制</strong>、<span
class="math inline">\(16B\)</span><strong>源IP地址</strong>、<span
class="math inline">\(16B\)</span><strong>目的IP地址</strong>、非必需且长度不定的扩展首部以及有效载荷。</p>
<p>　　流量类别等同于IPv4数据报中的服务类型。</p>
<p>　　类标签用于区分实时流量，不同的流标签+源IP地址可以确定唯一的数据流。</p>
<p>　　有效载荷长度包括<span
style="background-color: yellow">扩展首部的长度+有效载荷的长度</span>，若超过<span
class="math inline">\(65535B\)</span>则使用扩展首部中的超大有效载荷来表示。</p>
<p>　　下个首部类似于IPv4数据报中的上层协议，若存在下一个扩展首部则表示下一个扩展首部的编号，否则表示传输层协议的编号。</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 16%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr>
<th>扩展首部类型</th>
<th>对应的下个首部值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>逐跳选项扩展首部</td>
<td>0</td>
<td>用于为在传输链路上每跳转发指定参数，传输链路的每台中间节点都要读取并处理该字段。主要应用包括超大有效载荷、设备提示以及资源预留</td>
</tr>
<tr>
<td>路由选择扩展首部</td>
<td>43</td>
<td>用于强制让数据报经过特定的设备</td>
</tr>
<tr>
<td>分片扩展首部</td>
<td>44</td>
<td>用于分片</td>
</tr>
<tr>
<td>封装安全有效载荷扩展首部</td>
<td>50</td>
<td>由IPsec使用，提供认证、数据完整性校验以及重放保护，类似于认证</td>
</tr>
<tr>
<td>认证扩展首部</td>
<td>51</td>
<td>由IPsec使用，提供认证、数据完整性校验、首部部分字段保护以及重放保护</td>
</tr>
<tr>
<td>目的选项扩展首部</td>
<td>60</td>
<td>携带只有目的主机才会处理的信息</td>
</tr>
</tbody>
</table>
<p>　　跳限制等同于IPv4数据报中的生存时间。</p>
<p>　　IPv6数据报必须按照指定顺序：首部、逐跳选项首部扩展首部、目的选项扩展首部、路由选择扩展首部、分片扩展首部、认证扩展首部、封装安全有效载荷扩展首部、目的选项扩展首部以及有效载荷。</p>
<p>　　IPv6<span
style="background-color: yellow">只允许源主机和目的主机</span>进行分片与重组。若路由器收到的数据报因太大无法转发到链路上，则路由器丢弃该数据报并向发送端发送一个ICMP差错报文，然后发送端以较小长度的数据报重发。</p>
<p>　　由于传输层和链路层的协议都有差错检测，故IPv6并没有校验和。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/tunneling.svg" class="" title="tunneling">
<p>　　IPv4迁移到IPv6的方法是<strong>建立隧道</strong>。其基本思想是：假设两个IPv6主机需要使用IPv6数据报进行交互，但它们的传输路径经过IPv4路由器，将路径上的IPv4路由器集合为一个<strong>隧道</strong>，借助隧道，将IPv6数据报作为IPv4数据报的有效载荷。</p>
<h3 id="路由选择算法">4.3 路由选择算法</h3>
<p>　　无向图<span class="math inline">\(G=(N,E)\)</span>是一个<span
class="math inline">\(N\)</span>个节点和<span
class="math inline">\(E\)</span>条边的集合，其中每条边是取<span
class="math inline">\(N\)</span>的一对节点。节点可以表示路由器，连接节点的边可以表示路由器之间的物理路径。对于<span
class="math inline">\(E\)</span>中的任意一条边<span
class="math inline">\((x,y)\)</span>，<span
class="math inline">\(c(x,y)\)</span>表示节点<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>的成本。若节点对<span
class="math inline">\((x,y)\)</span>不属于<span
class="math inline">\(E\)</span>，则<span
class="math inline">\(c(x,y)=\infty\)</span>，否则两个节点互称<strong>邻居</strong>。<span
class="math inline">\(u\)</span>表示源节点。</p>
<p>　　对于任何两个节点<span class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>，通常有很多条路径，这些路径中的一条或多条是<strong>最低成本路径</strong>。当所有边的成本相同时，最低成本路径就是<strong>最短路径</strong>。</p>
<p>　　节点<span class="math inline">\(x\)</span>到节点<span
class="math inline">\(y\)</span>的最低成本可以用Bellman-Ford算法表示，即<span
class="math inline">\(d_{x}(y)=min_{v}\{c(x,v)+d_{v}(y)\}\)</span>，其中<span
class="math inline">\(v\)</span>表示<span
class="math inline">\(x\)</span>的所有邻居。</p>
<p>　　路由选择算法根据集中式/分布式可以分为<strong>集中式路由选择算法</strong>和<strong>分布式路由选择算法</strong>，根据静态/动态可以分为<strong>静态路由选择算法</strong>和<strong>动态路由选择算法</strong>，根据负载的敏感可以分为<strong>负载敏感算法</strong>和<strong>负载迟钝算法</strong>。</p>
<p>　　●
集中式路由选择算法以网络拓扑以及所有链路的成本为输入。具有全局状态信息的算法称为<strong>链路状态算法</strong>。</p>
<p>　　●
分布式路由选择算法中，每个节点开始时仅有与其直连链路的成本信息，然后通过迭代计算过程以及与相邻节点交换信息，逐渐计算出到达某个或某组目的节点的最低成本路径。每个节点维护到其他节点的成本(距离)估计的向量称为<strong>距离向量算法</strong>，主要通过与相邻路由器间交换交互式报文。</p>
<p>　　●
静态路由选择算法中路由选择随时间的变化非常缓慢，通常是人工进行调整。</p>
<p>　　●
动态路由选择算法随着网络流量负载或拓扑变化而改变路由选择路径。一个动态路由选择算法可以周期性地或直接响应拓扑或链路成本变化。</p>
<p>　　●
负载敏感算法中，链路成本会动态地变化来反映底层链路的当前拥塞水平。若当前拥塞的链路与高成本相关联则该算法会趋向绕开该拥塞链路来选择路由。</p>
<p>　　●
负载迟钝算法中，链路成本不会明确地反映其当前会最近的拥塞水平。</p>
<p>　　<strong>收敛</strong>指网络中所有路由器的路由选择表中的信息完全一致。</p>
<h4 id="ls算法">4.3.1 LS算法</h4>
<p>　　链路状态算法通过让每个节点向网络中所有其他节点广播链路状态分组来获得网络拓扑以及所有链路成本，其中每个链路状态分组包含它所连接的链路的标识和成本，这通常由<strong>链路状态广播算法</strong>来完成。</p>
<p>　　Dijkstra算法从某节点到网络中所有其他节点的最低成本路径，该算法是迭代算法，迭代<span
class="math inline">\(k\)</span>次后可以获得<span
class="math inline">\(k\)</span>个目的节点的最低成本路径。<span
class="math inline">\(D(v)\)</span>表示到本次迭代为止，从源节点<span
class="math inline">\(u\)</span>到节点<span
class="math inline">\(v\)</span>的最低成本路径的成本。<span
class="math inline">\(p(v)\)</span>表示源节点<span
class="math inline">\(u\)</span>到节点<span
class="math inline">\(v\)</span>的当前最低成本路径中<span
class="math inline">\(v\)</span>的前一节点。<span
class="math inline">\(N&#39;\)</span>表示节点子集，若源节点<span
class="math inline">\(u\)</span>到节点<span
class="math inline">\(v\)</span>的最低成本路径已知，则<span
class="math inline">\(N&#39;\)</span>包含<span
class="math inline">\(v\)</span>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 初始化阶段：N&#x27;仅包含u，若v是u的邻居则D(v) = c(u,v)，p(v) = u，否则D(v) = ∞ */</span><br><span class="line">Initialization:</span><br><span class="line">　N&#x27; = &#123;u&#125;</span><br><span class="line">　for all nodes v</span><br><span class="line">&amp;#12288;&amp;#12288;if v is a neighbor of u</span><br><span class="line">&amp;#12288;&amp;#12288;　D(v) = c(u, v)</span><br><span class="line">&amp;#12288;&amp;#12288;else D(v) = ∞</span><br><span class="line">/* 循环阶段：查找不在N&#x27;中且到u的最短成本路径最小的节点w，将w加入N&#x27;。若节点v不在N&#x27;中且是w的邻居则更新D(v)和p(v)。当N&#x27;包含所有节点时结束循环 */</span><br><span class="line">Loop</span><br><span class="line">　find w not in N&#x27; such that D(w) is a minimum</span><br><span class="line">　add w to N&#x27;</span><br><span class="line">　update D(v) for each neighbor v of w and not in N&#x27;:</span><br><span class="line">&amp;#12288;&amp;#12288;D(v) = min(D(v), D(w) + c(w, v))</span><br><span class="line">until N&#x27; = N</span><br></pre></td></tr></table></figure>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/link_state_algorithm_in_operation.svg" class="" title="link_state_algorithm_in_operation">
<p>　　LS算法结束后，获得了除源节点以外的每个节点的最低成本路径以及前一节点。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/osciallations_with_congestion_sensitive_routing.svg" class="" title="osciallations_with_congestion_sensitive_routing">
<p>　　当出现振荡时，最简单的解决方法是强制链路成本与承载的流量无关，但是这违背了路由选择的初衷之一——避开拥塞严重的链路。另一种解决方法是确保并非所有的路由器都同时运行LS算法。路由器最初在同一周期的不同时间执行算法，但最终算法会在路由器上同步并一直保持。避免这种自同步的方法之一就是让每台路由器发送链路通告的时间随机化。</p>
<h4 id="dv算法">4.3.2 DV算法</h4>
<p>　　根据Bellman-Ford算法可以实现邻居间的通信，基本思想是对应每个节点<span
class="math inline">\(x\)</span>以<span
class="math inline">\(D_x(y)\)</span>开始，对于<span
class="math inline">\(N\)</span>中的所有节点<span
class="math inline">\(y\)</span>，估计从<span
class="math inline">\(x\)</span>到<span
class="math inline">\(y\)</span>的最低成本路径的成本。<span
class="math inline">\(D_x=[D_x(y):y\in N]\)</span>表示节点<span
class="math inline">\(x\)</span>的距离向量，该向量是从<span
class="math inline">\(x\)</span>到<span
class="math inline">\(N\)</span>中所有目的地节点<span
class="math inline">\(y\)</span>的成本估计向量。</p>
<p>　　使用DV算法，每个节点<span
class="math inline">\(x\)</span>需要维护自身的距离向量<span
class="math inline">\(D_x=[D_x(y):y\in N]\)</span>，每个邻居<span
class="math inline">\(v\)</span>的成本<span
class="math inline">\(c(x,v)\)</span>以及每个邻居<span
class="math inline">\(v\)</span>的距离向量<span
class="math inline">\(D_v=[D_v(y):y\in
N]\)</span>。每个节点不时地向每个邻居发送它的距离向量副本，邻居收到新的距离向量时，保存该距离向量并使用Bellman-Ford算法更新自身的距离向量。当节点的距离向量因收到邻居的距离向量或链路成本变化而改变时，该节点需要向所有邻居发送改变后的距离向量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initialization:</span><br><span class="line">　for all destinations y in N:</span><br><span class="line">&amp;#12288;&amp;#12288;Dₓ(y) = c(x, y)</span><br><span class="line">　for each neighbor v</span><br><span class="line">&amp;#12288;&amp;#12288;Dᵥ(y) = ? for all destinations y in N</span><br><span class="line">　for each neighbor v</span><br><span class="line">&amp;#12288;&amp;#12288;send distance vector Dₓ = [Dₓ(y):y in N] to v</span><br><span class="line">Loop</span><br><span class="line">　wait until link cost changes or receive a distance vector</span><br><span class="line">　for each y in N:</span><br><span class="line">&amp;#12288;&amp;#12288;Dₓ(y) = minᵥ&#123;c(x, y) + Dᵥ(y)&#125;</span><br><span class="line">　if Dₓ(y) changed for any destination y</span><br><span class="line">&amp;#12288;&amp;#12288;send distance vector Dₓ = [Dₓ(y):y in N] to all neighbors</span><br><span class="line">forever</span><br></pre></td></tr></table></figure>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/distance_vector_algorithm_in_operation.svg" class="" title="distance_vector_algorithm_in_operation">
<p>　　假设<span class="math inline">\(t_0\)</span>时刻<span
class="math inline">\(x\)</span>与<span
class="math inline">\(y\)</span>间的链路成本从2变为10，则<span
class="math inline">\(D_y(x)=min\{10+0,1+3\}=4\)</span>，若<span
class="math inline">\(y\)</span>需要发送分组到<span
class="math inline">\(x\)</span>，则需要通过<span
class="math inline">\(z\)</span>，<span
class="math inline">\(t_1\)</span>时刻分组到达<span
class="math inline">\(z\)</span>，但是<span
class="math inline">\(z\)</span>节点的路由选择表中是通过<span
class="math inline">\(y\)</span>到达<span
class="math inline">\(x\)</span>，然后就出现了<strong>路由选择环路</strong>，即从<span
class="math inline">\(y\)</span>发往<span
class="math inline">\(x\)</span>的分组在<span
class="math inline">\(y\)</span>和<span
class="math inline">\(z\)</span>间来回传输。在<span
class="math inline">\(t_1\)</span>后的某个时刻，<span
class="math inline">\(z\)</span>收到了<span
class="math inline">\(y\)</span>的新距离向量，即<span
class="math inline">\(D_y(x)=4\)</span>，重新计算到<span
class="math inline">\(x\)</span>的最低成本<span
class="math inline">\(D_z(x)=min\{7+0,1+4\}=5\)</span>，<span
class="math inline">\(t_2\)</span>时刻<span
class="math inline">\(y\)</span>收到<span
class="math inline">\(z\)</span>的新距离向量，即<span
class="math inline">\(D_z(x)=5\)</span>，重新计算到x的最低成本<span
class="math inline">\(D_y(x)=min\{10+0,1+5\}=6\)</span>，这个过程会一直持续到<span
class="math inline">\(D_z(y)=11\)</span>，然后<span
class="math inline">\(z\)</span>确定到<span
class="math inline">\(x\)</span>的最低成本路径就是直接到<span
class="math inline">\(x\)</span>而不是通过<span
class="math inline">\(y\)</span>。当<span
class="math inline">\(c(x,y)\)</span>从4变为10000时，这种情况可以称为<strong>无穷计数</strong>问题。</p>
<p>　　通过<strong>毒性逆转</strong>可以解决这种<span
style="background-color: yellow">仅涉及2个节点</span>的简单路由选择环路，若<span
class="math inline">\(z\)</span>需通过<span
class="math inline">\(y\)</span>到达<span
class="math inline">\(x\)</span>，则发送<span
class="math inline">\(D_z(x)=\infty\)</span>的新距离向量给<span
class="math inline">\(y\)</span>来毒化<span
class="math inline">\(z\)</span>到<span
class="math inline">\(y\)</span>的逆向路径。<span
class="math inline">\(y\)</span>会发送<span
class="math inline">\(D_y(x)=10\)</span>的新距离向量给<span
class="math inline">\(z\)</span>，因为<span
class="math inline">\(y\)</span>不再通过<span
class="math inline">\(z\)</span>到<span
class="math inline">\(x\)</span>，之后<span
class="math inline">\(z\)</span>发送<span
class="math inline">\(D_z(x)=7\)</span>的新距离向量给<span
class="math inline">\(y\)</span>，<span
class="math inline">\(y\)</span>更新到<span
class="math inline">\(x\)</span>的最低成本路径的成本<span
class="math inline">\(D_y(x)=8\)</span>，此时<span
class="math inline">\(z\)</span>位于<span
class="math inline">\(y\)</span>到<span
class="math inline">\(x\)</span>的最低成本路径上，<span
class="math inline">\(y\)</span>发送<span
class="math inline">\(D_y(x)\)</span>的新距离向量来毒化<span
class="math inline">\(y\)</span>到<span
class="math inline">\(z\)</span>的逆向路径。</p>
<h4 id="ls算法与dv算法的比较">4.3.3 LS算法与DV算法的比较</h4>
<p>　　在LS算法的具体实现中，每个节点需要将该节点到所有邻居的直接相连链路的成本广播到其他所有节点。而在DV算法的具体实现中，每个节点仅需将已知的该节点到其他节点的估计最低成本发送给所有邻居。</p>
<p>　　● 从报文复杂性的角度，LS算法需要发送<span
class="math inline">\(O(|N||E|)\)</span>个报文，当某条链路的成本改变时需要重新向其他节点发送报文；DV算法需要迭代的过程中仅邻居间交换报文，当某个节点到另一节点的最低成本路径的成本改变时才发送改变后的路径成本。</p>
<p>　　● 从收敛速率的角度，LS算法的收敛所需时间为<span
class="math inline">\(O(|N|^2)\)</span>；DV算法的收敛速率较慢，收敛的过程中可能会出现路由选择环路以及无穷计数。</p>
<p>　　●
从健壮性的角度，LS算法使用了广播的形式，每个节点仅计算自身的路由选择表，即每个节点在一定程度上是分离的，若某个节点损坏或丢弃了某个收到的分组也只会影响自身的路由选择表，保证了一定的健壮性；DV算法中每次迭代中每个节点的计算的最低成本路径的成本会发送给邻居，在下次迭代中会进一步扩散，经过一段时间，一个错误的最低成本路径的成本会扩散到整个网络。</p>
<h3 id="ospf">4.4 OSPF</h3>
<p>　　OSPF是一种链路状态协议，它使用链路状态信息泛洪和Dijkstra最低成本路径算法。<strong>链路状态通告</strong>包含在OSPF报文中，OSPF报文由<span
style="background-color: yellow">直接由IP承载</span>。每台路由器都构建了整个AS的完整拓扑图，然后每台路由器在本地运行Dijkstra最低成本路径算法，以确定以自身为根节点到所有子网的最短路径树。OSPF不强制设置路径权值，而是提供一种协议，为给定链路权值集合确定最低成本路径的路由选择。</p>
<p>　　OSPF协议中，当一条链路的状态发生变化时，路由器会广播链路状态信息，即使未发生变化，路由器也周期性地广播链路状态信息。OSPF协议需要检测链路是否正常运行(通过邻居间发送HELLO报文)，允许路由器获得邻居网络范围内链路状态的数据库。</p>
<p>　　OSPF的优点包括安全、多条相同成本的路径、对单播与多播路由选择的综合支持以及支持单个AS中的层次结构。</p>
<p>　　●
OSPF协议提供了报文认证来保证安全性。OSPF报文默认不启用认证，可以配置简单认证和MD5认证。简单验证基于配置在所有路由器中的共享密码，但密码会以明文的形式出现在OSPF报文中。MD5认证基于配置在所有路由器上的共享密钥，发送路由器在OSPF报文中加入报文内容加密钥的MD5散列值。MD5认证与序号一起使用来防止重放攻击。</p>
<p>　　●
当存在多条成本相等的路径时，无须仅选择单一的路径来承载所有的流量。</p>
<p>　　● MOSPF是OSPF的简单扩展，用来提供多播的支持。</p>
<p>　　●
一个OSPF自治系统可以分层并配置为区域，其中只能存在一个主干区域，每个区域都运行自身的LS算法。在每个区域内，一台或多台区域边界路由器负责为发往区域外的分组提供路由选择。主干区域包含所有的区域边界路由器，可能包含一些非边界路由器。分组在区域间的路由选择需要先区域内路由到一个区域边界路由器，再通过主干区域路由到目的区域的区域边界路由器，最后路由到目的地。</p>
<h3 id="bgp">4.5 BGP</h3>
<p>　　在BGP中，分组并不是路由到一个特定的目的IP地址，而是路由到类似于CIDR的前缀，该前缀表示一个子网或一个子网的集合。因此，路由器的转发表将具有<span
class="math inline">\((x,I)\)</span>形式的表项，<span
class="math inline">\(x\)</span>表示诸如138.116.68/22的前缀，<span
class="math inline">\(I\)</span>表示该路由器的某个接口的接口号。</p>
<p>　　BGP允许每个子网向互联网的其他部分通告它的存在，同时确保所有AS收到该通告。</p>
<p>　　一台路由器可能知道多条到指定前缀的不同路由，为了确定最好的路由，而最好的路由基于策略以及可达性信息来确定，该路由器将在本地运行BGP路由选择(类似于DV算法，通过邻居获得前缀的可达性信息)。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/ebgp_and_ibgp_connections.svg" class="" title="ebgp_and_ibgp_connections">
<p>　　在BGP中，每条直接连接以及所有通过该连接发送的报文称为<strong>BGP连接</strong>。若BGP连接跨越AS则称为<strong>外部BGP</strong>连接，若在同一AS则称为<strong>内部BGP</strong>连接。内部BGP连接<span
style="background-color: yellow">并不总是</span>对应物理链路。建立BGP连接的两个路由器互称<strong>BGP对等体</strong>，其中发送BGP报文的路由器称为<strong>BGP发言者</strong>。</p>
<p>　　对于每个AS，其中的路由器是要么是<strong>网关路由器</strong>，要么是<strong>内部路由器</strong>。网关路由器位于AS边缘，内部路由器仅连接AS内部的主机和路由器。</p>
<p>　　假设需要通告前缀<span
class="math inline">\(x\)</span>的可达性信息，以跳数较多的路径为例，首先网关路由器3a向网关路由器2c发送EBGP报文“AS3
<span
class="math inline">\(x\)</span>”，然后网关路由器2c向AS2内的所有其他路由器发送IBGP报文“AS3
<span
class="math inline">\(x\)</span>”，最后网关路由器2a向网关路由器1c发送EBGP报文"AS2
AS3 <span class="math inline">\(x\)</span>"。</p>
<p>　　路由器通过BGP连接通告前缀时，前缀中包括一些<strong>BGP属性</strong>，前缀及其属性称为<strong>路由</strong>。BGP属性分为<strong>公认必遵</strong>、<strong>公认任意</strong>、<strong>可选传递</strong>和<strong>可选非传递</strong>。</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 53%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr>
<th>BGP属性类别</th>
<th>BGP属性类别详情</th>
<th>包含的BGP属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>公认必遵</td>
<td>所有BGP路由器必须支持，必须包含于更新报文中</td>
<td>ORIGIN、AS_PATH、NEXT_HOP</td>
</tr>
<tr>
<td>公认任意</td>
<td>所有BGP路由器必须支持</td>
<td>LOCAL_PREF、ATOMIC_AGGREGATE</td>
</tr>
<tr>
<td>可选传递</td>
<td>可以不支持，即使不支持也应该能接收包含该属性的路由并传递给邻居</td>
<td>COMMUNITY、AGGREGATOR</td>
</tr>
<tr>
<td>可选非传递</td>
<td>可以不支持，若不支持则可以忽略包含该属性的更新报文</td>
<td>MULTI_EXIT_DISC、ORIGINATOR_ID、CLUSTER_ID</td>
</tr>
</tbody>
</table>
<p>　　<strong>ORIGIN</strong>标识路由信息的来源。</p>
<p>　　<strong>AS_PATH</strong>包含了通告已通过的AS列表，可用来检测和防止通告环路，若路由器在AS_PATH中发现包含了自身所属的AS则拒绝该通告。</p>
<p>　　<strong>NEXT_HOP</strong>是<span
style="background-color: yellow">AS_PATH起始路由器接口的IP地址</span>。对于从AS1通过AS2到<span
class="math inline">\(x\)</span>的路由"AS2 AS3 <span
class="math inline">\(x\)</span>"，NEXT_HOP是路由器2a的左边接口的IP地址。对于AS1直接路由到AS3的路由"AS3
<span
class="math inline">\(x\)</span>"，NEXT_HOP是路由器3d的最左边接口的IP地址。</p>
<p>　　<strong>LOCAL_PREF</strong>表示路由的优先级，仅用在IBGP对等体间，由<span
style="background-color: yellow">本地AS的路由选择策略</span>决定。</p>
<p>　　<strong>ATOMIC_AGGREGATE</strong>表示路由已聚合。</p>
<p>　　<strong>COMMUNITY</strong>表示共享相同属性的目的地集合，用于将路由信息编组，通过组的标识决定路由策略的传递。</p>
<p>　　<strong>AGGREGATOR</strong>是ATOMIC_AGGREGATE的补充，包含发起路由聚合的ASN和形成聚合路由的BGP发言者的IP地址。</p>
<p>　　<strong>MULTI_EXIT_DISC</strong>用于区分同一相邻AS的多个接口。</p>
<p>　　<strong>ORIGINATOR_ID</strong>用于标识路由反射器。</p>
<p>　　<strong>CLUSTER_ID</strong>用于标识路由反射器组。</p>
<h4 id="bgp路由选择">4.5.1 BGP路由选择</h4>
<p>　　<strong>热土豆路由选择</strong>可以从所有可能的路由中选择到对应NEXT_HOP路由器成本最小的路由，忽略剩余端到端成本。</p>
<p>　　使用热土豆路由选择在转发表中增加AS外部目的前缀的步骤如下：</p>
<p>　　1) 从AS间路由选择协议知道可通过多个网关到达子网<span
class="math inline">\(x\)</span>。</p>
<p>　　2)
通过AS内部路由选择协议获取的路由选择信息来计算到每个网关的最低成本路径的成本。</p>
<p>　　3) 热土豆路由选择，即选择成本最低的网关。</p>
<p>　　4) 从转发表确定通往最低成本网关的接口<span
class="math inline">\(I\)</span>并在转发表中加入表项<span
class="math inline">\((x,I)\)</span>。</p>
<p>　　BGP实际使用的路由选择算法结合了热土豆路由选择的特点但更复杂。对应给定的目的前缀，算法的输入是到路由器已知悉且接受的到该前缀的所有路由的集合。若集合中多个路由则按下列消除原则直至最后一条路由：</p>
<p>　　1)
路由被分配LOCAL_PREF作为BGP属性之一。路由的LOCAL_PREF可能已由路由器设置，也可能已从同一AS中的另一台路由器获悉。选择具有最高LOCAL_PREF的路由。</p>
<p>　　2)
选择具有最短AS_PATH的路由。若该规则是路由选择的唯一规则，则BGP将使用DV算法决定路径，其中距离测量使用AS跳的跳数而非路由器跳的跳数。</p>
<p>　　3) 使用热土豆路由选择，选择到NEXT_HOP路由器成本最小的路由。</p>
<p>　　4) 使用BGP标识符来选择路由。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/simple_policy_scenario.svg" class="" title="simple_policy_scenario">
<p>　　假设A、B、C是主干提供商网络且它们直接向彼此发送流量，并向它们的客户网络提供全部的BGP信息，则W、Y是接入ISP，X是<strong>多宿接入ISP</strong>。可以通过控制BGP路由的通告的方式保证W、X和Y的存根网络行为，例如，X可能知道到Y的一条路径(XCY)，但X<span
style="background-color: yellow">不会</span>将此路径通告给B，因此B也不会经由X来转发到C或Y的分组。</p>
<p>　　所有进入接入ISP网络的流量必定是以该网络为目的地，所有离开接入ISP网络的流量必定源自该网络。</p>
<p>　　各个对等协议通常都是ISP双方协商且通常对外保密。</p>
<p>　　商业规则是任何流经ISP提供商网络的流量的源或目的地(或两者)必须位于该ISP的客户网络中，否则这些流量将免费通过该ISP的网络。</p>
<h4 id="ip任播">4.5.2 IP任播</h4>
<p>　　当BGP被用于实现IP任播时，常用于DNS中。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/ip_anycast_forwards_requests_to_the_closest_cdn_server.svg" class="" title="ip_anycast_forwards_requests_to_the_closest_cdn_server">
<p>　　在IP任播配置时，CDN公司为多台CDN服务器指派了<span
style="background-color: yellow">相同的IP地址</span>，然后这些服务器中的每一台都使用BGP来通告该IP地址。当某台BGP路由器收到该IP地址的多个路由通告时，它将这些通告视为到同一物理位置的不同路径，配置路由选择表时，路由器将在本地使用BGP路由选择算法来确定最合适的路由。实际中CDN通常不使用IP任播，因为BGP路由选择的变化可能导致同一的TCP连接的的分组到达Web服务器的不同实例。</p>
<p>　　在DNS系统中，IP任播常用于将DNS请求指向最近的根DNS服务器。</p>
<h3 id="sdn">4.6 SDN</h3>
<p>　　SDN体系结构包括<strong>基于流的转发</strong>、<strong>数据平面和控制平面分离</strong>、<strong>网络控制</strong>以及<strong>可编程网络</strong>这4个关键特征。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/sdn_architecture.svg" class="" title="sdn_architecture">
<p>　　控制平面由SDN控制器(或网络操作系统)以及若干网络控制应用程序(运行在网络控制服务器上)组成。控制器维护准确的网络状态信息并为网络控制应用程序提供这些信息，还为这些应用程序提供方法来监控、编程以及控制底层网络设备。</p>
<p>　　SDN控制器的功能可分为<strong>通信层</strong>、<strong>网络范围状态管理层</strong>和<strong>网络控制应用层的接口</strong>。</p>
<p>　　●
若SDN控制器需要控制远程设备，则需要一个协议(OpenFlow)来为SDN控制器和该设备传输信息。此外，该设备必须能够将本地观察到达的事件传输给SDN控制器。SDN控制器和受控网络设备之间的通信跨越了SDN控制器的南向接口。</p>
<p>　　●
SDN控制平面做出的最终控制决策将要求SDN控制器具有网络主机、链路、交换机和其他SDN控制的设备的最新状态信息。交换机的流表包含计数器，其值可以为网络控制应用程序所用。因为控制平面的最终目标是确定各种受控设备的流表，SDN控制器可能也维护这些表的副本。</p>
<p>　　●
SDN控制器通过它的北向接口与网络控制应用程序交互。该接口允许网络控制应用程序在状态管理层中读取/写入网络状态和流表。应用程序可以注册以状态更新事件时收到通知，这样它们可以采取行动以响应来自受控于SDN的设备发送的网络事件通知。</p>
<h4 id="openflow">4.6.1 OpenFlow</h4>
<p>　　<span
style="background-color: yellow">OpenFlow</span>是一个得到高度认可和成功的标准，它开创了匹配加动作转发抽象、控制器的概念以及更广泛的SDN革命。实际应用包括简单转发、负载均衡以及防火墙。</p>
<p>　　匹配加动作转发表在OpenFlow中称为<strong>流表</strong>。表项包括首部字段值的集合、计数器集合以及匹配项对应的动作集合。当匹配成功时更新计数器，计数器可能包括匹配成功分组的数量以及上次更新时间。匹配失败的分组将被丢弃或发送到远程控制器进行更多处理。在实践中，一个流表可能由多个流表实现。动作包括转发给指定的一个或多个输出端口、丢弃、复制以及重写部分首部字段。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/packet_matching_fields_of_openflow_1.0_flow_table.svg" class="" title="packet_matching_fields_of_openflow_1.0_flow_table">
<p>　　支持OpenFlow的设备可以充当路由器转发分组以及充当交换机转发帧。以太网类型对应用来分解复用帧的有效载荷的传输层协议。</p>
<p>　　输入端口指路由器接收分组的输入端口。</p>
<p>　　流表项可以使用通配符<code>*</code>。每个流表项具有优先级。</p>
<p>　　动作中重要的动作包括转发、丢弃和修改字段。</p>
<p>　　●
分组可以转发到指定的物理输出端口，可以广播到所有端口，也可以通过所选的端口集合进行多播。该分组可能被封装并发送到远程控制器，远程控制器可能会对分组进行某些动作，例如，安装新的流表项并可能返回分组来更新流表项来根据更新的流表项转发。</p>
<p>　　● 没有对应动作时分组将被丢弃。</p>
<p>　　●
分组被转发到指定的输出端口之前，源MAC地址、目的MAC地址、以太网类型、局域网ID、局域网优先级、源IP地址、目的IP地址、服务类型、源端口、目的端口这些字段的值可以重写。</p>
<p>　　从SDN控制器流向受控路由器的重要报文包括<span
style="background-color: yellow">配置</span>报文、<span
style="background-color: yellow">修改状态</span>报文、<span
style="background-color: yellow">读取状态</span>报文、<span
style="background-color: yellow">发送分组</span>报文。配置报文允许SDN控制器查询并设置路由器的配置参数。修改状态报文用于增加/删除/修改路由器流表中的表项并设置路由器的端口属性。读取状态报文用于从路由器的流表和端口收集统计数据以及计数器值。发送分组报文用于从受控路由器的指定端口发送特定报文，报文的有效载荷包含分组。</p>
<p>　　从受控路由器流向SDN控制器的重要报文包括<span
style="background-color: yellow">流删除</span>报文、<span
style="background-color: yellow">端口状态</span>报文、<span
style="background-color: yellow">分组进入</span>报文。流删除报文用于通知SDN控制器已删除一个流表项。端口状态报文用于向SDN控制器通知端口状态的变化。分组进入报文用于分组匹配成功的分组发给SDN控制器。</p>
<h4 id="数据平面与控制平面的交互">4.6.2 数据平面与控制平面的交互</h4>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/sdn_scenario_link_state_change.svg" class="" title="sdn_scenario_link_state_change">
<p>　　Dijkstra算法是实现在每台路由器中泛洪链路状态更新，这里Dijkstra算法作为路由器外部的一个单独的程序而且路由器将链路更新发送到SDN控制器而非彼此。</p>
<p>　　假设OpenFlow作为通信层协议，控制平面只执行路由选择。此外，s1与s2之间的链路出现了故障。</p>
<p>　　1) s1使用OpenFlow的端口状态报文通知SDN控制器链路状态改变。</p>
<p>　　2)
SDN控制器收到报文后通知链路状态管理器，链路状态管理器更新链路状态数据库。</p>
<p>　　3)
因为用于实现Dijkstra算法的网络控制应用程序之前已经注册，网络控制应用程序收到了链路状态更改的通知。</p>
<p>　　4)
链路状态应用程序与链路状态管理器交互以获取最新的链路状态信息，也可能会与链路状态管理层的其他组件交互，然后计算新的最低成本路径。</p>
<p>　　5) 链路状态应用程序与流表管理器交互来更新流量。</p>
<p>　　6) 流表管理器使用OpenFlow更新受影响路由器的流表项。</p>
<h4 id="sdn的发展">4.6.3 SDN的发展</h4>
<p>　　Google的B4网络使用定制的交换机，每台交换机实现了OpenFlow的扩展版并带有本地OpenFlow代理。每个OFA与网络控制服务器中的OpenFlow控制器连接，使用单独的带外网络，该网络不同于数据中心间传输数据中心流量的网络。OpenFlow控制器因此提供网络控制服务器和其受控交换机之间的通信。在B4中，OpenFlow控制器还执行状态管理功能，将节点与链路信息保存在网络信息数据库中。OpenFlow控制器的实现基于ONIX
SDN控制器。B4网络实现了BGP和IS-IS(类似于OSPF)。</p>
<p>　　在SDN发展早期，采用单一的SDN协议(OpenFlow)和单一的SDN控制器。后来，OpenDaylight(ODL)控制器和ONOS控制器得到业界广泛支持。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/opendaylight_simplified_architecture.svg" class="" title="opendaylight_simplified_architecture">
<p>　　<strong>网络服务应用程序</strong>用于决定受控路由器完成数据平面转发和其他服务(如防火墙和负载均衡)。ODL控制器的核心是<strong>基本网络服务功能</strong>。控制器有REST接口和服务抽象层这2个接口，外部应用程序通过HTTP上的REST接口与控制器通信，内部应用程序通过SAL相互通信。应用程序实现在控制器外部还是控制器内部由应用程序设计者决定。</p>
<p>　　SAL允许控制器组件和应用程序互相调用并订阅彼此生成的事件，它还为通信层中特定的协议(如OpenFlow、SNMP和OVSDB)提供统一的抽象接口。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/onos_simplified_architecture.svg" class="" title="onos_simplified_architecture">
<p>　　ONOS作为服务部署在一组互联的服务器上，每台服务器都运行相同的ONOS软件副本。</p>
<p>　　ONOS的一个独特功能是它的意图框架，它允许网络控制应用程序请求高级服务而无须了解该服务的具体信息。状态信息通过北向接口以同步(查询)或异步(监听器回调)提供给应用程序。</p>
<p>　　ONOS的分布式核心维护网络链路、主机以及设备的状态等。ONOS核心提供复制和实例间协调机制，为上层的应用程序和下层的受控设备提供逻辑上的集中式核心服务抽象。</p>
<p>　　ONOS的南向接口屏蔽底层主机、链路、交换机和协议的差异，允许分布式核心和这些无关。</p>
<h3 id="icmp">4.7 ICMP</h3>
<p>　　ICMP虽然是网络层协议，但ICMP报文作为IP数据包的有效载荷，类似于TCP和UDP。ICMP最典型的用途是差错报告。基于ICMP的常用程序是ping和traceroute。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/icmp_message_format.svg" class="" title="icmp_message_format">
<table>
<thead>
<tr>
<th>ICMP type</th>
<th>ICMP code</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>echo(ping) reply</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>destination network unreachable</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>destination host unreachable</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>destination protocol unreachable</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>destination port unreachable</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
<td>destination network unknown</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
<td>destination host unknown</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>source quench(congestion control)</td>
</tr>
<tr>
<td>8</td>
<td>0</td>
<td>echo(ping) request</td>
</tr>
<tr>
<td>9</td>
<td>0</td>
<td>router advertisement</td>
</tr>
<tr>
<td>10</td>
<td>0</td>
<td>router discovery</td>
</tr>
<tr>
<td>11</td>
<td>0</td>
<td>TTL exceeded</td>
</tr>
<tr>
<td>12</td>
<td>0</td>
<td>IP header bad</td>
</tr>
</tbody>
</table>
<p>　　源抑制报文最初的目的是用于拥塞控制，即发送或对方减小发送速率。</p>
<p>　　在traceroute中，为了确定源主机和目的主机之间的路由器的主机板和IP地址，源主机向目的主机发送了一系列的IP数据报，这些数据报都带有一个不可达的UDP端口的UDP报文段，其中第<span
class="math inline">\(n\)</span>个数据报的TTL为<span
class="math inline">\(n\)</span>。因此，当第<span
class="math inline">\(n\)</span>个数据报到达第<span
class="math inline">\(n\)</span>个路由器时TTL刚好过期，路由器丢弃数据报并向源主机发送ICMP报文(type=11,code=0)，该报文包括路由器的主机名以及IP地址。当数据报到达目的主机时，由于UDP端口不可达，目的主机会向源主机发送ICMP报文(type=3,code=3)，源主机收到该报文后停止发送数据报。</p>
<h3 id="网络管理">4.8 网络管理</h3>
<p>　　<strong>网络管理</strong>包括对硬件、软件和人为元素的部署、集成和协调，以便对网络资源进行监视、测试、轮询、配置、分析、评估和控制，这样能以合理的成本满足诸如实时运行性能、服务质量等需求。</p>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/components_of_network_management.svg" class="" title="components_of_network_management">
<p>　　网络管理的重要组件包括管理服务器、被管设备、MIB数据、远程代理以及SNMP。</p>
<p>　　管理服务器是一个应用程序，通常有人的参与，并在网络运营中心的集中式管理站上运行。管理服务器用于网络管理，负责网络管理信息的收集、处理、分析以及显示。</p>
<p>　　被管设备是被管网络中的网络设备(包括软件)。一个被管设备内可能有几个<strong>被管对象</strong>。这些被管对象包括被管设备中的实际硬件(例如，网络接口卡是主机或路由器的一个组件)以及用于这些硬件和软件组件的配置参数(例如，AS内部路由选择协议)。</p>
<p>　　被管设备中的每个被管对象的相关信息收集在<strong>管理信息库</strong>中，这些信息可供管理服务器使用。一个管理信息库的对象称为SMI，可以是计数器、收到的UDP报文的数量、描述性信息或状态信息等。</p>
<p>　　每个被管设备上都有<strong>网络管理代理</strong>，它是一个与管理服务器通信的进程，在管理服务器的命令和控制下在被管设备执行本地操作。</p>
<p>　　<strong>网络管理协议</strong>在管理服务器与被管设备间运行，运行管理服务器查询被管设备的状态并通过代理间接地在被管设备上采取行动。代理通过网络管理协议通知管理服务器异常事件。</p>
<p>　　<strong>简单网络管理协议</strong>用于管理服务器和被管设备上的网络管理代理之间传输网络管理控制和信息报文。SNMP常用模式是请求响应模式，管理服务器向代理发送请求，代理收到请求后执行某些操作并响应请求。请求通常用于查询或修改被管设备相关的MIB对象值。另一种情况是代理向管理服务器发送未被请求的报文，该报文称为<strong>陷阱报文</strong>。陷阱报文是异步产生的，即不是为了响应报文，而是为了响应管理服务器要求通知的事件，用于通知管理服务器异常情况导致MIB对象值改变。</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 34%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr>
<th>PDU类型</th>
<th>发送端-接收端</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GetRequest</td>
<td>管理服务器到代理</td>
<td>获取一个或多个MIB对象值</td>
</tr>
<tr>
<td>GetNextRequest</td>
<td>管理服务器到代理</td>
<td>获取下一个MIB对象值</td>
</tr>
<tr>
<td>GetBulkRequest</td>
<td>管理服务器到代理</td>
<td>获取大数据块的值</td>
</tr>
<tr>
<td>InformRequest</td>
<td>管理服务器到管理服务器</td>
<td>通知<span
style="background-color: yellow">远程</span>管理服务器远程访问的MIB值</td>
</tr>
<tr>
<td>SetRequest</td>
<td>管理服务器到代理</td>
<td>设置一个或多个MIB对象值</td>
</tr>
<tr>
<td>Response</td>
<td>代理到管理服务器/管理服务器到管理服务器</td>
<td>响应GetRequest、GetNextRequest、GetBulkRequest、InformRequest和SetRequest</td>
</tr>
<tr>
<td>Trap</td>
<td>代理到管理服务器</td>
<td>通知管理服务器异常事件</td>
</tr>
</tbody>
</table>
<img src="/2022/07/02/computer-networking-a-top-down-approach-7e-chpt-4/snmp_pdu_format.svg" class="" title="snmp_pdu_format">
<p>　　SNMP通常基于UDP，但UDP并不可靠，类似于rdt，管理服务器用Request
Id来标识报文。SNMP并没有强制重传，若需要重传，管理服务器设置重传频率和周期。</p>
<p>　　GetRequest、GetNextRequest、GetBulkRequest
PDU请求的值在PDU的变量绑定部分。GetRequest、GetNextRequest、GetBulkRequest
PDU的数据请求颗粒度不同，
GetRequest可以请求任意一组MIB值，多个GetNextRequest可用于对MIB对象的列表或表格进行排序，GetBulkRequest用于返回大块数据，相比多个GetRequest或GetNextRequest减小了成本。代理会使用包含对象标识符以及相关值的PDU来响应。</p>
<p>　　代理用带有"noError"错误状态的PDU来响应SetRequest。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法 第7版》第8章 多媒体网络</title>
    <url>/2022/09/10/computer-networking-a-top-down-approach-7e-chpt-8/</url>
    <content><![CDATA[<p>　　视频最为显著的特点是<strong>高比特率</strong>，另一个重要特点是可以被压缩，从而在视频质量和比特率之间权衡。视频有两种类型的冗余，都可以用来进行<strong>视频压缩</strong>。<span
style="background-color: yellow">空间冗余</span>是给定图像的内部冗余，主要由空白组成的图像具有高度冗余，可以在不牺牲图像质量下进行冗余。<span
style="background-color: yellow">时间冗余</span>反映了图像间的重复。可以通过压缩来生成<strong>多重版本</strong>的视频，不同版本具有不同的质量等级。</p>
<p>　　模拟音频信号以某个固定速率进行采样，每个采样值近似取值为有限数量的值之一，该过程称为<strong>量化</strong>，这些值的数量称为<strong>量化值</strong>，通常是2的幂。每个量化值由固定数量的位表示。解码后的的信号只是原始信号的近似值，音质可能有所下降(可能丢失高频的声音)。增加采样率和量化值的数量可以让解码后的信号更接近原始信号。</p>
<p>　　<strong>脉冲编码调制</strong>是一种音频编码技术，语音使用的PCM采用速率是每秒8000个样本，每个样本用8位表示，因此速率是<span
class="math inline">\(64Kb/s\)</span>。音频光盘使用的PCM采用速率是每秒44100个样本，每个样本用16位表示，单声道速率为<span
class="math inline">\(705.6Kb/s\)</span>，立体声速率为<span
class="math inline">\(1.411Mb/s\)</span>。</p>
<p>　　压缩也可以用于降低音频流的比特率，人类语音可以压缩到小于<span
class="math inline">\(10Kb/s\)</span>且依旧可以理解。用于接近CD质量的立体声音乐的流行压缩技术是<strong>MP3</strong>(MPEG
1 layer 3)，MP3编码器可以压缩到不同的速率，<span
class="math inline">\(128Kb/s\)</span>的编码速率可以保证很小的声音失真，一种相关标准是<strong>高级音频编码</strong>。</p>
<p>　　多媒体应用大致可以分为<span
style="background-color: yellow">流式存储音频/视频</span>、<span
style="background-color: yellow">会话式IP语音/视频</span>和<span
style="background-color: yellow">流式实况音频/视频</span>。</p>
<p>　　<strong>流式传输</strong>时，客户端在从服务器接收音频/视频一段时间后就可以播放，在播放的同时继续接收剩余部分，避免了在播放前需要接收整个文件。</p>
<p>　　●
流式存储视频依赖的媒体是服务器上预先录制的视频，用户向服务器请求以按需观看视频。流式存储视频的特点是<strong>流媒体</strong>、<strong>交互性</strong>和<strong>不间断播放</strong>。由于视频是预先录制的，用户可以进行快进等操作并获得即时响应。视频播放开始后应按照录制的时序进行，因此必须从服务器及时接收数据。流式存储音频与流式存储视频相同。</p>
<p>　　●
互联网上的实时会话式语音通常称为<strong>网络电话</strong>或<strong>IP语音</strong>。因为从用户的角度，它类似于传统的电话交换服务。会话式语音/视频是<span
style="background-color: yellow">时延敏感</span>但<span
style="background-color: yellow">容忍丢包</span>的。</p>
<p>　　●
流式实况音频/视频类似于传统的电台和电视，只是它通过互联网传输。</p>
<p>　　分发存储和实况视频经常使用CDN。</p>
<p>　　对于VOIP等会话时实时应用，重传一个错过预计播放时间的分组没有意义。</p>
<span id="more"></span>
<h3 id="流式存储视频">8.1 流式存储视频</h3>
<p>　　流式视频系统分为<strong>UDP流</strong>、<strong>HTTP流</strong>和<strong>自适应HTTP流</strong>。这三种形式的视频流的共同特点是广泛使用了客户端应用程序的缓存来减轻变化的的端到端时延以及变化的客户端和服务器间可用带宽的影响。这种<strong>客户端缓存</strong>不仅可以吸收服务器到客户端时延中的波动，而且当其未完全耗尽时，即使服务器到客户端的带宽暂时低于视频消耗速率，客户端也能维持不间断播放。</p>
<img src="/2022/09/10/computer-networking-a-top-down-approach-7e-chpt-8/client_playout_delay_in_video_streaming.svg" class="" title="client_playout_delay_in_video_streaming">
<p>　　假设视频以固定的比特率编码，因此每个视频块包含在固定时间<span
class="math inline">\(\Delta\)</span>播放的视频帧。服务器在<span
class="math inline">\(t_0\)</span>传输第一个视频块，在<span
class="math inline">\(t_0+\Delta\)</span>传输第二个视频块，依此类推。一旦客户端开始播放，每个块应该在前一个块之后播放<span
class="math inline">\(\Delta\)</span>时间单元来保证原始视频录制时的时序。若在<span
class="math inline">\(t_1\)</span>就开始播放视频则第二块不能在<span
class="math inline">\(t_1+\Delta\)</span>内到达，相反，若<span
class="math inline">\(t_3\)</span>开始播放，此时前6块已到达，所有收到的块都能按序且不间断地播放。</p>
<h4 id="udp流">8.1.1 UDP流</h4>
<p>　　UDP流通常使用的客户端缓存较小。由于UDP没有拥塞控制，服务器能够以客户端的视频消耗速率的传输视频。在视频块传递给UDP前，服务器将视频块封装在传输分组中，该传输分组专为传输音频/视频设计，使用了<strong>实时传输协议</strong>或<strong>会话发起协议</strong>等类似的方案。RTP可用于传输常见格式和专用的音频和视频格式，它也是其他实时交互协议(如<strong>生成树协议</strong>)的补充。SIP是一个开放的轻量级协议。</p>
<p>　　使用UDP时，除了服务器到客户端的视频流外，客户端和服务器还同时维护一个单独的控制链接，客户端通过该连接发送有关会话状态变化的命令(如暂停、重新开始、重定位等)，<strong>实时流传输协议</strong>是一种用于这种控制连接的协议。</p>
<p>　　UDP存在三个重大缺陷，首先，由于服务器和客户端之间的可用带宽不可预测且不断变化，因此恒定速率UDP流不一定能保证不间断播放。其次，需要RTSP服务器这样的媒体控制服务器来为每个正在进行的客户端会话处理客户端到服务器的交互请求并跟踪客户端状态，这增加了大规模部署成本和复杂性。最后，许多防火墙配置为阻止UDP流量。</p>
<h4 id="http流">8.1.2 HTTP流</h4>
<p>　　在HTTP流中，
视频作为具有特定URL的文件存储在HTTP服务器上。当用户要观看视频时，客户端与服务器建立一个TCP连接并对该URL发起HTTP
GET请求。服务器在HTTP响应报文中发送该视频文件，即以TCP拥塞控制和流控制允许的情况下尽快发送。在客户端，数据被收集在客户端应用程序缓存中。当缓存中的字节数达到阈值就开始播放，它周期性地从客户端应用程序缓存中读取视频帧，对帧解压并在用户屏幕上显示。</p>
<p>　　对于流式存储视频，客户端能够以高于消耗速率的速率下载视频，从而<strong>预取</strong>将被消耗的视频帧。当平均TCP吞吐量大约是媒体比特率的两倍时，TCP流达到最小的饥饿和低缓存时延。</p>
<p>　　由于TCP的拥塞控制机制，服务器到客户端的传输速率可能波动很大，而且分组可能由于重传机制而出现较大的时延。使用了客户端缓存和预取后，这些不一定会妨碍不间断播放。</p>
<p>　　HTTP基于TCP，因此更容易穿越防火墙和NAT。HTTP流无需媒体控制服务器，从而减低大规模部署的成本。</p>
<img src="/2022/09/10/computer-networking-a-top-down-approach-7e-chpt-8/streaming_stored_video_over_http.svg" class="" title="streaming_stored_video_over_http">
<p>　　服务器的视频文件通过套接字后，字节在传输到互联网前存放在TCP发送缓存，当服务器的TCP发送缓存已满时，服务器暂时无法将更多的字节从视频文件发送到套接字。客户端应用程序从TCP接收缓存(通过套接字)读取字节并将字节存放到客户端缓存。同时客户端应用程序周期性地从客户端缓存抓取视频帧并解压播放。若客户端缓存大于该视频文件则从客户端直接按照TCP允许的最快速率从服务器接收视频。</p>
<p>　　当客户端缓存变满时，可能会导致TCP接收缓存边满，进而TCP发送缓存也会变满，服务器不能向套接字中发送字节。因此，播放暂停可能服务器被迫停止传输直到继续播放。在常规的播放中，若客户端缓存变满，进而导致TCP缓存变满，迫使服务器降低发送速率，因此服务器的发送速率不能高于客户端视频消耗速率。因此，当使用HTTP流时，满的客户端缓存间接地限制了服务器到客户端的传输速率。</p>
<p>　　<span
class="math inline">\(B(b)\)</span>表示客户端应用程序的缓存，<span
class="math inline">\(Q(b)\)</span>表示客户端应用程序开始播放前必要的缓存。<span
class="math inline">\(r(b/s)\)</span>表示视频消耗速率。只要客户端应用程序的缓存未满，服务器会以恒定速率<span
class="math inline">\(x(b/s)\)</span>发送数据，则经过<span
class="math inline">\(t_{play}=\frac{Q}{x}\)</span>后首次播放。若<span
class="math inline">\(x&lt;r\)</span>，客户端在开始播放后应用程序缓存会以<span
class="math inline">\(r-x\)</span>的速率消耗，在<span
class="math inline">\(t_{pause}=\frac{Q}{r-x}\)</span>后出现停滞，再经过<span
class="math inline">\(t_{play}\)</span>后开始播放，一直循环这个过程直至结束。若<span
class="math inline">\(x&gt;r\)</span>，客户端在开始播放后应用程序缓存会以<span
class="math inline">\(x-r\)</span>的速率增加，经过<span
class="math inline">\(t_{full}=\frac{B-Q}{x-r}\)</span>后应用程序缓存达到最大值，播放开始后不会停滞。</p>
<p>　　现在进一步假设服务器发送数据的速率<span
class="math inline">\(x\)</span>不是恒定，初始为0，在<span
class="math inline">\(T(s)\)</span>后<span
style="background-color: yellow">线性增长</span>到最大值<span
class="math inline">\(H(b/s)\)</span>，然后变为0并再次线性增长，一直循环这个过程。为了保证不会停滞，需要<span
class="math inline">\(\overline{x}&gt;r\)</span>，因此<span
class="math inline">\(H&gt;2r\)</span>。当<span
class="math inline">\(x\)</span>从0开始线性增长时，其加速度<span
class="math inline">\(\alpha=\frac{H}{T}\)</span>，期间服务器发送数据<span
class="math inline">\(D=\frac{Ht^2}{2T}(b)\)</span>。</p>
<p>　　若需要保证<span class="math inline">\(Q\)</span>最小，则需要<span
class="math inline">\(x\)</span>从0增长到<span
class="math inline">\(r\)</span>期间消耗的数据刚好为<span
class="math inline">\(Q\)</span>，因此<span
class="math inline">\(Q_{min}=\frac{r^2}{2a}=\frac{Tr^2}{2H}\)</span>。</p>
<p>　　HTTP流经常使用HTTP
GET请求报文中的<strong>HTTP字节范围首部</strong>，用来指定客户端当前想要从所需视频中检索的特定字节范围。当需要跳转到视频中未播放的某个时间点时，客户端发送一个新HTTP请求，用字节范围首部指示服务器应该从文件中的对应字节发送，服务器收到后从字节范围首部指示的字节开始发送。当视频跳转到未播放的某个时间点或提前终止时，服务器传输的一些预取但未播放的视频将跳过，导致相关的带宽和服务器资源浪费，无线链路浪费的带宽和服务器资源可能更多。因此，很多流系统进使用了适当的客户端缓存或者使用HTTP请求中的字节范围首部来限制预取的视频。</p>
<h3 id="ip语音">8.2 IP语音</h3>
<p>　　VOIP一般默认使用UDP，当用户位于阻止UDP的NAT或防火墙后时才使用TCP。UDP存在丢包的问题，TCP没有丢包的问题，但TCP的重传会增加端到端时延，而且丢包后由于拥塞控制，发送端的传输速率可能降低到低于接收端的消耗速率，从而可能导致缓存饥饿。</p>
<p>　　实际中，VOIP可以容忍1%到20%的丢包，这取决于语音的编码、传输方式以及接收端隐藏丢包的方式。使用FEC将冗余信息和原始信息一起发送，能够从冗余信息中恢复一些丢失的初始数据。丢包率超过10%~20%则无法采取任何措施来恢复可接受的音频质量。</p>
<p>　　对于VOIP，小于150ms的时延收听者察觉不到，150ms~400ms的时延可以接受，但不够理想，超过400ms就影响语音交谈的质量。因此，VOIP应用程序的接收端通常忽略时延超过阈值的所有分组。</p>
<p>　　分组在路由器中经历的变化的排队时延是端到端时延的组成部分之一，因此发送端生成分组到接收端接收到分组的时间可能随着分组的变化而波动，称为<strong>时延抖动</strong>。</p>
<p>　　时延抖动可以通过<strong>序号</strong>、<strong>时间戳</strong>和<strong>播放时延</strong>来消除。发送端为每个音频块标记其生成时间。类似于流式存储视频的播放时延，接收端的音频块的播放时延必须足够大，以便大多数分组在其预计播放时间之前接收，播放时延可以固定或自适应。</p>
<h4 id="在接收端消除时延抖动">8.2.1 在接收端消除时延抖动</h4>
<p>　　使用固定延迟策略时，接收端尝试在块生成后<span
class="math inline">\(q(ms)\)</span>播放，若块在<span
class="math inline">\(t(ms)\)</span>时被标记时间戳，则接收端在<span
class="math inline">\(t+q\)</span>播放该块，若该块在<span
class="math inline">\(t+q\)</span>后到达则会被丢弃并视为丢包。若网络时延经常出现较大的变化则<span
class="math inline">\(q\)</span>较大更好，若网络时延较小且变化也较小则<span
class="math inline">\(q&lt;150ms\)</span>更好。</p>
<img src="/2022/09/10/computer-networking-a-top-down-approach-7e-chpt-8/packet_loss_for_different_fixed_playout_delays.svg" class="" title="packet_loss_for_different_fixed_playout_delays">
<p>　　对于第一个固定播放时延<span
class="math inline">\(p-r\)</span>，第4个分组在预计时间未到达则认为丢包。对于第二个固定播放时延<span
class="math inline">\(p&#39;-r\)</span>，所有分组都在预计时间内到达。</p>
<p>　　为了尽可能小的播放时延，可以估计网络时延及其变化并在每次语音的突发期开始时相应地调整播放时延，这会导致发送端的静默期的压缩或拉长。对于第<span
class="math inline">\(i\)</span>个分组，<span
class="math inline">\(t_i\)</span>表示生成时间，<span
class="math inline">\(r_i\)</span>表示接收时间，<span
class="math inline">\(p_i\)</span>表示播放时间，<span
class="math inline">\(r_i-t_i\)</span>表示网络时延，<span
class="math inline">\(d_i\)</span>表示收到该分组时的平均网络时延的估计值。<span
class="math inline">\(u\)</span>表示大于0而小于1的常数。 <span
class="math display">\[
d_i=(1-u)d_{i-1}+u(r_i-t_i)
\]</span> 　　<span
class="math inline">\(v_i\)</span>表示估计网络时延与估计的平均网络时延的平均偏差的估计值。
<span class="math display">\[
v_i=(1-u)v_{i-1}+u|r_i-t_i-d_i|
\]</span> 　　若分组<span
class="math inline">\(i\)</span>是语音突发期首个分组，则<span
class="math inline">\(p_i=t_i+d_i+Kv_i\)</span>，<span
class="math inline">\(K\)</span>是一个正的常数，<span
class="math inline">\(Kv_i\)</span>用于将播放时间设置到足够大，保证语音突发期的分组丢包率较低。突发期内之后的每个分组的播放时间被计算为该突发期内首个分组的播放时间的偏移量。语音突发期的首个分组生成到播放的时间跨度<span
class="math inline">\(q_i=p_i-t_i\)</span>，若分组<span
class="math inline">\(j\)</span>属于该突发期，它的播放时刻<span
class="math inline">\(p_j=t_j+q_i\)</span>。</p>
<h4 id="丢包恢复">8.2.2 丢包恢复</h4>
<p>　　VOIP通常使用<span
style="background-color: yellow">FEC</span>和<span
style="background-color: yellow">交织</span>这两种类型的<strong>丢包恢复方案</strong>。</p>
<p>　　FEC的基本思想是在初始的分组流增加冗余信息。以略微增加传输速率为代价，这些冗余信息可以用于重建一些丢失分组的近似或准确版本。</p>
<p>　　一种FEC机制是在每<span
class="math inline">\(n\)</span>个块后发送一个冗余编码块，冗余块通过异或<span
class="math inline">\(n\)</span>个初始块获得，由于接收端在播放前必须收到整个组的分组，因此增加了播放时延。</p>
<img src="/2022/09/10/computer-networking-a-top-down-approach-7e-chpt-8/piggybacking_lower-quality_redundant_information.svg" class="" title="piggybacking_lower-quality_redundant_information">
<p>　　第二种FEC机制是发送一个低质量的音频流作为冗余信息，发送端生成一个标称音频流和与一个相应的低分辨率、低比特率的音频流(标称流可以是<span
class="math inline">\(64Kb/s\)</span>的PCM编码，而低质量的流可以是<span
class="math inline">\(13Kb/s\)</span>的GSM编码。接收端在播放前只需接收两个分组，因此增加的时延较小。若低质量冗余音频的编码比标称音频小很多则增加的额外传输速率并不大。若需要处理连续丢失，发送端可以每个块附加更多低质量块，但同时也会增加传输带宽和播放时延。</p>
<img src="/2022/09/10/computer-networking-a-top-down-approach-7e-chpt-8/send_interleaved_audio.svg" class="" title="send_interleaved_audio">
<p>　　在交织中，发送端在传输前对音频数据单元重新排序，从而使传输流中原本相邻的单元分开。交织可以减轻丢包的影响从而提高音频流的质量。交织不增加流的带宽，且开销也较低，但增加了时延。</p>
<p>　　丢包恢复试图为丢失的分组产生一个相似的代替。音频信号表现除大量的短期自相似性，因此差错掩盖方案适用于丢失率较小(低于15%)和分组较小(小于音素)的场景，但损失长度接近音素的长度时，就会失效，因为听者可能听错。</p>
<h4 id="案例学习skype">8.2.3 案例学习：Skype</h4>
<p>　　对应音频和视频，Skype客户端使用多种不同的编码方式。Skype默认使用UDP发送音频和视频分组，但控制分组通过TCP发送，UDP被拦截时才使用TCP发送音频和视频分组。Skype客户端通过改变视频质量和FEC开销来使其发送的音频流和视频流适应当前网络环境。</p>
<p>　　Skype中除了主机间VOIP使用了P2P，用户定位和NAT穿透也使用了P2P。</p>
<img src="/2022/09/10/computer-networking-a-top-down-approach-7e-chpt-8/skype_peers.svg" class="" title="skype_peers">
<p>　　Skype中对等方组织成一个分层的覆盖网络，对等方分为超级对等方和普通对等方。Skype维护一个将用户映射到当前IP地址(和端口)的索引，该索引分布在超级对等方上。当A需要呼叫B时，客户端会搜索该分布式索引以决定B当前的IP地址。</p>
<p>　　NAT用于阻止外网的主机连接到内网主机，若A和B都有NAT，可以通过超级对等方和<strong>Skype中继</strong>来让A和B建立连接。A向非NAT的超级对等方建立连接，B也向非NAT的超级对等方建立连接。A通知A的超级对等方，A的超级对等方通知B的超级对等方，B的超级对等方再通知B。两个超级对等方选择第三个非NAT的超级对等方作为中继对等方，然后A、B都向中继对等方建立连接。</p>
<p>　　若<span
class="math inline">\(N(N&gt;2)\)</span>个参与者进行音频会议，每个参与者将音频流的副本发送给其他<span
class="math inline">\(N-1\)</span>个参与者，因此需将<span
class="math inline">\(N(N-1)\)</span>个音频流副本发送到网络中。为了减少带宽消耗，每个参与者向发起者发送其音频流，发起者将这些音频流结合为一个流(基本是将所有的音频流信号加在一起)并发送给其他<span
class="math inline">\(N-1\)</span>个参与者，因此需要将<span
class="math inline">\(2(N-1)\)</span>个音频流的副本发送到网络。</p>
<p>　　若<span
class="math inline">\(N(N&gt;2)\)</span>个参与者进行视频会议，视频并不能像音频一样结合为一个流且大多数接入链路的上行链路带宽明显低于下行链路带宽(上行链路可能无法支持P2P方式的<span
class="math inline">\(N-1\)</span>个视频流)，因此每个参与者的视频流被路由选择到一个服务器集群，该集群将该视频流中继给其他<span
class="math inline">\(N-1\)</span>个参与者。</p>
<h3 id="实时会话应用协议">8.3 实时会话应用协议</h3>
<h4 id="rtp">8.3.1 RTP</h4>
<p>　　若应用程序集成了RTP，而不是使用有限载荷类型、序号和时间戳这种专用方案，该应用程序更容易与其他应用程序交互。</p>
<p>　　RTP不提供任何机制来确保及时交互数据或提供其他QOS保证，也不保证分组交互或防止分组失序。RTP允许每个源(例如，一个麦克风或摄像头等)分配其独立的RTP分组流。很多编码技术将音频和视频捆绑在一个流中，因此也只产生一个RTP流。</p>
<p>　　RTP分组不仅限于单播应用，也可以经过一对多和多对多的多播树发送。对于多对多的多播会话，所有的发送端和源通常使用相同的多播组来发送RTP流。一起使用的RTP多播流(例如，视频会议中多个发送端发出的音频和视频流)同属于一个<strong>RTP会话</strong>。</p>
<p>　　对于语音，若语音源使用<span
class="math inline">\(64Kb/s\)</span>的PCM编码，每个编码数据的时间长度是20ms，即每个音频块有<span
class="math inline">\(160B\)</span>，发送端在每个音频块前添加一个RTP首部，RTP首部通常为<span
class="math inline">\(12B\)</span>，音频块和RTP首部一起形成<strong>RTP分组</strong>。</p>
<img src="/2022/09/10/computer-networking-a-top-down-approach-7e-chpt-8/rtp_header_fields.svg" class="" title="rtp_header_fields">
<p>　　RTP首部包括7位<strong>有限载荷类型</strong>、16位<strong>序号</strong>、32位<strong>时间戳</strong>、32<strong>位同步源标识符</strong>以及其他字段。</p>
<p>　　●
有限载荷类型字段表示音频/视频的编码类型。发送端可以在会话过程中改变编码。</p>
<table>
<thead>
<tr>
<th>有限载荷类型</th>
<th>媒体编码格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>PCM μ-law</td>
<td>采样率是8KHz，速率是<span class="math inline">\(64Kb/s\)</span></td>
</tr>
<tr>
<td>1</td>
<td>1016</td>
<td>采样率是8KHz，速率是<span
class="math inline">\(4.8Kb/s\)</span></td>
</tr>
<tr>
<td>3</td>
<td>GSM</td>
<td>采样率是8KHz，速率是<span class="math inline">\(13Kb/s\)</span></td>
</tr>
<tr>
<td>7</td>
<td>LPC</td>
<td>采样率是8KHz，速率是<span
class="math inline">\(2.4Kb/s\)</span></td>
</tr>
<tr>
<td>9</td>
<td>G.722</td>
<td>采样率是16KHz，速率是<span
class="math inline">\(48\sim64Kb/s\)</span></td>
</tr>
<tr>
<td>14</td>
<td>MPEG音频</td>
<td>采样率是90KHz</td>
</tr>
<tr>
<td>15</td>
<td>G.728</td>
<td>采样率是8KHz，速率是<span class="math inline">\(16Kb/s\)</span></td>
</tr>
<tr>
<td>26</td>
<td>MJPEG</td>
<td></td>
</tr>
<tr>
<td>31</td>
<td>H.261</td>
<td></td>
</tr>
<tr>
<td>32</td>
<td>MPEG1视频</td>
<td></td>
</tr>
<tr>
<td>33</td>
<td>MPEG2视频</td>
<td></td>
</tr>
</tbody>
</table>
<p>　　●
发送端每发送一个RTP分组，序号加1，接收端根据序号来检测丢包和恢复分组。</p>
<p>　　● 时间戳表示RTP分组中第一位的采样时刻。</p>
<p>　　●
SSRC用于标识流的源。在RTP会话中通常每个流的SSRC不同。当新的流生成时分配随机数，若两个流分配的SSRC相同则重新分配SSRC。</p>
<h4 id="sip">8.3.2 SIP</h4>
<p>　　SIP是常用于发起和结束呼叫的信令协议，可以用于视频会议和基于文本的会话。实际中，SIP可以作为即时通信应用程序的基本组件。</p>
<p>　　SIP提供了通过IP网络在呼叫者和被呼叫者间建立呼叫的机制，允许呼叫者通知被呼叫者将要开始呼叫，允许参与者就媒体编码达成一致，也允许参与者接收呼叫。</p>
<p>　　SIP为呼叫者提供被呼叫者的当前IP地址。用户可能没有固定IP地址，因为它们可能动态分配IP地址或使用多个IP设备。</p>
<p>　　SIP提供了呼叫管理机制，例如，呼叫期间添加新媒体流、呼叫期间更改编码、呼叫期间邀请新新参与者、呼叫转移和呼叫保持等。</p>
<p>　　SIP是一个带外协议，发送和接收SIP报文使用了不同于发送和接收媒体数据的套接字。SIP报文是ASCII，与HTTP报文类似。SIP要求所有的报文都有确认，因此能够在UDP或TCP上运行。</p>
<img src="/2022/09/10/computer-networking-a-top-down-approach-7e-chpt-8/call_establishment_when_ip_address_is_known.svg" class="" title="call_establishment_when_ip_address_is_known">
<p>　　当A知道B的IP地址时，A通过UDP向B的5060端口发送一个INVITE报文(类似于HTTP请求报文)，此时一个SIP会话开始。INVITE报文包括B的标识符、A当前IP地址、A希望接收的音频格式以及接收端口。B收到INVITE报文后向A的5060端口发送SIP响应报文(类似于HTTP响应报文)，SIP响应报文包括<code>200 OK</code>、B当前IP地址、B希望接收的音频格式以及接收端口。A收到SIP响应报文后响应SIP
ACK报文，然后双方就可以开始发送音频。</p>
<p>　　若B在收到A的INVITE报文后发现不支持A希望接收的音频编码，则会响应<code>606 NOT Acceptable</code>并在报文中列出支持的编码。A从中选择一个编码并再发送一个INVITE报文。B也能直接发送表示拒绝的代码来拒绝呼叫。</p>
<p>　　B的SIP地址是<code>B@193.64.210.89</code>，实际上SIP地址可能类似于email地址或电话号码或姓名等。SIP可以包含于Web页面中，当访问者点击SIP地址，访问者设备中SIP应用将启动并向该SIP地址发送INVITE报文。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">INVITE sip:B@domain.com SIP/2.0</span><br><span class="line"><span class="attribute">Via</span><span class="punctuation">: </span>SIP/2.0/UDP 167.180.112.24</span><br><span class="line"><span class="attribute">From</span><span class="punctuation">: </span>sip:A@hereway.com</span><br><span class="line"><span class="attribute">To</span><span class="punctuation">: </span>sip:B@domain.com</span><br><span class="line"><span class="attribute">Call-ID</span><span class="punctuation">: </span>a2e3a@pigeon.hereway.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/sdp</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>885</span><br><span class="line"> </span><br><span class="line">c=IN IP4 167.180.112.24</span><br><span class="line">m=audio 38060 RTP/AVP 0</span><br></pre></td></tr></table></figure>
<p>　　<code>INVITE</code>行包含SIP版本。每当SIP报文通过SIP设备(包括产生该报文的设备)时，它附加一个<code>Via</code>首部来指示该设备的IP地址。SIP报文包含一个<code>From</code>首部行和一个<code>To</code>首部行。<code>Call-ID</code>是呼叫的唯一标识符。<code>Content-Type</code>表示SIP报文中内容的格式。在一个换车和换行后就是报文的内容部分。</p>
<p>　　每个SIP用户都有一个相关联的<strong>SIP注册器</strong>。SIP注册器的功能类似于权威DNS，将SIP地址转换为IP地址。SIP注册器和<strong>SIP代理</strong>通常运行在同一台设备上。每当启动SIP应用程序时都会向SIP注册器发送SIP注册报文来告知它的当前IP地址。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">REGISTER sip:domain.com SIP/2.0</span><br><span class="line"><span class="attribute">Via</span><span class="punctuation">: </span>SIP/2.0/UDP 193.64.210.89</span><br><span class="line"><span class="attribute">From</span><span class="punctuation">: </span>sip:B@domain.com</span><br><span class="line"><span class="attribute">To</span><span class="punctuation">: </span>sip:B@domain.com</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>3600</span><br></pre></td></tr></table></figure>
<p>　　<code>Expires</code>表示注册有效期，过期后需要重新向SIP注册器注册。</p>
<img src="/2022/09/10/computer-networking-a-top-down-approach-7e-chpt-8/sip_session_initiation.svg" class="" title="sip_session_initiation">
<p>　　若当前IP地址为217.23.56.89的A需要对当前IP地址为197.87.54.21的B发起VOIP会话，A向hereway的SIP代理发送INVITE报文，该代理在注册器上对domain进行DNS查询并将报文转发给domain的SIP注册器。由于B并没有在domain的SIP注册器上注册，该注册器返回一个重定向到temp的应答。hereway的SIP代理向temp的SIP注册器发送INVITE报文，temp的SIP注册器将INVITE报文转发给B，B收到返回SIP响应，temp的SIP注册器将SIP响应转发给hereway的SIP代理并进一步转发给A。至此A、B可以开始传输音频(还有个SIP
ACK)。</p>
<h3 id="多媒体网络">8.4 多媒体网络</h3>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 20%" />
<col style="width: 16%" />
<col style="width: 35%" />
<col style="width: 5%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr>
<th>方法</th>
<th>粒度</th>
<th>保证</th>
<th>机制</th>
<th>复杂度</th>
<th>当前部署状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>尽力而为服务</td>
<td>公平处理所有流量</td>
<td>无/软</td>
<td>应用级支持，CDN，覆盖网络，网络级资源供给</td>
<td>最小</td>
<td>无处不在</td>
</tr>
<tr>
<td>区分服务</td>
<td>不同类型的流量处理不同</td>
<td>无/软</td>
<td>分组标识，监管，调度</td>
<td>中等</td>
<td>部分</td>
</tr>
<tr>
<td>每个连接QOS保证</td>
<td>每个源到目的地流处理不同</td>
<td>一旦流被准入，软/硬</td>
<td>分组标识，监管，调度，呼叫准入和信令</td>
<td>高</td>
<td>很少</td>
</tr>
</tbody>
</table>
<p>　　<strong>带宽供应</strong>指在给定拓扑中能达到给定性能水平的网络链路容量。<strong>网络定制</strong>指设计一个能达到给定水平端到端性能的网络拓扑。</p>
<p>　　为了预测端到端的应用程序级性能，需要考虑<span
style="background-color: yellow">端到端间的流量需求模型</span>、<span
style="background-color: yellow">明确定义的性能要求</span>和<span
style="background-color: yellow">用于预测给定负载模型的端到端性能模型并求出满足所有用户需求的最低成本带宽</span>。</p>
<h4 id="提供多种类型的服务">8.4.1 提供多种类型的服务</h4>
<p>　　在聚合流量(多种流量类型而不是单个连接)中提供了DS。相同类型的流量受到相同的服务，而与它们的所属的端到端连接无关。通过少量的聚合流量而不是大量的单个连接，提供优于尽力而为服务的新型网络机制更简单。</p>
<p>　　<strong>分组标记</strong>使得路由器区分属于不同类型流量的分组。在流量类型间提供一定程度的<strong>流量隔离</strong>防止某类流量受到另一类异常流量的负面影响，同时尽可能地保证资源利用率最大化。</p>
<p>　　一种实现流量隔离的方法是<strong>流量监管</strong>，若需要流量类型或流满足某些准则，可以设置监控机制以确保准则的确被遵守。若被监管的应用程序行为异常，则采取某种行动(丢包或延时)以确保其进入网络的流量符合准则。分组分类、分组标记和流量监管都一起在网络边缘或端系统或边界路由器中实现。另一种实现流量隔离的方法是链路级的分组调度机制为每种流量类型明确地分配固定的链路带宽。</p>
<p>　　流量监管有<span
style="background-color: yellow">平均速率</span>、<span
style="background-color: yellow">峰值速率</span>和<span
style="background-color: yellow">突发大小</span>这3个监管准则。平均速率用于限制较长时间内可以发送网络中的流量，峰值速率用于限制较短时间内可以发送的最大分组数量，突发大小用于限制瞬时发送到网络中分组数量。</p>
<p>　　漏桶机制是可用于描述流量监管准则的一种抽象，一个漏桶可以容纳<span
class="math inline">\(b\)</span>个令牌。可能潜在地添加到桶中的新令牌总是以<span
class="math inline">\(r\)</span>个每秒的速率生成。当生成一个新令牌时，若桶中的令牌数量少于<span
class="math inline">\(b\)</span>则将新令牌添加到桶中，否则，忽略该令牌。</p>
<p>　　漏桶机制可以用来监管分组。若分组被进入到网络之前，它必须先从桶中取出一个令牌。若桶为空，则分组必须等待令牌(或丢弃分组)。桶最多可以容纳<span
class="math inline">\(b\)</span>个令牌，因此最大突发大小是<span
class="math inline">\(b\)</span>个分组。由于令牌生成速率是<span
class="math inline">\(r\)</span>，因此长度为<span
class="math inline">\(t\)</span>的时间间隔内，可以进入网络的最大分组数为<span
class="math inline">\(rt+b\)</span>。此外，令牌的生成速率<span
class="math inline">\(r\)</span>用于限制长期内分组进入网络的平均速率。</p>
<img src="/2022/09/10/computer-networking-a-top-down-approach-7e-chpt-8/leaky_bucket_policer.svg" class="" title="leaky_bucket_policer">
<p>　　可以通过串联漏桶来监管流量的峰值速率，第一个漏桶以<span
class="math inline">\(r\)</span>个令牌每秒的速率生成令牌，其容量为<span
class="math inline">\(b\)</span>个令牌，第二个桶以<span
class="math inline">\(p\)</span>个令牌每秒的速率生成令牌，其容量为1个令牌。显然<span
class="math inline">\(r&lt;p\)</span>，因为<span
class="math inline">\(r&gt;p\)</span>会导致队列溢出并丢失分组。若峰值速率最长持续时间为<span
class="math inline">\(t\)</span>，则<span
class="math inline">\(rt+b=pt\)</span>，因此<span
class="math inline">\(t=\frac{b}{p-r}\)</span>。</p>
<img src="/2022/09/10/computer-networking-a-top-down-approach-7e-chpt-8/n_multiplexed_leaky_bucket_flows_with_wfq_scheduling.svg" class="" title="n_multiplexed_leaky_bucket_flows_with_wfq_scheduling">
<p>　　使用了WFQ调度的路由器的输出链路复用了<span
class="math inline">\(n\)</span>条流。流<span
class="math inline">\(i\)</span>被容量为<span
class="math inline">\(b_i\)</span>和令牌生成速率为<span
class="math inline">\(r_i\)</span>的漏桶监管，至少有<span
class="math inline">\(\frac{w_iR}{\sum_{j=1}^{n}{w_j}}\)</span>的共享链路带宽。若流1的令牌桶最初是满的，然后<span
class="math inline">\(b_1\)</span>个分组突发到达流1的漏桶监管器，因此流1的漏桶中不再有令牌，<span
class="math inline">\(b_1\)</span>个分组进入流1的WFQ等待区域。因为这<span
class="math inline">\(b_1\)</span>分组以至少<span
class="math inline">\(\frac{w_iR}{\sum_{j=1}^{n}{w_j}}\)</span>分组每秒的速率得到服务，其中最后一个分组有最大时延<span
class="math inline">\(d_{max}=\frac{b_1\sum^{n}_{j=1}{w_j}}{w_1R}\)</span>。</p>
<p>　　若在时间<span
class="math inline">\(t\)</span>内到达的分组需要排队，此期间内分组流1发送到网络的分组数量和在WFQ队列中排队的分组数量分别表示为<span
class="math inline">\(S\)</span>和<span
class="math inline">\(Q\)</span>。显然，<span
class="math inline">\(S\geqslant\frac{w_iRt}{\sum_{j=1}^{n}{w_j}}\)</span>，<span
class="math inline">\(Q=r_1t+b_1-S\)</span>。 <span
class="math display">\[
\begin{align}
Q&amp;\leqslant r_1t+b_1-\frac{w_iRt}{\sum_{j=1}^{n}{w_j}}\\[3px]
Q&amp;\leqslant (r_1-\frac{w_iR}{\sum_{j=1}^{n}{w_j}})t+b_1
\end{align}
\]</span> 　　若<span
class="math inline">\(r_1&lt;\frac{w_iR}{\sum_{j=1}^{n}{w_j}}\)</span>，则<span
class="math inline">\(Q\leqslant
b_1\)</span>，即分组流1在WFQ队列中排队的最大分组数是<span
class="math inline">\(b_1\)</span>，这些分组得到服务的速率最小值是<span
class="math inline">\(\frac{w_iR}{\sum_{j=1}^{n}{w_j}}\)</span>，分组流1中任何在WFQ队列中排队的分组承受的最大时延都是<span
class="math inline">\(d_{max}\)</span>。</p>
<h4 id="ds架构">8.4.2 DS架构</h4>
<p>　　DS架构由<span
style="background-color: yellow">边缘功能(分组分类和流量调节)</span>和<span
style="background-color: yellow">核心功能(转发)</span>的集合组成。在网络的传入边缘到达的分组将被标记，即将数据报首部中的DS字段设置为某个值。DS架构的一个关键原则是路由器的<strong>每跳行为</strong>仅基于分组(DS)标记，即分组所属的流量类型。因此，DS架构无需为各个"源到目的地对"保持路由器状态，这是DS具有可扩展性的一个关键考虑因素。</p>
<p>　　PHB导致不同服务类型的流量行为不同，PHB虽然定义了类型间的行为差异，但并未规定特定的机制来实现这些行为。行为的差异必须可以观察，因此可以计量。只需满足外部可观察的行为准则，任何实现机制和任何缓存/带宽分配策略都可以使用。已定义了<strong>加速转发</strong>和<strong>确保转发</strong>这两种PHB。EF
PHB规定了一类流量离开路由器的速率必须达到某个已配置的速率，AF
PHB将流量分为4类，每个类都确保提供某种最小的带宽和缓存。</p>
<img src="/2022/09/10/computer-networking-a-top-down-approach-7e-chpt-8/simple_ds_network_example.svg" class="" title="simple_ds_network_example">
<p>　　到达边缘路由器的分组首先被分类，分类器根据一个或多个分组首部字段选择分组并引导到对应的标记器。某些情况下，端用户可能同意限制分组发送速率来符合某个声明的<strong>流量配置文件</strong>(该流量配置文件可能包含对峰值速率和突发大小的限制)。只要用户符合流量配置文件，分组就会收到优先级标记并被转发到目的地，否则，超出限制的分组可能被整形(为了保持最大速率而延时)或丢弃。<strong>计量功能</strong>用于将传入的分组流与协商的流量配置文件进行比较并确定是分组否符合规范，而不符合规范时的操作由网络管理员决定。</p>
<p>　　若不总是有足够的资源提供但需保证呼叫(端到端流)的QOS，则需要进行<strong>呼叫准入控制</strong>，即呼叫声明其QOS所需资源，若网络能保证所需资源则准入，否则进行拦截。保证呼叫的QOS所需资源的唯一方法是显式地为该呼叫分配这些资源，称为<strong>资源预留</strong>。资源预留需要源到目的地路径上的每个路由器都预留足够的资源，这是<strong>呼叫建立</strong>的工作，主要通过<strong>资源预留协议</strong>等信令协议完成。一旦资源被保留，呼叫持续期间都可以按需访问这些资源，而忽略其他呼叫的QOS所需资源。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法 第7版》第5章 链路层</title>
    <url>/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/</url>
    <content><![CDATA[<p>　　运行链路层协议的设备称为<strong>节点</strong>。连接相邻节点的通信信道称为<strong>链路</strong>。</p>
<p>　　链路层提供的服务包括<strong>封装成帧</strong>、<strong>链路接入</strong>、<strong>可靠交付</strong>、<strong>差错检测和纠错</strong>。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/relationship_of_network_adapter_to_other_host_components.svg" class="" title="relationship_of_network_adapter_to_other_host_components">
<p>　　通常链路层是通过<strong>网络适配器</strong>实现的，网络适配器也称为<strong>网络接口卡</strong>。网络适配器的核心是链路层控制器，通常是一个实现了很多链路层服务的专用芯片。因此，链路层控制器的大部分功能(封装成帧、链路接入和差错检测)是通过硬件实现的。链路层的软件部分实现更高级别的链路层功能(组装链路层寻址信息和激活控制器硬件)。</p>
<p>　　交换机的工作是主机与路由器之间传输数据报，即交换机不必明确地将帧寻址到其他交换机，因此它没有与其相连的主机或路由器的链路层地址。</p>
<p>　　主机和路由器的<span
style="background-color: yellow">网络适配器(即网络接口)</span>拥有链路层地址。链路层地址又称<strong>LAN地址</strong>、<strong>物理地址</strong>或<strong>MAC地址</strong>。MAC地址长度为<span
class="math inline">\(6B\)</span>，共有<span
class="math inline">\(2^{48}\)</span>个可能的地址，常用16进制数表示，即<span
class="math inline">\(1B\)</span>对应一对16进制数。没有两块适配器拥有相同的MAC地址，因为一个公司想要生产网络适配器时需要向IEEE购买<span
class="math inline">\(2^{24}\)</span>个地址组成的地址空间，这些地址的前24位相同。</p>
<p>　　当网络适配器发送帧时会将目的网络适配器的MAC地址插入帧中。交换机可能将帧广播到所有接口，因此网络适配器可能收到不是发送给它的帧。当网络适配器收到帧时会将目的MAC地址与自身MAC地址进行匹配，若匹配则提取数据报并沿协议栈向上传递，否则丢弃该帧。</p>
<p>　　若网络适配器需要将帧广播到其他网络适配器，发送端网络适配器需要将帧的MAC地址设置为特殊的广播地址，即48位全是1。</p>
<span id="more"></span>
<p>　　<strong>集线器</strong>是物理层设备，作用于比特，当比特从一个接口到达时，集线器只需要重新生成该比特来提供其能量强度，并将该比特传输到其他所有接口。</p>
<p>　　<strong>中继器</strong>是物理层设备，用来放大信号，比特从输入接口达到后会重新生成该比特并传输到输出接口。</p>
<table>
<thead>
<tr>
<th></th>
<th>路由器</th>
<th>集线器</th>
<th>交换机</th>
</tr>
</thead>
<tbody>
<tr>
<td>流量隔离</td>
<td>✓</td>
<td>⨉</td>
<td>✓</td>
</tr>
<tr>
<td>即插即用</td>
<td>⨉</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>优化路由</td>
<td>✓</td>
<td>⨉</td>
<td>⨉</td>
</tr>
</tbody>
</table>
<h3 id="差错检测和纠错">5.1 差错检测和纠错</h3>
<p>　　<strong>前向纠错</strong>指接收端检测并纠错。</p>
<p>　　传输层通常由主机中的软件实现并作为主机操作系统的一部分，传输层的差错检验同样是通过软件实现的，故传输层使用了更简单快速的差错检测(例如，校验和)。而链路层的差错检测通常在网络适配器中的专用硬件实现，可以快速执行更复杂的CRC操作。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/single_bit_even_parity.svg" class="" title="single_bit_even_parity">
<p>　　最简单的差错检测技术是用单个<strong>奇偶校验位</strong>。假设待发送的信息<span
class="math inline">\(D\)</span>有<span
class="math inline">\(d\)</span>位，若使用偶校验，发送端只需要再加上1位，使得这<span
class="math inline">\(d+1\)</span>位有偶数个1，若使用奇校验则<span
class="math inline">\(d+1\)</span>位中有奇数个1。显然这种方案只能检测出奇数比特的差错。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/two_dimensional_even_parity.svg" class="" title="two_dimensional_even_parity">
<p>　　<strong>二维奇偶检验</strong>可以检测出单比特的错误并纠错，只能检测错两比特的错误。</p>
<p>　　另一种差错检测技术是校验和，比较简单的校验和方法就是将<span
class="math inline">\(d\)</span>位数据看作<span
class="math inline">\(k\)</span>位整数的序列化，再将这<span
class="math inline">\(k\)</span>位整数相加并将得到的和用作差错检测位。<strong>互联网校验和</strong>就基于这种方法，即将待发送数据字节视作16位的整数并求和，求和时需要回卷，求和后再取反码，这个反码设置为分组首部的校验和字段。接收端收到分组后用同样的方式(包括校验和)求和取反码，若结果全为1则表示没有出现差错。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/crc.svg" class="" title="crc">
<p>　　现在常用的差错检测技术是<strong>循环冗余校验编码</strong>，循环冗余校验编码也称为多项式编码，因为该编码将待发送的位串视作多项式，其系数是位串中的0和1，对位串的操作被视为多项式算术。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/simple_crc_calculation.svg" class="" title="simple_crc_calculation">
<p>　　所有的CRC都采用模2运算，模2运算<span
style="background-color: yellow">不考虑进位和借位</span>，模2加法和模2减法等价于操作数的异或运算<span
class="math inline">\(\oplus\)</span>，模2乘法和模2除法运算规则与二进制中的乘法和除法相同。</p>
<p>　　依然假设待发送的数据<span class="math inline">\(D\)</span>有<span
class="math inline">\(d\)</span>位，发送端接收端必须先就<span
class="math inline">\(r+1\)</span>位模式(二进制形式)达成一致，称为<strong>生成多项式</strong>，用<span
class="math inline">\(G\)</span>表示，<span
class="math inline">\(G\)</span>的最高有效位必须是1并且使用模2运算时<span
class="math inline">\(d+r\)</span>位模式(二进制形式)能整除<span
class="math inline">\(G\)</span>，若有余数则说明出现了差错。</p>
<p>　　根据二进制乘法中乘<span
class="math inline">\(2^k\)</span>相当于左移<span
class="math inline">\(k\)</span>位的特性，<span
class="math inline">\(d+r\)</span>位模式可以表示为<span
class="math inline">\(D\times 2^r\oplus R\)</span>。 <span
class="math display">\[
\begin{align}
D\times 2^r \oplus R&amp;=nG\\[3px]
D\times 2^r\oplus R\oplus R&amp;=nG\oplus R\\[3px]
D\times 2^r&amp;=nG \oplus R
\end{align}
\]</span> 　　显然，<span class="math inline">\(R= (D\times 2^r) \bmod
G\)</span>。</p>
<p>　　CRC能检测出奇数比特的差错，而且CRC能检测出小于<span
class="math inline">\(r+1\)</span>位的差错，在适当的假设下还可以以<span
class="math inline">\(1-\frac{r}{2}\)</span>的概率检测出大于<span
class="math inline">\(r+1\)</span>位的差错。</p>
<h3 id="多路访问链路和协议">5.2 多路访问链路和协议</h3>
<p>　　<strong>点对点链路</strong>由链路一端的单个发送端和链路另一端的单个接收端组成，相关协议包括PPP和HDLC。</p>
<p>　　<strong>广播</strong>指当任何节点通过广播信道传输帧时其他所有节点都会收到该帧的副本。<strong>广播链路</strong>可以有多个发送端和接收端都连接到同一共享广播信道。</p>
<p>　　因为所有的节点都能传输帧，所有可能多个节点会同时传输帧，此时，传输的帧在所有接收端<strong>碰撞</strong>，涉及此次碰撞的所有帧都会丢失。</p>
<p>　　<strong>多路访问</strong>指多个节点共享同一信道，其中任意节点发送的帧可以被多个节点接收。多路访问协议分为<strong>信道划分协议</strong>、<strong>随机接入协议</strong>和<strong>轮流协议</strong>。</p>
<p>　　在理想情况下，速率为<span
class="math inline">\(R(b/s)\)</span>的广播信息的，多路信道应该具有以下理想特性：</p>
<p>　　1) 当仅有一个节点发送数据时，该节点吞吐量为<span
class="math inline">\(R(b/s)\)</span>。</p>
<p>　　2) 当<span
class="math inline">\(M\)</span>个节点发送数据时，每个节点的吞吐量为<span
class="math inline">\(\frac{R}{M}(b/s)\)</span>。</p>
<p>　　3) 协议是去中心化的，即不会因为主节点故障而导致整个系统崩溃。</p>
<p>　　4) 协议是简单的，故实现成本也不高。</p>
<h4 id="信道划分协议">5.2.1 信道划分协议</h4>
<p>　　FDM和TDM可以用于信道划分。</p>
<p>　　FDM消除了碰撞且很公平，每个节点都获得了专用带宽<span
class="math inline">\(\frac{R}{N}(b/s)\)</span>，缺点是带宽的限制。</p>
<p>　　TDM也消除了碰撞且也很公平，每个节点在每个时间帧内都获得了专用传输速率<span
class="math inline">\(\frac{R}{N}(b/s)\)</span>，缺点是节点的平均速率被限制在<span
class="math inline">\(\frac{R}{N}(b/s)\)</span>以及节点必须等待传输序列的轮次。</p>
<p>　　另一种信道划分协议是<strong>码分多址</strong>，码分多址为每个节点分配了不同的编码，每个节点使用其唯一编码来将待发送的数据编码。若精心选择编码，码分多址既可以保证不同节点同时传输，又可以保证它们对应的接收端仍能正确地接收数据。</p>
<p>　　在CDMA协议中，发送端的每个比特都通过乘一个信号(编码)进行编码，该信号的变化速率(称为<strong>码片速率</strong>)比初始数据比特序列的变化速率快很多。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/simple_example_of_cmda.svg" class="" title="simple_example_of_cmda">
<p>　　假设初始数据比特达到CDMA编码器的速率定义了时间单位，即每个待发送的初始数据比特需要1比特的时隙。为了数学上的便利，这里用<span
class="math inline">\(-1\)</span>代替<span
class="math inline">\(0\)</span>。<span
class="math inline">\(d_i\)</span>表示第<span
class="math inline">\(i\)</span>个比特时隙中的数据比特值。每个比特时隙进一步细分为<span
class="math inline">\(M\)</span>个微时隙(这里<span
class="math inline">\(M=8\)</span>，实际中<span
class="math inline">\(M\)</span>的值大得多)。发送端使用CDMA编码由<span
class="math inline">\(M\)</span>个值的一个序列<span
class="math inline">\(c_m\)</span>组成。</p>
<p>　　对于<span class="math inline">\(d_i\)</span>比特传输时的第<span
class="math inline">\(m\)</span>个微时隙，CDMA编码器的输出<span
class="math inline">\(Z_{i,m}=d_i\cdot
c_m\)</span>。在没有其他发送端的干扰时，接收端将收到比特<span
class="math inline">\(Z_{i,m}\)</span>并恢复成初始的数据比特<span
class="math inline">\(d_i=\frac{\sum_{m=1}^MZ_{i,m}\cdot
c_m}{M}\)</span>。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/simple_example_of_two-sender_cmda.svg" class="" title="simple_example_of_two-sender_cmda">
<p>　　实际中干扰在所难免，CDMA在原始数据比特与干扰比特传输信号是相加的假设下工作。相比无干扰情况，接收端收到比特的值是所有发送端传输的比特总和<span
class="math inline">\(Z_{i,m}^*=\sum_{s=1}^NZ_{i,m}^s\)</span>。</p>
<h4 id="随机接入协议">5.2.2 随机接入协议</h4>
<p>　　随机接入协议中，节点总是以信道的最高速率<span
class="math inline">\(R(b/s)\)</span>进行传输，当发送碰撞时，涉及碰撞的每个节点都会重传直到无碰撞为止，但并非碰撞后立即重传，而是<span
style="background-color: yellow">等待随机时延</span>后重传。涉及碰撞的节点都独立地选择随机时延。</p>
<h5 id="时隙aloha">5.2.2.1 时隙ALOHA</h5>
<p>　　在时隙ALOHA协议中，先做如下假设：</p>
<p>　　● 所有帧的长度固定为<span
class="math inline">\(L\)</span>位。</p>
<p>　　● 时间划分为<span
class="math inline">\(\frac{L}{R}(s)\)</span>的时隙，即一个时隙等于传输一帧所需时间。</p>
<p>　　● 节点仅在时隙的开始传输帧。</p>
<p>　　● 节点是同步的，每个节点都指定时隙的开始时间。</p>
<p>　　●
若两个或多个帧在同一时隙内碰撞则所有节点在时隙结束前会检测到该碰撞。</p>
<p>　　当节点有帧待发送时，它等到下个时隙的开始并在该时隙内传输整个帧。若出现碰撞，该节点在时隙结束前会检测到该碰撞，在之后的每个时隙内以概率<span
class="math inline">\(p\)</span>(二项分布)重传该帧直到不出现碰撞。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/simple_example_of_slotted_aloha.svg" class="" title="simple_example_of_slotted_aloha">
<p>　　只有一个节点传输的时隙称为<strong>成功时隙</strong>。时隙ALOHA协议的<strong>效率</strong>指大量活动节点的情况下成功时隙的比例。</p>
<p>　　假设<span
class="math inline">\(N\)</span>个节点，则某个时隙是成功时隙的概率就是其他<span
class="math inline">\(N-1\)</span>个节点不进行传输的概率。某个节点传输的概率是<span
class="math inline">\(p\)</span>，其他节点不传输的概率是<span
class="math inline">\((1-p)^{N-1}\)</span>，因此该节点成功传输的概率是<span
class="math inline">\(p(1-p)^{N-1}\)</span>。因为有<span
class="math inline">\(N\)</span>个节点，其中任一节点成功传输的概率是<span
class="math inline">\(Np(1-p)^{N-1}\)</span>。 <span
class="math display">\[
\begin{align}
f(p)&amp;=Np(1-p)^{N-1}\\[3px]
f&#39;(p)&amp;=(Np)&#39;(1-p)^{N-1}-Np((1-p)^{N-1})&#39;\\[3px]
&amp;=N(1-p)^{N-1}-Np(N-1)(1-p)^{N-2}\\[3px]
&amp;=N(1-p)^{N-2}(1-p-p(N-1))\\[3px]
&amp;=N(1-p)^{N-2}(1-pN)
\end{align}
\]</span> 　　令<span
class="math inline">\(f&#39;(p)=0\)</span>时，则<span
class="math inline">\(p=\frac{1}{N}\)</span>或<span
class="math inline">\(p=1\)</span>。</p>
<p>　　当<span class="math inline">\(p=\frac{1}{N}\)</span>时，<span
class="math inline">\(f(\frac{1}{N})=(1-\frac{1}{N})^{N-1}&gt;0\)</span>，<span
class="math inline">\(p=\frac{1}{N}\)</span>是<span
class="math inline">\(f(p)\)</span>的极大值点。</p>
<p>　　当<span class="math inline">\(p=1\)</span>时，<span
class="math inline">\(f(1)=0\)</span>，<span
class="math inline">\(p=1\)</span>是<span
class="math inline">\(f(p)\)</span>的极小值点。 <span
class="math display">\[
\begin{align}
\lim \limits_{N\rightarrow \infty} f(\frac{1}{N})&amp;=\lim
\limits_{N\rightarrow \infty} (1-\frac{1}{N})^{N-1}\\[3px]
&amp;=\lim \limits_{N\rightarrow \infty}
\frac{(1-\frac{1}{N})^N}{1-\frac{1}{N}}\\[3px]
&amp;=\frac{\lim \limits_{N\rightarrow \infty}(1-\frac{1}{N})^N}{\lim
\limits_{N\rightarrow \infty}(1-\frac{1}{N})}\\[3px]
&amp;=\frac{1}{e}
\end{align}
\]</span></p>
<p>　　时隙ALOHA效率是<span class="math inline">\(\frac{1}{e}\approx
0.37\)</span>。</p>
<h5 id="aloha">5.2.2.2 ALOHA</h5>
<p>　　ALOHA是无时隙的。在ALOHA中，当一个帧首次到达(数据报从发送端的网络层向下传递)，节点立即将整个帧传输到广播信道中。若出现碰撞，该节点(传输完出现碰撞的帧后)下一个帧传输时间以概率<span
class="math inline">\(p\)</span>重传。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/interfering_transmission_in_aloha.svg" class="" title="interfering_transmission_in_aloha">
<p>　　为了确定ALOHA的最高效率，关注的重点是单独的节点。类似于时隙ALOHA，时间单元为帧的传输时间。对于指定时间，节点<span
class="math inline">\(i\)</span>传输帧的概率是<span
class="math inline">\(p\)</span>。该节点在<span
class="math inline">\(t_0\)</span>开始传输，若该帧能够成功传输，在<span
class="math inline">\([t_0-1,t_0]\)</span>内不能有其他节点传输，因为这样会导致传输干扰。其他所有节点在<span
class="math inline">\([t_0-1,t_0]\)</span>内不传输的概率是<span
class="math inline">\((1-p)^{N-1}\)</span>。当节点<span
class="math inline">\(i\)</span>传输时不能有其他节点传输，这样概率也是<span
class="math inline">\((1-p)^{N-1}\)</span>。因此，节点<span
class="math inline">\(i\)</span>成功传输的概率是<span
class="math inline">\((1-p)^{2N-2}\)</span>。当有<span
class="math inline">\(N\)</span>个节点，其中任一节点成功传输的概率是<span
class="math inline">\(Np(1-p)^{2N-2}\)</span>。 <span
class="math display">\[
\begin{align}
f(p)&amp;=Np(1-p)^{2N-2}\\[3px]
f&#39;(p)&amp;=(Np)&#39;(1-p)^{2N-2}-Np((1-p)^{2N-2})&#39;\\[3px]
&amp;=N(1-p)^{2N-2}-Np(2N-2)(1-p)^{2N-3}\\[3px]
&amp;=N(1-p)^{2N-3}(1-p-p(2N-2))\\[3px]
&amp;=N(1-p)^{2N-3}(1-p(2N-1))
\end{align}
\]</span> 　　令<span
class="math inline">\(f&#39;(p)=0\)</span>时，则<span
class="math inline">\(p=\frac{1}{2N-1}\)</span>或<span
class="math inline">\(p=1\)</span>。</p>
<p>　　当<span class="math inline">\(p=\frac{1}{2N-1}\)</span>时，<span
class="math inline">\(f(\frac{1}{2N-1})= \frac{N}{2N-1} \times
(1-\frac{1}{2N-1})^{2N-2}&gt;0\)</span>，<span
class="math inline">\(p=\frac{1}{2N-1}\)</span>是<span
class="math inline">\(f(p)\)</span>的极大值点。</p>
<p>　　当<span class="math inline">\(p=1\)</span>时，<span
class="math inline">\(f(1)=0\)</span>，<span
class="math inline">\(p=0\)</span>是<span
class="math inline">\(f(p)\)</span>的极小值点。 <span
class="math display">\[
\begin{align}
\lim \limits_{N\rightarrow \infty} f(\frac{1}{2N-1})&amp;=\lim
\limits_{N\rightarrow \infty} [\frac{N}{2N-1} \times
(1-\frac{1}{2N-1})^{2N-2}]\\[3px]
&amp;=\lim \limits_{N\rightarrow \infty} \frac{N}{2N-1}\times \lim
\limits_{N\rightarrow \infty} (1-\frac{1}{2N-1})^{2N-2}\\[3px]
&amp;=\frac{1}{2}\times \frac{\lim \limits_{N\rightarrow
\infty}(1-\frac{1}{2N-1})^{2N-1}}{\lim \limits_{N\rightarrow
\infty}(1-\frac{1}{2N-1})}\\[3px]
&amp;=\frac{1}{2e}
\end{align}
\]</span></p>
<p>　　ALOHA效率是<span
class="math inline">\(\frac{1}{2e}\)</span>，仅为时隙ALOHA的一半。</p>
<h5 id="csma">5.2.2.3 CSMA</h5>
<p>　　<strong>载波侦听</strong>指节点在传输前先侦听信道。若有其他节点在通过该信道传输则该节点会等待，直到短时间内未检测到传输再开始传输。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/two_csma_nodes_collide.svg" class="" title="two_csma_nodes_collide">
<p>　　假设一条广播总线有A、B、C、D这4个节点。在<span
class="math inline">\(t_0\)</span>时刻，节点B侦听到信道是空闲的，因此节点B开始传输，帧向着总线的两端传输。在<span
class="math inline">\(t_1\)</span>时刻，节点D有帧待发送，此时节点B的帧还未到达节点D，因此D侦听到信道是空闲的，因此节点D也开始传输帧。过了一段时间后B的传输与D的传输碰撞。</p>
<p>　　广播信道的端到端<strong>信道传播时延</strong>在性能方面起到关键作用。信道传播时延越长，载波侦听节点不能侦听到另一节点已开始传输的几率越大。</p>
<h5 id="csmacd">5.2.2.4 CSMA/CD</h5>
<p>　　<strong>碰撞检测</strong>指节点在传输时侦听信道。若检测到其他节点在传输，该节点会停止并等待随机时延，再进入“侦听-空闲时传输”的循环。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/csma_with_collision_detection.svg" class="" title="csma_with_collision_detection">
<p>　　从连接到广播信道的节点的网络适配器角度来说明CSMA/CD的内容：</p>
<p>　　1)
网络适配器从网络层获取数据报，将数据报封装成帧并将帧放入网络适配器的缓存中。</p>
<p>　　2)
如果网络适配器侦听到信道是空闲的(无信号能量从信道进入网络适配器)则开始传输帧，否则网络适配器将等待，直至信道空闲。</p>
<p>　　3) 传输帧时网络适配器会监视该信道中其他网络适配器的信号能量。</p>
<p>　　4)
若传输整个帧的过程中未检测到其他网络适配器的能量信号则网络适配器完成了传输，否则网络适配器将中止传输。</p>
<p>　　5) 中止之后，网络适配器将等待随机时延并回到第2步。</p>
<p>　　<strong>二进制指数退避算法</strong>可以让碰撞后节点等待的随机时延随着碰撞次数增长而增长。<span
class="math inline">\(512b\)</span>数据在端到端的往返时间表示为<span
class="math inline">\(2\tau\)</span>，也称为<strong>冲突窗口</strong>或<strong>竞争期</strong>，一般设置为基本退避时间。若一个帧的碰撞次数达到16次时会<span
style="background-color: yellow">丢弃该帧并向上层反馈错误</span>。定义一个与冲突次数相关的参数<span
class="math inline">\(k\)</span>，<span
class="math inline">\(k=min\{碰撞次数,10\}\)</span>。从<span
class="math inline">\([0,1,2,\cdots ,2^k-1]\)</span>中选取随机数<span
class="math inline">\(r\)</span>，则等待的随机时延是<span
class="math inline">\(r\)</span>倍的基本退避时间，即<span
class="math inline">\(r\times 2\tau\)</span>。</p>
<p>　　CSMA/CD的效率指大量活动节点时，帧在信道上无碰撞地传输的时间所占的比例。
<span class="math display">\[
effciency\approx \frac{1}{1+5\frac{d_{prop}}{d_{trans}}}
\]</span> 　　<span
class="math inline">\(d_{prop}\)</span>表示信号能量在任意两个网络适配器之间传输所需的最长时间。<span
class="math inline">\(d_{trans}\)</span>表示传输最大长度的帧所需时间。</p>
<p>　　假设<span
class="math inline">\(S\)</span>表示类似于时隙ALOHA的时隙，<span
class="math inline">\(S\)</span>比传输一帧的时间小很多且<span
class="math inline">\(S&gt;d_{prop}\)</span>，这样在时隙结束前每个节点都能检测到其他节点的信号能量。所有帧的长度固定，用<span
class="math inline">\(L\)</span>表示，<span
class="math inline">\(L=kRS\)</span>，<span
class="math inline">\(R\)</span>表示信道的速率，即成功传输帧需要连续<span
class="math inline">\(k\)</span>个传输成功的时隙。由于时隙结束前每个节点都能检测到其他节点的信号能量，首个传输成功的时隙后的<span
class="math inline">\(k-1\)</span>个时隙无时隙竞争。此外，有<span
class="math inline">\(N\)</span>个节点且每个节点有无限帧待发送。每个节点在时隙内传输的概率是<span
class="math inline">\(p\)</span>。每<span
class="math inline">\(x\)</span>个传输失败的时隙后有传输成功的时隙。时隙内成功传输的概率是<span
class="math inline">\(\beta\)</span>，<span
class="math inline">\(\beta=Np(1-p)^{N-1}\)</span>。<span
class="math inline">\(Y\)</span>表示时隙序号。 <span
class="math display">\[
P(Y=x+1)=\beta (1-\beta)^{x}
\]</span> 　　根据几何分布期望，<span
class="math inline">\(E(x+1)=\frac{1}{\beta}\)</span>，则<span
class="math inline">\(E(x)=\frac{1-\beta}{\beta}=\frac{1-Np(1-p)^{N-1}}{Np(1-p)^{N-1}}\)</span>。
<span class="math display">\[
\begin{align}
effciency&amp;=\frac{k}{k+x}\\[3px]
&amp;=\frac{k}{k+\frac{1-Np(1-p)^{N-1}}{Np(1-p)^{N-1}}}
\end{align}
\]</span> 　　显然<span
class="math inline">\(\beta\)</span>越大，效率越高，在时隙ALOHA中推导了<span
class="math inline">\(p=\frac{1}{N}\)</span>时<span
class="math inline">\(\beta\)</span>取最大值<span
class="math inline">\(\frac{1}{e}\)</span>，<span
class="math inline">\(effciency_{max}=\frac{k}{k+e-1}\)</span>。</p>
<h4 id="轮流协议">5.2.3 轮流协议</h4>
<p>　　轮流协议中，只有一个节点活跃时，该节点的吞吐量为<span
class="math inline">\(R(b/s)\)</span>，当有<span
class="math inline">\(M\)</span>个活跃节点时，每个活跃节点的吞吐量接近<span
class="math inline">\(\frac{R}{M}(b/s)\)</span>。</p>
<p>　　<strong>轮询协议</strong>需要一个主节点，主节点以循环的方式<strong>轮询</strong>其他节点。主节点通过侦听信道来确定节点是否完成了传输帧。例如，主节点向节点1发送报文来告诉它能够传输的帧的最大数量。节点1传输了一些帧后，主节点再向节点2发送报文来告诉它能够传输的帧的最大数量。主节点通过这种方式来轮询每个节点。</p>
<p>　　轮询协议相比随机访问协议消除了碰撞和空时隙。但轮询协议需要引入了轮询延迟，更严重的的是问题是当主节点发生故障时整个信道将无法运行。</p>
<p>　　<strong>令牌传递协议</strong>相比轮询协议没有主节点，而是一个称为的<strong>令牌</strong>的小型专用帧以某种固定顺序在节点之间交换。当节点收到令牌且有帧待传输时，才持有令牌并发送最大数量的帧，否则将按序向下一个节点转发令牌。</p>
<h4 id="docsis">5.2.4 DOCSIS</h4>
<p>　　有线接入网通常将数千个住宅有线调制解调器连接到<strong>电缆调制解调器终端系统</strong>。<strong>有线电缆数据服务接口规范</strong>规定了有线网络架构及其协议。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/upstream_and_downstream_channels.svg" class="" title="upstream_and_downstream_channels">
<p>　　DOCSIS使用FDM将下行(CMTS到调制解调器)和上行(调制解调器到CMTS)网段划分为多个频率信道。</p>
<p>　　每个下行信道的带宽是6Mhz，每个信道的最大吞吐量大约为<span
class="math inline">\(40Mb/s\)</span>。每个上行信道的最大带宽是6.4Mhz，最大上行吞吐量约为<span
class="math inline">\(30Mb/s\)</span>。每个上行和下行通道都是一个广播信道。</p>
<p>　　每个上行信道被划分为时间间隔(类似于TDM)，每个时间间隔包含一个微时隙序列，电缆调制解调器可以通过这些微时间序列向CMTS传输。CMTS显式地授予各个电缆调制解调器在指定微时隙序列传输的权限(通过CMTS在下行信道发送的称为MAP报文的控制报文来实现)。</p>
<p>　　CMTS在下行信道上传输的帧被所有接收该信道的电缆调制解调器接收。由于只有一个CMTS传输到下行信道，故不存在多路访问的问题。多个电缆调制解调器共享相同的上行信道到CMTS，因此可能出现碰撞。</p>
<p>　　电缆调制解调器在微时隙请求帧专用的微时隙间隔内向CMTS发送微时隙请求帧来让CMTS知晓自身有数据待发送。这些微时隙请求帧以随机接入方式传输，故可能出现碰撞。电缆调制解调器既不能侦听上行信道是否空闲，也不能检测碰撞。相反，若电缆调制解调器没有在下一个下行信道的控制报文中收到微时隙请求帧的响应，则推断微时隙请求帧出现了碰撞并使用二进制指数退避算法来重传。</p>
<p>　　当上行信道的流量很少时，电缆调制解调器可以在微时隙请求帧专用的信道中传输帧。</p>
<h3 id="交换局域网">5.3 交换局域网</h3>
<h4 id="arp">5.3.1 ARP</h4>
<p>　　<strong>地址解析协议</strong>用于将网络层地址解析为链路层地址，而<strong>反向地址解析协议</strong>用于将链路层地址解析为网络层地址。ARP仅解析同一子网下的主机和路由器接口的IP地址。</p>
<p>　　每个主机或路由器的内存中都有一个<strong>ARP表</strong>，其中包含IP地址到MAC地址映射。ARP表字段包括IP地址、MAC地址和TTL，TTL表示每个映射的删除时间，一般设置为20min。ARP表是自动构建的，若主机与子网断开连接，子网中的其他ARP表会删除该主机的表项。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/arp_packet_format.svg" class="" title="arp_packet_format">
<p>　　ARP分组包括16位<strong>硬件地址类型</strong>、16位<strong>协议地址类型</strong>、8位<strong>硬件地址长度</strong>、8位<strong>协议长度</strong>、16位<strong>操作类型</strong>、48位<strong>发送端MAC地址</strong>、32位<strong>发送端IP地址</strong>、48位<strong>目的MAC地址</strong>、32位<strong>目的IP地址</strong>。</p>
<p>　　● 硬件地址类型为1时表示以太网。</p>
<p>　　● 协议类型为0x0080时表示IP。</p>
<p>　　● 硬件地址长度和协议地址长度的单位是<span
class="math inline">\(B\)</span>。</p>
<p>　　●
操作类型为1时表示ARP请求分组，操作类型为2时表示ARP响应分组，操作类型为3时表示RARP请求分组，操作类型为4时表示RARP响应分组。</p>
<p>　　ARP请求分组用于获取目的IP地址对应的MAC地址，因此目的MAC地址为空(全为0)。</p>
<p>　　若主机需要发送一个IP寻址的数据报，需要获取目的IP地址对应的目的MAC地址，但其ARP表中没有目的IP地址的表项，则需要ARP协议来解析这个IP地址。</p>
<p>　　1)
主机构造ARP分组，网络适配器将分组封装成帧时将广播地址作为帧的目的MAC地址。</p>
<p>　　2) 主机将待发送的数据报放入缓存。</p>
<p>　　3)
同一子网下的其他网络适配器接收帧后将帧内的ARP分组传递给ARP模块。ARP模块会将分组中的目的IP地址与自身IP地址进行匹配，若匹配则向请求主机发送一个带有所需映射的ARP响应分组。主机根据ARP响应分组更新ARP表。若主机无法收到ARP响应分组，则会丢弃数据报。</p>
<p>　　4) 主机从缓存中取出数据报并查询ARP表获取MAC地址。</p>
<p>　　5) 主机将数据报封装成帧并发送。</p>
<p>　　某些ARP模块在等待ARP响应报文时<span
style="background-color: yellow">丢弃数据报</span>而不是放入缓存。</p>
<p>　　若子网1的主机A需要向子网2的主机B发送数据报，数据报首先发送到子网1中的第一跳路由，封装成帧时目的MAC地址应该是第一跳路由的IP地址对应的MAC地址。路由器收到帧后提取数据报，再次封装成帧并根据转发表进行转发。</p>
<h4 id="交换机">5.3.2 交换机</h4>
<p>　　交换机是全双工的，它可以在任何接口同时发送和接收。</p>
<p>　　交换机消除了碰撞，支持不同物理介质混搭且易于管理。</p>
<p>　　<strong>过滤</strong>是决定帧应该被转发到某个接口还是将其丢弃的交换机功能。<strong>转发</strong>是决定帧应该到哪个接口并移动到这个接口的交换机功能。交换机的过滤和转发功能是通过<strong>交换机表</strong>完成的。交换机表的表字段包括MAC地址、通向该MAC地址的接口和表项加入的时间。交换机表不一定包含局域网下所有主机和路由器的表项。</p>
<p>　　若一个帧从交换机的接口<span
class="math inline">\(x\)</span>到达，交换机用帧的目的MAC地址索引交换机表。若交换机表中没有帧的目的MAC地址的相关表项，交换机将帧的副本移动到接口<span
class="math inline">\(x\)</span>之外的所有接口的输出缓存，即广播该帧。若交换机表中有帧的目的MAC地址关联接口<span
class="math inline">\(x\)</span>的表项，表示帧已经在包含目的MAC地址的局域网广播，交换机会丢弃该帧来执行过滤。若交换机表中有帧的目的MAC地址的相关表项且关联的接口不是<span
class="math inline">\(x\)</span>，交换机会将帧的副本移动到该接口的输出缓存来执行转发。</p>
<p>　　交换机表是<strong>自学习</strong>的。交换机表初始为空。对于每个从接口上到达的帧，交换机表会存储帧的源MAC地址、帧到达的接口和当前时间。交换机通过这种方式记录发送端所在的局域网。若一段时间(老化期)后没有收到源MAC地址为该地址的帧，交换机将删除表中的地址。</p>
<p>　　<strong>交换机毒化</strong>指向交换机发送大量不同伪造源MAC地址的帧来填满交换机表。</p>
<h4 id="以太网">5.3.3 以太网</h4>
<p>　　在基于集线器的星形拓扑以太网中，主机或路由器通过双绞铜线直接连接到集线器。因此，这种局域网是一种广播局域网。若集线器仅在一个接口收到帧，它会向所有其他接口发送副本。若集线器同时从两个接口接收帧就会发送碰撞，生成帧的节点需要重传帧。随着以太网的发展，集线器被交换机代替。集线器是半双工设备，交换机是全双工设备。</p>
<p>　　最初的以太网的吞吐量是<span
class="math inline">\(10Mb/s\)</span>，使用了CMSA/CD协议，称为标准以太网。后来以太网有了不同规格，通过不同字符组合区分，例如，10BASE-T、100BASE-2等。缩略词的第一部分为数字，表示吞吐量。第二部分通常是BASE或BROAD。BASE指基带以太网，表示物理介质仅承载以太网流量。BOARD指宽带以太网。第三部分表示物理介质，2表示细同轴电缆，5表示粗同轴电缆，F表示光纤，T表示双绞线。</p>
<p>　　<span
class="math inline">\(100Mb/s\)</span>以太网除了吞吐量的提高，还定义了更高速的物理层。双绞线的距离限制为100m，光纤距离限制为几千米。</p>
<p>　　吉比特/千兆以太网是<span
class="math inline">\(10Mb/s\)</span>和<span
class="math inline">\(100Mb/s\)</span>的扩展，除了兼容前者和吞吐量的单位提高到了<span
class="math inline">\(Gb/s\)</span>，还提供了全双工和半双工两种方式。半双工基于集线器，使用了一对电缆线，需要CMSA/CD。全双工基于交换机，使用了两对电缆线，不需要链路层协议。</p>
<p>　　以太网提供无连接且不可靠服务。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/ethernet_frame_format.svg" class="" title="ethernet_frame_format">
<p>　　以太网帧包括<span
class="math inline">\(8B\)</span><strong>前同步码</strong>、<span
class="math inline">\(6B\)</span><strong>目的MAC地址</strong>、<span
class="math inline">\(6B\)</span><strong>源MAC地址</strong>、<span
class="math inline">\(2B\)</span><strong>类型</strong>、<span
class="math inline">\(46\sim1500B\)</span>的<strong>有效载荷</strong>和<span
class="math inline">\(4B\)</span>的<strong>帧校验序列</strong>。</p>
<p>　　● 前同步码的前<span
class="math inline">\(7B\)</span>都是10101010，用于保证接收MAC帧时接收端的网络适配器的时钟频率与发送端的网络适配器同步。前同步码最后<span
class="math inline">\(1B\)</span>是10101011，最后连续的11表示之后是帧的信息。</p>
<p>　　●
类型表示上层(网络层)协议类型。值为0x0800时表示IPv4，值为0x0806表示ARP，值为0x86DD表示IPv6。</p>
<p>　　● 有效载荷不足<span
class="math inline">\(46B\)</span>时会将数据报填充到<span
class="math inline">\(46B\)</span>，网络层根据数据报首部中的长度字段来去掉填充的字节。</p>
<p>　　● 帧校验序列用于差错检测，一般是CRC编码。</p>
<h4 id="虚拟局域网">5.3.4 虚拟局域网</h4>
<p>　　支持<strong>虚拟局域网</strong>的交换机可以在单个物理局域网基础设施上定义多个虚拟局域网。</p>
<p>　　在基于端口的VLAN中，交换机的接口被分组。每个组构成一个VLAN，每个VLAN中的端口组成一个广播域，即来自端口的广播流量只能达到组中的其他端口。</p>
<p>　　将交换机端口连接到外部路由器，并将路由器接口中连接交换机的接口配置为属于交换机所属VLAN。通过这种方式可以实现基于端口的VLAN互联，从逻辑上就是通过路由器转发。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/802.1q_ethernet_frame_format.svg" class="" title="802.1q_ethernet_frame_format">
<p>　　另一种更加可扩展性的实现基于端口的VLAN互联的方式是<strong>虚拟局域网干道</strong>，每个交换机的部分接口配置为干道接口，干道端口用于连接其他交换机，干道接口属于所有VLAN，干道接口之间的链路称为干道链路，发送到任何VLAN的帧都会通过干道链路转发到另一台交换机。为了区分VLAN，IEEE定义了一种扩展以太网帧格式802.1Q。相比以太网帧在首部加入了<span
class="math inline">\(4B\)</span><strong>VLAN标签</strong>用于标识VLAN。</p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 5%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr>
<th>字段名</th>
<th>长度</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>标签控制信息</td>
<td><span class="math inline">\(2B\)</span></td>
<td>表示帧类型，一般取固定值0x8100，若自定义则各个设备需统一</td>
</tr>
<tr>
<td>优先级</td>
<td>3位</td>
<td>网络拥塞时，优先发送优先级高的帧</td>
</tr>
<tr>
<td>标准格式指示位</td>
<td>1位</td>
<td>取值0时表示以标准格式封装，取值1时表示非标准格式封装</td>
</tr>
<tr>
<td>VLAN标识符</td>
<td>12位</td>
<td>全为0和全为1为协议保留值</td>
</tr>
</tbody>
</table>
<p>　　在基于接口的VLAN中，以太网帧分为<strong>有标记帧</strong>和<strong>无标记帧</strong>，有标记帧有VLAN标签，无标记帧没有。若交换机不支持有标记帧则会丢弃。干道链路上传输的帧都是有标记帧，接入链路上传输的帧都是无标记帧。交换机内部处理的帧都是有标记帧，若收到无标记帧，交换机会为无标记帧添加VLAN标签并重新计算FCS。交换机向接入链路发送帧时会将有标记帧的VLAN标签去除。</p>
<p>　　由于802.1Q以太网帧中的VLAN标识符只能表示<span
class="math inline">\(2^{12}-2=4096\)</span>个VLAN，为了扩展VLAN数量，可以将802.1Q以太网帧作为另一个802.1Q以太网帧的有效载荷，称为QinQ(802.1Q
in 802.1Q)，这样VLAN数量增加到了<span class="math inline">\(4096\times
4096\)</span>。</p>
<p>　　VLAN除了基于接口，还可以基于其他方式，例如，MAC地址和网络层协议等。在基于MAC地址中的VLAN中会为VLAN指定MAC地址集。VLAN也可以跨IP路由器扩展，允许LAN岛连接在一起形成全球性的VLAN。</p>
<h3 id="mpls">5.4 MPLS</h3>
<p>　　为了提高路由器的转发速率，MPLS采用了虚电路网络的一个关键概念——固定长度标签，其目标是在可能的情况下，标记数据报并允许路由器基于固定长度标签转发数据报(通常与IP协同)来提供转发速率。</p>
<p>　　MPLS是一种分类转发技术，它将具有相同转发处理方式的分组归类，称为<strong>转发等价类</strong>。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/mpls_label.svg" class="" title="mpls_label">
<p>　　<strong>MPLS标签栈</strong>表示MPLS首部的排序集合。靠近链路层帧的MPLS首部称为栈顶标签或外层标签，靠近网络层数据报的MPLS首部称为栈底标签或内层标签。MPLS标签栈按后进先出方式组成首部，从栈顶开始处理首部。</p>
<p>　　MPLS首部位于链路层帧首部和网络层数据报首部之间。MPLS首部包括20位<strong>标签</strong>、3位<strong>实验</strong>、1位<strong>栈底标识</strong>和8位<strong>生存时间</strong>。</p>
<p>　　● 标签用于标识分组所属FEC。</p>
<p>　　● 实验常用于<strong>服务分类</strong>。</p>
<p>　　● 栈底标识值为1时表示为最底层标签。</p>
<p>　　● 生存时间与IPv4数据报中的生存时间相同。</p>
<p>　　支持MPLS的路由器称为<strong>标签交换路由器</strong>，MPLS分组仅能标签交换路由器之间传输。LSR通过在其转发表中查找MPLS标签来转发MPLS分组，然后将数据报移动到对应的输出接口。<strong>标签交换路径</strong>指同一FEC报文在MPLS域内转发的路径。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/basic_operations_of_mpls_label.svg" class="" title="basic_operations_of_mpls_label">
<p>　　MPLS标签的基本操作包括<strong>标签压入</strong>、<strong>标签交换</strong>和<strong>标签弹出</strong>。</p>
<p>　　●
标签压入指当LSP入口节点添加新MPLS标签或LSP中间节点按需添加一层新的标签。</p>
<p>　　● 标签交换指LSP中间节点根据标签转发表替换MPLS分组的栈顶标签。</p>
<p>　　●
标签弹出指当LSP出口节点去除标签或在LSP倒数第二跳节点去除栈顶标签。</p>
<p>　　在MPLS域内的最后一跳时，MPLS标签已失去作用，可以利用<strong>倒数第二跳弹出</strong>在MPLS域内倒数第二跳节点将标签弹出以减少最后一跳的处理负担。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/mpls_enhanced_forwarding.svg" class="" title="mpls_enhanced_forwarding">
<p>　　R1-R4是LSR，R5和R6是标准IP路由器。R1已向R2、R3通告可以路由到A，MPLS标签为6的帧将被转发到A。R3已向R4通告可以到达A和D，MPLS标签为10的帧将被转发到A，MPLS标签为12的帧将被转发到D。R2已向R4通告可以到达A，MPLS标签为10的帧将被转发到A。与交换LAN或ATM网络一样，R1-R4路由器的转发与IP数据报无关。</p>
<p>　　MPLS是一种简单的<strong>流量工程</strong>，其中ISP可以覆盖常规的IP路由并强制一些流量沿着一条链路传输到指定目的地，而其他流量则沿着另一条链路流向同一目的地。</p>
<p>　　MPLS可用于执行MPLS转发路径的快速恢复，例如，用过预先计算的故障转移链路重新路由流量来响应链路故障。</p>
<p>　　MPLS可用于来实现<strong>虚拟专用网络</strong>，ISP使用支持MPLS的网络将客户的各种网络连接在一起。MPLS还可用于将VPN客户端使用的资源和地址与跨ISP网络的其他用户的资源和地址隔离。</p>
<h3 id="数据中心网络">5.5 数据中心网络</h3>
<p>　　每个数据中心都有<strong>数据中心网络</strong>，将其主机互联并将数据中心与互联网互联。数据中心网络的关键需求是计算和服务放置的灵活。</p>
<p>　　数据中心的主机称为<strong>刀片</strong>。刀片负责提供内容、存储数据并共同执行大型分布式计算。主机堆叠在机架上，每个机架顶部都有一台<strong>机架式</strong>交换机。TOR交换机将机架上的互联。机架上的主机都有一个与TOR交换机连接的网络接口卡，每个TOR交换机都有可以连接到其他TOR交换机的额外接口。每台主机都分配了数据中心的内网IP。</p>
<p>　　数据中心网络支持两种流量：外部客户端和内部主机之间的流量以及内部主机之间的流量。为了处理外部客户端和内部主机之间的流量，数据中心网络包括一个或多个<strong>边界路由器</strong>用于将数据中心网络连接到互联网。所以数据中心网络需要将所有主机互联并将机架与边界路由器连接。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/data_center_network_with_hierarchical_topology.svg" class="" title="data_center_network_with_hierarchical_topology">
<p>　　大型数据中心通常使用<strong>等级拓扑</strong>形式，其中有多个负载均衡器，每个负载均衡器专门用于一组特定的应用程序，这种负载均衡器也称为第4层交换机，因为它根据分组的端口号和目的IP地址进行决策。收到请求后，负载均衡器会将其转发到对应的主机，主机处理请求后将响应发送给负载均衡器，负载均衡器再将响应发送给客户端。负载均衡器不仅可以提供负载均衡，还可以提供类似NAT的功能，将公网IP地址转换为内网IP地址并将响应按向相反的转发方式处理。</p>
<p>　　在等级拓扑的数据中心网络中，边界路由器与接入路由器相连，接入路由器下有3层交换机。每台接入路由器下的主机构成一个子网，为了本地化ARP广播流量，这些子网进一步划分为VLAN子网。所有链路通常使用以太网作为链路层和物理层并使用铜缆和光纤。此外，数据中心还包括冗余网络设备和链路(例如，TOR交换机连接两台第2层交换机，其中接入路由器、第1层交换机和第2层交换机都可以冗余)。虽然这种结构解决了扩展性的问题，但是存在吞吐量的问题。</p>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/data_network_with_fully_connected_topology.svg" class="" title="data_network_with_fully_connected_topology">
<p>　　用<strong>全连接拓扑</strong>来代替交换机和路由器的等级结构可以改善吞吐量，这种结构中每台第1层交换机都连接到所有第2层交换机，因此需要考虑交换机之间选择算法，较简单的算法是随机，另一种在每个主机中部署多个网络接口卡，将主机连接到多个低成本商用交换机并允许主机在交换机之间智能路由流量。</p>
<p>　　另一种方式是采用基于集装箱的<strong>模块化数据中心</strong>。在MDC中，工厂在一个集装箱内建造一个迷你数据中心，并将集装箱运送到数据中心位置。当许多组件发生故障并且性能下降到阈值时，整个容器会被换掉。对于MDC，有两种网络类型：每个容器内的容器内部网络和连接每个容器的核心网络。容器内部可以使用全连接拓扑，但核心网络存在吞吐量问题。</p>
<h3 id="web页面请求的流程">5.6 Web页面请求的流程</h3>
<img src="/2022/07/21/computer-networking-a-top-down-approach-7e-chpt-5/process_of_a_web_page_request.svg" class="" title="process_of_a_web_page_request">
<p>　　用户的主机用以太网电缆连接到局域网的以太网交换机，以太网交换机连接着路由器，路由器连接着ISP(comcast)且ISP为局域网提供DNS服务。就像大多数情况，DHCP服务器在路由器内运行。假设主机刚连接，并<span
style="background-color: yellow">未</span>获得IP地址，获得IP地址后用户会访问google主页。</p>
<p>　　1) 主机生成<span
style="background-color: yellow">DHCP请求报文</span>并封装成源端口是68和目的端口是67的<span
style="background-color: yellow">UDP报文段</span>，进一步封装成源IP地址是<code>0.0.0.0</code>和目的IP地址是<code>255.255.255.255</code>的<span
style="background-color: yellow">IP数据报</span>，最后封装成源MAC地址是<code>FF:FF:FF:FF:FF:FF</code>和目的MAC地址是主机的MAC地址的<span
style="background-color: yellow">以太网帧</span>。</p>
<p>　　2) 主机将广播以太网帧发送到以太网交换机，以太网交换机是<span
style="background-color: yellow">自学习</span>的，它更新了交换机表，然后在所有的输出接口广播该帧。</p>
<p>　　3) 路由器收到帧后解封提取IP数据报，IP数据报<span
style="background-color: yellow">被分解</span>为UDP报文段并解封获取DHCP请求报文。路由器在<span
style="background-color: yellow">CIDR</span>块<code>68.85.2.0/24</code>中给主机分配了<code>68.85.2.101</code>并生成<span
style="background-color: yellow">DHCP
ACK报文</span>，报文除了包含该IP地址还包含DNS服务器的IP地址<code>68.87.71.226</code>、默认网关<code>68.85.2.1</code>以及子网掩码<code>68.85.2.0/24</code>。DHCP
ACK报文封装成UDP报文段再封装成以太网帧，以太网帧的源MAC地址是路由器接口的MAC地址，目的MAC地址是主机的MAC地址。路由器将以太网帧发送给以太网交换机。</p>
<p>　　4)
以太网交换机收到帧后，根据交换机表将帧转发给连接到主机的接口。</p>
<p>　　5) 主机收到帧后经过层层解封后提取DHCP
ACK报文，主机中的DHCP客户端根据报文记录IP地址和DNS服务器IP地址并在<span
style="background-color: yellow">IP转发表</span>中更新默认网关的表项。此时，主机以完成网络组件的初始化，可以开始访问Web页面。</p>
<p>　　6)
主机对google页面生成DNS查询报文，再封装成目的端口是53和目的IP地址是DNS服务器IP地址的数据报，最后封装成以太网帧。该帧将送给网关路由器，但主机并未获取网关路由器MAC地址，需要使用<span
style="background-color: yellow">ARP</span>，主机对默认网关生成<span
style="background-color: yellow">ARP查询报文</span>，层层封装成源MAC地址是<code>FF:FF:FF:FF:FF:FF</code>的以太网帧并发送给以太网交换机，以太网交换机转发给所有输出接口。</p>
<p>　　7) 网关路由器收到以太网帧后，层层解封提取ARP查询报文，生成<span
style="background-color: yellow">ARP响应报文</span>并层层封装成目的MAC地址为主机MAC地址的以太网帧，最后将该帧发送给以太网交换机，以太网交换机转发给主机。</p>
<p>　　8)
主机收到帧后，层层解封提取ARP响应报文并获得网关路由器的MAC地址，将之前待发送的帧的目的MAC地址设置为网关路由器的MAC地址并发送给以太网交换机，以太网交换机再转发给网关路由器。</p>
<p>　　9)
网关路由器收到帧后解封提取包含DNS查询报文的IP数据报。网关路由器根据数据报的目的IP地址和转发表再次封装成帧并转发给comcast网络的边界路由器。</p>
<p>　　10)
comcast网络的边界路由器收到帧后，解封提取IP数据报根据comcast的路由选择算法以及<span
style="background-color: yellow">IBGP</span>再次封装成帧并转发给DNS服务器。</p>
<p>　　11) DNS服务器收到帧后，层层解封提取DNS查询报文，根据<span
style="background-color: yellow">DNS源记录</span>生成<span
style="background-color: yellow">DNS应答报文</span>，封装成UDP报文段，再封装成IP数据报，最后封装成以太网帧反向转发给主机。</p>
<p>　　12) 主机收到帧后，层层解封并获得google主页的IP地址，创建<span
style="background-color: yellow">TCP套接字</span>用于将<span
style="background-color: yellow">HTTP
GET报文</span>发送给google主页。主机创建TCP套接字时必须先进行<span
style="background-color: yellow">三次握手</span>，主机生成一个80端口的<span
style="background-color: yellow">TCP
SYN报文段</span>并封装成目的MAC地址是网关路由器MAC地址的帧，最后将帧发送给以太网交换机。</p>
<p>　　13) 局域网、comcast网络和google网络的路由器根据<span
style="background-color: yellow">BGP</span>转发包含TCP
SYN报文段的数据报。</p>
<p>　　14) google网络的HTTP服务器收到帧后，生成<span
style="background-color: yellow">TCP
SYNACK报文段</span>并层层封装成目的MAC地址为google网络的第一跳路由器MAC地址的帧，最后转发给google网络的第一跳路由器。</p>
<p>　　14) 包含TCP
SYNACK报文段的数据报经过google网络、comcast网络和局域网到达主机。主机收到帧后，TCP进入连接状态。主机生成HTTP
GET报文并写入套接字，然后封装成TCP报文段，就像12~14步中发送给google网络中HTTP服务器。</p>
<p>　　15) google网络中HTTP服务器从TCP套接字中读取HTTP
GET报文，生成<span
style="background-color: yellow">HTTP响应报文</span>并发送到TCP套接字中。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》 附录</title>
    <url>/2023/12/21/computer-systems-a-programmer&#39;s-perspective-3e-appx/</url>
    <content><![CDATA[<p>　　官方资料下载地址：<a
href="https://csapp.cs.cmu.edu/">点击这里</a>。</p>
<h3 id="a.1-错误处理">A.1 错误处理</h3>
<p>　　在之前遇到的系统级函数中，使用的错误返回风格有3种，即Unix风格、Posix风格和GAI风格。</p>
<h4 id="a.1.1-unix风格">A.1.1 Unix风格</h4>
<p>　　Unix早期开发的<code>fork()</code>和<code>wait()</code>等函数
(以及一些较老的Posix函数)
是Unix风格，它们出错时，会在返回的同时设置<code>errno</code>。例如，对于函数<code>wait()</code>，若出错，则会返回-1并设置<code>errno</code>；若正常运行，则返回回收的子进程PID。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = wait(<span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;wait error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是Unix风格的错误处理代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Unix风格错误输出函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param msg 错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数wait()的 (错误处理) 包装函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param status 状态</span></span><br><span class="line"><span class="comment"> * @return pid_t PID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Wait</span><span class="params">(<span class="type">int</span> *status)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = wait(status)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;Wait error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数kill()的 (错误处理) 包装函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param pid PID</span></span><br><span class="line"><span class="comment"> * @param signum 信号编号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> signum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="keyword">if</span> ((rc = kill(pid, signum)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;Kill error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是Unix风格的错误输出函数和错误处理包装函数。</p>
<span id="more"></span>
<h4 id="a.1.2-posix风格">A.1.2 Posix风格</h4>
<p>　　很多较新的Posix函数是Posix风格，其返回值仅表示成功 (0) 或出错
(非0)，有用的结果通过引用传递的参数返回。例如，函数<code>pthread_create()</code>的返回值仅表示成功或出错，新创建的线程TID通过第1个参数返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((retcode = pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(retcode));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是Posix风格的错误处理代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Posix风格错误输出函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param code 错误码</span></span><br><span class="line"><span class="comment"> * @param msg 错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">posix_error</span><span class="params">(<span class="type">int</span> code, <span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(code));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数pthread_detach()的 (错误处理) 包装函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param tid TID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="keyword">if</span> ((rc = pthread_detach(tid)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        posix_error(rc, <span class="string">&quot;Pthread_detach error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是Posix风格的错误输出函数和错误处理包装函数。</p>
<h4 id="a.1.3-gai风格">A.1.3 GAI风格</h4>
<p>　　GAI是函数<code>getaddrinfo()</code>的简称，这种风格的返回值仅表示成功
(0) 或出错 (非0)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((retcode = getaddrinfo(host, service, &amp;hints, &amp;result)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;getaddrinfo error: %s\n&quot;</span>, gai_strerror(retcode));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是GAI风格的错误处理代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief GAI风格错误输出函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param code 错误码</span></span><br><span class="line"><span class="comment"> * @param msg 错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gai_error</span><span class="params">(<span class="type">int</span> code, <span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, gai_strerror(code));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数getaddrinfo()的 (错误处理) 包装函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param host 主机名</span></span><br><span class="line"><span class="comment"> * @param service 服务名</span></span><br><span class="line"><span class="comment"> * @param hints 可选项</span></span><br><span class="line"><span class="comment"> * @param res 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *service, <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **res)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(host, service, hints, res)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gai_error(rc, <span class="string">&quot;Getaddrinfo error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是GAI风格的错误输出函数和错误处理包装函数。</p>
<h3 id="a.2-相关术语">A.2 相关术语</h3>
<blockquote>
<p><strong>abelian group</strong> 阿贝尔群</p>
<p><strong>action in distance</strong> 在远处起作用</p>
<p><strong>actuator arm</strong> 传动臂</p>
<p><strong>additive inverse</strong> 加法逆元</p>
<p><strong>address-space layout randomization (ASLR)</strong>
地址空间布局随机化</p>
<p><strong>address translation</strong> 地址转换</p>
<p><strong>Advanced Research Projects Agency (ARPA)</strong>
高级研究计划署</p>
<p><strong>advanced vecter extension</strong> 高级向量扩展</p>
<p><strong>aggregate payload</strong> 聚合有效载荷</p>
<p><strong>alignment</strong> 对齐</p>
<p><strong>always taken (AT)</strong> 总是选择</p>
<p><strong>American National Standards Institute (ANSI)</strong>
美国国家标准协会</p>
<p><strong>Andrew File System (AFS)</strong> 安德鲁文件系统</p>
<p><strong>archive</strong> 存档</p>
<p><strong>arithmetic logic unit (ALU)</strong> 算术逻辑单元</p>
<p><strong>assembler directive</strong> 汇编指示</p>
<p><strong>asymptotic inefficiency</strong> 渐进低效</p>
<p><strong>async-signal-safe</strong> 异步信号安全</p>
<p><strong>background</strong> 后台</p>
<p><strong>backward taken, forward non-taken (BTFNT)</strong>
反向选择、正向不选择</p>
<p><strong>basic input/output system (BIOS)</strong>
基本输入输出系统</p>
<p><strong>best fit</strong> 最佳适配</p>
<p><strong>block storage start (BSS)</strong> 块存储开始</p>
<p><strong>bias</strong> 偏置</p>
<p><strong>bijection</strong> 双射</p>
<p><strong>big endian</strong> 大端</p>
<p><strong>binary</strong> 二进制</p>
<p><strong>bit</strong> 位</p>
<p><strong>bi-endian</strong> 双端</p>
<p><strong>block device</strong> 块设备</p>
<p><strong>Boolean algebra</strong> 布尔代数</p>
<p><strong>boundary tag</strong> 边界标记</p>
<p><strong>branch prediction logic</strong> 分支预测逻辑</p>
<p><strong>bridge</strong> 网桥</p>
<p><strong>buddy system</strong> 伙伴系统</p>
<p><strong>bus</strong> 总线</p>
<p><strong>bypassing</strong> 旁路</p>
<p><strong>byte</strong> 字节</p>
<p><strong>cache memory</strong> 高速缓存</p>
<p><strong>callee-saved</strong> 被调用者保存</p>
<p><strong>caller-saved</strong> 调用者保存</p>
<p><strong>calling environment</strong> 调用环境</p>
<p><strong>carriage return (CR)</strong> 回车</p>
<p><strong>case expression</strong> 情况表达式</p>
<p><strong>cache friendly</strong> 缓存友好</p>
<p><strong>cache hit</strong> 缓存命中</p>
<p><strong>cache line</strong> 缓存行</p>
<p><strong>cache miss</strong> 缓存未命中</p>
<p><strong>cache set</strong> 缓存组</p>
<p><strong>capacity miss</strong> 容量未命中</p>
<p><strong>central processing unit (CPU)</strong> 中央处理器</p>
<p><strong>character device</strong> 字符设备</p>
<p><strong>circuit retiming</strong> 电路重定时</p>
<p><strong>client</strong> 客户端</p>
<p><strong>code motion</strong> 代码移动</p>
<p><strong>code profiler</strong> 代码剖析程序</p>
<p><strong>column access strobe (CAS)</strong> 列地址选通脉冲</p>
<p><strong>combinational circuit</strong> 组合电路</p>
<p><strong>common gateway interface (CGI)</strong> 通用网关接口</p>
<p><strong>complex instruction set computer (CISC)</strong>
复杂指令集计算机</p>
<p><strong>compulsory miss</strong> 强制未命中</p>
<p><strong>concurrency</strong> 并发</p>
<p><strong>concurrent server</strong> 并发服务器</p>
<p><strong>condition code (CC)</strong> 条件码</p>
<p><strong>conflict miss</strong> 冲突未命中</p>
<p><strong>conservative garbage collector</strong> 保守式垃圾回收器</p>
<p><strong>constant word</strong> 常数字</p>
<p><strong>context</strong> 上下文</p>
<p><strong>control dependency</strong> 控制依赖</p>
<p><strong>control hazard</strong> 控制隐患</p>
<p><strong>control transfer</strong> 控制转移</p>
<p><strong>coprocessor</strong> 协处理器</p>
<p><strong>copy-on-write</strong> 写时复制</p>
<p><strong>core dump</strong> 内存快照</p>
<p><strong>core memory</strong> 磁芯存储器</p>
<p><strong>current working directory</strong> 当前工作目录</p>
<p><strong>cycles per element (CPE)</strong> 每元素周期数</p>
<p><strong>cycles per instruction (CPI)</strong> 每指令周期数</p>
<p><strong>cylinder</strong> 柱面</p>
<p><strong>data cache (d-cache)</strong> 数据缓存</p>
<p><strong>data dependency</strong> 数据依赖</p>
<p><strong>data forwarding</strong> 数据转发</p>
<p><strong>data hazard</strong> 数据隐患</p>
<p><strong>data section</strong> 数据节</p>
<p><strong>datagram</strong> 数据报</p>
<p><strong>deadlock</strong> 死锁</p>
<p><strong>deferred coalescing</strong> 延迟合并</p>
<p><strong>demand paging</strong> 按需页面调度</p>
<p><strong>demand-zero page</strong> 请求二进制0的页</p>
<p><strong>demangling</strong> 还原</p>
<p><strong>denormalize</strong> 非规格化</p>
<p><strong>descriptor</strong> 描述符</p>
<p><strong>descriptor set</strong> 描述符集</p>
<p><strong>direct-mapped cache</strong> 直接映射缓存</p>
<p><strong>direct memory access (DMA)</strong> 直接存储器存取</p>
<p><strong>directory</strong> 目录</p>
<p><strong>dirty bit</strong> 修改位</p>
<p><strong>disassembler</strong> 反汇编器</p>
<p><strong>domain name</strong> 域名</p>
<p><strong>domain name system (DNS)</strong> 域名系统</p>
<p><strong>dotted-decimal notation</strong> 点分十进制表示法</p>
<p><strong>double date-rate synchronous DRAM (DDR SDRAM)</strong>
双数据率同步DRAM</p>
<p><strong>double word</strong> 双字</p>
<p><strong>dual inline memory module (DIMM)</strong>
双列直插存储模块</p>
<p><strong>dynamic linking</strong> 动态链接</p>
<p><strong>dynamic link library (DLL)</strong> 动态链接库</p>
<p><strong>dynamic memory allocator</strong> 动态内存分配器</p>
<p><strong>dynamic random access memory (DRAM)</strong>
动态随机存取存储器</p>
<p><strong>effective address</strong> 有效地址</p>
<p><strong>electrically erasable PROM</strong> 电可擦写可编程ROM</p>
<p><strong>encapsulation</strong> 封装</p>
<p><strong>end of file (EOF)</strong> 文件结束</p>
<p><strong>end of line (EOL)</strong> 行尾符</p>
<p><strong>entry point</strong> 入口点</p>
<p><strong>ephemeral port</strong> 临时端口</p>
<p><strong>epilogue block</strong> 结尾块</p>
<p><strong>erasable programmable ROM (EPROM)</strong>
可擦写可编程ROM</p>
<p><strong>error-reporting function</strong> 错误报告函数</p>
<p><strong>Ethernet</strong> 以太网</p>
<p><strong>excepting instrcution</strong> 异常指令</p>
<p><strong>exception handler</strong> 异常处理程序</p>
<p><strong>exception table base register</strong> 异常表基址寄存器</p>
<p><strong>exceptional control flow (ECF)</strong> 异常控制流</p>
<p><strong>executable and linkable format (ELF)</strong>
可执行可链接格式</p>
<p><strong>executable object file</strong> 可执行目标文件</p>
<p><strong>execution unit (EU)</strong> 执行单元</p>
<p><strong>explicit free list</strong> 显式空闲链表</p>
<p><strong>exploit code</strong> 攻击代码</p>
<p><strong>exponent</strong> 阶码</p>
<p><strong>extended data out DRAM (EDO DRAM)</strong>
扩展数据输出DRAM</p>
<p><strong>first fit</strong> 首次适配</p>
<p><strong>flash memory</strong> 闪存</p>
<p><strong>flash translation layer (FTL)</strong> 闪存转换层</p>
<p><strong>flat addressing</strong> 平坦寻址</p>
<p><strong>floating-point</strong> 浮点</p>
<p><strong>footer</strong> 脚部</p>
<p><strong>foreground</strong> 前台</p>
<p><strong>garbage collection</strong> 垃圾回收</p>
<p><strong>garbage collector</strong> 垃圾回收器</p>
<p><strong>general-purpose register</strong> 通用目的寄存器</p>
<p><strong>giga-instructions per second (GIPS)</strong>
每秒千兆条指令</p>
<p><strong>gigahertz (GHz)</strong> 千兆赫兹</p>
<p><strong>global offset table (GOT)</strong> 全局偏移表</p>
<p><strong>gradual underflow</strong> 渐进下溢</p>
<p><strong>granularity</strong> 粒度</p>
<p><strong>graphics card</strong> 显卡</p>
<p><strong>guaranteed bound</strong> 确界</p>
<p><strong>hardware control language (HCL)</strong> 硬件控制语言</p>
<p><strong>hardware description language (HDL)</strong> 硬件描述语言</p>
<p><strong>heap</strong> 堆</p>
<p><strong>hexadecimal</strong> 十六进制</p>
<p><strong>host bus adapter</strong> 主机总线适配器</p>
<p><strong>hub</strong> 集线器</p>
<p><strong>hypertext transfer protocol (HTTP)</strong>
超文本传输协议</p>
<p><strong>hypertext markup language (HTML)</strong> 超文本标记语言</p>
<p><strong>hyperthreading (HT)</strong> 超线程</p>
<p><strong>false fragmentation</strong> 假碎片</p>
<p><strong>fast page mode DRAM (FPM DRM)</strong> 快页模式DRAM</p>
<p><strong>faulting instruction</strong> 故障指令</p>
<p><strong>firmware</strong> 固件</p>
<p><strong>floating exception</strong> 浮点异常</p>
<p><strong>formal verification</strong> 形式化验证</p>
<p><strong>fragmentation</strong> 碎片</p>
<p><strong>frame</strong> 帧</p>
<p><strong>front side bus (FSB)</strong> 前端总线</p>
<p><strong>fully associate cache</strong> 全相联缓存</p>
<p><strong>I/O redirection</strong> I/O重定向</p>
<p><strong>idempotent</strong> 幂等元</p>
<p><strong>immediate coalescing</strong> 立即合并</p>
<p><strong>implied leading 1</strong> 隐含前导1</p>
<p><strong>implicit free list</strong> 隐式空闲链表</p>
<p><strong>inline substitution</strong> 内联替换</p>
<p><strong>input/output (I/O)</strong> 输入/输出</p>
<p><strong>integer indefinite</strong> 整数不定值</p>
<p><strong>interrupt handler</strong> 中断处理程序</p>
<p><strong>instruction cache (i-cache)</strong> 指令缓存</p>
<p><strong>instruction code (icode)</strong> 指令代码</p>
<p><strong>instruction control unit (ICU)</strong> 指令控制单元</p>
<p><strong>instructions executed per cycle (IPC)</strong>
每周期执行指令数</p>
<p><strong>instruction function (ifun)</strong> 指令函数</p>
<p><strong>instruction squashing</strong> 指令排除</p>
<p><strong>instruction set architecture (ISA)</strong> 指令集架构</p>
<p><strong>Institute of Electrical and Electronics Engineers
(IEEE)</strong> 电气与电子工程师协会</p>
<p><strong>International Organization for Standardization (ISO)</strong>
国际标准化组织</p>
<p><strong>International Telephone and Telegraph Corporation (AT&amp;T,
ITT)</strong> 美国国际电话电报公司</p>
<p><strong>internet protocol (IP)</strong> 网际协议</p>
<p><strong>interpretation</strong> 解释</p>
<p><strong>interprocess communication (IPC)</strong> 进程间通信</p>
<p><strong>inverse function</strong> 反函数</p>
<p><strong>issue time</strong> 发出时间</p>
<p><strong>iterative server</strong> 迭代服务器</p>
<p><strong>Java native interface (JNI)</strong> Java本地接口</p>
<p><strong>job</strong> 作业</p>
<p><strong>just-in-time</strong> 即时</p>
<p><strong>kernel</strong> 内核；核心</p>
<p><strong>last-in first-out (LIFO)</strong> 后进先出</p>
<p><strong>latency bound</strong> 延迟界限</p>
<p><strong>lazy binding</strong> 延迟绑定</p>
<p><strong>least frequently used (LFU)</strong> 最不常用使用</p>
<p><strong>least recently used (LRU)</strong> 最近最少使用</p>
<p><strong>library interpositioning</strong> 库打桩</p>
<p><strong>line feed (LF)</strong> 换行</p>
<p><strong>little endian</strong> 小端</p>
<p><strong>load effective address</strong> 加载有效地址</p>
<p><strong>load interlock</strong> 加载互锁</p>
<p><strong>load/use hazard</strong> 加载/使用隐患</p>
<p><strong>load penalty</strong> 加载处罚</p>
<p><strong>local area network (LAN)</strong> 局域网</p>
<p><strong>locality</strong> 局部性</p>
<p><strong>logic gate</strong> 逻辑门</p>
<p><strong>logic synthsis</strong> 逻辑合成</p>
<p><strong>logical control flow</strong> 逻辑控制流</p>
<p><strong>loop unrolling</strong> 循环展开</p>
<p><strong>loopback address</strong> 环回地址</p>
<p><strong>macro</strong> 宏</p>
<p><strong>main memory</strong> 主存；内存</p>
<p><strong>mangling</strong> 倾轧</p>
<p><strong>mark&amp;sweep</strong> 标记-清除</p>
<p><strong>mask</strong> 掩码</p>
<p><strong>memory aliasing</strong> 内存混叠</p>
<p><strong>memory controller</strong> 存储控制器</p>
<p><strong>memory hierarchy</strong> 存储器层次结构</p>
<p><strong>memory-mapped I/O</strong> 内存映射I/O</p>
<p><strong>memory mapping</strong> 内存映射</p>
<p><strong>memory management unit (MMU)</strong> 存储管理单元</p>
<p><strong>memory mountain</strong> 存储器山</p>
<p><strong>metadata</strong> 元数据</p>
<p><strong>mispredicted branch penalty</strong> 预测错误分支处罚</p>
<p><strong>mode bit</strong> 模式位</p>
<p><strong>multicore</strong> 多核</p>
<p><strong>multiple zone recording</strong> 多区记录</p>
<p><strong>multiplexor (MUX)</strong> 多路复用器</p>
<p><strong>multiprocessor</strong> 多处理器</p>
<p><strong>multipurpose internet mail extensions (MIME)</strong>
多用途互联网邮件扩展</p>
<p><strong>multiway branching</strong> 多重分支</p>
<p><strong>mutex</strong> 互斥锁</p>
<p><strong>mutual exclusion</strong> 互斥</p>
<p><strong>named pipe</strong> 命名管道</p>
<p><strong>National Science Foundation (NSF)</strong> 国家科学基金会</p>
<p><strong>negative weight</strong> 负权</p>
<p><strong>network file system</strong> 网络文件系统</p>
<p><strong>never taken (NT)</strong> 从不选择</p>
<p><strong>newline character</strong> 换行符</p>
<p><strong>next fit</strong> 下次适配</p>
<p><strong>no-write-allocate</strong> 非写分配</p>
<p><strong>no operation (nop)</strong> 空操作</p>
<p><strong>noexecute (NE)</strong> 不执行</p>
<p><strong>nonlocal jump</strong> 非本地跳转</p>
<p><strong>nonvolatile memory (NVM)</strong> 非易失性存储器</p>
<p><strong>nop sled</strong> 空操作雪橇</p>
<p><strong>normal size</strong> 标称大小</p>
<p><strong>not a number (NaN)</strong> 非数字</p>
<p><strong>object file format</strong> 目标文件格式</p>
<p><strong>object module</strong> 目标模块</p>
<p><strong>oct word</strong> 八字</p>
<p><strong>off-by-one</strong> 相差1</p>
<p><strong>ones' complement</strong> 反码</p>
<p><strong>operand</strong> 操作数</p>
<p><strong>optimization blocker</strong> 优化阻碍</p>
<p><strong>origin server</strong> 原始服务器</p>
<p><strong>overflow</strong> 溢出</p>
<p><strong>packet</strong> 分组</p>
<p><strong>page fault</strong> 缺页</p>
<p><strong>page frame</strong> 页帧</p>
<p><strong>page in</strong> 页面调入</p>
<p><strong>page out</strong> 页面调出</p>
<p><strong>page table</strong> 页表</p>
<p><strong>page table base register (PTBR)</strong> 页表基址寄存器</p>
<p><strong>page table entry</strong> 页表条目</p>
<p><strong>parallelism</strong> 并行</p>
<p><strong>parity flag (PF)</strong> 奇偶标志</p>
<p><strong>pathname</strong> 路径名</p>
<p><strong>PC-relative</strong> PC相对</p>
<p><strong>peak utilization</strong> 峰值利用率</p>
<p><strong>pending signal</strong> 待处理信号</p>
<p><strong>peripheral component interconnect (PCI)</strong>
外围组件互联</p>
<p><strong>physical address (PA)</strong> 物理地址</p>
<p><strong>physical page (PP)</strong> 物理页</p>
<p><strong>picosecond (ps)</strong> 微微秒；皮秒</p>
<p><strong>placement policy</strong> 放置策略</p>
<p><strong>platter</strong> 盘片</p>
<p><strong>pointer dereferencing</strong> 指针间接引用</p>
<p><strong>position-independint code (PIC)</strong> 位置无关代码</p>
<p><strong>prefetch</strong> 预取</p>
<p><strong>prethread</strong> 预线程</p>
<p><strong>printed circuit board (PCB)</strong> 印制电路板</p>
<p><strong>preempt</strong> 抢占</p>
<p><strong>prefix sum</strong> 前缀和</p>
<p><strong>private address space</strong> 私有地址空间</p>
<p><strong>privileged instruction</strong> 特权指令</p>
<p><strong>procedure linkage table (PLT)</strong> 过程链接表</p>
<p><strong>process graph</strong> 进度图</p>
<p><strong>process group</strong> 进程组</p>
<p><strong>processor package</strong> 处理器封装</p>
<p><strong>program counter (PC)</strong> 程序计数器</p>
<p><strong>programmable ROM (PROM)</strong> 可编程ROM</p>
<p><strong>programmer visible state</strong> 程序员可见状态</p>
<p><strong>prologue block</strong> 序言块</p>
<p><strong>proxy cache</strong> 代理缓存</p>
<p><strong>proxy chain</strong> 代理链</p>
<p><strong>portable executable (PE)</strong> 可移植可执行</p>
<p><strong>quad word</strong> 四字</p>
<p><strong>random access memory (RAM)</strong> 随机 (存取) 存储器</p>
<p><strong>reachability graph</strong> 可达图</p>
<p><strong>read-only memory (ROM)</strong> 只读存储器</p>
<p><strong>read/write head</strong> 读/写磁头</p>
<p><strong>reassociation transformation</strong> 重新结合变换</p>
<p><strong>reentrancy</strong> 可重入性</p>
<p><strong>recursion</strong> 递归</p>
<p><strong>reduced instruction set computer (RISC)</strong>
精简指令集计算机</p>
<p><strong>register specifier byte</strong> 寄存器指示符字节</p>
<p><strong>relocateable object file</strong> 可重定位目标文件</p>
<p><strong>relocation entry</strong> 重定位条目</p>
<p><strong>request for comment (RFC)</strong> 请求评论</p>
<p><strong>reset configuration</strong> 复位配置</p>
<p><strong>resident set</strong> 常驻集合</p>
<p><strong>retirement unit</strong> 退役单元</p>
<p><strong>return penalty</strong> 返回处罚</p>
<p><strong>reverse engineering</strong> 逆向工程</p>
<p><strong>revolution per minute (RPM)</strong> 转每分钟</p>
<p><strong>router</strong> <strong>路由器</strong></p>
<p><strong>row access strobe (RAS)</strong> 行地址选通脉冲</p>
<p><strong>security monoculture</strong> 安全单一化</p>
<p><strong>section header table</strong> 节首部表</p>
<p><strong>sector</strong> 扇区</p>
<p><strong>seek</strong> 寻道</p>
<p><strong>segmentation fault</strong> 段故障</p>
<p><strong>segmented addressing</strong> 段寻址</p>
<p><strong>segregated fit</strong> 分离适配</p>
<p><strong>semaphore</strong> 信号量</p>
<p><strong>separate compliation</strong> 分离编译</p>
<p><strong>sequential circuit</strong> 时序电路</p>
<p><strong>serial advanced technology attachment (SATA)</strong>
串行高级技术附件</p>
<p><strong>server</strong> 服务器</p>
<p><strong>set associative cashe</strong> 组相联缓存</p>
<p><strong>shared library</strong> 共享库</p>
<p><strong>shared object</strong> 共享目标</p>
<p><strong>short count</strong> 计数不足</p>
<p><strong>side effect</strong> 副作用</p>
<p><strong>sign magnitude</strong> 原码</p>
<p><strong>signal</strong> 信号</p>
<p><strong>signal mask</strong> 信号掩码</p>
<p><strong>significand</strong> 尾数</p>
<p><strong>slow system call</strong> 慢速系统调用</p>
<p><strong>small code model</strong> 小型代码模型</p>
<p><strong>small computer system interface (SCSI)</strong>
小型计算机系统接口</p>
<p><strong>simple segregated storage</strong> 简单分离存储</p>
<p><strong>simultaneous multithreading</strong> 同时多线程</p>
<p><strong>single instruction multiple data (SIMD)</strong>
单指令多数据</p>
<p><strong>socket</strong> 套接字</p>
<p><strong>socket pair</strong> 套接字对</p>
<p><strong>solid state disk (SSD)</strong> 固态硬盘</p>
<p><strong>speculative execution</strong> 试探执行</p>
<p><strong>speedup</strong> 加速比</p>
<p><strong>spill</strong> 溢出</p>
<p><strong>stack</strong> 栈</p>
<p><strong>standard library</strong> 标准库</p>
<p><strong>state machine</strong> 状态机</p>
<p><strong>static library</strong> 静态库</p>
<p><strong>static linker</strong> 静态链接器</p>
<p><strong>static random access memory (SRAM)</strong>
静态随机存取存储器</p>
<p><strong>streaming SIMD extension (SSE)</strong> 流式SMID扩展</p>
<p><strong>stride-1 reference pattern</strong> 步长为1的引用模式</p>
<p><strong>strong scaling</strong> 强缩放</p>
<p><strong>superscalar</strong> 超标量</p>
<p><strong>supervisors mode</strong> 超级用户模式</p>
<p><strong>swap area</strong> 交换区域</p>
<p><strong>swap file</strong> 交换文件</p>
<p><strong>swap space</strong> 交换空间</p>
<p><strong>symbol resolution</strong> 符号解析</p>
<p><strong>symbolic link</strong> 字符链接</p>
<p><strong>symbolic method</strong> 符号方法</p>
<p><strong>synchronous DRAM (SDRAM)</strong> 同步DRAM</p>
<p><strong>system call</strong> 系统调用</p>
<p><strong>tag bit</strong> 标识位</p>
<p><strong>The Internet Corporation for Assigned Names and Numbers
(ICANN)</strong> 互联网名称与数据地址分配机构</p>
<p><strong>The Internet Engineering Task Force (IETF)</strong>
互联网工程任务组</p>
<p><strong>thrash</strong> 抖动</p>
<p><strong>thread</strong> 线程</p>
<p><strong>thread ID (TID)</strong> 线程ID</p>
<p><strong>thread routine</strong> 线程例程</p>
<p><strong>throughput bound</strong> 吞吐量界限</p>
<p><strong>time slicing</strong> 时间分片</p>
<p><strong>topological sort</strong> 拓扑排序</p>
<p><strong>track</strong> 磁道</p>
<p><strong>transaction</strong> 事务</p>
<p><strong>transfer time</strong> 传输时间</p>
<p><strong>transition</strong> 过渡</p>
<p><strong>translation lookaside buffer (TLB)</strong>
转换后备缓冲区；页表缓存</p>
<p><strong>transmission control protocol (TCP)</strong> 传输控制协议</p>
<p><strong>truncation</strong> 截断</p>
<p><strong>two's-complement</strong> 补码</p>
<p><strong>unified cache</strong> 统一缓存</p>
<p><strong>uniform resource identifier (URI)</strong> 统一资源标识符</p>
<p><strong>uniprocessor</strong> 单处理器</p>
<p><strong>universal resource locator (URL)</strong> 统一资源定位符</p>
<p><strong>universal serial bus (USB)</strong> 通用串行总线</p>
<p><strong>unsigned</strong> 无符号</p>
<p><strong>user datagram protocol (UDP)</strong> 用户数据报协议</p>
<p><strong>valid bit</strong> 有效位</p>
<p><strong>video RAM (VRAM)</strong> 显存</p>
<p><strong>virtual page (VP)</strong> 虚拟页</p>
<p><strong>virtual page offset (VPO)</strong> 虚拟页偏移</p>
<p><strong>wait set</strong> 等待集合</p>
<p><strong>weak scaling</strong> 弱缩放</p>
<p><strong>wear-leveling</strong> 磨损均衡</p>
<p><strong>wide area network (WAN)</strong> 广域网</p>
<p><strong>word size</strong> 字长</p>
<p><strong>working set</strong> 工作集</p>
<p><strong>world wide web</strong> 万维网</p>
<p><strong>wrapper function</strong> 包装函数</p>
<p><strong>write-allocate</strong> 写分配</p>
<p><strong>write-through cache</strong> 透写缓存</p>
<p><strong>write-back cache</strong> 回写缓存</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法 第7版》第7章 网络安全</title>
    <url>/2022/08/24/computer-networking-a-top-down-approach-7e-chpt-7/</url>
    <content><![CDATA[<p>　　<strong>安全通信</strong>应该具有<span
style="background-color: yellow">保密</span>、<span
style="background-color: yellow">报文完整</span>、<span
style="background-color: yellow">端点认证</span>、<span
style="background-color: yellow">运行安全</span>的特点。</p>
<p>　　互联网协议栈中不止网络层提供安全性功能。首先，网络层可以通过加密数据报中的有效载荷以及认证所有源IP地址来提供全面覆盖的安全性，但并不能提供用户级安全，因此也需要其他层的安全性功能来实现。其次，在协议栈的较上层部署新的的互联网服务(包括安全性服务)通常更容易。</p>
<img src="/2022/08/24/computer-networking-a-top-down-approach-7e-chpt-7/provide_anonymity_and_privacy_with_a_proxy.svg" class="" title="provide_anonymity_and_privacy_with_a_proxy">
<p>　　为了在访问Web获得隐私和匿名，可以组合使用可信代理服务器和SSL。首先主机与可信代理服务器建立SSL连接，通过SSL连接发送到所需站点的HTTP请求。代理收到SSL加密的HTTP请求后，它会解密该请求并将明文HTTP转发到网站，然后服务器响应代理，代理再通过SSL将响应转发给主机。该Web站点仅能看到代理的IP地址，主机的本地ISP无法记录主机的访问，但代理可以获取主机的IP地址以及主机和网站之间所有明文流量。因此，这种方式的安全取决于代理的可信度。</p>
<p>　　TOR匿名和隐私服务采用一系列非串通代理服务器来路由流量。TOR允许独立个体为其代理池贡献代理。当某用户使用TOR连接到服务器时，TOR从代理池随机选择三个代理形成代理链并通过代理链路由在用户和服务器之间所有流量。若三个代理不串通则无法得知用户与Web站点间的通信。尽管最后一个代理和服务器之间传输明文，但最后一个代理并不知道用户的IP地址。</p>
<span id="more"></span>
<h3 id="密码学">7.1 密码学</h3>
<p>　　使用<strong>加密算法</strong>对<strong>明文</strong>进行加密后生成<strong>密文</strong>。</p>
<p>　　在<strong>对称加密</strong>中双方使用相同的密钥。在<strong>非对称加密</strong>中使用<strong>公钥</strong>和<strong>密钥</strong>，任何人都可以获得公钥。</p>
<p>　　若只能得到截取的密文，也不了解明文内容，统计分析有助于对加密方案的<strong>唯密文攻击</strong>。若能得到部分明文与密文的匹配关系，通过这种方式的攻击称为<strong>已知明文攻击</strong>。在<strong>选择明文攻击</strong>中，能选择明文信息并获取对应的密文，但并不代表能获取加密的过程。</p>
<h4 id="对称加密">7.1.1 对称加密</h4>
<p>　　<strong>凯撒密码</strong>加密字母时，将每个字母在字母表中该字母后第<span
class="math inline">\(k\)</span>个字母与之替换。 <span
class="math display">\[
x=(x+k) \bmod 26
\]</span>
　　凯撒密码的改进版是<strong>单表替换密码</strong>，但它不是根据常规模式进行替换，任何字母可以替换其他字母，只需每个字母有唯一的替换字母即可。</p>
<img src="/2022/08/24/computer-networking-a-top-down-approach-7e-chpt-7/a_monoalphabetic_cipher.svg" class="" title="a_monoalphabetic_cipher">
<p>　　单表替换密码的字母配对看似很多，但通过对明文语言进行统计分析后可以发现e和t出现的频率最高且特定的两个和三个字母经常一起出现，实际上破解更容易一些。</p>
<p>　　单表替换密码的的改进版是<strong>多表替换密码</strong>。多表替换密码的基本思想是使用多个单表替换密码，一个单表替换密码用于加密明文中特定位置的字母。因此，明文中不同位置出现的字母可能以不同的方式加密。</p>
<p>　　现代对称加密大致分为<strong>流加密</strong>和<strong>块加密</strong>。块加密用于PGP、SSL和IPsec等，流加密用于WEP等。</p>
<img src="/2022/08/24/computer-networking-a-top-down-approach-7e-chpt-7/simple_example_of_block_cipher.svg" class="" title="simple_example_of_block_cipher">
<p>　　在块加密中，明文以<span
class="math inline">\(k\)</span>位块进行处理。为了对块进行加密，使用一对一映射将明文的<span
class="math inline">\(k\)</span>位映射到密文的<span
class="math inline">\(k\)</span>位块，因此每种输入都有不同的输出。块密码通常使用函数模拟随机排列表。以64位块为例并假设置乱函数为公共已知，将64位块分成8个小块，每个小块由8位组成，每个小块由一个8位到8位的映射表进行映射，该表具有的大小可管理的映射长度，然后这8个输出块重新组装成64位块并置乱，最后将结果作为输入再循环<span
class="math inline">\(n\)</span>次该过程。循环的目的是使每个输入位都影响最后输出位的大部分乃至全部。这种块密码算法的密钥是8张映射表。</p>
<p>　　诸如DES、3DES和AES的块密码都使用位串作为密钥，密钥决定了映射表的映射和算法内部的排列。DES使用了具有56位密钥的64位块，AES使用了128位块且能够使用128、192和256位的密钥进行操作。</p>
<p>　　报文明文中可能存在多个相同的明文块，使用块密码产生的密文也相同，因此可能猜出明文并根据相同的密文块和协议结构相关的知识解密整个报文。为了解决这个问题，可以在密文中混合一些随机性使得相同的明文生成不同的密文。</p>
<p>　　密钥为<span
class="math inline">\(S\)</span>的块密码加密算法表示为<span
class="math inline">\(K_S\)</span>，第<span
class="math inline">\(i\)</span>个明文块和密文块分布表示为<span
class="math inline">\(m(i)\)</span>和<span
class="math inline">\(c(i)\)</span>。发送端根据第<span
class="math inline">\(i\)</span>块生成随机的<span
class="math inline">\(k\)</span>位数<span
class="math inline">\(r(i)\)</span>且计算<span
class="math inline">\(c(i)=K_s(m(i)\oplus
r(i))\)</span>。接收端能接收到<span
class="math inline">\(c(i)\)</span>和<span
class="math inline">\(r(i)\)</span>，根据<span
class="math inline">\(m(i)=K_s(c(i)\oplus
r(i))\)</span>可以进行解密。但这样需要传输额外的随机数，为了解决这一问题，块密码使用了<strong>密码块链接</strong>，基本思想是仅第一个报文发送一个随机值，然后让发送端和接收端使用计算出的密文代替后继的随机数。</p>
<p>　　1) 在加密报文前，发送端生成一个随机的<span
class="math inline">\(k\)</span>位串，称为<strong>初始向量</strong>，用<span
class="math inline">\(c(0)\)</span>表示。发送端以<span
style="background-color: yellow">明文</span>发送IV给接收端。</p>
<p>　　2) 对第一个块，发送端计算<span class="math inline">\(m(1)\oplus
c(0)\)</span>，然后通过块密码得到对应的密文<span
class="math inline">\(c(1)=K_S(m(1)\oplus c(0))\)</span>并发送。</p>
<p>　　3) 对于第<span
class="math inline">\(i\)</span>个块，发送端根据<span
class="math inline">\(c(i)=K_S(m(i)\oplus c(i-1))\)</span>生成第<span
class="math inline">\(i\)</span>个密文块。</p>
<h4 id="非对称加密">7.1.2 非对称加密</h4>
<p>　　公钥和私钥分别表示为<span
class="math inline">\(K^+_B\)</span>和<span
class="math inline">\(K^-_B\)</span>。报文<span
class="math inline">\(m\)</span>通过公钥和众所周知的加密算法加密后得到密文<span
class="math inline">\(K^+_B(m)\)</span>，密文通过私钥和众所周知的解密算法进行解密<span
class="math inline">\(K^-_B(K^+_B(m))=m\)</span>。私钥加密后也可以用公钥解密<span
class="math inline">\(K^+_B(K^-_B(m))=m\)</span>。</p>
<p>　　RSA算法广泛使用了模<span class="math inline">\(n\)</span>运算。
<span class="math display">\[
\begin{align}
[(a \bmod n)\cdot (b \bmod n)]&amp;=(a\cdot b)\bmod n\\[3px]
(a \bmod n)^d \bmod n&amp;=a^d\bmod n
\end{align}
\]</span> 　　为了生成RSA的公钥和密钥，首先选择两个大素数<span
class="math inline">\(p\)</span>和<span
class="math inline">\(q\)</span>，<span
class="math inline">\(p\)</span>和<span
class="math inline">\(q\)</span>越大，破解RSA越困难，加密和解密的时间也越长。然后计算公共模数<span
class="math inline">\(n=pq\)</span>和欧拉函数<span
class="math inline">\(\varphi(n)=(p-1)(q-1)\)</span>。选择一个小于<span
class="math inline">\(n\)</span>且与<span
class="math inline">\(\varphi(n)\)</span>没有(非1的)公因数的公钥指数<span
class="math inline">\(e\)</span>，再选择<span
class="math inline">\(d\)</span>使<span class="math inline">\(ed\bmod
\varphi(n)=1\)</span>成立。公钥<span
class="math inline">\(K^+_B\)</span>是一对数<span
class="math inline">\((n,e)\)</span>，私钥<span
class="math inline">\(K^-_B\)</span>是一对数<span
class="math inline">\((n,d)\)</span>。实际中，RSA的<span
class="math inline">\(n\)</span>一般是1024位和2048位，<span
class="math inline">\(e\)</span>常使用3、17和65537。</p>
<p>　　对于明文<span class="math inline">\(m(m&lt;n)\)</span>的密文<span
class="math inline">\(c=m^e \bmod n\)</span>，解密时先对该值进行<span
class="math inline">\(d\)</span>次幂运算，再做模<span
class="math inline">\(n\)</span>运算。 <span class="math display">\[
\begin{align}
(m^e \bmod n)^d \bmod n&amp;=m^{ed}\bmod n\\[3px]
&amp;=m^{(ed \bmod \varphi(n))} \bmod n\\[3px]
&amp;=m^1 \bmod n\\[3px]
&amp;=m
\end{align}
\]</span> 　　使用私钥加密同样可以用公钥解密<span
class="math inline">\((m^d \bmod n)^e \bmod n=m^{ed}\bmod
n=m\)</span>。</p>
<p>　　RSA的指数运算比较耗时，DES则快很多，因此在实际应用中RSA常与对称加密结合使用。首先选择加密数据的共享对称密钥，称为<strong>会话密钥</strong><span
class="math inline">\(K_S\)</span>。然后使用RSA密钥对会话密钥进行加密<span
class="math inline">\(c=(K_S)^e \bmod
n\)</span>。最后对方收到后使用私钥进行解密可以获得会话密钥。</p>
<h4 id="密钥分发和管理">7.1.3 密钥分发和管理</h4>
<p>　　Diffie-Hellman(DH)密钥协商算法能够让通信双方在<span
style="background-color: yellow">非安全</span>的信道中安全地交换密钥，用于加密后续的通信信息。DH算法选择一个大素数<span
class="math inline">\(p\)</span>和小于<span
class="math inline">\(p\)</span>的数<span
class="math inline">\(g\)</span>，这两个数以明文的形式从一方发送到另一方，A、B双方完成共享<span
class="math inline">\(g\)</span>和<span
class="math inline">\(p\)</span>后各自选择密钥<span
class="math inline">\(S_A\)</span>和<span
class="math inline">\(S_B\)</span>。A、B各自计算公钥<span
class="math inline">\(T_A=g^{S_A}\bmod p\)</span>和<span
class="math inline">\(T_B=g^{S_B}\bmod
p\)</span>并通过公网交换公钥。A计算共享密钥<span
class="math inline">\(S=S_A^{^{S_B}}\bmod
p\)</span>，同样B计算共享密钥<span
class="math inline">\(S&#39;=S_B^{^{S_A}}\bmod p\)</span>。 <span
class="math display">\[
\begin{align}
S&amp;=S_A^{^{S_B}}\bmod p=(g^{S_A})^{S_B}\bmod p=g^{S_A\cdot S_B}\bmod
p=S&#39;
\end{align}
\]</span> 　　若<span
class="math inline">\(g=p-1\)</span>，根据费马小定理可以推出<span
class="math inline">\(g^{p-1}\equiv 1( \bmod
p)\)</span>，这对密钥协商构成威胁，因此<span
class="math inline">\(g\)</span>只能在<span
class="math inline">\([1,p-2]\)</span>中选择。</p>
<p>　　DH算法并不能防御欺骗攻击，攻击者在在双方交换密钥时截获并替换成自身的密钥，双方的密钥协商就变成了每方单独都和攻击者的协商。</p>
<p>　　<strong>密钥分发中心</strong>存储每个用户信息以及仅用户和KDC共享的对称密钥，该密钥称为<strong>长效密钥</strong>，因此通信双方都是KDC用户时KDC可以作为通信双方的第三方。</p>
<p>　　<span class="math inline">\(K_S\)</span>表示A和B的会话密钥，<span
class="math inline">\(K_{A-KDC}\)</span>和<span
class="math inline">\(K_{B-KDC}\)</span>表示A和B与KDC的长效密钥。A用<span
class="math inline">\(K_{A-KDC}\)</span>加密A和B的标识得到<span
class="math inline">\(K_{A-KDC}(A,B)\)</span>并发送给KDC。KDC收到后解密得知A将与B通信并生成<span
class="math inline">\(K_S\)</span>，用<span
class="math inline">\(K_{B-KDC}\)</span>加密A的标识和<span
class="math inline">\(K_S\)</span>得到<span
class="math inline">\(K_{B-KDC}(A,K_S)\)</span>，用<span
class="math inline">\(K_{A-KDC}\)</span>加密<span
class="math inline">\(K_S\)</span>和<span
class="math inline">\(K_{B-KDC}(A,K_S)\)</span>得到<span
class="math inline">\(K_{A-KDC}(K_S,K_{B-KDC}(A,K_S))\)</span>并发送给A。A收到后解密得到<span
class="math inline">\(K_S\)</span>并把<span
class="math inline">\(K_{B-KDC}(A,K_S)\)</span>发送给B，B收到后解密得到<span
class="math inline">\(K_S\)</span>。</p>
<h3 id="报文完整性和数字签名">7.2 报文完整性和数字签名</h3>
<p>　　散列函数输入<span
class="math inline">\(m\)</span>，可以得到一个固定长度的字符串<span
class="math inline">\(H(m)\)</span>。<strong>密码散列函数</strong>的特点是不同的输入不能得到相同的输出。</p>
<p>　　在MD5散列算法中，首先添加一个64位数来表示明文长度，再填充长度(添加1并在后面添加足够的0)，直到输入满足一定的条件，初始化累加器并进行循环，在循环中对报文的16字块进行4轮处理。另一个常用散列算法是SHA。</p>
<img src="/2022/08/24/computer-networking-a-top-down-approach-7e-chpt-7/mac.svg" class="" title="mac">
<p>　　为了执行<strong>报文完整性</strong>，除了使用密码散列函数，还需要一个称为<strong>认证密钥</strong>的共享密钥<span
class="math inline">\(s\)</span>。发送端用报文<span
class="math inline">\(m\)</span>和<span
class="math inline">\(s\)</span>级联生成<span
class="math inline">\(m+s\)</span>并计算散列值<span
class="math inline">\(H(m+s)\)</span>，散列值<span
class="math inline">\(H(m+s)\)</span>称为<strong>报文认证码</strong>。然后将MAC附加到<span
class="math inline">\(m\)</span>生成扩展报文<span
class="math inline">\((m,H(m+s))\)</span>并发送。接收端收到扩展报文<span
class="math inline">\((m,h)\)</span>，由于接收端也有<span
class="math inline">\(s\)</span>，若<span
class="math inline">\(H(m+s)=h\)</span>则表示一切正常。</p>
<p>　　常用的MAC有HMAC，它能够与MD5或SHA一起使用。HMAC实际上通过散列函数计算数据和认证密钥两次。在LS算法中，可以通过物理操作或直接使用路由器自带的公钥实现认证密钥分发给AS内的每个路由器。</p>
<p>　　可以使用<span
style="background-color: yellow">非对称加密</span>和<span
style="background-color: yellow">散列函数</span>来进行<strong>数字签名</strong>。发送端的公钥和密钥表示为<span
class="math inline">\(K^+_S\)</span>和<span
class="math inline">\(K^-_S\)</span>，接收端的公钥和密钥表示为<span
class="math inline">\(K^+_R\)</span>和<span
class="math inline">\(K^-_R\)</span>。发送端先用散列函数计算明文获得散列值，用<span
class="math inline">\(K^-_S\)</span>加密散列值得到数字签名并和<span
class="math inline">\(K^+_R\)</span>加密后的密文一起发送。接收端收到后用<span
class="math inline">\(K^+_S\)</span>解密数字签名后的结果并和<span
class="math inline">\(K^-_R\)</span>解密密文后的结果的散列值进行比较，若相等则表示一切正常。</p>
<p>　　<strong>公钥认证</strong>是证明公钥属于特定的实体。将公钥认证通常由<strong>认证中心</strong>完成，其功能是证实一个实体的真实身份，一旦证实了身份后，CA会生成一个其身份和实体的公钥绑定的<strong>证书</strong>，该证书包含公钥和公钥所有者的全局唯一标识信息(人名或IP地址等)，CA会对这个证书进行数字签名。</p>
<p>　　ITU和IETF都研发了用于CA的系列标准。</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>version</td>
<td>X.509规范的版本号</td>
</tr>
<tr>
<td>serial number</td>
<td>CA颁发的证书的唯一标识符</td>
</tr>
<tr>
<td>signature</td>
<td>规定CA用于签署证书的算法</td>
</tr>
<tr>
<td>issuer name</td>
<td>颁发此证书的CA的身份(采用DN格式)</td>
</tr>
<tr>
<td>validity period</td>
<td>证书有效期的时间范围</td>
</tr>
<tr>
<td>subject name</td>
<td>其公钥与该证书相关连的实体身份(采用DN格式)</td>
</tr>
<tr>
<td>subject public key</td>
<td>公钥以及使用的公钥算法及其参数的指示</td>
</tr>
</tbody>
</table>
<h3 id="端点认证">7.3 端点认证</h3>
<p>　　<strong>端点认证</strong>是一个实体通过计算机网络向另一个实体证明其身份的过程。</p>
<p>　　<strong>认证协议</strong>将在两个通信实体运行其他协议之前运行。AP首先建立相互认可的各方的标识，当认证完成后才继续之后的事情。</p>
<p>　　ap1.0就是直接告知对方其身份，但该身份可以假冒。</p>
<p>　　ap2.0使用了类似于IP地址的众所周知的网络地址，但IP哄骗可以在数据报的源地址中填入任何地址且并非所有网关路由器都配置了仅转发源IP地址为路由器所属网络的IP地址的数据报的功能。</p>
<p>　　ap3.0加入了密码，密码由认证实体和被认证实体共享，但密码可能被窃取，例如，当Telnet其他主机并登录时，登录密码会以明文的形式发送端Telnet服务器，而连接到Telnet客户端或服务器LAN的攻击者可以嗅探LAN上传输的所有数据包来获取登录密码。</p>
<p>　　ap3.1加入了加密密码，但这样并不能防御<strong>重放攻击</strong>，攻击者只需窃听通信并记录加密密码，再将重放加密密码。</p>
<p>　　ap4.0加入了类似于TCP建立连接的方式和<strong>不重数</strong>，不重数是不重复使用的随机数。被认证实体向认证实体发送认证信息，认证实体返回一个不重数<span
class="math inline">\(R\)</span>，被认证实体使用共享对称密钥<span
class="math inline">\(K\)</span>来加密<span
class="math inline">\(R\)</span>并把<span
class="math inline">\(K(R)\)</span>发回给认证实体。认证实体解密后得到的结果与<span
class="math inline">\(R\)</span>相等则表示认证成功。<span
class="math inline">\(R\)</span>也可以用被认证实体的私钥来加密，认证实体收到后使用被认证实体的公钥解密。</p>
<h3 id="安全电子邮件">7.4 安全电子邮件</h3>
<p>　　安全电子邮件应该具有<span
style="background-color: yellow">保密</span>、<span
style="background-color: yellow">报文完整</span>、<span
style="background-color: yellow">发送端认证</span>的特点。</p>
<p>　　保密性可以通过会话密钥实现，报文完整性和发送端认证都可以通过数字签名实现。若需要同时实现保密性、报文完整性和发送端认证则需要将会话密钥和数字签名结合使用，安全分发公钥可以使用CA来验证公钥。</p>
<p>　　<span class="math inline">\(K_S\)</span>表示会话密钥，<span
class="math inline">\(K^+_S\)</span>和<span
class="math inline">\(K^-_S\)</span>表示发送端的公钥和私钥， <span
class="math inline">\(K^+_R\)</span>和<span
class="math inline">\(K^-_R\)</span>表示接收端的公钥和私钥。发送端通过散列函数计算原始报文的散列值，使用<span
class="math inline">\(K^-_S\)</span>对散列值加密得到数字签名并和原始报文级联形成预备包。然后使用<span
class="math inline">\(K_S\)</span>加密预备包并使用<span
class="math inline">\(K^+_R\)</span>加密<span
class="math inline">\(K_S\)</span>，最后将加密的预备包和加密的<span
class="math inline">\(K_S\)</span>级联形成包并发送。接收端收到报文后使用<span
class="math inline">\(K^-_R\)</span>解密得到<span
class="math inline">\(K_S\)</span>并进一步解密得到数字签名和原始报文，再使用<span
class="math inline">\(R^+_S\)</span>解密的结果和原始报文的散列值进行比较。</p>
<p>　　PGP(Pretty Good
Privacy)是安全电子邮件的一个范例。PGP使用MD5或SHA来计算散列值，使用CAST、3DES或IDEA进行对称加密，使用RSA进行非对称加密。</p>
<p>　　用户安装PGP时会为用户生成一个公钥，该公钥可以发布在用户的网站或放置在公钥服务器上。用户每次访问私钥时都必须输入密码。PGP为用户提供了报文的数字签名、加密或两者都执行的选项。PGP也提供公钥认证机制，但公钥由可信网站认证，用户可以查询某公钥是否属于某用户。此外，PGP允许用户为其所信任的用户认证更多密钥提供担保。PGP用户间可以通过持有密钥签署方来签署彼此的密钥。</p>
<h3 id="ssl">7.5 SSL</h3>
<img src="/2022/08/24/computer-networking-a-top-down-approach-7e-chpt-7/ssl.svg" class="" title="ssl">
<p>　　<strong>安全套接字层</strong>使用保密性、数据完整性和端点认证来强化TCP。SSL
3.1称为<strong>安全传输层</strong>。SSL常用于为通过HTTP的事务提供安全性，实际上，SSL为TCP提供安全性，故任何通过TCP的应用程序都可以使用SSL。SSL提供了一个简单的具有套接字的接口，该接口类似于TCP的接口。</p>
<p>　　SSL具有<span style="background-color: yellow">握手</span>、<span
style="background-color: yellow">密钥派生</span>和<span
style="background-color: yellow">数据传输</span>三个阶段。</p>
<img src="/2022/08/24/computer-networking-a-top-down-approach-7e-chpt-7/simplified_ssl_handshake.svg" class="" title="simplified_ssl_handshake">
<p>　　在握手阶段，客户端与服务器创建TCP连接并对服务器认证，然后客户端发送给服务器一个主密钥，客户端和服务器都将使用该密钥生成
SSL会话所需的所有对称密钥。一旦建立TCP连接，客户端就向服务器发送一个hello报文，服务器用其证书响应，证书中包括服务器的公钥<span
class="math inline">\(K^+_S\)</span>。客户端生成一个仅用于SSL会话的<strong>主密钥</strong>，用<span
class="math inline">\(K^+_S\)</span>加密MS得到加密主密钥并发送给服务器。服务器收到后对EMS使用服务器的私钥<span
class="math inline">\(K^-_S\)</span>进行解密获得MS。</p>
<p>　　在密钥派生阶段，发送端和服务器各自使用MS派生用于加密和报文完整的密钥，<span
class="math inline">\(E_C\)</span>和<span
class="math inline">\(E_S\)</span>表示客户端和服务器各自用于加密数据的会话密钥。<span
class="math inline">\(M_C\)</span>和<span
class="math inline">\(M_S\)</span>表示客户端和服务器各自用于验证数据完整的认证密钥。</p>
<p>　　在数据传输阶段，TCP是一种字节流协议，为了传输流的同时验证数据完整性，SSL将数据流分成多个<strong>记录</strong>，每个记录附加一个认证密钥来验证完整性。为了防御重排序或重放报文段，SSL使用了序号，序号从0开始并随着发送的每条SSL记录递增，SSL记录中并不包含序号，而是在计算MAC时加入序号，即数据加认证密钥加当前序号的散列值。对方跟踪序号并在验证数据完整性的计算中加入序号。</p>
<img src="/2022/08/24/computer-networking-a-top-down-approach-7e-chpt-7/ssl_record_format.svg" class="" title="ssl_record_format">
<p>　　SSL记录由类型、版本、长度、数据和MAC组成。前三个字段不加密。类型表示报文类型(握手报文或数据报文)，也用于关闭SSL。虽然SSL的关闭连接直接使用了TCP关闭连接，这为<strong>截断攻击</strong>创造了条件，即攻击者使用TCP
FIN来关闭连接，但SSL记录中指示了记录类型加上MAC可以防止截断攻击。</p>
<p>　　SSL并未规定加密算法的选择，它允许在SSL会话开始时就加密算法取得一致。</p>
<p>　　1)
客户端发送它支持的加密算法列表和客户端不重数。不重数是为了防御连接重放攻击，即攻击者重放从建立连接到关闭连接的所有报文。</p>
<p>　　2)
服务器选择一种对称加密算法、一种非对称加密算法和一种MAC算法并将它的选择、证书以及服务器不重数返回给客户端。</p>
<p>　　3)
客户端验证证书，提取服务器的公钥，生成一个<strong>前主密钥</strong>，用服务器的公钥加密PMS并发送给服务器。</p>
<p>　　4)
客户端和服务器使用相同的密钥派生函数并各自根据PMS和不重数计算MS，然后对MS进行切片以生成两个密钥和认证密钥。此外，对称加密中的CBC的IV也从MS获得。</p>
<p>　　5) 客户端和服务器分别发送各自握手报文的MAC。</p>
<h3 id="ipsec和vpn">7.6 IPsec和VPN</h3>
<p>　　<strong>互联网安全协议</strong>为网络层提供安全性，保护任意两个网络层实体间的IP数据报，可以用来建立VPN。IPsec提供了保密性、源认证、数据完整性和重放攻击防护。</p>
<p>　　与互联网完全分离的物理网络称为<strong>专用网络</strong>。</p>
<p>　　VPN的流量通过互联网而不是专用网络发送，流量在进入互联网前会加密。</p>
<p>　　IPsec协议族中的主要协议有<strong>认证首部</strong>协议和<strong>封装安全有效载荷</strong>协议。AH协议提供源认证和数据完整性但<span
style="background-color: yellow">不</span>提供保密性。ESP协议提供源认证、数据完整性和保密性。</p>
<img src="/2022/08/24/computer-networking-a-top-down-approach-7e-chpt-7/sa.svg" class="" title="sa">
<p>　　在源使用和目的实体发送IPsec数据报之前先建立称为<strong>安全联盟</strong>的网络层逻辑连接。一个SA是单工逻辑连接，如果两个实体需要互相发送IPsec数据报则需要创建两个SA。并非所有网关路由器或主机发送到互联网的流量都受到IPsec保护。</p>
<p>　　IPsec实体将其所有SA的状态信息存储在其<strong>安全联盟数据库</strong>中，该数据库是实体操作系统内核中的一个数据结构，需要维护的SA的状态信息包括称为<strong>安全参数索引</strong>的32位SA标识符、SA的源接口IP地址、SA的目的接口IP地址、将要使用的加密算法类型、加密密钥、完整性验证的类型以及认证密钥。IPsec实体还维护一个称为<strong>安全策略数据库</strong>的数据结构，SPD指示哪些类型(IP地址和协议类型)的数据报将被作为IPsec处理并指定SA。</p>
<p>　　IPsec数据报有<strong>隧道模式</strong>和<strong>传输模式</strong>。</p>
<img src="/2022/08/24/computer-networking-a-top-down-approach-7e-chpt-7/esp_tunnel_mode_datagram_format.svg" class="" title="esp_tunnel_mode_datagram_format">
<p>　　IP数据报转换成ESP隧道模式数据报时，先在IP数据报后面附上ESP尾部并使用SA指定的算法和密钥对这部分(IP数据报和ESP尾部)加密。在这个加密部分的前加上ESP首部并附加MAC形成有效载荷，最后加上新的IP数据报首部形成一个IP数据报。</p>
<p>　　新IP数据报首部源IP地址和目的IP地址是隧道两端路由器的接口，其协议号设置为50，表示使用ESP协议的IPsec数据报。</p>
<p>　　ESP尾部包括填充字段、填充长度和下个首部，下个首部长度表示原IP数据报有效载荷(报文段)的类型。</p>
<p>　　ESP首部包括SPI和序号，SPI表示数据报所属SA，然后接收实体可以使用SPI搜索器SAD以确定对应的认证/加密算法和密钥。序号用于重放攻击防护。</p>
<p>　　IPsec使用<strong>互联网密钥交换</strong>协议来自动创建SA。IKE协议与SSL中握手有些类似，每个IPsec实体都有一个证书，其中包括实体的公钥。两个实体交换证书、协商认证和加密算法并安全地交换密钥材料以在SA中生成会话密钥。与SSL不同的是，IKE通过两次报文交换来完成这些。</p>
<p>　　● 在首次报文交换期间，双方使用DH算法在路由器间生成一个双向的IKE
SA，该IKE
SA在两台路由器间提供认证和加密的信道。双方还创建用于认证和加密的密钥和第二次报文交换期间将用到的MS。</p>
<p>　　●
在第二次报文交换期间，双方通过数字签名表明了身份，但嗅探器无法嗅探到这些身份，因为报文是通过IKE
SA信道发生的。双方还协商用于IPsec SA的加密和认证算法。</p>
<p>　　在IKE协议第二阶段，双方在每个方向建立一个SA。在第二阶段末时，为两个SA在双方建立加密和认证会话密钥。IKE协议有两个阶段的主要原因是计算成本，由于第二阶段不涉及任何非对称加密，IKE可以在两个IPsec实体间能以较低成本生成大量SA。</p>
<h3 id="wlan安全">7.7 WLAN安全</h3>
<p>　　802.11规范中标准化的安全机制称为<strong>有线等效保密</strong>协议，WEP协议旨在提供与有线网络类似的安全级别。</p>
<p>　　WEP协议使用对称共享密钥在无线站点和无线AP之间提供认证和加密。WEP协议并没有指定密钥管理算法，因此无线站点和无线AP通过带外方法以某种方式就密钥达成一致。无线站点请求无线AP进行认证，无线AP以128位的不重数响应，无线站点用共享对称密钥加密这个不重数并发送，无线AP收到后解密并和不重数比较。</p>
<img src="/2022/08/24/computer-networking-a-top-down-approach-7e-chpt-7/802.11_wep_protocol.svg" class="" title="802.11_wep_protocol">
<p>　　若无线站点和无线AP共享40位的对称密钥<span
class="math inline">\(K_S\)</span>且<span
class="math inline">\(K_S\)</span>后附加24位的IV来创建用于加密单个帧的64位密钥。每个帧使用的IV都不同，IV以明文形式包含于每个WEP加密的802.11帧的首部中。对于64位密钥，RC4算法产生一个用于加密单个帧中的有效载荷和CRC值的密钥值的流<span
class="math inline">\(k^{IV}_1\)</span>、<span
class="math inline">\(k^{IV}_2\)</span>、<span
class="math inline">\(k^{IV}_3\)</span>，…，通过把有效载荷的第<span
class="math inline">\(i\)</span>位<span
class="math inline">\(d_i\)</span>和<span
class="math inline">\(k^{IV}_i\)</span>进行异或运算来进行加密产生密文<span
class="math inline">\(c_i=d_i\oplus
k^{IV}_i\)</span>，解密同样也是异或运算<span
class="math inline">\(d_i=c_i\oplus k^{IV}_i\)</span>。</p>
<p>　　对于给定<span class="math inline">\(K_S\)</span>只有<span
class="math inline">\(2^{24}\)</span>个密钥可用，若进行随机选择则在处理12000帧后重复的概率超过99%。攻击者通过IP哄骗的等方式来获取内容已知的加密帧，通过<span
class="math inline">\(d_i\oplus c_i=K^{IV}_i\)</span>可以获取<span
class="math inline">\(K^{IV}_i\)</span>，当攻击者再次嗅探到相同的IV时可以对其进行解密。</p>
<img src="/2022/08/24/computer-networking-a-top-down-approach-7e-chpt-7/802.11i.svg" class="" title="802.11i">
<p>　　相比WEP，802.11i提供了更强大的加密形式、可扩展的认证机制集合和密钥分发机制。802.11i除了无线站点和无线AP，还有认证服务器。认证服务器与无线AP分离允许一个认证服务器为多个无线AP服务，将认证和访问的决策集中在单个服务器内，并降低无线AP的成本和复杂性。</p>
<p>　　1)
在发现阶段，无线AP通告它的存在以及它能够给无线站点提供认证和加密的形式。无线站点请求所需形式的认证和加密。虽然无线站点和无线AP已经在交换报文，但无线站点尚未认证，也没有加密密钥。</p>
<img src="/2022/08/24/computer-networking-a-top-down-approach-7e-chpt-7/eap.svg" class="" title="eap">
<p>　　2)
在相互认证和MK生成阶段，AP作为中继在无线站点和认证服务器间转发报文。<strong>可扩展认证协议</strong>定义了无线站点和认证服务器间的报文格式。EAP使用EAPOL封装并通过802.11无线链路发送，EAP报文在无线AP拆封并使用RADIUS协议重新封装以便通过UDP/IP传输给认证服务器。802.11i并未规定认证方法，但常使用EAP
TLS认证方案。EAP
TLS使用了非对称加密(不包括不重数和散列算法)来实现无线站点和认证服务器相互认证并派生共享的MS。</p>
<p>　　3)
在生成<strong>成对主密钥</strong>阶段，MK是仅无线站点和认证服务器所共享的密钥，它们各自使用它来生成第二个密钥，即PMK。认证服务器向无线AP发送PMK。现在无线站点和无线AP共享密钥且相互认证。</p>
<p>　　4)
在生成<strong>临时密钥</strong>阶段，无线站点和无线AP可以生成用于通信的附加密钥。其中的关键是TK，TK用于通过无线链路发送的数据的链路层加密。</p>
<p>　　802.11i提供了多次加密形式，包括基于AES的加密方案和WEP加密的增强版本。</p>
<h3 id="防火墙和入侵检测系统">7.8 防火墙和入侵检测系统</h3>
<h4 id="防火墙">7.8.1 防火墙</h4>
<p>　　<strong>防火墙</strong>是硬件和软件的组合，它将内网与整个互联网隔开，允许部分分组通过并阻止其他分组。防火墙允许网络管理员通过管理进出这些资源的流量来控制互联网和受管网络内的资源之间的访问。防火墙的目标包括<span
style="background-color: yellow">进出受管网络的流量都必须通过防火墙</span>，<span
style="background-color: yellow">仅允许本地安全策略定义的授权流量通过</span>以及<span
style="background-color: yellow">防火墙本身免于渗透</span>。</p>
<p>　　防火墙包括<strong>传统分组过滤器</strong>、<strong>状态过滤器</strong>和<strong>应用程序网关</strong>。</p>
<p>　　一个组织通常有一个网关路由器，将其内网连接到其ISP或互联网。所有进出内网的流量都经过这个路由器，<strong>分组过滤</strong>在这个路由器上进行。</p>
<p>　　传统分组过滤器单独检查每个数据报并根据过滤规则来确定转发或丢弃数据报。过滤决策通常基于IP地址、数据报中协议类型、端口、TCP标志位(SYN和ACK等)、ICMP报文类型、数据报出入网络的规则以及不同路由器接口的不同规则。</p>
<table>
<colgroup>
<col style="width: 39%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr>
<th>策略</th>
<th>防火墙设置</th>
</tr>
</thead>
<tbody>
<tr>
<td>无外部Web访问</td>
<td>丢弃所有到任何IP地址、端口80的分组</td>
</tr>
<tr>
<td>除访问内网的公共Web服务器外无入TCP连接</td>
<td>丢弃所有到除指定IP地址、端口80外的任何IP地址的入TCP SYN分组</td>
</tr>
<tr>
<td>防止Web无线电占用带宽</td>
<td>丢弃除DNS分组外的所有入UDP分组</td>
</tr>
<tr>
<td>防御smurf dos攻击</td>
<td>丢弃所有到指定广播地址的ICMP ping分组</td>
</tr>
<tr>
<td>防止路由跟踪</td>
<td>丢弃所有ICMP TTL过期分组</td>
</tr>
</tbody>
</table>
<p>　　相比传统分组过滤器，状态过滤器实际跟踪的是TCP连接并可以根据TCP状态进行过滤。状态过滤器跟踪连接表中所有正在进行的TCP连接，通过三次握手来知晓新连接的开始，通过FIN分组或一段时间内未检查到连接活跃来知晓连接结束。</p>
<p>　　应用程序网关是应用程序特定的服务器，所有应用程序数据都必须通过它。多个应用程序网关可以在同一台主机上运行，但每个应用程序网关都有独立进程。除了IP/TCP/UDP首部，应用程序网关还根据应用数据做决策。　　应用程序网关并非没有缺点。首先，不同应用程序需要不同的应用程序网关。其次，由于所有的流量都通过应用程序网关进行中继，应用程序网关的负担较大。最后，当用户发送请求时客户端必须知道如何联系应用程序网关并告知其连接到对应的外部服务器。</p>
<p>　　实际中，一个机构的邮件服务器和Web缓存都是应用程序网关。</p>
<h4 id="入侵检测系统">7.8.2 入侵检测系统</h4>
<p>　　为了检测多种攻击类型，需要执行<strong>深度分组检测</strong>，即深入检测分组的有效载荷。应用程序网关经常进行DPI，但仅对特定的应用程序执行。</p>
<p>　　当检测到潜在恶意流量时发送警报的设备称为<strong>入侵检测系统</strong>。过滤可疑流量的设备称为<strong>入侵防御系统</strong>。由于IDS和IPS的重要技术都是检测可疑流量，所以将IDS和IPS统称IDS。</p>
<p>　　IDS可用于检测多种攻击，包括网络映射(例如，使用nmp分析)、端口扫描、TCP栈扫描、DOS带宽泛洪攻击、蠕虫、病毒、操作系统漏洞攻击和应用程序漏洞攻击。</p>
<p>　　IDS大致分为<strong>基于特征的IDS</strong>和<strong>基于异常的IDS</strong>。基于特征的IDS维护了一个范围广泛的攻击特征数据库。每个特征是与一个入侵活动相关的一组规则。特征可能是单个或多个分组相关的特征列表(端口、协议类型或特定位串等)，当分组符合特征时发送警报，但实际中可能由于各种情况无效或误报。基于异常的IDS观测正常流量时会生成一个流量概况文件并查找在统计上异常的分组流，但区分正常流量和在统计上异常的流量仍是一个挑战。</p>
<p>　　一个机构可能在其内网部署一个或多个IDS传感器。由于IDS不仅需要进行DPI，还需要将每个分组与诸多的特征比较，这可能是极大的处理量，因此可能需要多个IDS传感器。将IDS传感器放置在更下游的位置，每个IDS传感器仅能检测到部分流量，这样更易于维护。</p>
<img src="/2022/08/24/computer-networking-a-top-down-approach-7e-chpt-7/ids.svg" class="" title="ids">
<p>　　当部署多个IDS传感器时，它们通常协同工作，将有关可疑流量的信息发送到中心IDS处理器，中心IDS处理器收集并综合这些信息，当时机合适时发送警报。该机构将内网划分为较高安全区和称为<strong>隔离区</strong>的较低安全区，较高安全区由分组过滤器和应用程序网关保护，DMZ仅由分组过滤器保护，它们都受IDS传感器监控。DMZ包括了该机构需要与互联网通信的服务器，例如，Web服务器、FTP服务器和权威DNS服务器等。实际中，有很多高性能的IDS和IPS供使用，因此有些机构仅需一个位于接入路由器附近的IDS传感器。</p>
<p>　　Snort是一个公共域的开源IDS，它使用通用嗅探接口libpcap(Wireshark和其他分组嗅探器也使用该接口)。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》 第1章 计算机系统概览</title>
    <url>/2022/09/17/computer-systems-a-programmer&#39;s-perspective-3e-chpt-1/</url>
    <content><![CDATA[<p>　　<strong>计算机系统</strong>由硬件和系统软件组成，它们协同工作来运行应用程序。大部分现代计算机系统都使用ASCII标准来表示文本字符。</p>
<p>　　20世纪60年代的操作系统都是庞大且复杂的，例如，IBM的OS/360和Honeywell的Multics系统。贝尔实验室曾是Multics项目的最初参与者，由于该项目的复杂性和缺乏进展于1969年退出。同年，贝尔实验室的部分人员开始用机器语言编写Unix系统，并于1973年用C语言重新编写内核并在次年发布。</p>
<p>　　在20世纪80年代，Unix供应商通过增加全新且通常不兼容的功能来区分自身。IEEE为了阻止这种趋势，制定了一系列标准，Richard
Stallman称其为Posix。后来，1个名为 "标准Unix规范"
的标准化项目与Posix联手为Unix创建了统一标准。</p>
<p>　　C语言是贝尔实验室的Dennis
Ritchie于1969年~1973年间设计。ANSI在1989年创建了ANSI
C的标准。后来，ISO负责C语言的标准，1990年推出了几乎和ANSI
C一样的版本，称为ISO C90。1999年推出了ISO C99。2011年推出了ISO
C11。这些标准定义了C语言和一组称为C语言标准库的库函数。</p>
<p>　　GNU (GNU's Not Unix) 项目由Richard
Stallman于1984年建立的一个免税慈善机构，其目标是开发一个完整的类Unix系统，其源代码不受修改和分发方式的限制。GNU项目开发了一个除内核外的包含Unix操作系统所有主要部件的环境，内核由Linux项目独立发展而来。</p>
<p>　　1991年8月，芬兰研究生Linus
Torvalds发布了一个出于教育目的的类Unix的操作系统内核Minix，即Linux的前身。</p>
<p>　　GCC (GNU Compiler Collection)
是GNU项目开发的工具之一，可以基于不同命令选项，根据不同版本的C语言规则来编译程序，例如，<code>gcc -std=c11 proc.c</code>。</p>
<table>
<thead>
<tr>
<th>C版本</th>
<th>GCC命令行</th>
</tr>
</thead>
<tbody>
<tr>
<td>GNU 89</td>
<td><code>-std=gnu89</code></td>
</tr>
<tr>
<td>ANSI，ISO C90</td>
<td><code>-ansi</code>，<code>-std=c89</code></td>
</tr>
<tr>
<td>ISO C99</td>
<td><code>-std=c99</code></td>
</tr>
<tr>
<td>ISO C11</td>
<td><code>-std=c11</code></td>
</tr>
</tbody>
</table>
<p>　　shell是一个命令解释器，它会先输出提示符，然后等待命令输入并执行。若该命令的首个单词不是内置命令，则会默认该命令是可执行文件的名称，然后加载并执行。</p>
<p>　　早期的计算机先驱Gene Amdahl提出了<span
style="background-color: yellow">Amdahl定律</span>，用于衡量提升计算机系统部分组件性能的有效性，主要思想是当提升系统部分组件性能时，对系统整体性能的影响取决于这部分组件的重要性和提升过程。若系统执行某应用程序的时间是<span
class="math inline">\(T_{old}\)</span>，某个组件的占比是<span
class="math inline">\(\alpha\)</span>。当该组件性能提升为原来的<span
class="math inline">\(k\)</span>倍后，该组件的执行时间从<span
class="math inline">\(\alpha T_{old}\)</span>变为<span
class="math inline">\(\frac{\alpha
T_{old}}{k}\)</span>，系统执行该程序的时间变为<span
class="math inline">\(T_{new}\)</span>，提升比为<span
class="math inline">\(S\)</span>。<span
class="math inline">\(S\)</span>通常用 "数字X"
的形式来表示，例如，2.2X表示速度提升为原来的2.2倍。 <span
class="math display">\[
\begin{align}
S&amp;=\frac{T_{old}}{T_{new}}\\[3px]
&amp;=\frac{T_{old}}{(1-\alpha)T_{old}+\frac{\alpha T_{old}}{k}}\\[3px]
&amp;=\frac{1}{1-\alpha+\frac{a}{k}}
\end{align}
\]</span>
　　因此，若想要提升系统整体性能，就必须提升系统中大部分组件的性能。</p>
<span id="more"></span>
<h3 id="计算机系统的硬件">1.1 计算机系统的硬件</h3>
<img src="/2022/09/17/computer-systems-a-programmer's-perspective-3e-chpt-1/hardware_organization_of_a_typical_system.svg" class="" title="hardware_organization_of_a_typical_system">
<p>　　<strong>总线</strong>贯穿整个系统，它们在组件之间传输数据。总线通常设计为用于传输称为<strong>字</strong>的固定大小的字节块。字的字节数
(简称<strong>字长</strong>)
是基本系统参数之一，因系统而异，例如，很多机器的字长是4B (32位) 或8B
(64位)。</p>
<p>　　I/O设备是系统与外部的连接通道。每个I/O设备都通过<strong>控制器</strong>或<strong>适配器</strong>与I/O总线连接，两者的区别在于封装方式。控制器是I/O设备本身或系统的<strong>主印制电路板</strong>
(简称<strong>主板</strong>)
的芯片组，而适配器是一块插在主板插槽上的卡，两者的功能都是在I/O总线与I/O设备之间传输信息。</p>
<p>　　网络为计算机系统之间的通信提供了途径，从单个系统的角度，网络可看作一种I/O设备。</p>
<p>　　<strong>中央处理器</strong> (简称<strong>处理器</strong>)
是解释或执行存储在内存中的指令引擎。CPU的核心是一个字大小的存储设备或寄存器，称为<strong>程序计数器</strong>。PC总是指向内存中的某个机器语言指令
(包含其地址)。</p>
<p>　　<strong>主存储器</strong>
(简称<strong>主存</strong>或<strong>内存</strong>)
是一种在CPU执行程序时保存程序和它操作的数据的临时存储设备。从物理角度，内存由一组<strong>动态随机存取存储器</strong>组成。从逻辑角度，存储器是一个线性的字节数组，每个字节都有唯一的地址
(从0开始的数组索引)。组成程序的机器指令的字节数可能不同。与C语言程序变量对应的数据项的大小因类型而异。</p>
<p>　　CPU看似按照<strong>指令集架构</strong>定义的指令执行模型进行操作。在该模型中，指令按照严格的顺序执行，执行一条指令涉及一系列步骤。CPU从PC指向的内存中读取指令，解释指令中的位，执行该指令指示的一些简单操作然后更新PC以指向下一条指令
(这两条指令在内存中并不一定相邻)。这种围绕着内存、寄存器文件和<strong>算术逻辑单元</strong>进行简单操作并不多。<strong>寄存器文件</strong>是由一组单字长且都有名称的寄存器组成的小型存储设备。
ALU计算新数据和地址的值。</p>
<p>　　● <span
style="background-color: yellow">加载</span>时CPU将一个字节或字从内存复制到寄存器。</p>
<p>　　● <span
style="background-color: yellow">存储</span>时CPU将一个字节或字从寄存器复制到内存。</p>
<p>　　● <span
style="background-color: yellow">操作</span>时CPU将两个寄存器的值复制到ALU并进行算术运算，然后将结果存储到某个寄存器。</p>
<p>　　● <span
style="background-color: yellow">跳转</span>时CPU从指令中提取一个字并将该字复制到PC。</p>
<h3 id="信息就是位上下文">1.2 信息就是位+上下文</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* hello.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　<code>hello</code>程序的生命周期以<strong>源程序</strong>或<strong>源文件</strong>的形式开始。源程序是一个位序列，8个位组成一个字节，每个字节代表程序中的某些文本字符。</p>
<p>　　<code>hello</code>程序以字节序列的形式存储在文件中，每个文本行都以不可见的<code>\n</code>结尾，每个字节的值都对应1个字符
(包括<code>\n</code>)。只由ASCII字符组成的文件称为<strong>文本文件</strong>，所有其他文件都称为<strong>二进制文件</strong>。</p>
<p>　　系统中的所有信息
(包括磁盘文件、存储在内存中的程序、存储在内存中的用户数据以及通过网络传输的数据)
都表示为位串。区分不同数据对象的唯一方法是它们的<strong>上下文</strong>。因此，不同上下文中相同的字节序列可能表示不同的含义。</p>
<img src="/2022/09/17/computer-systems-a-programmer's-perspective-3e-chpt-1/compilation_system.svg" class="" title="compilation_system">
<p>　　● 在<span
style="background-color: yellow">预处理</span>阶段，预处理器 (cpp)
会根据<code>#</code>开头的代码修改原始C程序。例如，<code>hello.c</code>中的<code>#include &lt;stdio.h&gt;</code>会告诉预处理器读取头文件<code>stdio.h</code>并将其直接插入到程序的文本中，这样会得到另一个C程序，通常是以<code>.i</code>作为文件扩展名。</p>
<p>　　● 在<span
style="background-color: yellow">编译</span>阶段，编译器 (ccl)
会将文本文件<code>hello.i</code>转换成文本文件<code>hello.s</code>，其中包含如下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">	subq	$8, %rsp</span><br><span class="line">	movl	$.LCO, %edi</span><br><span class="line">	call	puts</span><br><span class="line">	movl	$0, $eax</span><br><span class="line">	addq	$8,%rsp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　● 在<span
style="background-color: yellow">汇编</span>阶段，汇编器 (as)
会将<code>hello.s</code>转换成机器指令，然后打包为<strong>可重定位目标文件</strong><code>hello.o</code>。该文件是17B的二进制文件，用于对函数<code>main()</code>的指令进行编码。</p>
<p>　　● 在<span
style="background-color: yellow">链接</span>阶段，链接器 (ld)
会合并<code>hello.o</code>和它调用的函数来得到<code>hello</code>文件。<code>hello</code>是<strong>可执行目标文件</strong>
(简称为<strong>可执行文件</strong>)，可以加载到内存中并执行。例如，这里主函数调用了函数<code>printf()</code>，该函数存放于单独的预编译目标文件<code>printf.o</code>中，链接器会将<code>printf.o</code>和<code>hello.o</code>合并来得到可执行文件<code>hello</code>。</p>
<img src="/2022/09/17/computer-systems-a-programmer's-perspective-3e-chpt-1/read_the_command_from_the_keyboard.svg" class="" title="read_the_command_from_the_keyboard">
<p>　　在shell输入<code>./hello</code>后，shell会将可执行文件<code>hello</code>中每个字符读取到寄存器并存储到内存中。当输入回车后，shell会执行一系列指令来加载该文件，这些指令会将该文件中的代码和数据从磁盘复制到内存。数据包括最终会被输出的<code>hello, world\n</code>。</p>
<img src="/2022/09/17/computer-systems-a-programmer's-perspective-3e-chpt-1/load_the_executable_from_disk_into_main_memory.svg" class="" title="load_the_executable_from_disk_into_main_memory">
<p>　　使用<strong>直接存储器存取</strong>，数据可以不通过CPU而直接到达内存。</p>
<img src="/2022/09/17/computer-systems-a-programmer's-perspective-3e-chpt-1/write_the_output_string_from_memory_to_the_display.svg" class="" title="write_the_output_string_from_memory_to_the_display">
<p>　　一旦可执行文件<code>hello</code>中的代码和数据加载到内存中，CPU就会开始执行<code>main()</code>中的机器指令。这些指令会将<code>hello, world\n</code>从内存中复制到寄存器文件，再从寄存器文件中复制到显示设备
(即显示在屏幕上)。</p>
<h3 id="高速缓存">1.3 高速缓存</h3>
<p>　　较大的存储设备比较小的存储设备更慢，速度较慢的设备比速度较快的设备制造成本更低。一个典型的寄存器文件的容量数量级是100B，而内存的容量数量级可达到TB。但是，寄存器文件的存取速度几乎是内存的存取速度的100倍。随着半导体技术的发展，这种差距会不断增大。加快寄存器文件的存取速度比加快内存的存取速度更容易和更便宜。</p>
<img src="/2022/09/17/computer-systems-a-programmer's-perspective-3e-chpt-1/cache_memory.svg" class="" title="cache_memory">
<p>　　为了减小寄存器文件的存取速度和内存的存取速度之间的差距，系统设计者使用了<strong>高速缓存</strong>
(简称<strong>缓存</strong>)
来存放短期内CPU可能会需要的数据，即位于CPU中的L1、L2和L3缓存，它们通过<strong>静态随机存取存储器</strong>实现。L1缓存的存取速度比L2缓存的快，L2缓存的存取速度比L3缓存的快。L1缓存的容量比L2缓存的小，L2缓存的容量比L3缓存的小。</p>
<p>　　缓存的主要思想是系统可以通过缓存的<span
style="background-color: yellow">局部性</span>
(程序存取局部区域中的数据和代码的趋势)
来获得很大的内存和很快的存取速度。通过在缓存里存放可能经常存取的数据，可以通过缓存执行大部分内存操作。</p>
<h3 id="存储器层次结构">1.4 存储器层次结构</h3>
<img src="/2022/09/17/computer-systems-a-programmer's-perspective-3e-chpt-1/example_of_a_memory_hierarchy.svg" class="" title="example_of_a_memory_hierarchy">
<p>　　在<strong>存储器层次结构</strong>中，从顶部到底部，容量越来越大，速度越来越慢，存储每个字节的成本越来越低。寄存器文件在顶部，即L0或0级。L1~L3缓存在L1~L3，内存在L4，本地2级存储在L5，远程2级存储在L6。</p>
<p>　　存储器层次结构的主要思想是<span
style="background-color: yellow">上一级存储器作为下一级存储器的缓存</span>。因此，寄存器文件是L1缓存的缓存，L1缓存是L2缓存的缓存，依次类推。</p>
<h3 id="操作系统">1.5 操作系统</h3>
<img src="/2022/09/17/computer-systems-a-programmer's-perspective-3e-chpt-1/layered_view_of_a_computer_system.svg" class="" title="layered_view_of_a_computer_system">
<p>　　操作系统的基本功能包括<span
style="background-color: yellow">防止硬件被失控的应用程序滥用</span>和<span
style="background-color: yellow">为应用程序提供简单且统一的机制来控制复杂且通常大相径庭的底层硬件</span>，这些功能通常通过基本抽象概念
(<strong>进程</strong>、<strong>虚拟内存</strong>和<strong>文件</strong>)
来实现。</p>
<img src="/2022/09/17/computer-systems-a-programmer's-perspective-3e-chpt-1/abstraction_provided_by_a_computer_system.svg" class="" title="abstraction_provided_by_a_computer_system">
<p>　　<span
style="background-color: yellow">文件</span>是对I/O设备的抽象，<span
style="background-color: yellow">虚拟内存</span>是对内存和磁盘I/O设备的抽象，<span
style="background-color: yellow">指令集架构</span>是对CPU的抽象，<span
style="background-color: yellow">进程</span>是对CPU、内存和I/O设备的抽象，<span
style="background-color: yellow">虚拟机</span>是对整个计算机系统的抽象。</p>
<p>　　文件是字节序列。每个I/O设备 (磁盘、键盘、显示器、网络等)
都可以视为文件。系统中的所有输入和输出都是通过读写文件来实现
(调用一组称为Unix
I/O的系统函数)。文件为应用程序提供了系统中可能包含的所有I/O设备的统一视图。</p>
<h4 id="进程">1.5.1 进程</h4>
<p>　　进程是操作系统对正在运行的程序的抽象。多个进程可以在同一系统上<strong>并发</strong>运行并且每个进程<span
style="background-color: yellow">似乎</span>都独占地使用硬件。并发运行是某个进程的指令和其他进程的指令交错，操作系统使用<strong>上下文切换</strong>来执行这种交错。</p>
<p>　　操作系统会跟踪进程运行所需的所有状态信息，这些状态称为<strong>上下文</strong>，包括PC当前的值、寄存器文件和内存的内容等信息。单核CPU在同一时间只能执行1个进程的代码。当操作系统决定将控制权从当前进程A转移到进程B时，就会执行上下文切换，即保存进程A的上下文，恢复进程B的上下文并将控制器传递给进程B。进程B从上次停止的地方开始。</p>
<img src="/2022/09/17/computer-systems-a-programmer's-perspective-3e-chpt-1/process_context_switching.svg" class="" title="process_context_switching">
<p>　　进程切换由操作系统的<strong>内核</strong>执行。内核是系统用于管理所有进程的代码和数据结构的集合。当应用程序需要操作系统执行某些操作
(例如，读写文件)
时，会执行特殊的<strong>系统调用</strong>指令，将控制权转移给内核，内核执行请求的操作并返回到应用程序。</p>
<p>　　进程实际上可以由多个称为<strong>线程</strong>的执行单元组成，每个线程都在进程的上行文中运行并共享相同的代码和全局数据。</p>
<h4 id="虚拟内存">1.5.2 虚拟内存</h4>
<img src="/2022/09/17/computer-systems-a-programmer's-perspective-3e-chpt-1/process_virtual_address_space.svg" class="" title="process_virtual_address_space">
<p>　　虚拟内存是为每个进程提供了它独占内存的假象。每个进程都有相同的内存视图，称为<strong>虚拟地址空间</strong>。在Linux中，地址自底向上递增，最顶部是保留给操作系统中所有进程共享的代码和数据，底部存放用户进程定义的代码和数据。</p>
<p>　　● 最底部是<span
style="background-color: yellow">程序代码和数据</span>，所有进程的代码都从相同的固定地址开始，然后是对应C语言全局变量的数据位置。代码和数据区域是直接按照可执行文件
(这里是<code>hello</code>) 的内容初始化。</p>
<p>　　● 代码和数据区域之上是<span
style="background-color: yellow">堆</span>，一旦程序开始运行，堆的大小被指定，但可以通过<code>malloc</code>和<code>free</code>等C语言标准库函数来在运行时动态地扩展和收缩堆。</p>
<p>　　● 在堆之上是<span
style="background-color: yellow">共享库</span>，用于保存共享库的代码和数据。</p>
<p>　　● 共享库之上是编译器用来实现函数调用的<span
style="background-color: yellow">栈</span>，栈在程序运行期间可以动态地扩展和收缩，每次调用函数时栈会扩展，每次函数返回时栈会收缩。</p>
<p>　　● 最顶部是为内核保留的<span
style="background-color: yellow">内核虚拟内存</span>。应用程序不能读写该区域或直接调用内核代码中定义的函数，必须调用内核来执行这些操作。</p>
<h4 id="并发和并行">1.5.3 并发和并行</h4>
<p>　　<strong>并发</strong>表示系统同时具有多个活动，而<strong>并行</strong>表示用并发来使系统运行得更快。</p>
<p>　　<strong>单核CPU系统</strong>中即使CPU在多个任务之间切换，大多数实际的计算都是由单个核心完成。<strong>多核CPU系统</strong>中操作系统内核控制多个核心。</p>
<img src="/2022/09/17/computer-systems-a-programmer's-perspective-3e-chpt-1/multicore_cpu_organization.svg" class="" title="multicore_cpu_organization">
<p>　　多核CPU是将多个核心被集成到1个集成电路芯片。这里以4核为例，每个核都有自己的L1缓存和L2缓存，L1缓存分为两部分，一部分保存最近获取的指令，另一部分保存数据。这些核共享更底层的缓存和内存的接口。</p>
<p>　　超线程 (也称为<strong>同时多线程</strong>)
CPU允许单个核心执行多个控制流。它涉及CPU部分硬件 (例如，PC和寄存器文件)
的多个副本，而其他部分硬件 (例如，ALU)
的单个副本。传统CPU需要大约20000个时钟周期才能在不同线程之间切换，而超线程CPU可以在逐个周期地决定执行哪个线程。超线程CPU也属于多核CPU。</p>
<p>　　使用多核CPU可以从2个方面提供系统性能。首先，它降低了执行多个任务时模拟并发的要求。其次，它可能更快地运行以多线程方式工作的应用程序。</p>
<p>　　在较底层的抽象上，现代CPU可以1次执行多条指令，称为<strong>指令级并行</strong>。</p>
<p>　　可以维持执行速度高于每周期1条指令的CPU称为<strong>超标量</strong>CPU。</p>
<p>　　<strong>单指令多数据</strong>指单个指令并行执行多个操作。SIMD指令主要用于加速处理图像、音频和视频数据应用程序。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第10章 系统级I/O</title>
    <url>/2023/08/16/computer-systems-a-programmer&#39;s-perspective-3e-chpt-10/</url>
    <content><![CDATA[<p>　　<strong>输入/输出</strong>就是在内存与硬盘驱动或网络等外部设备之间复制数据的过程，输入就是从I/O设备复制数据到内存，输出就从内存复制数据到I/O设备。</p>
<p>　　Linux<strong>文件</strong>就是<span
class="math inline">\(m\)</span>字节的序列<span
class="math inline">\(B_0,B_1,...,B_k,...B_{m-1}\)</span>。所有I/O设备都会被模型化为文件，并且所有I/O通过读/写合适的文件来执行。这种从设备到文件的映射允许Linux内核输出称为<strong>Unix
I/O</strong>的底层应用接口，这使得I/O能以统一且一致的方式执行。</p>
<p>　　1) <span
style="background-color: yellow">打开文件</span>。应用程序通过向内核请求打开对应的文件来声明其想要访问I/O设备的意图。内核会返回较小的非负整数，称为<strong>描述符</strong>，它会在之后所有的对该文件的操作中标识该文件。内核会保留该文件的所有信息的记录。应用程序只会保留描述符。</p>
<p>　　2) <span
style="background-color: yellow">改变当前文件位置</span>。内核会为每个文件都维护<strong>文件位置</strong><span
class="math inline">\(k\)</span>，其初始化值为0。文件位置是从文件起始处的字节偏移。应用程序可以通过seek操作
(调用函数<code>lseek()</code>) 显式地设置文件位置。</p>
<p>　　3) <span
style="background-color: yellow">读写文件</span>。读操作会从文件的当前文件位置<span
class="math inline">\(k\)</span>处复制<span
class="math inline">\(n\)</span>字节到内存，然后将<span
class="math inline">\(k\)</span>增加<span
class="math inline">\(n\)</span>。同样，写操作会从内存复制<span
class="math inline">\(n\)</span>字节到文件的当前文件位置<span
class="math inline">\(k\)</span>处，然后更新<span
class="math inline">\(k\)</span>。对于<span
class="math inline">\(m\)</span>字节的文件，执行读操作时<span
class="math inline">\(k\geqslant
m\)</span>会触发称为<strong>文件结束符</strong>的条件，应用程序能检测到该条件。文件结尾并没有显式的文件结束符。</p>
<p>　　4) <span
style="background-color: yellow">关闭文件</span>。当应用程序完成访问文件时，它会通过请求内核关闭文件来通知内核。内核通过释放打开文件时创建的数据结构并将描述符恢复到可用描述符池来响应。当进程终止时，内核会关闭所有打开的文件并释放它们的内存资源。</p>
<p>　　C语言中定义了一组高级的输入和输出函数，称为<strong>标准I/O库</strong>，这为程序员提供了Unix
I/O的更高级的替代方案，该库提供的功能有打开和关闭文件
(<code>fopen()</code>和<code>fclose()</code>)、读写字节
(<code>fread()</code>和<code>fwrite()</code>)、读写字符串
(<code>fgets()</code>和<code>fputs()</code>) 以及复杂的格式化I/O
(<code>scanf()</code>和<code>printf()</code>)。标准I/O库将打开的文件模型化为<strong>流</strong>，从程序员角度，流就是指向<code>FILE</code>类型结构体的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> FILE *<span class="built_in">stdin</span>;  <span class="comment">/* 标准输入 */</span></span><br><span class="line"><span class="keyword">extern</span> FILE *<span class="built_in">stdout</span>; <span class="comment">/* 标准输出 */</span></span><br><span class="line"><span class="keyword">extern</span> FILE *<span class="built_in">stderr</span>; <span class="comment">/* 标准错误 */</span></span><br></pre></td></tr></table></figure>
<p>　　shell创建的每个进程都会在生命周期开始时打开3个文件，即标准输入<code>stdin</code>
(描述符0)、标准输出<code>stdout</code> (描述符1)
和标准错误<code>stderr</code>
(描述符2)。头文件<code>unistd.h</code>包含常量<code>STDIN_FILEND</code>、<code>STDOUT_FILEND</code>和<code>STDERR_FILEND</code>，它们能够代替显式描述符值。</p>
<p>　　<code>FILE</code>类型的流就是<span
style="background-color: yellow">文件描述符</span>和<span
style="background-color: yellow">流缓冲区</span>的抽象，流缓冲区是为了最小化Linux
I/O系统调用的次数。例如，某程序会反复调用标准I/O函数<code>getc()</code>，该函数会返回文件的下一个字符。当首次调用函数<code>getc()</code>时，标准I/O库会调用1次函数<code>read()</code>用来填充流缓冲区并将流缓冲区的首个字节返回给程序。只要流缓冲区中还有未读的字节，随后对函数<code>getc()</code>的调用都会直接从流缓冲区中得到服务。</p>
<span id="more"></span>
<h3 id="文件">10.1 文件</h3>
<p>　　每个Linux文件都有<strong>类型</strong>，用于指示它在系统中的作用。</p>
<p>　　●
<strong>常规文件</strong>可以包含任意数据。应用程序通常会区分文本文件和二进制文件，而内核不会。</p>
<p>　　●
<strong>目录</strong>是包含一组<strong>链接</strong>的文件，其中的每个链接将文件名映射到文件，这里的文件可以是其他目录。每个目录至少包括2个条目，即<code>.</code>和<code>..</code>。<code>.</code>是到当前目录的链接，<code>..</code>是目录结构中当前目录的父目录的链接。</p>
<p>　　● <strong>套接字</strong>是用于通过网络与其他进程通信的文件。</p>
<p>　　●
其他文件类型还有<strong>命名管道</strong>、<strong>字符链接</strong>、<strong>字符设备</strong>和<strong>块设备</strong>。</p>
<p>　　命令<code>mkdir</code>可以创建目录，命令<code>ls</code>可以查看目录的内容，命令<code>rmdir</code>可以删除目录。</p>
<p>　　Linux文本文件只包括ASCII或Unicode字符，其中包括若干个<strong>文本行</strong>，每行包括若干个字符，以换行符<code>\n</code>结尾。<code>\n</code>等同于ASCII中的换行符LF，其值是<code>0xa</code>。Windows和网络协议的换行符是<code>\r\n</code>，其值是<code>0xd 0xa</code>，等同于Linux中的回车符加上换行符。当用Linux打开Windows中创建的文本文件时，行尾会有回车符<code>^M</code>，这可以通过如下命令移除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">perl -pi -e &quot;s/\r\n/\n/g&quot; text.txt</span><br></pre></td></tr></table></figure>
<img src="/2023/08/16/computer-systems-a-programmer's-perspective-3e-chpt-10/portion_of_the_linux_directory_hierarchy.svg" class="" title="portion_of_the_linux_directory_hierarchy">
<p>　　Linux内核将文件组织为由根目录<code>/</code>锚定的单个目录层次结构。所有文件都是根目录的直接或间接后代。每个进程的<strong>当前工作目录</strong>作为其上下文的一部分。可以通过命令<code>cd</code>来改变当前工作目录。</p>
<p>　　目录层次结构中的位置由<strong>路径名</strong>指定。路径名是可选的<code>/</code>加上以<code>/</code>分隔的文件名组成的字符串。路径名有<span
style="background-color: yellow">相对路径名</span>和<span
style="background-color: yellow">绝对路径名</span>这2种形式。绝对路径名以<code>/</code>开头
(表示根目录)，相对路径名以文件名开始
(表示当前工作目录)。<code>hello.c</code>的绝对路径名是<code>/home/droh/hello.c</code>。若当前工作目录是<code>/home/droh</code>，则<code>hello.c</code>的相对路径名是<code>./hello.c</code>；若当前工作目录是<code>/home/bryant</code>，则<code>hello.c</code>的相对路径名是<code>../home/droh/hello.c</code>。</p>
<h3 id="打开和关闭文件">10.2 打开和关闭文件</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">char</span> *filename, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>; <span class="comment">/* 若成功则返回文件描述符，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　进程可以通过函数<code>open()</code>打开已存在的文件或创建新文件。函数<code>open()</code>会将参数<code>filename</code>转换为文件描述符并返回描述符号，即进程未打开的最小描述符号。参数<code>flags</code>表示进程对文件的访问权限。</p>
<p>　　● <code>O_RDONLY</code>表示只读。</p>
<p>　　● <code>O_WRONLY</code>表示只写。</p>
<p>　　● <code>O_RDWR</code>表示可读写。</p>
<p>　　参数<code>flag</code>能与多个提供额外写指令的位掩码进行或操作。</p>
<p>　　●
<code>O_cREAT</code>表示若文件不存在，则创建文件名为<code>filename</code>的空文件。</p>
<p>　　● <code>O_TRUNC</code>表示若文件存在，则进行截断。</p>
<p>　　●
<code>O_APPEND</code>表示在写操作前，将文件位置设置为文件结尾。</p>
<p>　　例如，需要打开已存在的文件并在且结尾加上一些数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = Open(<span class="string">&quot;foo.txt&quot;</span>, O_WRONLY | O_APPEND, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>　　参数<code>mode</code>表示新文件的访问权限位，这些位的符号名定义在头文件<code>sys/stat.h</code>中。</p>
<table>
<thead>
<tr>
<th>访问权限位</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_IRUSR</code></td>
<td>用户 (所有者) 能读该文件</td>
</tr>
<tr>
<td><code>S_IWUSR</code></td>
<td>用户 (所有者) 能写该文件</td>
</tr>
<tr>
<td><code>S_IXUSR</code></td>
<td>用户 (所有者) 能执行该文件</td>
</tr>
<tr>
<td><code>S_IRGRP</code></td>
<td>用户所属组的成员能读该文件</td>
</tr>
<tr>
<td><code>S_IWGRP</code></td>
<td>用户所属组的成员能写该文件</td>
</tr>
<tr>
<td><code>S_IXGRP</code></td>
<td>用户所属组的成员能执行该文件</td>
</tr>
<tr>
<td><code>S_IROTH</code></td>
<td>其他用户 (所有用户) 能读该文件</td>
</tr>
<tr>
<td><code>S_IWOTH</code></td>
<td>其他用户 (所有用户) 能写该文件</td>
</tr>
<tr>
<td><code>S_IXOTH</code></td>
<td>其他用户 (所有用户) 能执行该文件</td>
</tr>
</tbody>
</table>
<p>　　每个进程的<code>umask</code>会作为其上下文的一部分，<code>umask</code>可以通过调用函数<code>umask()</code>来设置。当进程通过带参数<code>mode</code>调用函数<code>open()</code>创建新文件时，该文件的访问权限位会设置为<code>mode &amp; ~umask</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_MODE S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_UMASK S_IWGRP | S_IWOTH</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">umask(DEF_MODE);</span><br><span class="line">fd = open(<span class="string">&quot;foo.txt&quot;</span>, O_CREAT | O_TRUNC | O_WRONLY, DEF_MODE);</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，函数<code>open()</code>会创建新文件，该文件的所有者有读写权限，其他用户有读权限。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>; <span class="comment">/* 若成功则返回0，若出错额返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　进程可以调用函数<code>close()</code>来关闭打开的文件。关闭已关闭的文件会出错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd1, fd2;</span><br><span class="line">    fd1 = Open(<span class="string">&quot;foo.txt&quot;</span>, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    Close(fd1);</span><br><span class="line">    fd2 = Open(<span class="string">&quot;baz.txt&quot;</span>, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，由于Unix进程在生命周期开始时会打开<code>stdin</code>
(描述符0)、<code>stdout</code> (描述符1) 和<code>stderr</code>
(描述符2)，第1次调用函数<code>open()</code>会返回描述符3，函数<code>close()</code>会关闭文件。因此，第2次调用函数<code>open()</code>也会返回描述符3。</p>
<h3 id="读和写文件">10.3 读和写文件</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span>; <span class="comment">/* 若成功则返回字节数，若EOF则返回0，若失败则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span>; <span class="comment">/* 若成功则返回字节数，若失败则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　应用程序可以调用函数<code>read()</code>和<code>write()</code>来执行输入和输出。</p>
<p>　　函数<code>read()</code>会从文件描述符<code>fd</code>的当前文件位置处复制最多<code>n</code>字节到内存位置<code>buf</code>。若出错，则返回-1；若到达文件结尾，则返回0；若正常执行，则返回值就是实际传输的字节数。</p>
<p>　　函数<code>write()</code>会从内存位置<code>buf</code>处复制最多<code>n</code>字节到文件描述符<code>fd</code>的当前文件位置。</p>
<p>　　有时，函数<code>read()</code>和<code>write()</code>实际传输的字节数少于应用程序请求的字节数，这种<strong>计数不足</strong>的情况不属于错误，造成原因如下：</p>
<p>　　● <span
style="background-color: yellow">读时遇到EOF</span>。若需要读50B，而当前文件位置仅剩余20B，则本次读会返回20，而下次读该文件会返回0。</p>
<p>　　● <span
style="background-color: yellow">在终端读文本行</span>。若打开的文件与终端关联，例如，键盘和显示器，则每次执行函数<code>read()</code>会传输1行，返回值等于该行的长度。</p>
<p>　　● <span
style="background-color: yellow">读写套接字</span>。若打开的文件对应套接字，则网络缓冲区的限制和网络时延可能会导致计数不足。当在Linux管道中调用函数<code>read()</code>和<code>write()</code>时，也可能会导致计数不足。</p>
<p>　　实际中，读磁盘中的文件不会出现计数不足，除非EOF，写磁盘不会出现计数不足。但是对于可靠的网络应用程序，必须重复调用函数<code>read()</code>和<code>write()</code>直到满足需求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (Read(STDIN_FILENO, &amp;c, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Write(STDOUT_FILENO, &amp;c, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　这个示例会每次从标准输入复制1B到标准输出。</p>
<h3 id="通过rio包读和写">10.4 通过RIO包读和写</h3>
<p>　　这里将实现能自动处理计数不足的RIO包。RIO包提供<span
style="background-color: yellow">无缓冲的输入和输出函数</span>以及<span
style="background-color: yellow">有缓冲的输入函数</span>。前者不会使用应用级缓冲，直接在内存和文件之间传输数据，对于通过网络传输二进制数据尤其有效。后者是线程安全的，可以高效地从已缓存在应用级缓冲区的文件中读取文本行和二进制数据，还可以在同一描述符任意交错，例如，可以先从某个描述符中读取一些文本行，然后读取一些二进制数据，最后读取一些文本行。</p>
<p>　　RIO包以W. Richard
Stevens的经典网络编程作品中描述的函数<code>readline()</code>、<code>readn()</code>和<code>writen()</code>为灵感。RIO包中的无缓冲的输入和输出函数与函数<code>readn()</code>和<code>writen()</code>完全相同，RIO包中的有缓冲的输入函数纠正了函数<code>readline()</code>的部分缺点。首先，函数<code>readline()</code>会缓冲，而函数<code>readn()</code>不缓冲，所以这2个函数不能对同一描述符一起调用。其次，函数<code>readline()</code>使用的是静态缓冲区
(线程不安全)，所以Stevens后来提出了其线程安全的版本<code>readline_r</code>。这里纠正了以上2个缺点，函数<code>readn()</code>和<code>readline()</code>在RIO包中的对应的使用缓冲的版本是兼容且线程安全的。</p>
<h4 id="无缓冲的输入和输出函数">10.4.1 无缓冲的输入和输出函数</h4>
<p>　　应用程序可以调用函数<code>rio_readn()</code>和<code>rio_writen()</code>来直接在内存和文件之间传输数据。对同一描述符可以任意交错地调用函数<code>rio_readn()</code>和<code>rio_writen()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 若成功则返回传输的字节数，若EOF则返回0，若出错则返回-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param fd 文件描述符</span></span><br><span class="line"><span class="comment"> * @param usrbuf 内存位置</span></span><br><span class="line"><span class="comment"> * @param n 字节数</span></span><br><span class="line"><span class="comment"> * @return ssize_t</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">char</span> *bufp = usrbuf;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = read(fd, bufp, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                nread = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* EOF */</span></span><br><span class="line">        &#125;</span><br><span class="line">        nleft -= nread;</span><br><span class="line">        bufp += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n - nleft);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 若成功则返回传输的字节数，若出错则返回-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param fd 文件描述符</span></span><br><span class="line"><span class="comment"> * @param usrbuf 内存位置</span></span><br><span class="line"><span class="comment"> * @param n 字节数</span></span><br><span class="line"><span class="comment"> * @return ssize_t</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;</span><br><span class="line">    <span class="type">ssize_t</span> nwritten;</span><br><span class="line">    <span class="type">char</span> *bufp = usrbuf;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nwritten = write(fd, bufp, nleft)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                nwritten = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">        bufp += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>rio_readn()</code>会从文件描述符<code>fd</code>的当前文件位置复制最多<code>n</code>字节到内存位置<code>usrbuf</code>。同样，函数<code>rio_writen()</code>会从内存位置<code>usrbuf</code>复制最多<code>n</code>字节到文件描述符<code>fd</code>的当前文件位置。前者可能会遇到EOF，而后者不会。为了尽可能地保证可移植性，这里允许被系统调用中断并在必要时重启。这2个函数在被信号处理程序的返回中断时，会重新调用函数<code>read()</code>或<code>write()</code>。</p>
<h4 id="有缓冲的输入函数">10.4.2 有缓冲的输入函数</h4>
<p>　　若需要计算文本文件中的行数，可以调用函数<code>read()</code>从文本文件每次传输1B到内存并检查换行符，这种方法的效率不高。更好的方法是使用包装函数<code>rio_readlineb()</code>，该函数会复制从内部缓冲区复制文本行，当内部缓冲区为空，会自动调用函数<code>read()</code>填充。对于HTTP响应等包括文本行和二进制数据的文件，可以使用函数<code>rio_readnb()</code>，类似函数<code>rio_readlineb()</code>，该函数会从相同的读缓冲区中传输原始数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RIO_BUFSIZE 8192</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rio_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> rio_fd;                <span class="comment">/* 内部缓冲区的描述符 */</span></span><br><span class="line">    <span class="type">int</span> rio_cnt;               <span class="comment">/* 内部缓冲区的未读的字节数 */</span></span><br><span class="line">    <span class="type">char</span> *rio_bufptr;          <span class="comment">/* 内部缓冲区的下一个未读的字节 */</span></span><br><span class="line">    <span class="type">char</span> rio_buf[RIO_BUFSIZE]; <span class="comment">/* 内部缓冲区 */</span></span><br><span class="line">&#125; <span class="type">rio_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化读缓冲区</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rp 读缓冲区指针</span></span><br><span class="line"><span class="comment"> * @param fd 文件描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rio_readinitb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    rp-&gt;rio_fd = fd;</span><br><span class="line">    rp-&gt;rio_cnt = <span class="number">0</span>;</span><br><span class="line">    rp-&gt;rio_bufptr = rp-&gt;rio_buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief (私有) 读</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rp 读缓冲区指针</span></span><br><span class="line"><span class="comment"> * @param usrbuf 内存位置</span></span><br><span class="line"><span class="comment"> * @param n 字节数</span></span><br><span class="line"><span class="comment"> * @return ssize_t</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">rio_read</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">char</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">while</span> (rp-&gt;rio_cnt &lt;= <span class="number">0</span>) <span class="comment">/* 若为空则填充 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf, <span class="keyword">sizeof</span>(rp-&gt;rio_buf));</span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rp-&gt;rio_cnt == <span class="number">0</span>) <span class="comment">/* EOF */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            rp-&gt;rio_bufptr = rp-&gt;rio_buf; <span class="comment">/* 重置缓冲区指针 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从内部缓冲区复制min(n, rp-&gt;rio_cnt)字节到内存位置 */</span></span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt = rp-&gt;rio_cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(usrbuf, rp-&gt;rio_bufptr, cnt);</span><br><span class="line">    rp-&gt;rio_bufptr += cnt;</span><br><span class="line">    rp-&gt;rio_cnt -= cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 若成功则返回读的字节数，若EOF则返回0，若出错则返回-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rp 读缓冲区指针</span></span><br><span class="line"><span class="comment"> * @param usrbuf 内存位置</span></span><br><span class="line"><span class="comment"> * @param maxlen 最大长度</span></span><br><span class="line"><span class="comment"> * @return ssize_t</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> maxlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, rc;</span><br><span class="line">    <span class="type">char</span> c, *bufp = usrbuf;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; maxlen; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rc = rio_read(rp, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *bufp++ = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* EOF (没有读到数据) */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">/* EOF (读取了一些数据) */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* 出错 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *bufp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 若成功则返回读的字节数，若EOF则返回0，若出错则返回-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rp 读缓冲区指针</span></span><br><span class="line"><span class="comment"> * @param usrbuf 内存位置</span></span><br><span class="line"><span class="comment"> * @param n 字节数</span></span><br><span class="line"><span class="comment"> * @return ssize_t</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">char</span> *bufp = usrbuf;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = rio_read(rp, bufp, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* EOF */</span></span><br><span class="line">        &#125;</span><br><span class="line">        nleft -= nread;</span><br><span class="line">        bufp += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　结构体<code>rio_t</code>是读缓冲区的格式。函数<code>rio_readinitb</code>会将设置空的读缓冲区并将其和已打开的文件描述符关联来初始化读缓冲区，即将描述符<code>fd</code>与地址<code>rp</code>处的<code>rio_t</code>类型的读缓冲区关联。每个打开的文件都会调用函数<code>rio_readinitb</code>。</p>
<p>　　函数<code>rio_read</code>与函数<code>read()</code>的语义相同，前者在后者的基础上使用了缓冲区。当调用函数<code>rio_read</code>读取<code>n</code>字节时，读缓冲区中有<code>rp-&gt;rio_cnt</code>未读的字节。若读缓冲区为空，则会调用函数<code>read()</code>来重新填充。填充后，函数<code>rio_read</code>会从读缓冲区复制<code>n</code>和<code>rp-&gt;rio_cnt</code>的最小值个字节到内存并返回复制的字节数。对于函数<code>rio_read</code>，若出错，则返回-1并设置合适的<code>errno</code>；若EOF，则返回0；若请求的字节数大于读缓冲区中的未读字节数，则出现计数不足。</p>
<p>　　函数<code>rio_readlineb()</code>会从文件<code>rp</code>中读取下一行
(包括换行符)
并复制到内存位置<code>usrbuf</code>，然后以<code>NULL</code>字符结束文本行。该函数最多读取<code>maxlen - 1</code>字节
(为结尾的<code>NULL</code>保留空间)。超过<code>maxlen - 1</code>字节的文本行会被截断并以<code>NULL</code>字符结束。</p>
<p>　　函数<code>rio_readnb()</code>会从文件<code>rp</code>中读取最多<code>n</code>字节到内存位置<code>usrbuf</code>。</p>
<p>　　对同一描述符可以任意交错地调用函数<code>rio_readlineb()</code>和<code>rio_readnb()</code>。但是，对这2个函数的调用不能与对无缓冲的函数<code>rio_readn()</code>交错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    Rio_readinitb(&amp;rio, STDIN_FILENO);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Rio_writen(STDOUT_FILENO, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会使用RIO函数从标准输入复制文本文件到标准输出，每次1行。</p>
<h3 id="读取文件元数据">10.5 读取文件元数据</h3>
<p>　　应用程序可以调用函数<code>stat()</code>和<code>fstat()</code>来检索文件的相关信息
(也称为<strong>元数据</strong>)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="keyword">struct</span> stat *buf)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>stat()</code>会将文件名作为输入并填充结构体<code>stat()</code>的成员，函数<code>fstat()</code>与之类似，区别是后者会将文件描述符作为输入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> st_dev;             <span class="comment">/* 设备 */</span></span><br><span class="line">    <span class="type">ino_t</span> st_ino;             <span class="comment">/* 索引节点 */</span></span><br><span class="line">    <span class="type">mode_t</span> st_mode;           <span class="comment">/* 保护和文件类型 */</span></span><br><span class="line">    <span class="type">nlink_t</span> st_nlink;         <span class="comment">/* 硬链接数 */</span></span><br><span class="line">    <span class="type">uid_t</span> st_uid;             <span class="comment">/* 所有者的用户ID */</span></span><br><span class="line">    <span class="type">gid_t</span> st_gid;             <span class="comment">/* 所有者的组ID */</span></span><br><span class="line">    <span class="type">dev_t</span> st_rdev;            <span class="comment">/* 设备类型 (若是索引节点设备) */</span></span><br><span class="line">    <span class="type">off_t</span> st_size;            <span class="comment">/* 总大小 (单位是字节) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> st_blksize; <span class="comment">/* 文件系统I/O的块大小 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> st_blocks;  <span class="comment">/* 已分配的块数 */</span></span><br><span class="line">    <span class="type">time_t</span> st_atime;          <span class="comment">/* 上次访问时间 */</span></span><br><span class="line">    <span class="type">time_t</span> st_mtime;          <span class="comment">/* 上次修改时间 */</span></span><br><span class="line">    <span class="type">time_t</span> st_ctime;          <span class="comment">/* 上次更改时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　结构体<code>stat()</code>定义在头文件<code>sys/stat.h</code>。成员<code>st_size</code>是文件大小
(单位是B)。成员<code>st_mode</code>会编码文件的权限位和文件类型。Linux在头文件<code>sys/stat.h</code>中定义了宏谓词来确定成员<code>st_mode</code>的文件类型：</p>
<p>　　● <code>S_ISREG(m)</code>会判断是否为常规文件。</p>
<p>　　● <code>S_ISDIR(m)</code>会判断是否为目录文件。</p>
<p>　　● <code>S_ISSOCK(m)</code>会判断是否为套接字。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat</span>;</span></span><br><span class="line">    <span class="type">char</span> *type, *readok;</span><br><span class="line">    Stat(argv[<span class="number">1</span>], &amp;stat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断文件类型 */</span></span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(stat.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        type = <span class="string">&quot;regular&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(stat.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        type = <span class="string">&quot;directory&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        type = <span class="string">&quot;other&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查文件的读权限 */</span></span><br><span class="line">    <span class="keyword">if</span> (stat.st_mode &amp;&amp; S_IRUSR)</span><br><span class="line">    &#123;</span><br><span class="line">        readok = <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        readok = <span class="string">&quot;no&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;type: %s, read: %s\n&quot;</span>, type, readok);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会通过函数<code>stat()</code>来读取并解释文件的<code>st_mode</code>位。</p>
<h3 id="读取目录内容">10.6 读取目录内容</h3>
<p>　　应用程序可以调用<code>readdir()</code>系列函数来读取目录内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 若成功则返回句柄指针，若出错则返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>opendir()</code>会输入路径名并输出指向<span
style="background-color: yellow">目录流</span>的指针。流就是项的有序列表的抽象，所以目录流就是目录条目列表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>; <span class="comment">/* 若成功则返回指向下一个目录条目的指针，若没有条目或出错则返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>readdir()</code>会返回指向流<code>dirp</code>中的下一个目录条目的指针。若没有条目，则返回<code>NULL</code>；若出错，则会返回<code>NULL</code>并设置<code>errno</code>。因此，需要检查<code>errno</code>在调用函数<code>readdir()</code>后是否被修改过，才能判断返回<code>NULL</code>的原因。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">ino_t</span> d_ino;      <span class="comment">/* 索引节点号 */</span></span><br><span class="line">    <span class="type">char</span> d_name[<span class="number">256</span>]; <span class="comment">/* 文件名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　结构体<code>dirent</code>就是目录条目，不过有些Linux版本还包括其他成员，这里的2个成员是所有系统都有的标准成员。成员<code>d_ino</code>是文件位置，成员<code>d_name</code>是文件名。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>closedir()</code>会关闭流并释放其资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    DIR *streamp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dep</span>;</span></span><br><span class="line">    streamp = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((dep = readdir(streamp)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found file: %s\n&quot;</span>, dep-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;readdir error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(streamp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会调用函数<code>readdir()</code>读取目录内容。</p>
<h3 id="文件共享">10.7 文件共享</h3>
<p>　　内核用<strong>描述符表</strong>、<strong>文件表</strong>和<strong>v-node表</strong>来表示打开的文件。</p>
<p>　　●
每个进程都有单独的描述符表，其中的条目通过进程打开的文件描述符来索引。每个打开的描述符条目都指向文件表中的1个条目。</p>
<p>　　●
打开的文件集合由所有文件共享的文件表来表示。每个文件表条目包括当前文件位置、当前指向它的描述符的引用次数和指向v-node表中的1个条目的指针。关闭描述符会减少对应的文件表条目的引用次数。只有当引用次数为0时，内核才会删除文件表条目。</p>
<p>　　●
所有文件共享v-node表。v-node表的条目包含结构体<code>stat()</code>中的大部分信息，包括成员<code>st_mode</code>和<code>st_size</code>。</p>
<img src="/2023/08/16/computer-systems-a-programmer's-perspective-3e-chpt-10/typical_kernel_data_structures_for_open_files.svg" class="" title="typical_kernel_data_structures_for_open_files">
<p>　　在这个示例中，描述符1和4通过不同的打开文件表条目来引用不同的文件，这是文件不共享且每个描述符对应不同的文件时的典型情况。</p>
<img src="/2023/08/16/computer-systems-a-programmer's-perspective-3e-chpt-10/file_sharing.svg" class="" title="file_sharing">
<p>　　多个描述符可以通过不同的文件表条目引用相同的文件，例如，对同一文件名调用2次函数<code>open()</code>。关键思想是每个描述符有自己的文件位置，所以对不同描述符的读可以从同一文件的不同位置获取数据。</p>
<img src="/2023/08/16/computer-systems-a-programmer's-perspective-3e-chpt-10/how_a_child_process_inherits_the_parent's_open_files.svg" class="" title="how_a_child_process_inherits_the_parent" alt="s_open_files">
<p>　　假设在调用函数<code>fork()</code>时，父进程已经打开了一些文件。当父进程调用函数<code>fork()</code>时，子进程会得到父进程描述符表的副本。父子进程共享打开文件表，所以它们也会共享文件位置。因此，在内核删除文件表条目前，<span
style="background-color: yellow">父子进程都必须关闭</span>对应的描述符。</p>
<h3 id="io重定向">10.8 I/O重定向</h3>
<p>　　shell提供了<strong>I/O重定向</strong>操作符来允许用户将标准输入和输出与磁盘文件关联。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls &gt; foo.txt</span><br></pre></td></tr></table></figure>
<p>　　这条命令会让shell加载并执行<code>ls</code>程序，并且带有重定向到磁盘文件<code>foo.txt</code>的标准输出。实现I/O重定向的方法之一就是函数<code>dup2()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>; <span class="comment">/* 若成功则返回非负描述符，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>dup2()</code>会复制描述符表条目<code>oldfd</code>到描述符表条目<code>newfd</code>，这里会覆盖描述符表条目<code>newfd</code>的内容。若述符表条目<code>newfd</code>已打开，则函数<code>dup2()</code>在复制前会关闭它。</p>
<img src="/2023/08/16/computer-systems-a-programmer's-perspective-3e-chpt-10/kernel_data_structures_after_redirecting_standard_output_by_calling_dup2.svg" class="" title="kernel_data_structures_after_redirecting_standard_output_by_calling_dup2">
<p>　　在这个示例中，调用<code>dup2(4, 1)</code>后，2个描述表条目都指向文件B，文件A会被关闭且它的文件表和v-node表条目会被删除。此时，所有对标准输出的写都会重定向到文件B。</p>
<h3 id="io函数之选">10.9 I/O函数之选</h3>
<img src="/2023/08/16/computer-systems-a-programmer's-perspective-3e-chpt-10/relationship_between_unix_io,standard_io,and_rio.svg" class="" title="relationship_between_unix_io,standard_io,and_rio">
<p>　　Unix
I/O实现在操作系统内核中，可以通过系统级函数访问。较高级的RIO和标准I/O通过Unix
I/O实现，RIO是10.4中实现的可靠包装函数，它可以自动处理计数不足的情况并提供用于文本行的高效缓冲区。相比Unix
I/O，标准I/O提供更完整的使用缓冲的代替方案，包括<code>printf()</code>和<code>scantf</code>等格式化函数。</p>
<p>　　●
尽量使用标准I/O函数。对于磁盘和终端设备上的I/O，标准I/O函数是首选方案。除了函数<code>stat()</code>，Unix
I/O中的函数在标准I/O都有对应的更好的代替函数。</p>
<p>　　●
不要使用函数<code>scanf()</code>或<code>rio_readlineb()</code>读二进制文件。类似函数<code>scanf()</code>或<code>rio_readlineb()</code>的函数是专门用于读取文本行。二进制文件中可能有很多与终止文本行无关的<code>0xa</code>。</p>
<p>　　●
对套接字使用RIO函数。当使用标准I/O函数来处理套接字上的I/O时，会出现一些问题。</p>
<p>　　标准I/O是<span
style="background-color: yellow">全双工</span>的，因为可以在同一流上进行输入和输出。然而，有时对流的限制和对套接字的限制会冲突，而只有极少的文档描述这些问题：</p>
<p>　　●
若不在中间穿插调用函数<code>fflush()</code>、<code>fseek()</code>、<code>fsetpos()</code>或<code>rewind()</code>，输入函数的调用不能紧接着输出函数的调用。</p>
<p>　　●
若不在中间穿插调用函数<code>fseek()</code>、<code>fsetpos()</code>或<code>rewind()</code>，输出函数的调用不能紧接着输入函数的调用，除非输入函数遇到EOF。</p>
<p>　　函数<code>fflush()</code>会清空流关联的缓冲区，函数<code>fseek()</code>、<code>fsetpos()</code>和<code>rewind()</code>会调用Unix
I/O的函数<code>lseek()</code>来重置当前文件位置。但是，对套接字调用函数<code>lseek()</code>是非法的。第1个问题可以通过每次输入前清空缓冲区来解决，第2个问题只能通过对同一套接字描述符打开1个用于读的流和1个用于写的流来解决。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *fpin, *fpout;</span><br><span class="line"></span><br><span class="line">fpin = fdopen(sockfd, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">fpout = fdopen(sockfd, <span class="string">&quot;w&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>　　这个解决方法也有问题，它需要应用程序对这2个流都调用函数<code>fclose()</code>来清空每个流关联的内存资源，避免内存泄漏。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fclose(fpin);</span><br><span class="line">fclose(fpout);</span><br></pre></td></tr></table></figure>
<p>　　这2个操作会关闭同一套接字描述符，所以第2个操作会失败，这对顺序程序并不是问题，但线程化的程序中关闭已关闭的描述符会导致严重的问题。</p>
<p>　　综上所述，建议在套接字上使用RIO函数。若需要格式化输出，可以先调用函数<code>sprintf()</code>格式化内存中的字符，然后通过函数<code>rio_writen()</code>将其发送到套接字；若需要格式化输入，可以先调用函数<code>rio_readlineb()</code>来读取整个文本行，然后调用函数<code>sscanf()</code>来提取其中的字段。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第12章 并发编程</title>
    <url>/2023/11/03/computer-systems-a-programmer&#39;s-perspective-3e-chpt-12/</url>
    <content><![CDATA[<p>　　若多个逻辑控制流在时间上有重叠，则它们是并发的，这种机制称为<strong>并发</strong>，并且存在于计算机系统的各个层级中，例如，硬件异常处理程序、进程和Linux信号处理程序。</p>
<p>　　<strong>线程</strong>是运行在进程上下文中的逻辑流，由内核自动调度。每个线程都有自己的<strong>线程上下文</strong>，包括唯一的整数<strong>线程ID</strong>、栈、栈指针、PC、通用目的寄存器和条件码。同一进程中所有线程共享虚拟地址空间，包括只读代码区域、读写区域、堆、共享库和打开的文件。</p>
<p>　　栈位于虚拟地址空间中的栈区域，<span
style="background-color: yellow">通常</span>由对应的线程访问。但是，栈并没有严格的访问权限控制，若某个线程以某种方式得到指向其他线程的栈的指针，则它可以读写该栈的任意部分。</p>
<p>　　使用应用级并发的程序称为<strong>并发程序</strong>。现代操作系统提供了3种构建并发程序的基本方法，即<span
style="background-color: yellow">进程</span>、<span
style="background-color: yellow">I/O多路复用</span>和<span
style="background-color: yellow">线程</span>。</p>
<p>　　●
对于基于进程的并发编程，每个逻辑流1个进程。内核自动调度每个进程，每个进程都有私有的地址空间，这使得逻辑流共享数据比较困难。</p>
<p>　　●
对于基于I/O多路复用的并发编程，需要手动创建逻辑流并通过I/O多路复用来显式调度这些逻辑流。因为只有1个进程，所以逻辑流共享地址空间。</p>
<p>　　● 对于基于线程的并发编程，它结合前2种方法的特点。</p>
<p>　　函数<code>waitpid()</code>和信号量是基本的IPC机制，它们允许同一主机上的进程相互发送短信息。套接字接口是IPC的重要形式之一，它允许不同主机上的进程通信。术语Unix
IPC是所有允许同一主机上的进程通信的技术的统称，包括管道、FIFO、系统V共享内存和系统V信号量。</p>
<p>　　实现同步的方法不止有信号量。Java线程可以通过<span
style="background-color: yellow">监视器</span>来实现同步，监视器提供信号量的互斥访问和调度功能的高级抽象。实际上，监视器可以通过信号量来实现。</p>
<p>　　Posix线程是C程序控制线程的标准接口
(1995年新增)，可用于所有Linux系统上。Posix线程定义了一组对互斥锁和条件变量的同步操作，前者用于互斥，后者用于调度共享资源的访问。</p>
<p>　　程序可以分为<span
style="background-color: yellow">顺序程序</span>和<span
style="background-color: yellow">并发程序</span>。顺序程序实现为单个逻辑流。并发程序实现为多个逻辑流。<span
style="background-color: yellow">并行程序</span>是运行在多核CPU的并发程序。</p>
<span id="more"></span>
<h3 id="基于进程的并发编程">12.1 基于进程的并发编程</h3>
<p>　　最简单的构建并发程序的方法是使用进程，调用类似<code>fork</code>、<code>exec</code>和<code>waitpid()</code>的函数。</p>
<p>　　这里以构建并发服务器为例，构建并发服务器最自然的方法是服务器接收客户端的连接请求，然后创建子进程来服务客户端。</p>
<img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/simple_example_of_concurrent_programming_with_processes.svg" class="" title="simple_example_of_concurrent_programming_with_processes">
<p>　　假设有2个客户端和1个服务器 (监听描述符为描述符3)。</p>
<p>　　如图a所示，服务器接收客户端1的连接请求并返回新的已连接描述符
(描述符4)。</p>
<p>　　如图b所示，客户端创建子进程1，子进程1有服务器的描述符表的完整副本。子进程1<span
style="background-color: yellow">关闭自己的描述符3</span>，服务器<span
style="background-color: yellow">关闭自己的描述符4</span>。然后，子进程1服务客户端1。</p>
<p>　　如图c所示，服务器接收新客户端2的连接请求并返回新的已连接描述符
(描述符5)。</p>
<p>　　如图d所示，服务器创建子进程2，子进程2通过描述符5来服务客户端2。</p>
<p>　　此时，服务器等待下一个连接请求，2个子进程并发地服务对应的客户端。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 基于进程的并发echo服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Close(listenfd); <span class="comment">/* 子进程关闭它的的监听描述符 */</span></span><br><span class="line">            echo(connfd);    <span class="comment">/* 子进程服务客户端 */</span></span><br><span class="line">            Close(connfd);   <span class="comment">/* 子进程关闭和客户端的连接 */</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);         <span class="comment">/* 子进程退出 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        Close(connfd); <span class="comment">/* 服务器关闭它的已连接标识符 (重要) */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于基于进程的并发echo服务器，由于服务器会运行较长时间，必须要加入信号处理程序来回收子进程
(第3~8行)。因为信号SGICHLD在信号SGICHLD处理程序运行时会被阻塞并且信号不会排队，所以信号SIGCHLD处理程序必须准备回收多个僵尸子进程。由于套接字的文件表条目中的引用次数，只有当父子进程都关闭各自的<code>connfd</code>时，与客户端的连接才会关闭。</p>
<p>　　进程拥有用于父子进程之间共享状态信息的清晰模型，即文件表是共享的，而用户地址空间不是共享的。不共享的地址空间既是优点也是缺点，优点是进程不可能意外地覆写其他进程的虚拟内存，缺点是不共享的地址空间不易于共享状态信息。若需要共享状态信息，必须使用显式IPC机制。基于进程的并发编程的另一个缺点是不低的进程控制和IPC成本，所以更可能会导致效率低下。</p>
<h3 id="基于io多路复用的并发编程">12.2 基于I/O多路复用的并发编程</h3>
<p>　　若需要编写能够响应通过键盘输入的命令行的echo服务器，可以使用I/O多路复用。基本思想是调用函数<code>select()</code>来请求内核挂起进程，并在I/O事件发生后将控制权转移给应用程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> n, fd_set *fdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span>; <span class="comment">/* 若成功则返回准备好读的描述符数，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于控制描述符集的宏 */</span></span><br><span class="line">FD_ZERO(fd_set *fdset);          <span class="comment">/* 清除fdset的所有位 */</span></span><br><span class="line">FD_CLR(<span class="type">int</span> fd, fd_set *fdset);   <span class="comment">/* 清除fdset的fd位 */</span></span><br><span class="line">FD_SET(<span class="type">int</span> fd, fd_set *fdset);   <span class="comment">/* 启用fdset的fd位 */</span></span><br><span class="line">FD_ISSET(<span class="type">int</span> fd, fd_set *fdset); <span class="comment">/* fdset的fd位是否启用 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>select()</code>控制类型为<code>fd_set</code>的集合，称为<strong>描述符集</strong>。从逻辑角度，可以将描述符集视为长度为<span
class="math inline">\(n\)</span>的位向量<span
class="math inline">\([b_{n-1},...,b_{1},b_{0}]\)</span>，<span
class="math inline">\(b_k\)</span>对应描述符<span
class="math inline">\(k\)</span>。当且仅当<span
class="math inline">\(b_k=1\)</span>时，描述符<span
class="math inline">\(k\)</span>才是描述符集的成员。能对描述符集的进行操作只有3个，即分配它们、将该类型的变量赋值给其他变量以及通过宏<code>FD_ZERO</code>、<code>FD_CLR</code>、<code>FD_SET</code>和<code>FD_ISSET</code>来修改和查看它们。</p>
<p>　　函数<code>select()</code>有多种应用场景。这里仅介绍其中之一，即等待一组描述符准备好读。因此，这里仅需要使用函数<code>select()</code>的2个参数，即称为<strong>读集合</strong>的描述符集<code>fdset</code>和读集合的基数
(所有描述符集的最大基数)。函数<code>select()</code>会阻塞，直到读集合中至少有1个描述符准备好读。当前仅当从描述符<code>k</code>读1B的请求不会阻塞时，描述符<code>k</code>才准备好读。</p>
<p>　　函数<code>select()</code>有1个副作用，它会让参数<code>fdset</code>指向<code>fd_set</code>来指示读集合的子集，该子集称为<strong>准备集合</strong>，由准备好读的描述符组成。该函数返回的值表示准备集合的基数。因此，每次调用函数<code>select()</code>时必须更新读集合。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从标准输入读命令</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">command</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">if</span> (!Fgets(buf, MAXLINE, <span class="built_in">stdin</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* EOF */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf); <span class="comment">/* 处理命令 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 基于I/O多路复用的echo服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    fd_set read_set, ready_set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;read_set);              <span class="comment">/* 清空读集合 */</span></span><br><span class="line">    FD_SET(STDIN_FILENO, &amp;read_set); <span class="comment">/* 将标准输入加入读集合 */</span></span><br><span class="line">    FD_SET(listenfd, &amp;read_set);     <span class="comment">/* 将监听描述符加入读集合 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ready_set = read_set;</span><br><span class="line">        Select(listenfd + <span class="number">1</span>, &amp;ready_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;ready_set))</span><br><span class="line">        &#123;</span><br><span class="line">            command(); <span class="comment">/* 从标准输入读命令行 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;ready_set))</span><br><span class="line">        &#123;</span><br><span class="line">            clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">            connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">            echo(connfd); <span class="comment">/* echo客户端输入，直到EOF */</span></span><br><span class="line">            Close(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例通过函数<code>select()</code>来实现能够响应通过键盘输入的命令行的迭代echo服务器。</p>
<p>　　首先，通过函数<code>open_listenfd()</code>来打开监听描述符
(第34行)，调用宏<code>FD_ZERO</code>来创建空的读集合
(第36行)。然后，将描述符0 (标准输入) 和3 (监听描述符)
加入读集合。最后，开始常规的服务器循环，这里调用函数<code>select()</code>来阻塞自己，直到标准输入和监听描述符之一准备好读
(第43行)。函数<code>select()</code>返回后，调用宏<code>FD_ISSET</code>来判断描述符是否准备好读。若标准输入准备好读
(第44行)，则调用函数<code>command()</code>；若监听描述符准备好读
(第48行)，则调用函数<code>accept()</code>和<code>echo()</code>。</p>
<p>　　这个示例有1个问题，即一旦它连接客户端，会不断回显输入行，直到客户端关闭其连接端点。因此，若在键盘输入命令到标准输入，则需要在服务器完成服务客户端后才会得到响应，这可以通过每次服务器循环回显最多1行文本来解决。</p>
<h4 id="基于io多路复用的并发事件驱动服务器">12.2.1
基于I/O多路复用的并发事件驱动服务器</h4>
<p>　　I/O多路复用可用于实现并发事件驱动程序，其逻辑流会随着特定事件的完成而进行。基本思想是将逻辑流模型为<strong>状态机</strong>。状态机是状态、输入事件和转换的集合，每个事件将1个输入状态和1个输入事件映射到1个输出状态。<strong>自循环</strong>是输入状态和输出状态相同的转换。状态机通常描述为有向图，节点表示状态，有向弧表示转换，弧标签表示输入事件。状态机在开始执行时有初始状态。每个输入事件会触发从当前状态到下一状态的转换。</p>
<img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/state_machine_for_a_logical_flow_in_a_concurrent_event_driven_echo_server.svg" class="" title="state_machine_for_a_logical_flow_in_a_concurrent_event_driven_echo_server">
<p>　　对于每个新的客户端<span
class="math inline">\(k\)</span>，基于I/O多路复用的并发服务器会创建1个新的状态机<span
class="math inline">\(s_k\)</span>并将其关联到描述符<span
class="math inline">\(d_k\)</span>。如图所示，每个状态机<span
class="math inline">\(s_k\)</span>都有1个状态 (等待描述符<span
class="math inline">\(d_k\)</span>准备好读)、输入事件 (描述符<span
class="math inline">\(d_k\)</span>准备好读) 和转换 (从描述符<span
class="math inline">\(d_k\)</span>中读1行文本)。</p>
<p>　　服务器通过I/O多路复用 (由函数<code>select()</code>提供)
来检查输入事件的发生。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 已连接描述符 (客户端) 池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> maxfd;                   <span class="comment">/* 读集合中的最大描述符 */</span></span><br><span class="line">    fd_set read_set;             <span class="comment">/* 已启用的描述符集 */</span></span><br><span class="line">    fd_set ready_set;            <span class="comment">/* 准备好读的描述符集*/</span></span><br><span class="line">    <span class="type">int</span> nready;                  <span class="comment">/* 函数select的准备好读的描述符数 */</span></span><br><span class="line">    <span class="type">int</span> maxi;                    <span class="comment">/* 客户端池的最大索引 */</span></span><br><span class="line">    <span class="type">int</span> clientfd[FD_SETSIZE];    <span class="comment">/* 已启用的描述符集 */</span></span><br><span class="line">    <span class="type">rio_t</span> clientrio[FD_SETSIZE]; <span class="comment">/* 已启用的读缓冲区集合 */</span></span><br><span class="line">&#125; pool;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> byte_cnt = <span class="number">0</span>; <span class="comment">/* 服务器接收的字节总数 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 基于I/O多路复用的并发事件驱动echo服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">static</span> pool pool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    init_pool(listenfd, &amp;pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 等待监听/已连接描述符准备好读 */</span></span><br><span class="line">        pool.ready_set = pool.read_set;</span><br><span class="line">        pool.nready = Select(pool.maxfd + <span class="number">1</span>, &amp;pool.ready_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 若监听描述符准备好读，则将新的客户端加入池中 */</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;pool.ready_set))</span><br><span class="line">        &#123;</span><br><span class="line">            clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">            connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">            add_client(connfd, &amp;pool);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从每个已连接描述符中回显1行文本行 */</span></span><br><span class="line">        check_clients(&amp;pool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于并发事件驱动echo服务器，客户端集合通过结构体<code>pool</code>来维护。在调用函数<code>init_pool()</code>初始化客户端池后
(第35行)，服务器进入无限循环。在每次迭代时，服务器会调用函数<code>select()</code>来确定2个事件，即新客户端的连接请求的到达和已存在客户端的已连接描述符的准备好读。当新客户端的连接请求到达时
(第44行)，服务器会接受连接并调用函数<code>add_client()</code>来将该客户端加入到客户端池
(第47~48行)。最后，服务器调用函数<code>check_clients()</code>来从每个已连接描述符中回显1行文本行
(第52行)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化客户端池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param listenfd 监听描述符</span></span><br><span class="line"><span class="comment"> * @param p 客户端池指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pool</span><span class="params">(<span class="type">int</span> listenfd, pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始时，没有已连接的描述符 */</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    p-&gt;maxi = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;clientfd[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始时, 函数select的读集合中只有监听描述符 */</span></span><br><span class="line">    p-&gt;maxfd = listenfd;</span><br><span class="line">    FD_ZERO(&amp;p-&gt;read_set);</span><br><span class="line">    FD_SET(listenfd, &amp;p-&gt;read_set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>init_pool()</code>会初始化客户端池。数组<code>clientfd</code>表示已连接描述符集，整数-1表示有可用的位置。初始时，已连接描述符集是空集合
(第11~15行)，函数<code>select()</code>的读集合中只有监听描述符
(第18~20行)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将新的客户端加入到客户端池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param connfd 已连接描述符</span></span><br><span class="line"><span class="comment"> * @param p 客户端池指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_client</span><span class="params">(<span class="type">int</span> connfd, pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    p-&gt;nready--;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">        <span class="comment">/* 找到可用的位置 */</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;clientfd[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 将已连接描述符加入池中 */</span></span><br><span class="line">            p-&gt;clientfd[i] = connfd;</span><br><span class="line">            Rio_readinitb(&amp;p-&gt;clientrio[i], connfd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将该描述符加入函数select的读集合 */</span></span><br><span class="line">            FD_SET(connfd, &amp;p-&gt;read_set);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 更新最大描述符以及相关参数 */</span></span><br><span class="line">            <span class="keyword">if</span> (connfd &gt; p-&gt;maxfd)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;maxfd = connfd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; p-&gt;maxi)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;maxi = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == FD_SETSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 找不到可用的位置 */</span></span><br><span class="line">        app_error(<span class="string">&quot;add_client error: Too many clients&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>add_client()</code>会将新的客户端加入到客户端池。若在数组<code>clientfd</code>中找到位置，则服务器会将连接描述符加入到该数组并初始化对应的RIO读缓冲区
(第16~17行)。然后，将该已连接描述符加入到函数<code>select()</code>的读集合
(第20行)
并更新客户端池的部分全局属性。变量<code>maxfd</code>表示函数<code>select()</code>的最大文件描述符
(第23~26行)，变量<code>maxi</code>表示数组<code>clientfd</code>中的最大索引。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 服务客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param p 客户端池指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_clients</span><span class="params">(pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, connfd, n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; (i &lt;= p-&gt;maxi) &amp;&amp; (p-&gt;nready &gt; <span class="number">0</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        connfd = p-&gt;clientfd[i];</span><br><span class="line">        rio = p-&gt;clientrio[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 若描述符准备好读，则从中回显1行文本 */</span></span><br><span class="line">        <span class="keyword">if</span> ((connfd &gt; <span class="number">0</span>) &amp;&amp; (FD_ISSET(connfd, &amp;p-&gt;ready_set)))</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;nready--;</span><br><span class="line">            <span class="keyword">if</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                byte_cnt += n;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Server received %d (%d total) bytes on fd %d\n&quot;</span>, n, byte_cnt, connfd);</span><br><span class="line">                Rio_writen(connfd, buf, n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 检测到EOF，从池中移除描述符 */</span></span><br><span class="line">                Close(connfd);</span><br><span class="line">                FD_CLR(connfd, &amp;p-&gt;read_set);</span><br><span class="line">                p-&gt;clientfd[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>check_clients()</code>会从每个准备好读的已连接描述符中返回1行文本，并将那行文本返回给客户端
(第23~25行)。第23行会维护全局变量<code>byte_cnt</code>来表示从所有客户端接收的总字节数。当客户端关闭连接端点时，服务器会检测到EOF，进而关闭连接端点
(第30行) 并将对应的描述符从客户端池中移除 (第31~32行)。</p>
<p>　　从状态机角度，函数<code>select()</code>用于检测输入事件，函数<code>add_client()</code>用于创建新状态机，函数<code>check_clients()</code>用于执行状态转换
(回显输入行) 和在客户端完成发送文本行时删除状态机。</p>
<h4 id="io多路复用的优点和缺点">12.2.2 I/O多路复用的优点和缺点</h4>
<p>　　I/O多路复用有2个优点和2个缺点。</p>
<p>　　第1个优点是相比进程驱动的设计，事件驱动的设计能让程序员更好地基于程序行为来控制程序。例如，若需要设计优先服务某些客户端的并发服务器，使用进程驱动的设计来实现会比较复杂。</p>
<p>　　第2个优点是基于I/O多路复用的事件驱动服务器可以运行在单个进程的上下文中，所以每个逻辑流都可以访问该进程的地址空间，这样易于逻辑流之间共享数据。运行在单个进程还可以使用GDB等调试工具来像调试顺序程序一样调试并发服务器。此外，事件驱动的设计通常比进程驱动的设计高效很多，因为无需执行进程上下文切换来调度新的逻辑流。</p>
<p>　　第1个缺点是事件驱动的设计的实现代码比较复杂。并发事件驱动echo服务器的代码量是并发进程驱动echo服务器的3倍多。复杂度随着并发粒度
(每个逻辑流在每个时间片上执行的指令数)
的降低而增加。例如，对于12.2.1中的示例，并发粒度就是读1整行文本所需的指令数。当某个逻辑流在读1行文本时，其他逻辑流无法进行，这使得服务器更容易受到恶意客户端的攻击
(仅发送部分文本行，再停止)。修改事件驱动服务器以处理这种攻击并不简单，但进程驱动服务器可以自动处理这种攻击。</p>
<p>　　第2个缺点是事件驱动的设计无法充分利用多核CPU。</p>
<p>　　虽然事件驱动的设计有以上缺点，但Node.js、Nginx和Tornado等现代高性能服务器都是使用基于I/O多路复用的事件驱动来实现，因为相比通过进程或线程来实现，这种方式有良好的性能。</p>
<h3 id="基于线程的并发编程">12.3 基于线程的并发编程</h3>
<img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/concurrent_thread_execution.svg" class="" title="concurrent_thread_execution">
<p>　　多线程的执行模型与多进程的执行模型有些类似。每个进程的生命周期开始时会有1个进程，称为<strong>主线程</strong>。在某个时刻下，主线程会创建<strong>对等线程</strong>，此时，主线程与对等线程并发运行。一段时间后，主线程会将控制权转移给对等线程
(调用<code>read</code>和<code>sleep</code>等慢系统调用或被系统间隔定时器中断)。对等线程执行一段时间后将控制权转移给主线程，依此类推。</p>
<p>　　线程执行与进程执行有一些重要的不同。首先，由于线程上下文比进程上下文小很多，所以线程上下文切换比进程上下文切换快很多。其次，不同于进程组织为严格的父子层次结构，进程关联的线程形成<span
style="background-color: yellow">对等体池</span>，与线程是否由其他线程创建无关。主线程与其他线程的唯一区别是主线程是进程中运行的第1个线程。对等体池的主要作用是某个线程可以终止任意对等体线程或等待任意对等体终止。</p>
<h4 id="posix线程">12.3.1 Posix线程</h4>
<p>　　Posix线程定义了大约60种函数来创建线程、终止线程、回收线程、安全地在对等线程之间共享数据和通知对等线程系统状态的改变。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 线程例程</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param vargp</span></span><br><span class="line"><span class="comment"> * @return void* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，主线程会创建对等线程并等待其终止。对等线程打印<code>Hello, world!\n</code>并终止。当主线程检测到对等线程终止时，会调用函数<code>exit()</code>来终止进程。对等线程的代码称为<strong>线程例程</strong>
(第17~21行)，其输入和输出都是通用指针。若需要给线程例程传递多个参数，则可以将这些参数封装为结构体并将指向该结构体的指针传递给线程例程；若需要线程例程返回多个参数，则可以返回指向结构体的指针。</p>
<p>　　主函数就是主线程的代码。首先，主线程声明局部变量<code>tid</code>来存放对等线程TID并调用函数<code>Pthread_create()</code>来创建对等线程
(第11~12行)，当函数<code>Pthread_create()</code>返回时，对等线程TID会存放在参数<code>tid</code>中且对等线程与主线程并发运行。然后，主线程调用函数<code>Pthread_join()</code>来等待对等线程终止
(第13行)。最后，主线程调用函数<code>exit()</code>来终止进程中的所有线程
(第14行)。</p>
<h4 id="创建线程">12.3.2 创建线程</h4>
<p>　　可以调用函数<code>pthread_create()</code>来创建线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *(func)(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *tid, <span class="type">pthread_attr_t</span> *attr, func *f, <span class="type">void</span> *arg)</span>; <span class="comment">/* 若成功则返回0，若出错则返回非0错误码 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">()</span>; <span class="comment">/* 返回调用者TID */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_create()</code>会创建线程并在新线程的上下文中带有参数<code>arg</code>调用线程例程。参数<code>attr</code>可用于改变新线程的默认属性。</p>
<p>　　当函数<code>pthread_create()</code>返回时，参数<code>tid</code>会包含新线程TID。新线程可以调用函数<code>pthread_self()</code>来查看自己TID。</p>
<h4 id="初始化线程">12.3.3 初始化线程</h4>
<p>　　可以调用函数<code>pthread_once()</code>来初始化线程例程的相关状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_once</span><span class="params">(<span class="type">pthread_once_t</span> *once_control, <span class="type">void</span> (*init_routine)(<span class="type">void</span>))</span>; <span class="comment">/* 总是返回0 */</span></span><br></pre></td></tr></table></figure>
<p>　　变量<code>once_control</code>是全局/静态变量，总是初始化为<code>PTHREAD_ONCE_INIT</code>。第1次带有参数<code>once_control</code>调用函数<code>pthread_once()</code>时，会调用既没输入也没有输出的函数<code>init_routine()</code>。之后带有参数<code>once_control</code>调用函数<code>pthread_once()</code>时，不会做任何事。函数<code>pthread_once()</code>适合初始化多个线程共享的全局变量。</p>
<h4 id="终止和回收线程">12.3.4 终止和回收线程</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *thread_return)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> tid)</span>; <span class="comment">/* 若成功则返回0，若出错则返回非0错误码 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> tid, <span class="type">void</span> **thread_return)</span>; <span class="comment">/* 若成功则返回0，若出错则返回非0错误码 */</span></span><br></pre></td></tr></table></figure>
<p>　　可以通过以下方式来终止线程：</p>
<p>　　● 当线程的上级线程例程返回时，该线程会<span
style="background-color: yellow">隐式</span>终止。</p>
<p>　　● 调用函数<code>pthread_exit()</code>来显式终止当前线程。</p>
<p>　　●
调用函数<code>exit()</code>来关闭当前进程以及与之关联的所有线程。</p>
<p>　　●
调用函数<code>pthread_cancel()</code>来关闭TID为参数<code>tid</code>的线程。</p>
<p>　　当主线程调用函数<code>pthread_exit()</code>时，会等待所有对等线程终止，再终止主线程，最后整个进程返回<code>thread_return</code>。</p>
<p>　　线程可以调用函数<code>pthread_join()</code>来等待其他线程终止，当前线程会阻塞，直到TID为参数<code>tid</code>的线程终止，然后，将线程例程返回的通用指针<code>void *</code>分配给<code>thread_return</code>指向的位置，最后，回收已终止线程的所有内存资源。</p>
<p>　　不同于函数<code>wait()</code>，函数<code>pthread_join()</code>只会等待1个特定的线程终止，这使得检测进程终止需要使用其他更复杂的机制来实现。</p>
<h4 id="分离线程">12.3.5 分离线程</h4>
<p>　　线程要么是<span
style="background-color: yellow">可合并</span>的，要么是<span
style="background-color: yellow">可分离</span>的。可合并的线程能被其他线程回收或终止，其内存资源不会释放，直到被其他线程回收。相反，可分离的线程不能被其他线程回收或终止，在终止时，其内存资源会被系统自动回收。</p>
<p>　　线程创建时默认是可合并的。为了避免内存泄漏，可合并的线程的内存资源应该显式被其他线程回收或调用函数<code>pthread_detach()</code>来变为可分离的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span>; <span class="comment">/* 若成功则返回0，若出错则返回非0错误码 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_detach()</code>会将TID为参数<code>tid</code>的可合并的线程变为可分离的。</p>
<h4 id="基于线程的并发echo服务器">12.3.6 基于线程的并发echo服务器</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 基于线程的并发echo服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, *connfdp;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfdp = Malloc(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *connfdp = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, connfdp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> connfd = *((<span class="type">int</span> *)vargp);</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    Free(vargp);</span><br><span class="line">    echo(connfd);</span><br><span class="line">    Close(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　基于线程的并发echo服务器的大体结构与进程驱动的设计相似，主线程等待连接请求并创建对等线程来处理请求。</p>
<p>　　在调用函数<code>pthread_create()</code>时
(第28行)，会将指向已连接描述符的指针<code>connfdp</code>作为参数。在线程例程中，将该指针分配给局部变量
(第34行)。若像之前的示例一样直接使用<code>int</code>来存储已连接描述符会导致对等线程中的赋值语句与主线程中下一次调用函数<code>accept()</code>之间出现<span
style="background-color: yellow">竞争</span>。若前者竞争胜利，则线程例程中局部变量<code>connfd</code>会得到正确的描述符值；若后者竞争胜利，则线程例程中局部变量<code>connfd</code>会得到下一个连接的描述符值。为了避免这种竞争，必须将函数<code>accept()</code>返回的已连接描述符赋值给动态分配的内存块
(第26~27行)。</p>
<p>　　为了避免线程例程中的内存泄漏，这里会将每个线程变为可分离的并释放在主线程中分配的内存块
(第35~36行)。</p>
<h3 id="线程化程序的共享变量">12.4 线程化程序的共享变量</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> **ptr; <span class="comment">/* 全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">char</span> *msgs[N] = &#123;<span class="string">&quot;Hello from foo&quot;</span>, <span class="string">&quot;Hello from bar&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    ptr = msgs;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, (<span class="type">void</span> *)i);</span><br><span class="line">    &#125;</span><br><span class="line">    Pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> myid = (<span class="type">int</span>)vargp;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]: %s (cnt=%d)\n&quot;</span>, myid, ptr[myid], ++cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例中有1个主线程和2个对等线程。主线程会给每个对等线程传递唯一的ID，对等线程通过该ID来输出个性化信息和线程例程被调用的总次数。在第25行，对等线程通过指针<code>ptr</code>来间接引用主线程的栈中的内容。</p>
<p>　　线程化程序中的变量会按照其存储类别映射到虚拟内存：</p>
<p>　　●
全局变量是声明在函数外的变量。在运行时，虚拟内存的读写区域仅包含全局变量的1个实例，例如，第3行声明的指针<code>ptr</code>。当变量仅有1个实例时，可以简单地使用变量名来引用该实例。</p>
<p>　　●
局部自动变量是函数体内声明的变量。在运行时，每个线程的栈都包含所有局部自动变量的私有实例。例如，局部变量<code>tid</code>仅有1个实例，它存储在主线程的栈中，这里用<code>tid.m</code>来表示。局部变量<code>myid</code>有2个实例，分别存储在对等线程1和2的栈中，这里分别用<code>myid.p0</code>和<code>myid.p1</code>来表示。</p>
<p>　　●
局部静态变量是函数体内使用关键字<code>static</code>声明的变量。在运行时，虚拟内存的读写区域仅包含局部静态变量的1个实例。例如，即使每个对等线程都会声明局部静态变量<code>cnt</code>
(第24行)，在运行时，虚拟内存的读写区域仅包含该变量的1个实例，所有对等线程都读写该实例。</p>
<p>　　综上所述，当且仅当变量只有1个实例时，它才是共享的。例如，变量<code>cnt</code>在运行时仅有1个实例，所以它是共享的。变量<code>myid</code>在运行时有2个实例，每个线程引用1个实例，所以它是不共享的。此外，局部自动变量<span
style="background-color: yellow">可能</span>是共享的，例如，第11行声明的<code>msgs</code>。</p>
<h3 id="同步线程与信号量">12.5 同步线程与信号量</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> niters;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;niters&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    niters = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建线程并等待其结束 */</span></span><br><span class="line">    Pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">    Pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">    Pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查结果 */</span></span><br><span class="line">    <span class="keyword">if</span> (cnt != (<span class="number">2</span> * niters))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;BOOM! cnt=%ld\n&quot;</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OK cnt=%ld\n&quot;</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i, niters = *((<span class="type">long</span> *)vargp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; niters; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会创建2个线程，每个线程都会增加共享变量<code>cnt</code>，<code>cnt</code>的最终值应该是<code>2 * niters</code>，但实际并非如此。</p>
<img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/assembly_code_for_the_counter_loop.svg" class="" title="assembly_code_for_the_counter_loop">
<p>　　这里将线程例程中循环部分的汇编代码分为5部分。对于线程<span
class="math inline">\(i\)</span>，<span
class="math inline">\(H_i\)</span>表示循环首部的指令块。<span
class="math inline">\(L_i\)</span>表示将共享变量<code>cnt</code>加载到累加寄存器<code>%rdx</code>的指令。<span
class="math inline">\(U_i\)</span>表示更新寄存器<code>%rdx</code>的指令。<span
class="math inline">\(S_i\)</span>表示将寄存器<code>%rdx</code>更新后的值存回共享变量<code>cnt</code>的指令。<span
class="math inline">\(T_i\)</span>表示循环尾部的指令块。这里<span
class="math inline">\(H_i\)</span>和<span
class="math inline">\(T_i\)</span>操作局部栈变量，<span
class="math inline">\(L_i\)</span>、<span
class="math inline">\(U_i\)</span>和<span
class="math inline">\(S_i\)</span>操作共享变量<code>cnt</code>。</p>
<p>　　当2个对等线程在单核CPU上并发运行时，指令会按照某种顺序执行。每次并发执行会定义2个线程中指令的顺序，其中的某些顺序可能会产生正确的结果，而其他则不会。</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>线程</th>
<th>指令</th>
<th style="text-align: left;"><code>%rdx</code> (线程1)</th>
<th style="text-align: left;"><code>%rdx</code> (线程2)</th>
<th style="text-align: left;"><code>cnt</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td><span class="math inline">\(H_1\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td><span class="math inline">\(L_1\)</span></td>
<td style="text-align: left;">0</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td><span class="math inline">\(U_1\)</span></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
<td><span class="math inline">\(S_1\)</span></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">1</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td><span class="math inline">\(H_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">1</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
<td><span class="math inline">\(L_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
<tr>
<td>7</td>
<td>2</td>
<td><span class="math inline">\(U_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">1</td>
</tr>
<tr>
<td>8</td>
<td>2</td>
<td><span class="math inline">\(S_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">2</td>
</tr>
<tr>
<td>9</td>
<td>2</td>
<td><span class="math inline">\(T_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">2</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
<td><span class="math inline">\(T_1\)</span></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">2</td>
</tr>
</tbody>
</table>
<p>　　这是首次迭代的正确指令执行顺序。在2个线程都更新共享变量<code>cnt</code>后，其值为2。</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>线程</th>
<th>指令</th>
<th style="text-align: left;"><code>%rdx</code> (线程1)</th>
<th style="text-align: left;"><code>%rdx</code> (线程2)</th>
<th style="text-align: left;"><code>cnt</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td><span class="math inline">\(H_1\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td><span class="math inline">\(L_1\)</span></td>
<td style="text-align: left;">0</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td><span class="math inline">\(U_1\)</span></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td><span class="math inline">\(H_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td><span class="math inline">\(L_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td><span class="math inline">\(S_1\)</span></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">1</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td><span class="math inline">\(T_1\)</span></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">1</td>
</tr>
<tr>
<td>8</td>
<td>2</td>
<td><span class="math inline">\(U_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
<tr>
<td>9</td>
<td>2</td>
<td><span class="math inline">\(S_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
<tr>
<td>10</td>
<td>2</td>
<td><span class="math inline">\(T_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
</tbody>
</table>
<p>　　这是首次迭代的错误指令执行顺序。线程2过早地加载共享变量<code>cnt</code>
(第5步)。</p>
<h4 id="进度图">12.5.1 进度图</h4>
<p>　　<strong>进度图</strong>将<span
class="math inline">\(n\)</span>个并发进程的执行模型化为通过<span
class="math inline">\(n\)</span>维笛卡尔空间的轨迹。轴<span
class="math inline">\(k\)</span>对应线程<span
class="math inline">\(k\)</span>的进度。每个点都对应某个状态。点<span
class="math inline">\(I_k\)</span>表示线程<span
class="math inline">\(k\)</span>已完成指令<span
class="math inline">\(I_k\)</span>。原点对应初始状态，表示没有线程完成指令。</p>
<p>　　进度图将指令执行模型化为从某个状态到其他状态的<strong>过渡</strong>，表示为某个点到相邻点的有向边。过渡只能是向右
(线程1完成指令) 或向上 (线程2完成指令)，不允许对角线过渡
(2个指令同时完成)。程序的执行过程模型化为通过状态空间的<strong>轨迹</strong>。</p>
<img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/an_example_trajectory.svg" class="" title="an_example_trajectory">
<p>　　在这个示例中，轨迹对应的指令顺序为<span
class="math inline">\(H_1\)</span>、<span
class="math inline">\(L_1\)</span>、<span
class="math inline">\(U_1\)</span>、<span
class="math inline">\(H_2\)</span>、<span
class="math inline">\(L_2\)</span>、<span
class="math inline">\(S_1\)</span>、<span
class="math inline">\(T_1\)</span>、<span
class="math inline">\(U_2\)</span>、<span
class="math inline">\(S_2\)</span>和<span
class="math inline">\(T_2\)</span>。</p>
<p>　　对于线程<span
class="math inline">\(i\)</span>，操作共享变量<code>cnt</code>的指令<span
class="math inline">\(L_i\)</span>、<span
class="math inline">\(U_i\)</span>和<span
class="math inline">\(S_i\)</span>组成<strong>关键部分</strong>。某个线程的关键部分不应该与其他线程的关键部分重叠，即线程在执行其关键部分的指令时，对共享变量有互斥访问权限，这种情况称为<strong>互斥</strong>。</p>
<img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/safe_and_unsafe_trajectories.svg" class="" title="safe_and_unsafe_trajectories">
<p>　　在进度图中，2个关键部分的交集定义了状态空间的<strong>不安全区域</strong>，不安全区域并不包括其边界。例如，状态<span
class="math inline">\((H_1,H2)\)</span>和<span
class="math inline">\((S_1,U_2)\)</span>毗邻不安全区域，但并不属于不安全区域。绕开不安全区域的轨迹称为<strong>安全轨迹</strong>，通过不安全区域的轨迹称为<strong>不安全轨迹</strong>。所有安全轨迹都会正确地更新共享变量<code>cnt</code>。</p>
<p>　　进度图提供了很好的方法来可视化运行在单核CPU上的并发程序和理解同步。但是，进度图并不适用于运行在多核CPU的并发程序。多核CPU的存储系统可以处于与进度图中任何轨迹都不对应的状态。</p>
<h4 id="信号量">12.5.2 信号量</h4>
<p>　　并发编程先驱Edsger Dijkstra (1930~2002，荷兰人)
提出了不同线程的同步问题的经典解决方法之一，该方法基于称为<strong>信号量</strong>的特殊类型变量。信号量<code>s</code>是非负的整数值，只能通过2种特殊操作来控制，即<code>P</code>和<code>V</code>。<code>P</code>和<code>V</code>
源自荷兰语proberen (尝试) 和verhogen (增加)。</p>
<p>　　●
<code>P(s)</code>会判断<code>s</code>。若<code>s</code>非0，则将<code>s</code>减1并立即返回；若<code>s</code>是0，则挂起线程，直到<code>s</code>变为非0，然后通过<code>V</code>操作来恢复该线程。在恢复后，<code>P</code>操作将<code>s</code>减1并将控制权转移给调用者。</p>
<p>　　●
<code>V(s)</code>会将<code>s</code>加1。若存在线程阻塞在<code>P</code>操作
(等待<code>s</code>变为非0)，则恢复其中的<span
style="background-color: yellow">1个</span>线程。</p>
<p>　　<code>P</code>中的判断和递减操作是不可分割的。<code>V</code>操作中的递增操作也是不可分割的。V操作并<span
style="background-color: yellow">未定义</span>等待线程的恢复顺序。</p>
<p>　　<code>P</code>和<code>V</code>的定义确保正在运行的程序不会进入正确初始化的信号量为负值的状态，这个属性称为<strong>信号量不变式</strong>，它提供了用于控制并发程序的轨迹的有效工具。</p>
<p>　　Posix标准定义了多个函数来操作信号量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="number">0</span>, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *s)</span>; <span class="comment">/* P(s) */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *s)</span>; <span class="comment">/* V(s) */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="type">sem_t</span> *s)</span>; <span class="comment">/* sem_wait的包装函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="type">sem_t</span> *s)</span>; <span class="comment">/* sem_post的包装函数 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>sem_init()</code>会将信号量<code>sem</code>初始化为<code>value</code>
(这里将第2个参数直接设置为0)，信号量在使用前必须初始化。可以调用函数<code>sem_wait()</code>和<code>sem_post()</code>来执行<code>P</code>和<code>V</code>操作，为了简洁，这里使用它们的包装函数。</p>
<h4 id="使用信号量来互斥">12.5.3 使用信号量来互斥</h4>
<p>　　信号量提供了便利的方法来实现共享变量的互斥访问。基本思想是将每个共享变量与1个初始值为1的信号量关联，然后将对应的关键部分用<code>P</code>和<code>V</code>操作包围起来。</p>
<p>　　用于实现共享变量的互斥访问的信号量称为<strong>二进制信号量</strong>
(因为其值只能是0和1)
或<strong>互斥锁</strong>。执行<code>V</code>操作的过程称为<strong>解锁</strong>。已上锁的线程<strong>持有</strong>锁。用作可用资源计数器的信号量称为<strong>计数信号量</strong>。</p>
<img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/using_semaphores_for_mutual_exclusion.svg" class="" title="using_semaphores_for_mutual_exclusion">
<p>　　以同步12.5中的计数器程序为例，这里每个状态都标上了对应的<code>s</code>值，其关键思想是<code>P</code>和<code>V</code>操作的结合产生了称为<strong>禁止区域</strong>的状态集，其中<code>s</code>的值为负。由于信号量非负，所有可行的轨迹都不能通过禁止区域。由于禁止区域包含不安全区域，所以所有可行的轨迹都是安全的，无论指令运行时以何种顺序执行，程序总能正确地增加计数器。</p>
<p>　　首先，声明互斥锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> cnt = <span class="number">0</span>; <span class="comment">/* 计数器 */</span></span><br><span class="line"><span class="type">sem_t</span> mutex;           <span class="comment">/* 包含计数器的信号量 */</span></span><br></pre></td></tr></table></figure>
<p>　　然后，在主函数将信号量初始化为1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>　　最后，将线程例程中共享变量<code>cnt</code>的更新用<code>P</code>和<code>V</code>操作包围起来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; niters; i++)</span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    cnt++;</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用信号量来调度共享资源">12.5.4 使用信号量来调度共享资源</h4>
<p>　　除了提供互斥访问，信号量的另一个重要用途是调度共享资源的访问。在这种情况下，线程通过信号量操作来通知其他线程程序状态中某些条件变为真，例如，生产者-消费者问题和读者-写者问题。</p>
<h5 id="生产者-消费者问题">12.5.4.1 生产者-消费者问题</h5>
<img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/producer-consumer_problem.svg" class="" title="producer-consumer_problem">
<p>　　生产者线程和消费者线程共享<span
style="background-color: yellow">有限</span>缓冲区。生产者线程反复生成新项并将其放入缓冲区。消费者线程反复从缓冲区取出项并使用。此外，可能出现多个生产者和消费者的情况。</p>
<p>　　由于放入和取出项涉及更新共享变量，必须确保对缓冲区的互斥访问，但这还不够，还需要调度缓冲区的访问。若缓冲区已满，则生产者线程必须等待缓冲区中有空位；若缓冲区为空，则消费者必须等待缓冲区中有可用项。</p>
<p>　　这里将实现包<code>SBUF</code>，用于实现生产者-消费者程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> *buf;    <span class="comment">/* 缓冲区数组 */</span></span><br><span class="line">    <span class="type">int</span> n;       <span class="comment">/* 缓冲区大小 */</span></span><br><span class="line">    <span class="type">int</span> front;   <span class="comment">/* 第1个项buf[(front+1)%n] */</span></span><br><span class="line">    <span class="type">int</span> rear;    <span class="comment">/* 最后1个项buf[rear%n] */</span></span><br><span class="line">    <span class="type">sem_t</span> mutex; <span class="comment">/* 互斥锁 */</span></span><br><span class="line">    <span class="type">sem_t</span> slots; <span class="comment">/* 缓冲区的可用空位数 */</span></span><br><span class="line">    <span class="type">sem_t</span> items; <span class="comment">/* 缓冲区的可用项数 */</span></span><br><span class="line">&#125; <span class="type">sbuf_t</span>;</span><br></pre></td></tr></table></figure>
<p>　　<code>SBUF</code>通过结构体<code>sbuf_t</code>来操作缓冲区。项存储在大小为<code>n</code>的动态分配的整数数组<code>buf</code>中。<code>front</code>和<code>rear</code>表示数组中第1个和最后1个项。3个信号量用于同步缓冲区的访问，<code>mutex</code>提供缓冲区的互斥访问，<code>slots</code>和<code>items</code>分别计算缓冲区中可用空位和可用项。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 生成带有n个空位的FIFO缓冲区</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sp 缓冲区指针</span></span><br><span class="line"><span class="comment"> * @param n 缓冲区大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    sp-&gt;buf = Calloc(n, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    sp-&gt;n = n;</span><br><span class="line">    sp-&gt;front = sp-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    Sem_init(&amp;sp-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">/* 互斥锁 */</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;slots, <span class="number">0</span>, n); <span class="comment">/* 缓冲区初始化有n个空位  */</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;items, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">/* 缓冲区初始化没有数据项 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放缓冲区</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sp 缓冲区指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Free(sp-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将项放入到缓冲区的尾部</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sp 缓冲区指针</span></span><br><span class="line"><span class="comment"> * @param item 项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span></span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;sp-&gt;slots);                          <span class="comment">/* 等待可用空位 */</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);                          <span class="comment">/* 对缓冲区上锁 */</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear) % (sp-&gt;n)] = item; <span class="comment">/* 放入项 */</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);                          <span class="comment">/* 解锁缓冲区 */</span></span><br><span class="line">    V(&amp;sp-&gt;items);                          <span class="comment">/* 更新可用项 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从缓冲区的头部取出项</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sp 缓冲区指针</span></span><br><span class="line"><span class="comment"> * @return int 取出的项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    P(&amp;sp-&gt;items);                           <span class="comment">/* 等待可用空位 */</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);                           <span class="comment">/* 对缓冲区上锁 */</span></span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front) % (sp-&gt;n)]; <span class="comment">/* 取出项 */</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);                           <span class="comment">/* 解锁缓冲区 */</span></span><br><span class="line">    V(&amp;sp-&gt;slots);                           <span class="comment">/* 更新可用空位 */</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>sbuf_init()</code>会给缓冲区分配堆空间，设置<code>front</code>和<code>rear</code>以及初始化3个信号量，该函数在调用其他3个函数前会被调用1次。函数<code>sbuf_deinit()</code>会释放缓冲区。函数<code>sbuf_insert()</code>会等待空位，对缓冲区上锁，放入项，解锁缓冲区并更新可用项数。函数<code>sbuf_remove()</code>会等待可用项，对缓冲区上锁，取出项，解锁缓冲区并更新可用空位数。</p>
<h5 id="读者-写者问题">12.5.4.2 读者-写者问题</h5>
<p>　　读者-写者问题是互斥问题的综合。一组并发线程访问同一共享变量，例如，内存中的某个数据结构和磁盘上的某个数据库。部分线程只会读对象，其他线程会修改对象，前者称为<span
style="background-color: yellow">读者</span>，后者称为<span
style="background-color: yellow">写者</span>。写者必须互斥地访问对象，读者可能会与其他任意数量的读者共享对象。读者和写者的数量通常可以是任意个。</p>
<p>　　读者-写者问题有多个变体，都基于读者和写者的优先级。</p>
<p>　　●
对于偏向于读者的读者-写者问题，读者无须等待，除非有写者已被授权使用该对象，即读者不应该因为写者在等待而等待。</p>
<p>　　●
对于偏向于写者的读者-写者问题，一旦写者准备好写，就会尽快开始。若读者在写者后到达，即使写者在等待，读者也必须等待。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 全局变量 */</span></span><br><span class="line"><span class="type">int</span> readcnt;    <span class="comment">/* 初始值为0 */</span></span><br><span class="line"><span class="type">sem_t</span> mutex, w; <span class="comment">/* 初始值都为1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt++;</span><br><span class="line">        <span class="keyword">if</span> (readcnt == <span class="number">1</span>) <span class="comment">/* 先进 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            P(&amp;w);</span><br><span class="line">        &#125;</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 关键部分 */</span></span><br><span class="line">        <span class="comment">/* 执行读操作 */</span></span><br><span class="line"></span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt--;</span><br><span class="line">        <span class="keyword">if</span> (readcnt == <span class="number">0</span>) <span class="comment">/* 后出 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            V(&amp;w);</span><br><span class="line">        &#125;</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(&amp;w);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 关键部分 */</span></span><br><span class="line">        <span class="comment">/* 执行写操作 */</span></span><br><span class="line"></span><br><span class="line">        V(&amp;w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是第1个读者-写者问题的解决方法。信号量<code>w</code>控制关键部分的访问。信号量<code>mutex</code>控制共享变量<code>cnt</code>的访问，该变量用于给当前正在访问关键部分的读者计数。写者每次访问关键部分时都会上锁并在完成访问时解锁，这保证了同时最多有1个写者访问关键部分。只有第1个读者访问关键部分时才会上锁，并且只有最后1个读者完成访问时才会解锁，中间的读者可以无视锁。这表示<span
style="background-color: yellow">只要有读者持有锁</span>，其他读者可以直接访问关键部分而无需等待。</p>
<p>　　这2个读者-写者问题的解决方法都会导致<strong>饥荒</strong>，即线程无期限地阻塞。例如，第1个读者-写者问题会可能导致大量读者到达时，写者长时间等待。</p>
<h4 id="基于预线程的并发服务器">12.5.5 基于预线程的并发服务器</h4>
<img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/organization_of_a_prethreaded_concurrent_server.svg" class="" title="organization_of_a_prethreaded_concurrent_server">
<p>　　基于<strong>预线程</strong>的服务器可以通过生产者-消费者模型来减少创建新线程的成本，该服务器有1个主线程和多个工作线程。主线程反复接收客户端的连接请求并将作为结果的描述符放入缓冲区。工作线程反复从缓冲区取出描述符，服务客户端并等待下一个描述符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbuf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NTHREADS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBUFSIZE</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo_cnt</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sbuf_t</span> sbuf; <span class="comment">/* 共享的已连接描述符缓冲区 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 基于预线程的并发echo服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    sbuf_init(&amp;sbuf, SBUFSIZE);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHREADS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>); <span class="comment">/* 创建工作线程 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        sbuf_insert(&amp;sbuf, connfd); <span class="comment">/* 将已连接描述符放入缓冲区 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> connfd = sbuf_remove(&amp;sbuf); <span class="comment">/* 从缓冲区取出已连接描述符 */</span></span><br><span class="line">        echo_cnt(connfd);                <span class="comment">/* 服务客户端 */</span></span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会使用包<code>SBUF</code>来实现基于预线程的并发echo服务器。在初始化缓冲区<code>sbuf</code>后
(第28行)，主线程会创建工作线程
(第29~32行)，开始无限循环，接收连接请求并将作为结果的已连接描述符放入缓冲区。工作线程会一直等待，直到缓冲区中有可用已连接描述符，然后从缓冲区取出已连接描述符
(第47行) 并调用函数<code>echo_cnt()</code>来回显客户端输入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> byte_cnt; <span class="comment">/* 字节计数器 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">sem_t</span> mutex;  <span class="comment">/* 字节计数器的互斥锁 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_echo_cnt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    byte_cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 计算从所有客户端接收的字节总数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param connfd 已连接描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo_cnt</span><span class="params">(<span class="type">int</span> connfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_once_t</span> once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line">    Pthread_once(&amp;once, init_echo_cnt);</span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        byte_cnt += n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %d (%d total) bytes on fd %d\n&quot;</span>, n, byte_cnt, connfd);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>echo_cnt()</code>会通过全局变量<code>byte_cnt</code>来计算从所有客户端接收的字节总数。这里需要初始化计数器<code>byte_cnt</code>和信号量<code>mutex</code>，可以通过包<code>SBUF</code>和<code>RIO</code>来初始化
(需要主线程显式调用1次初始化函数)，这里通过函数<code>pthread_once()</code>来初始化
(第22行)。这种初始化方法的优点是易用，缺点是每次调用函数<code>echo_cnt()</code>也会调用函数<code>pthread_once()</code>
(大多数对函数<code>pthread_once()</code>的调用都是无效的)。</p>
<p>　　初始化后，函数<code>pthread_once()</code>会初始化包<code>RIO</code>的缓冲区
(第23行)
并回显从客户端收到的每行文本。共享变量<code>byte_cnt</code>的访问是互斥的
(第26~29行)。</p>
<p>　　实现事件驱动并非只能通过I/O多路复用，预线程也可以用于实现事件驱动。对于这里的示例，主线程有2个状态
(等待连接请求和等待可用缓冲区空位)、2个I/O事件
(连接请求到达和缓冲区中有可用空位) 和2个转换
(接收连接请求和将描述符放入缓冲区)。工作线程有1个状态
(等待缓冲区中的可用描述符)、1个I/O事件 (缓冲区中有可用描述符) 和1个转换
(从缓冲区取出描述符)。</p>
<h3 id="使用线程来实现并行">12.6 使用线程来实现并行</h3>
<p>　　以并行地计算0到<span class="math inline">\(n-1\)</span>这<span
class="math inline">\(n\)</span>个数的和为例，最直接的方法是将这<span
class="math inline">\(n\)</span>个数分为<span
class="math inline">\(t\)</span>组，然后让<span
class="math inline">\(t\)</span>个线程分别计算这<span
class="math inline">\(t\)</span>组。此外，假设<span
class="math inline">\(n\)</span>是<span
class="math inline">\(t\)</span>的整数倍，所以每组有<span
class="math inline">\(\frac{n}{t}\)</span>个元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTHREADS 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 线程例程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param vargp</span></span><br><span class="line"><span class="comment"> * @return void*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sum_mutex</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局共享变量 */</span></span><br><span class="line"><span class="type">long</span> gsum = <span class="number">0</span>;          <span class="comment">/* 总和 */</span></span><br><span class="line"><span class="type">long</span> nelems_per_thread; <span class="comment">/* 每个线程中参与计算的元素数 */</span></span><br><span class="line"><span class="type">sem_t</span> mutex;            <span class="comment">/* 总和的互斥锁 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 通过多线程来计算多个元素序列的和</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i, nelems, log_nelems, nthreads, myid[MAXTHREADS];</span><br><span class="line">    <span class="type">pthread_t</span> tid[MAXTHREADS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;nthreads&gt; &lt;log_nelems&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nthreads = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    log_nelems = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    nelems = (<span class="number">1L</span> &lt;&lt; log_nelems);</span><br><span class="line">    nelems_per_thread = nelems / nthreads;</span><br><span class="line">    sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建对等线程并等待它们结束 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        myid[i] = i;</span><br><span class="line">        Pthread_create(&amp;tid[i], <span class="literal">NULL</span>, sum_mutex, &amp;myid[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查总和 */</span></span><br><span class="line">    <span class="keyword">if</span> (gsum != (nelems * (nelems - <span class="number">1</span>)) / <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: result=%ld\n&quot;</span>, gsum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　最直白的实现方法是让线程通过共享变量来计算总和。在第38~46行，主线程创建对等线程并等待它们终止，这里主线程给每个对等线程都传递了ID来作为其TID。每个对等线程会通过其TID来决定它应该计算序列的哪个组。最后，主线程通过封闭解来验证结果
(第49~52行)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">sum_mutex</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> myid = *((<span class="type">long</span> *)vargp);          <span class="comment">/* 提取TID */</span></span><br><span class="line">    <span class="type">long</span> start = myid * nelems_per_thread; <span class="comment">/* 开始元素索引 */</span></span><br><span class="line">    <span class="type">long</span> end = start + nelems_per_thread;  <span class="comment">/* 结束元素索引 */</span></span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt; end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        gsum += i;</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在函数<code>sum_mutex()</code>中，第3行会从参数中提取TID并通过TID来决定它应该计算序列的哪个组
(第4~5行)。第8~13行会迭代求和。</p>
<p>　　当在4核CPU上对有<span
class="math inline">\(2^{32}\)</span>个元素的序列调用函数<code>sum_mutex()</code>时，可以得到如下结果：</p>
<table>
<thead>
<tr>
<th>线程数</th>
<th>函数<code>sum_mutex()</code>运行时间 (单位是s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>68</td>
</tr>
<tr>
<td>2</td>
<td>432</td>
</tr>
<tr>
<td>4</td>
<td>719</td>
</tr>
<tr>
<td>8</td>
<td>552</td>
</tr>
<tr>
<td>16</td>
<td>599</td>
</tr>
</tbody>
</table>
<p>　　在这种情况下，程序并行运行比单线程运行的效率低很多，并且效率会随着核的数量增加继续降低，这是因为同步操作的开销很大。因此，<span
style="background-color: yellow">应尽量避免使用同步操作</span>，若无法避免，则通过尽可能多有用的计算来摊销。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">sum_array</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> myid = *((<span class="type">long</span> *)vargp);          <span class="comment">/* 提取TID */</span></span><br><span class="line">    <span class="type">long</span> start = myid * nelems_per_thread; <span class="comment">/* 开始元素索引 */</span></span><br><span class="line">    <span class="type">long</span> end = start + nelems_per_thread;  <span class="comment">/* 结束元素索引 */</span></span><br><span class="line">    <span class="type">long</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt; end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    psum[myid] = sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　避免在线程例程中使用同步操作的方法之一是让对等线程用局部变量来计算每个组的和，这里是在主线程中定义了全局数组<code>psum</code>，对等线程将对应组的和存储在数组<code>psum</code>中的索引为自身TID的元素中。最后，主线程只需计算数组<code>psum</code>中的元素的和。</p>
<p>　　当在4核CPU上对有<span
class="math inline">\(2^{32}\)</span>个元素的序列调用函数<code>sum_array()</code>时，可以得到如下结果：</p>
<table>
<thead>
<tr>
<th>线程数</th>
<th>函数<code>sum_array()</code>运行时间 (单位是s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1.06</td>
</tr>
<tr>
<td>2</td>
<td>0.54</td>
</tr>
<tr>
<td>4</td>
<td>0.28</td>
</tr>
<tr>
<td>8</td>
<td>0.29</td>
</tr>
<tr>
<td>16</td>
<td>0.30</td>
</tr>
</tbody>
</table>
<p>　　在理想情况下，运行时间应该随着线程数的增加而线性减少，即每次都减少一半。但事实并非如此，因为在<span
style="background-color: yellow">同一核上进行线程上下文需要额外的时间</span>。因此，并行程序通常实现为每个核1个线程。</p>
<p>　　并行程序的<strong>加速比</strong>定义为<span
class="math inline">\(S_p=\frac{T_1}{T_p}\)</span>，该公式也称为<strong>强缩放</strong>。<span
class="math inline">\(p\)</span>是CPU核心数，<span
class="math inline">\(T_p\)</span>是程序在<span
class="math inline">\(p\)</span>核CPU上的运行时间。当<span
class="math inline">\(T_1\)</span>是并行程序的顺序版本的运行时间时，<span
class="math inline">\(S_p\)</span>是<strong>绝对加速比</strong>。当<span
class="math inline">\(T_1\)</span>是并行程序在单核CPU上的运行时间时，<span
class="math inline">\(S_p\)</span>是<strong>相对加速比</strong>。相比相对加速比，绝对加速比能更真实地衡量并行的提升。</p>
<p>　　即使并行程序在单核CPU上运行，也需要受到同步操作的影响
(即增加相对加速比)，因为它会增加加速比公式的分子。绝对加速比相对加速比更难以衡量，因为绝对加速比需要2个版本的程序。对于复杂的并行代码，编写对应的顺序代码并非易事。</p>
<p>　　<strong>效率</strong>是加速比的相关度量之一，定义为<span
class="math inline">\(E_p=\frac{S_p}{p}=\frac{T_1}{pT_p}\)</span>，其取值范围是
(0,1]。效率用于衡量并行的影响。相比低效率的程序，高效率的程序将更多的时间用在执行有用的工作，将更少的时间用在同步和通信上。</p>
<p>　　函数<code>sum_array()</code>的加速比和效率如下：</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 28%" />
<col style="width: 36%" />
<col style="width: 13%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr>
<th>线程数<span class="math inline">\(t\)</span></th>
<th>CPU核心数<span class="math inline">\(p\)</span> (实际使用)</th>
<th>函数<code>sum_array()</code>运行所需<span
class="math inline">\(T_p\)</span></th>
<th>加速比<span class="math inline">\(S_p\)</span></th>
<th>效率<span class="math inline">\(E_p\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1.06</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0.54</td>
<td>1.9</td>
<td>0.98</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>0.28</td>
<td>3.8</td>
<td>0.95</td>
</tr>
<tr>
<td>8</td>
<td>4</td>
<td>0.29</td>
<td>3.7</td>
<td>0.91</td>
</tr>
<tr>
<td>16</td>
<td>4</td>
<td>0.30</td>
<td>3.5</td>
<td>0.88</td>
</tr>
</tbody>
</table>
<p>　　这里展示的示例的效率都很高，但实际中并非如此。数十年来，并行编程一直都是活跃的研究领域。</p>
<p>　　除了强缩放，另一种加速比的理解是<strong>弱缩放</strong>，它让问题的大小随着CPU核心数的增加而增加，即随着CPU核心数的增加，每个核心上执行的工作量保存不变。在这种情况下，加速比和效率表示为单位时间内完成的工作量。例如，若在将CPU核心数加倍后，完成的工作量也能加倍，则加速比是线性的，效率是1。</p>
<p>　　弱缩放通常比强缩放更符合实际情况，因为它能更准确地表达用更好的机器去完成更多的工作的愿景。但是，对于那些工作量不易轻易增加的程序，强缩放更合适。例如，实时信号处理程序的工作量通常由产生信号的物理传感器来决定，这类程序通常通过并行来尽快完成固定量的工作。</p>
<h3 id="其他并行问题">12.7 其他并行问题</h3>
<p>　　同步会导致一些顺序程序中根本不会出现的问题，这里主要介绍线程安全和可重入性的相关问题。</p>
<h4 id="线程安全">12.7.1 线程安全</h4>
<p>　　当且仅当函数被多个线程反复调用且都产生正确的结果时，该函数才是<span
style="background-color: yellow">线程安全</span>的。线程不安全的函数可以分为4类，即<span
style="background-color: yellow">不保护共享变量的函数</span>、<span
style="background-color: yellow">多个调用中保持状态的函数</span>、<span
style="background-color: yellow">返回静态变量指针的函数</span>、<span
style="background-color: yellow">调用线程不安全的函数的函数</span>。</p>
<p>　　●
不保护共享变量的函数很容易变为线程安全，只需要将共享变量用同步操作来保护起来。这种方法的优点是调用者无需进行任何更改，缺点是同步操作会降低性能。</p>
<p>　　●
线程不安全的伪随机数生成器就是多个调用中保持状态的函数的简单示例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> next_seed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 返回0~32767内的伪随机整数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return unsigned </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">rand</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    next_seed = next_seed * <span class="number">1103515245</span> + <span class="number">12543</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span>)(next_seed &gt;&gt; <span class="number">16</span>) % <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置函数rand的种子</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param new_seed 种子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">srand</span><span class="params">(<span class="type">unsigned</span> new_seed)</span></span><br><span class="line">&#123;</span><br><span class="line">    next_seed = new_seed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>rand()</code>是线程不安全的，因为本次调用的结果取决于上次调用产生的结果。当在单线程中调用函数<code>srand()</code>来设置种子并反复调用函数<code>rand()</code>时，得到的结果是符合预期的。但当多个线程调用函数<code>rand()</code>时，得到的结果就不再符合预期。</p>
<p>　　将函数<code>rand()</code>改为线程安全的方法是不再使用静态数据，而是调用者将状态信息作为参数传递。这种方法的缺点是必须修改代码。</p>
<p>　　●
<code>ctime</code>和<code>gethostbyname</code>等函数会将结果存储在静态变量中，然后返回指向该静态变量的指针。若在并发线程中调用这类函数会导致严重后果，因为返回的结果可能会被其他线程覆盖。</p>
<p>　　将此类函数变为线程安全的函数有2种方法。第1种方法是重写函数，调用者传递某个变量的地址，函数将结果保存在该变量中。第2种方法是使用<span
style="background-color: yellow">上锁并复制</span>技术，即每次调用前先上锁，然后将结果复制到私有内存中，最后解锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief C标准库函数ctime的线程安全的包装函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param timep</span></span><br><span class="line"><span class="comment"> * @param privatep</span></span><br><span class="line"><span class="comment"> * @return char*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime_ts</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="type">char</span> *privatep)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *sharedp;</span><br><span class="line"></span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    sharedp = ctime(timep);</span><br><span class="line">    <span class="built_in">strcpy</span>(privatep, sharedp); <span class="comment">/* 将字符串复制到私有区域 */</span></span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> privatep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于第2种方法，为了修改最少的代码，应使用对应的线程安全的包装函数，并将对原来函数的调用修改为对包装函数的调用。</p>
<p>　　●
对于调用线程不安全的函数<code>g()</code>的函数<code>f()</code>，若函数<code>g()</code>是多个调用中保持状态的函数，则只能重写函数<code>g()</code>来让函数<code>f()</code>变为线程安全的；若函数<code>g()</code>是其他类型的线程不安全的函数，则可以用上锁并复制技术来让函数<code>f()</code>变为线程安全的。</p>
<h4 id="可重入性">12.7.2 可重入性</h4>
<p>　　<strong>可重入的函数</strong>是重要的线程安全的函数之一，其特点是当它们被多个线程调用时，它们<span
style="background-color: yellow">不会引用任何共享数据</span>。</p>
<p>　　可重入的函数比非可重入的线程安全的函数更高效，因为它无需同步操作。将多个调用中保持状态的函数变为线程安全的函数的唯一方法是将其重写为可重入的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数rand的可重入的版本</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param nextp</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rand_r</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *nextp)</span></span><br><span class="line">&#123;</span><br><span class="line">    *nextp = *nextp * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)(*nextp / <span class="number">65536</span>) % <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是函数<code>rand()</code>的可重入的版本，关键思想是将共享变量<code>next_seed</code>替换为作为参数的指针。</p>
<p>　　对于可重入函数，若所有的函数参数都是值传递 (即没有指针)
且所有的数据引用都是指向局部自动栈变量，则该函数是<span
style="background-color: yellow">显式可重入</span>的；若将条件放宽到所有的函数参数可以有引用传递
(即有指针)，则该函数是<span
style="background-color: yellow">隐式可重入</span>的。例如，函数<code>rand_r()</code>就是隐式可重入的。</p>
<h4 id="竞争">12.7.3 竞争</h4>
<p>　　当程序的正确执行需要线程A的控制流在线程B的控制流到达<span
class="math inline">\(y\)</span>点前到达<span
class="math inline">\(x\)</span>点时，就会出现<span
style="background-color: yellow">竞争</span>。竞争的出现通常是程序员假设线程将在执行状态空间中按照特定的轨迹执行，而这与程序必须能适用于所有可行的轨迹相矛盾。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 竞争示例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[N];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread, &amp;i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> myid = *((<span class="type">int</span> *)vargp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread %d\n&quot;</span>, myid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，主线程会创建4个对等线程并会给对等线程传递指向唯一整数ID的指针。对等线程将参数复制到局部变量并输出包含该ID的字符串
(第27~28行)。</p>
<p>　　当主线程创建对等线程并传递指针给该对等线程时
(第16行)，竞争出现在<code>i</code>的增加 (第14行) 与参数的解引用和赋值
(第27行)。若前者先执行，则得到其他线程的ID；若后者先执行，则得到正确的ID。是否得到正确的ID完全取决于内核如何调度线程的执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 消除竞争</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[N];</span><br><span class="line">    <span class="type">int</span> i, *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = Malloc(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *ptr = i;</span><br><span class="line">        Pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> myid = *((<span class="type">int</span> *)vargp);</span><br><span class="line">    Free(vargp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread %d\n&quot;</span>, myid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　为了消除竞争，可以给每个ID动态分配空间并将对应的指针传递给线程例程
(第16~18行)，线程例程需要释放对应的空间 (第30行)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread, (<span class="type">void</span> *)i);</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="type">int</span> myid = (<span class="type">int</span>)vargp;</span><br></pre></td></tr></table></figure>
<p>　　另一种消除竞争的方法是将<code>i</code>转换成指针并作为参数传递给线程例程，然后线程例程将参数转换为<code>int</code>。这种方法无需分配和释放空间，但需要指针的长度至少和<code>int</code>的长度相同。</p>
<h4 id="死锁">12.7.4 死锁</h4>
<p>　　信号量引入了称为<strong>死锁</strong>的运行时错误，即一组线程阻塞，等待永远不会为真的条件。</p>
<img src="/2023/11/03/computer-systems-a-programmer's-perspective-3e-chpt-12/progress_graph_for_a_program_that_can_deadlock.svg" class="" title="progress_graph_for_a_program_that_can_deadlock">
<p>　　在这个示例中，2个线程使用2个信号量来进行互斥。若按照错误的顺序使用<code>P</code>和<code>V</code>操作，则2个信号量的禁止区域会有重叠。重叠的禁止区域包括一组<strong>死锁状态</strong>
(即<strong>死锁区域</strong>)。若某些轨迹碰巧到达死锁状态，则这2个线程都会等待对方执行<code>V</code>操作。</p>
<p>　　可以通过<span
style="background-color: yellow">互斥锁排序原则</span>来避免死锁，即规定所有互斥锁的总顺序，线程按序申请互斥锁，并按反序释放互斥锁。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第2章 信息的表示与处理</title>
    <url>/2022/10/05/computer-systems-a-programmer&#39;s-perspective-3e-chpt-2/</url>
    <content><![CDATA[<p>　　使用了1000多年的十进制源自印度，12世纪被阿拉伯数学家改进并在13世纪被意大利数学家Leonardo
Pisano (即Fibonacci)
带到西方。对于10个手指头的人类而言，十进制很自然。但是，现代计算机存储和处理的信息都是用二进制
(称为<strong>位</strong>)
表示，因为二进制更容易被表示、存储和传输，例如，高电压和低电压。</p>
<p>　　单个位并不是很有用，当把位组合在一起并附加上<strong>解释</strong>来给不同的位模式赋予意义时，可以表示任何有限集合中的元素。</p>
<p>　　<strong>无符号</strong>编码基于传统的二进制表示法，表示大于等于0的数字。<strong>补码</strong>编码是表示有符号整数
(有正负)
的最常见的方式。<strong>浮点</strong>编码是以2为基数的科学计数法版本，用于表示实数。</p>
<p>　　计算机的表示法使用有限数量的位来编码，所以当结果太大时以至于不能表示时，某些运算可能<strong>溢出</strong>。溢出可能会导致奇怪的结果，例如，对于<code>int</code>是32位的计算机，C语言有<span
class="math inline">\(200\times300\times400\times500=-884901888\)</span>。</p>
<p>　　计算机的整数运算满足数学中整数运算的许多属性，例如，乘法的结合律和交换律。计算机的浮点运算具有完全不同的数学属性。正数之间的乘积始终为正，尽管溢出时会产生特殊值<span
class="math inline">\(+\infty\)</span>。由于表示的精度有限，浮点运算不是不可结合的，例如，大多数计算机上，C语言有<span
class="math inline">\((3.14+10^{20})-10^{20}=0.0\)</span>。整数与浮点算术的不同数学属性源于其CPU表示的有限性的方式不同，整数是精确的，但表示的值范围较小；浮点是近似的，但表示的值范围较大。</p>
<p>　　在20世纪80年代前，计算机制造商都会设计自己的浮点数表示规则以及相关运算细节，它们都更注重实现的速度和简便而非精确。在1985年，这些随着IEEE
754的出现而发生了变化，IEEE
754是精心设计的标准，用于表示浮点数以及其执行的操作。这些工作始于1976年，开始由Intel赞助，与8087
(为8086 CPU提供浮点支持的芯片)
的设计同时进行。Intel聘请加州大学伯克利分校的教授William
Kahan作为顾问，帮助其为未来的CPU设计浮点标准。Intel允许Kahan与委员会合作，在IEEE的主持下制定行业标准。委员会最终采用的标准很接近Kahan为Intel设计的标准。</p>
<p>　　ASCII字符集适合对英语文档进行编码，但不支持特殊字符
(希腊语、俄语和中文等)。多年来，出现了很多对不同语言进行编码的方法。Unicode联盟设计了最全面和最广泛的文本编码标准，7.0版本的Unicode标准的拥有超过100000个字符，支持多种语言，包括古埃及语和巴比伦语。Unicode技术委员会否决了为克林贡语编写语言标准的提议。</p>
<p>　　基本编码称为Unicode的通用字符集使用32位表示字符，这似乎要求文本中的每个字符占用4B，另一种编码方案是常见字符仅需1B或2B，而不太常见的字符需要更多字节。例如，UTF-8的表示形式将每个字符编码为字节序列，所有ASCII字节序列用ASCII表示和UTF-8表示相同。Java使用Unicode表示字符串，C语言也有支持Unicode的库。</p>
<p>　　由于二进制是计算机编码、存储和操作信息的核心，所以围绕0和1的研究已演化出了丰富的数学知识体系，这源自1850年左右的George
Boole (1815-1864)
的工作，所以称为<strong>布尔代数</strong>。Boole观察到，将逻辑值TRUE和FALSE编码为二进制值0和1，可以制定1种包含逻辑推理基本原理的代数。</p>
<p>　　ISO
C99在头文件<code>stdint.h</code>中加入了固定长度的整数类型，其声明类似<code>intN_t</code>和<code>uintN_t</code>，其中<code>N</code>表示<span
class="math inline">\(N\)</span>位的有符号和无符号整数，<code>N</code>的具体值与实现有关，但大多数编译器允许的值为8、16、32和64。这些整数类型有一组对应的宏，即<code>INTN_MIN</code>、<code>INTN_MAX</code>和<code>UINTN_MAX</code>。</p>
<span id="more"></span>
<h3 id="信息存储">2.1 信息存储</h3>
<p>　　大多数计算机将<span
style="background-color: yellow">字节</span>作为最小的可寻址内存单元。应用程序将内存视为很大的字节数组，称为<strong>虚拟内存</strong>。内存的每个字节都由唯一的数字标识，称为<strong>地址</strong>，所有可能的地址集称为<strong>虚拟地址空间</strong>。</p>
<p>　　相比二进制和十进制，<span
style="background-color: yellow">十六进制</span>更适合描述位模式，因为它比较精简且无需转换。</p>
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0001</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0010</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>0011</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>0100</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>0101</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>0110</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>0111</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td>1000</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>1001</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td>1010</td>
<td>10</td>
<td>A</td>
</tr>
<tr>
<td>1011</td>
<td>11</td>
<td>B</td>
</tr>
<tr>
<td>1100</td>
<td>12</td>
<td>C</td>
</tr>
<tr>
<td>1101</td>
<td>13</td>
<td>D</td>
</tr>
<tr>
<td>1110</td>
<td>14</td>
<td>E</td>
</tr>
<tr>
<td>1111</td>
<td>15</td>
<td>F</td>
</tr>
</tbody>
</table>
<p>　　在C语言中，十六进制以<code>0x</code>和<code>0X</code>开头，字符<code>A</code>~<code>F</code>大小写不限。</p>
<h4 id="数据长度">2.1.1 数据长度</h4>
<p>　　每个计算机都有<strong>字长</strong>，表示指针的标称大小。虚拟地址以这样的字来编码，所以字长决定虚拟地址空间的范围。对于字长为<span
class="math inline">\(w\)</span>位的计算机，虚拟地址的范围是<span
class="math inline">\(0\sim2^w-1\)</span>。32位虚拟地址空间为4GB，64位虚拟地址空间为16EB。</p>
<p>　　32位程序和64位程序的区别是编译过程。大多数64位计算机可以兼容32位程序。</p>
<p>　　计算机和编译器支持多种不同方法编码的数据格式，例如，不同长度的整数和浮点数。C语言中某些数据类型字节数取决于程序的编译方式。整数可以是<strong>有符号</strong>
(有正负) 或<strong>无符号</strong>
(非负)，关键字分别是<code>signed</code>和<code>unsigned</code>。大多数计算机支持单精度和双精度浮点数，长度分别是4B和8B。</p>
<table>
<thead>
<tr>
<th>有符号 (C语言)</th>
<th>无符号 (C语言)</th>
<th>字节数 (32位)</th>
<th>字节数 (64位)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[signed] char</code></td>
<td><code>unsigned char</code></td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>unsigned short</code></td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>unsigned</code></td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>unsigned long</code></td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td><code>int32_t</code></td>
<td><code>uint32_t</code></td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td><code>int64_t</code></td>
<td><code>uint64_t</code></td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td><code>T *</code></td>
<td></td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td><code>float</code></td>
<td></td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td><code>double</code></td>
<td></td>
<td>8</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>　　大多数数据类型都会编码为有符号，除非使用关键字<code>unsigned</code>或固定大小数据类型的特定无符号声明。但是，<code>char</code>是例外，大多数计算机和编译器都将<code>char</code>编码为有符号，但C语言标准不保证这一点。当使用<code>char</code>存储长度是1B的数据时，应使用关键字<code>signed</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> l1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> l2;</span><br><span class="line"><span class="type">long</span> <span class="type">unsigned</span> l3;</span><br><span class="line"><span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span> l4;</span><br></pre></td></tr></table></figure>
<p>　　C语言允许多种方式来对关键字进行排序以及省略可选关键字，这里<code>l1</code>、<code>l2</code>、<code>l3</code>和<code>l4</code>意义相同。</p>
<p>　　对不同数据类型的确切大小不敏感是程序的可移植性的方面之一。C语言标准对不同数据类型的范围设置了下限但没有设置上限。当32位程序迁移到64位程序时，很多隐藏的字长依赖项会作为错误出现，例如，32位程序中<code>int</code>类型的对象可用于存储指针，但这并不适用于64位程序。</p>
<h4 id="寻址和字节顺序">2.1.2 寻址和字节顺序</h4>
<p>　　对于包含多个字节的程序对象，必须确定对象的地址以及字节在内存中的顺序。在几乎所有计算机中，多字节对象都存储为连续的字节序列，对象的地址是所使用字节中的最小地址。若<code>int</code>类型
(32位)
的变量<code>x</code>的地址为<code>0x100</code>，即地址表达式<code>&amp;x</code>的值是<code>0x100</code>，则<code>x</code>的4个字节存储在内存位置<code>0x100</code>、<code>0x101</code>、<code>0x102</code>和<code>0x103</code>。</p>
<img src="/2022/10/05/computer-systems-a-programmer's-perspective-3e-chpt-2/big_endian_and_little_endian.svg" class="" title="big_endian_and_little_endian">
<p>　　以<code>w</code>位的整数为例，其位表示为<span
class="math inline">\([x_{w-1},x_{w-2},\cdots,x_1,x_0]\)</span>，其中<span
class="math inline">\(x_{w-1}\)</span>是最高有效位，<span
class="math inline">\(x_0\)</span>是最低有效位。若<span
class="math inline">\(w\)</span>是8的倍数，则这些位可以分组为字节，其中最高有效字节包含位<span
class="math inline">\([x_{w-1},x_{w-2},\cdots
,x_{w-8}]\)</span>，而最低有效字节包含位<span
class="math inline">\([x_7,x_6,\cdots
,x_0]\)</span>，其他字节包含中间的位。某些计算机按从低 (有效) 字节到高
(有效) 字节的顺序存储对象，其他计算机从高 (有效) 字节到低 (有效)
字节的顺序存储对象。前者称为<strong>小端</strong>，后者称为<strong>大端</strong>。大多数与Intel兼容的计算机仅支持小端模式，IBM和Oracle的大多数计算机仅支持大端模式。部分CPU是<strong>双端</strong>，即支持这2种模式。实际中，一旦选择了操作系统，字节顺序就会固定，例如，许多手机使用的ARM
CPU是双端，但Android和IOS仅支持小端模式。</p>
<p>　　对于大多数应用程序程序员，计算机使用的字节顺序是完全不可见的。无论为哪种类型的计算机所编译的程序，都会得到相同的结果，但有时字节顺序会成为问题。</p>
<p>　　●
当二进制数据通过网络在不同计算机之间通信时，若计算机的字节顺序不同，接收端和发送端的字节相反。为了避免此类问题，TCP/IP定义了<strong>网络字节顺序</strong>，即通过网络传输的数据必须是大端。</p>
<p>　　● 阅读表示整数数据的字节序列时字节顺序很重要。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4004d3:	01 05 43 0b 20 00	add	%eax,0x200b43(%rip)</span><br></pre></td></tr></table></figure>
<p>　　这是Intel x86-64
CPU的机器级代码的文本表示，由反汇编器生成，<strong>反汇编器</strong>是确定可执行文件对应的指令序列的工具。十六进制字节序列<code>01 05 43 0b 20 00</code>是一条指令的字节级表示形式，该指令会将单字长的数据加到某个值上，该值的存储地址由<code>0x200b43</code>加上当前PC的值
(待执行的下一指令的地址)
得到。若将序列的最后4个字节<code>43 0b 20 00</code>转换为小端，则得到<code>00 20 0b 43</code>，去掉开头作为填充的0，得到值<code>0x200b43</code>。</p>
<p>　　●
在编写绕过数据类型系统的程序时字节排序很重要。C语言中，可以通过使用<strong>强制类型转换</strong>和<strong>联合</strong>来允许一种数据类型引用一个对象，但该数据类型与创建该对象时定义的数据类型不同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印对象的字节表示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param start 对象指针</span></span><br><span class="line"><span class="comment"> * @param len 对象长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_bytes</span><span class="params">(byte_pointer start, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %.2x&quot;</span>, start[i]); <span class="comment">/* 至少用2个数字的十六进制格式输出 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印int的字节表示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_int</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印float的字节表示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_float</span><span class="params">(<span class="type">float</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印指针的字节表示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_pointer</span><span class="params">(<span class="type">void</span> *x)</span></span><br><span class="line">&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 测试函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param val</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_show_bytes</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ival = val;</span><br><span class="line">    <span class="type">float</span> fval = (<span class="type">float</span>)ival;</span><br><span class="line">    <span class="type">int</span> *pval = &amp;ival;</span><br><span class="line">    show_int(ival);</span><br><span class="line">    show_float(fval);</span><br><span class="line">    show_pointer(pval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　若参数为<code>12345</code>，对应的十六进制是<code>0x00003039</code>，Linux和Windows都是小端，Windows
64的输出是<code>39 30 00 00</code>、<code>00 e4 40 46</code>以及<code>4c fb 9f e4 9f 00 00 00</code>。<code>int</code>和<code>float</code>的字节模式看似不同，将其转换为二进制后会发现会有13个匹配的位序列。指针值根据不同的计算机或操作系统配置的存储分配规则分配。</p>
<p>　　C语言中的字符串以<code>null</code>字符 (值为0)
结尾的字符数组编码。以ASCII为例，若以参数<code>"12345"</code>和<code>6</code>来运行函数<code>show_bytes()</code>，则可以得到结果<code>31 32 33 34 35 00</code>。十进制数字<code>n</code>的ASCII码值是<code>0x0n</code>，<code>null</code>的ASCII码值为<code>0x00</code>。ASCII在任何系统上都可以获得相同的结果，与字节顺序和字长无关。因此，文本数据比二进制数据更具有平台独立性。</p>
<h4 id="布尔代数简介">2.1.3 布尔代数简介</h4>
<img src="/2022/10/05/computer-systems-a-programmer's-perspective-3e-chpt-2/operations_of_boolean_algebra.svg" class="" title="operations_of_boolean_algebra">
<p>　　最简单的布尔代数是在双元集合<span
class="math inline">\(\{0,1\}\)</span>上定义。布尔运算~表示逻辑运算非，用<span
class="math inline">\(\lnot\)</span>表示。布尔运算&amp;表示逻辑运算与，用<span
class="math inline">\(\land\)</span>表示。布尔运算|表示逻辑运算或，用<span
class="math inline">\(\lor\)</span>表示。布尔运算^表示逻辑运算异或，用<span
class="math inline">\(\oplus\)</span>表示。</p>
<p>　　布尔运算也适用于<strong>位向量</strong> (长度为<span
class="math inline">\(w\)</span>，由0和1组成的序列)。若<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>分别表示位向量<span
class="math inline">\([a_{w-1},a_{w-2},\cdots ,a_0]\)</span>和<span
class="math inline">\([b_{w-1},b_{w-2},\cdots ,b_0]\)</span>，则<span
class="math inline">\(a\)</span>&amp;<span
class="math inline">\(b\)</span>可以定义为长度为<span
class="math inline">\(w\)</span>的位向量，其中第<span
class="math inline">\(i\)</span>个元素等于<span
class="math inline">\(a_i\)</span>&amp;<span
class="math inline">\(b_i\)</span>，类似的方法可以扩展到|、~和^上。</p>
<p>　　对于长度为<span
class="math inline">\(2^w\)</span>的位向量，布尔代数和整数算术有很多相似之处。类似乘法对加法的分配律，&amp;和|相互都有分配律，即<span
class="math inline">\(a\)</span>&amp;<span
class="math inline">\((b\)</span>|<span
class="math inline">\(c)=(a\)</span>&amp;<span
class="math inline">\(b)|(a\)</span>&amp;<span
class="math inline">\(c)\)</span>和<span
class="math inline">\(a\)</span>|<span
class="math inline">\((b\)</span>&amp;<span
class="math inline">\(c)=(a\)</span>|<span
class="math inline">\(b)\)</span>&amp;<span
class="math inline">\((a\)</span>|<span
class="math inline">\(c)\)</span>。</p>
<p>　　对位向量进行布尔运算会得到<strong>布尔环</strong>。布尔环由<strong>幂等元</strong>组成
(所有元素都满足<span
class="math inline">\(x^2=x\)</span>)，布尔环与整数算术有很多相似之处，例如，整数算术的属性之一是是每个值<span
class="math inline">\(n\)</span>都有1个<strong>加法逆元</strong><span
class="math inline">\(-n\)</span>，使得<span
class="math inline">\(n+-n=0\)</span>。</p>
<p>　　位向量可用于表示有限集合，即用位向量<span
class="math inline">\([a_{w-1},a_{w-2},\cdots
,a_0]\)</span>对任何子集<span
class="math inline">\(A\subseteq\{0,1,\cdots
,w-1\}\)</span>编码，当<span class="math inline">\(i\in
A\)</span>时，<span class="math inline">\(a_i=1\)</span>。若<span
class="math inline">\(a_{w-1}\)</span>在左边，<span
class="math inline">\(a_0\)</span>在右边，则位向量<span
class="math inline">\(a=[01101001]\)</span>表示集合<span
class="math inline">\(A=\{0,3,5,6\}\)</span>，而<span
class="math inline">\(b=[01010101]\)</span>表示集合<span
class="math inline">\(B=\{0,2,4,6\}\)</span>。使用这种编码集合的方式时，布尔运算|、&amp;和~分别表示交集、并集和补集。若<span
class="math inline">\(a\)</span>&amp;<span
class="math inline">\(b\)</span>得到位向量<span
class="math inline">\([0100001]\)</span>，则<span
class="math inline">\(A\cap B=\{0,6\}\)</span>。</p>
<h4 id="c语言相关支持">2.1.4 C语言相关支持</h4>
<p>　　C语言支持布尔运算，其符号也是<code>~</code>、<code>&amp;</code>、<code>|</code>和<code>^</code>，能用于所有整型数。</p>
<p>　　位级运算可用于<strong>掩码</strong>运算，掩码属于位模式，表示字中部分位的位模式，例如，掩码<code>0xFF</code>表示字中的低位字节。<code>n &amp; 0xFF</code>会得到低位字节是<code>n</code>的低位字节，其他值全为0的结果。<code>~0</code>会得到值全为1的掩码。</p>
<p>　　C语言也提供了逻辑运算符<code>||</code>、<code>&amp;&amp;</code>和<code>!</code>，分别对应逻辑或、与和非运算。</p>
<p>　　C语言还支持<strong>移位</strong>运算，用于向左和向右移动位模式。对于位模式为<span
class="math inline">\([x_{w-1},x_{w-2},\cdots
,x_0]\)</span>的操作数<code>x</code>，<code>x &lt;&lt; k</code>的结果的位模式是<span
class="math inline">\([x_{w-k-1},x_{w-k-w},\cdots ,x_0,0,\cdots
,0]\)</span>，即<code>x</code>向左移动<span
class="math inline">\(k\)</span>位，丢弃最高<span
class="math inline">\(k\)</span>位并在右端补<span
class="math inline">\(k\)</span>个0。显然，偏移量应该介于0和<span
class="math inline">\(w-1\)</span>之间。移位操作从左到右执行，故<code>x &lt;&lt; j &lt;&lt; k</code>等效于<code>(x &lt;&lt; j) &lt;&lt; k</code>。</p>
<p>　　计算机通常支持<strong>逻辑右移</strong>和<strong>算术右移</strong>。对于<code>x &gt;&gt; k</code>，逻辑右移类似于右移，会直接在左端补<span
class="math inline">\(k\)</span>个0。算术右移会在左端补<span
class="math inline">\(k\)</span>个最高有效位的值，即<span
class="math inline">\([x_{w-1},\cdots ,x_{w-1},x_{w-1},x_{w-2},\cdots
x_k]\)</span>，主要用于有符号数。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>值1</th>
<th>值2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x</code></td>
<td>[01100011]</td>
<td>[10010101]</td>
</tr>
<tr>
<td><code>x &lt;&lt; 4</code></td>
<td>[0011<strong>0000</strong>]</td>
<td>[0101<strong>0000</strong>]</td>
</tr>
<tr>
<td><code>x &gt;&gt; 4</code> (逻辑右移)</td>
<td>[<strong>0000</strong>0011]</td>
<td>[<strong>0000</strong>1001]</td>
</tr>
<tr>
<td><code>x &gt;&gt; 4</code> (算术右移)</td>
<td>[<strong>0000</strong>0011]</td>
<td>[<strong>1111</strong>1001]</td>
</tr>
</tbody>
</table>
<p>　　C语言标准并未定义有符号数应使用的右移类型。实际中，几乎所有编译器和计算机会对有符号数使用算术右移，对无符号数使用逻辑右移。对于<span
class="math inline">\(w\)</span>位的数据类型，移动<span
class="math inline">\(k(k\geqslant w)\)</span>位，实际位移量为<span
class="math inline">\(k\bmod w\)</span>。</p>
<h3 id="整数表示">2.2 整数表示</h3>
<p>　　数学术语<strong>双射</strong>指函数<span
class="math inline">\(f\)</span>有2种映射方式，可以将数字<span
class="math inline">\(x\)</span>映射为数值<span
class="math inline">\(y\)</span>，即<span
class="math inline">\(y=f(x)\)</span>，也可以反向操作，因为对于每个<span
class="math inline">\(y\)</span>都有唯一的<span
class="math inline">\(x\)</span>满足<span
class="math inline">\(f(x)=y\)</span>，这通过<strong>反函数</strong><span
class="math inline">\(f^{-1}\)</span>来表示，即<span
class="math inline">\(x=f^{-1}(y)\)</span>。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(B2T_w\)</span></td>
<td>函数</td>
<td>二进制转补码</td>
</tr>
<tr>
<td><span class="math inline">\(B2U_w\)</span></td>
<td>函数</td>
<td>二进制转无符号数</td>
</tr>
<tr>
<td><span class="math inline">\(U2B_w\)</span></td>
<td>函数</td>
<td>无符号数转二进制</td>
</tr>
<tr>
<td><span class="math inline">\(U2T_w\)</span></td>
<td>函数</td>
<td>无符号数转补码</td>
</tr>
<tr>
<td><span class="math inline">\(T2B_w\)</span></td>
<td>函数</td>
<td>补码转二进制</td>
</tr>
<tr>
<td><span class="math inline">\(T2U_w\)</span></td>
<td>函数</td>
<td>补码转无符号数</td>
</tr>
<tr>
<td><span class="math inline">\(TMin_w\)</span></td>
<td>常数</td>
<td>最小补码值</td>
</tr>
<tr>
<td><span class="math inline">\(TMax_w\)</span></td>
<td>常数</td>
<td>最大补码值</td>
</tr>
<tr>
<td><span class="math inline">\(UMax_w\)</span></td>
<td>常数</td>
<td>最大无符号数</td>
</tr>
<tr>
<td><span class="math inline">\(+^t_w\)</span></td>
<td>操作符</td>
<td>补码加法</td>
</tr>
<tr>
<td><span class="math inline">\(+^u_w\)</span></td>
<td>操作符</td>
<td>无符号数加法</td>
</tr>
<tr>
<td><span class="math inline">\(*^t_w\)</span></td>
<td>操作符</td>
<td>补码乘法</td>
</tr>
<tr>
<td><span class="math inline">\(*^u_w\)</span></td>
<td>操作符</td>
<td>无符号数乘法</td>
</tr>
<tr>
<td><span class="math inline">\(-^t_w\)</span></td>
<td>操作符</td>
<td>补码取反</td>
</tr>
<tr>
<td><span class="math inline">\(-^u_w\)</span></td>
<td>操作符</td>
<td>无符号数取反</td>
</tr>
</tbody>
</table>
<p>　　有符号数和无符号数之间转换可能导致错误或漏洞，解决方法之一是尽量不使用无符号数。但是，无符号数并非一无是处，在表示布尔类型时很有用，ISO
C99在<code>&lt;stdbool.h&gt;</code>中加入的<code>bool</code>本质是<code>unsigned char</code>。</p>
<h4 id="整型数据类型">2.2.1 整型数据类型</h4>
<p>　　C语言支持多种整型数据类型，每种数据类型用<code>char</code>、<code>short</code>和<code>long</code>等关键字来指定大小，<span
style="background-color: yellow">默认</span>有符号数。</p>
<table>
<thead>
<tr>
<th style="text-align: left;">C语言整型数据类型</th>
<th style="text-align: left;">32位程序的取值范围</th>
<th style="text-align: left;">64位程序的取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>[signed] char</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^7\sim2^7-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(-2^7\sim2^7-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>unsigned char</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^8-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^8-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>short</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{15}\sim2^{15}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{15}\sim2^{15}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>unsigned short</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{16}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{16}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>unsigned</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{32}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{32}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>long</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{63}\sim2^{63}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>unsigned long</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{32}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{64}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>int32_t</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{32}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{32}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>int64_t</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{63}\sim2^{63}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{63}\sim2^{63}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>uint64_t</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{64}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{64}-1\)</span></td>
</tr>
</tbody>
</table>
<p>　　C语言标准定义了每种整型数据类型的最小取值范围，其中有符号正数和负数的取值范围是对称的。对于有符号整型数，负数的取值范围比正数的大1。<code>int</code>的长度可以是2B，<code>long</code>的长度可以是4B。</p>
<table>
<thead>
<tr>
<th style="text-align: left;">C语言整型数据类型</th>
<th style="text-align: left;">C语言标准定义的最小取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>[signed] char</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^7+1\sim2^7-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>unsigned char</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^8-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>short</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{15}+1\sim2^{15}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>unsigned short</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{16}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{15}+1\sim2^{15}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>unsigned</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{16}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>long</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{31}+1\sim2^{31}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>unsigned long</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{32}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>int32_t</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{31}+1\sim2^{31}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t</code></td>
<td style="text-align: left;"><span class="math inline">\(0\sim
2^{32}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>int64_t</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{63}+1\sim2^{63}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>uint64_t</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{64}-1\)</span></td>
</tr>
</tbody>
</table>
<p>　　C语言处理包含有符号数和无符号数组合的表达式时会将有符号数隐式转换为无符号数，例如，比较式<code>-1 &lt; 0U</code>，若两者都是32位，则<code>-1</code>将转换为<code>4294967295U</code>并返回<code>false</code>。</p>
<p>　　C语言中将位模式较短的有符号数转换为位模度较长的无符号数时，需要先进行符号扩展，再完成有符号到无符号的转换。</p>
<h4 id="编码">2.2.2 编码</h4>
<p>　　对于<span class="math inline">\(w\)</span>位的整数<span
class="math inline">\(x\)</span>，其位向量表示为<span
class="math inline">\(\vec{x}\)</span>。</p>
<p>　　将<span
class="math inline">\(\vec{x}\)</span>视为二进制表示的数就可以得到<span
class="math inline">\(\vec{x}\)</span>的无符号表示。在此编码中，每个位<span
class="math inline">\(x_i\)</span>的值都为0或1，值为1表示<span
class="math inline">\(2^i\)</span>应为数字值的一部分。 <span
class="math display">\[
B2U_w(\vec{x})=\sum_{i=0}^{w-1}x_i2^i
\]</span> 　　对于无符号数，<span
class="math inline">\(\vec{x}\)</span>的最小值是位向量<span
class="math inline">\([00\cdots 0]\)</span>，最大值是位向量<span
class="math inline">\([11\cdots 1]\)</span>，其整数值<span
class="math inline">\(UMax_w=2^w-1\)</span>，所以函数<span
class="math inline">\(B2U_w\)</span>能定义为映射<span
class="math inline">\(B2U_w:\{0,1\}^w\rightarrow\{0,\cdots
,UMax_w\}\)</span>。<span
class="math inline">\(B2U_w\)</span>是双射，它能将每个长度为<span
class="math inline">\(w\)</span>的位向量都映射到<span
class="math inline">\(0\sim2^w-1\)</span>之间的1个唯一值，也能将<span
class="math inline">\(0\sim2^w-1\)</span>之间的每个整数都可以映射到1个唯一的长度为<span
class="math inline">\(w\)</span>的位模式 (即<span
class="math inline">\(U2B_w\)</span>)。</p>
<p>　　在补码中，最高有效位解释为<strong>负权</strong>，也称为<strong>符号位</strong>，其权重为<span
class="math inline">\(-2^{w-1}\)</span>。 <span class="math display">\[
B2T_w(\vec{x})=-x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i
\]</span> 　　对于补码，<span
class="math inline">\(\vec{x}\)</span>的最小值是位向量<span
class="math inline">\([10\cdots 0]\)</span>，其整数值<span
class="math inline">\(TMin_w=-2^{w-1}\)</span>，最大值是位向量<span
class="math inline">\([01\cdots 1]\)</span>，其整数值<span
class="math inline">\(TMax=2^{w-1}-1\)</span>，所以函数<span
class="math inline">\(B2T_w\)</span>能定义为映射<span
class="math inline">\(B2T_w:\{0,1\}^w\rightarrow\{TMin_w,\cdots
,TMax_w\}\)</span>。<span
class="math inline">\(B2T_w\)</span>同样也是双射。</p>
<p>　　C语言标准并未要求有符号数以补码形式表示，但几乎所有计算机都是如此，但考虑到可移植性等因素，有符号数都默认补码。C语言库文件<code>&lt;limits.h&gt;</code>定义了一组常量来限定编译器运行的计算机的不同整数数据类型的取值范围，常量<code>INT_MAX</code>、<code>INT_MIN</code>和<code>UINT_MAX</code>来定义有
(有符号和无符号) <code>int</code>的取值范围。</p>
<p>　　有符号数的也能表示为<strong>反码</strong>，除了其最高有效位的权重是<span
class="math inline">\(1-2^{w-1}\)</span>，其他与补码相同。 <span
class="math display">\[
B2O_w(\vec{x})=-x_{w-1}(1-2^{w-1})+\sum_{i=0}^{w-2}x_i2^i
\]</span>
　　有符号数的还能表示为<strong>原码</strong>，其最高有效位是符号位，用于确定其他位是负权或正权。
<span class="math display">\[
B2S_w(\vec{x})=(-1)^{x_{w-1}} \cdot(\sum_{i=0}^{w-2}x_i2^i)
\]</span>
　　原码和反码都有一个奇怪的特性，即数字0有两种不同的编码，两者都将<span
class="math inline">\([00\cdots 0]\)</span>解释为+0，前者将<span
class="math inline">\([10\cdots 0]\)</span>解释为-0，后者将<span
class="math inline">\([11\cdots 1]\)</span>解释为-0。</p>
<p>　　补码 (two's complement) 源于情况：对于非负<span
class="math inline">\(x\)</span>，用<span
class="math inline">\(2^w-x\)</span>计算<span
class="math inline">\(-x\)</span>的<span
class="math inline">\(w\)</span>位表示 (单个2)。反码 (ones' complement)
源于属性：用<span class="math inline">\([111\cdots
1]-x\)</span>计算<span class="math inline">\(-x\)</span>的反码表示
(多个1)。</p>
<h4 id="有符号数和无符号数的转换">2.2.3 有符号数和无符号数的转换</h4>
<p>　　C语言允许在不同的表示数字的数据类型之间转换，例如，从有符号数转换到无符号数，这种转换通常基于位而非数字。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> v = <span class="number">-12345</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> uv = (<span class="type">unsigned</span> <span class="type">short</span>)v;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;v = %d, uv = %u\n&quot;</span>, v, uv); <span class="comment">/* v = -12345, uv = 53191 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">-1</span>;</span><br><span class="line"><span class="type">unsigned</span> ui = (<span class="type">unsigned</span>)i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d, ui = %u\n&quot;</span>, i, ui); <span class="comment">/* i = -1, ui = 4294967295 */</span></span><br></pre></td></tr></table></figure>
<p>　　-12345的16位补码与53191的16位无符号表示相同，-1的32位补码也与4294967295的32位无符号表示相同。这是大多数C语言中相同字长的有符号数和无符号数之间转换的规则，即数值可能改变，但位模式不会变。给定一个整数<span
class="math inline">\(x\)</span>，当<span
class="math inline">\(x\)</span>满足<span
class="math inline">\(0\leqslant x\leqslant UMax_w\)</span>时，函数<span
class="math inline">\(U2B_w(x)\)</span>会得到<span
class="math inline">\(x\)</span>的唯一<span
class="math inline">\(w\)</span>位无符号表示形式。同样，当<span
class="math inline">\(x\)</span>满足<span
class="math inline">\(TMin_w\leqslant x\leqslant
TMax_w\)</span>时，函数<span
class="math inline">\(T2B_w(x)\)</span>会得到<span
class="math inline">\(x\)</span>的唯一<span
class="math inline">\(w\)</span>位补码表示形式。 <span
class="math display">\[
\begin{aligned}
T2U_w(x)&amp;= B2U_w(T2B_w(x))\\[3px]
U2T_w(x)&amp;= B2T_w(U2B_w(x))
\end{aligned}
\]</span>
　　<code>0xCFC7</code>的16位位模式既是-12345的补码表示，也是53191的无符号表示，而<span
class="math inline">\(12345+53191=2^{16}\)</span>，该属性也适用于给定位模式表示的两个数值
(补码和无符号数) 之间的关系，无符号表示中<span
class="math inline">\(UMax\)</span>和-1的补码具有相同的位模式，所以<span
class="math inline">\(1+UMax_w=2^w\)</span>。</p>
<p>　　对于位模式<span
class="math inline">\(\vec{x}\)</span>，若计算<span
class="math inline">\(B2U(\vec{x})-B2T(\vec{x})\)</span>，则0到<span
class="math inline">\(w-2\)</span>位的加权和将相互抵消，得到<span
class="math inline">\(x_{w-1}2^w\)</span>。 <span
class="math display">\[
B2U_w(T2B_w(x))=T2U_w(x)=x+x_{w-1}2^w
\]</span> 　　在<span
class="math inline">\(x\)</span>的补码表示中，位<span
class="math inline">\(x_{w-1}\)</span>决定了<span
class="math inline">\(x\)</span>的正负。 <span class="math display">\[
T2U_w(x)=
\begin{cases}
x+2^w&amp;&amp;{TMin_x\leqslant x&lt;0}\\
x&amp;&amp;{0\leqslant x\leqslant TMax_w}
\end{cases}
\]</span> 　　设<span
class="math inline">\(\vec{u}=U2B_w(u)\)</span>，即<span
class="math inline">\(U2T_w(u)\)</span>的补码表示。 <span
class="math display">\[
U2T_w(u)=-u_{w-1}2^w+u
\]</span> 　　在<span
class="math inline">\(u\)</span>的无符号表示中，位<span
class="math inline">\(u_{w-1}\)</span>决定了<span
class="math inline">\(u\)</span>是否大于<span
class="math inline">\(TMax_w=2^{w-1}-1\)</span>。 <span
class="math display">\[
U2T_w(u)=
\begin{cases}
u&amp;&amp;{0\leqslant u\leqslant TMax_w}\\
u-2^w&amp;&amp;{TMax_w&lt;u\leqslant UMax_w}
\end{cases}
\]</span> 　　当整数<span class="math inline">\(x\)</span>满足<span
class="math inline">\(0\leqslant x\leqslant TMax_w\)</span>时，<span
class="math inline">\(T2U_w(x)=U2T_w(x)=x\)</span>，在此范围外转换需要增加或减去<span
class="math inline">\(2^w\)</span>。</p>
<h4 id="扩展数的位表示">2.2.4 扩展数的位表示</h4>
<p>　　<strong>零扩展</strong> (在位模式的开头填充0)
可用于将无符号数转换为位模式更长的无符号数。</p>
<p>　　若<span class="math inline">\(w\)</span>位位向量<span
class="math inline">\(\vec{u}=[u_{w-1},u_{w-2},\cdots
,u_0]\)</span>和<span class="math inline">\(w&#39;\)</span>位位向量<span
class="math inline">\(\vec{u}&#39;=[0,\cdots ,0,u_{w-1},u_{w-2},\cdots
,u_0]\)</span>，当<span
class="math inline">\(w&#39;&gt;w\)</span>时，<span
class="math inline">\(B2U_w(\vec{u})=B2T_{w&#39;}(\vec{u}&#39;)\)</span>。</p>
<p>　　<strong>符号扩展</strong> (在位模式的开头填充最高有效位的值)
可用于将有符号数转换为位模式更长的有符号数。</p>
<p>　　若<span class="math inline">\(w\)</span>位位向量<span
class="math inline">\(\vec{x}=[x_{w-1},x_{w-2},\cdots
,x_0]\)</span>和<span class="math inline">\(w&#39;\)</span>位位向量<span
class="math inline">\(\vec{x}&#39;=[x_{w-1},\cdots
,x_{w-1},x_{w-1},x_{w-2},\cdots ,x_0]\)</span>，当<span
class="math inline">\(w&#39;&gt;w\)</span>时，<span
class="math inline">\(B2U_w(\vec{u})=B2U_{w&#39;}(\vec{u}&#39;)\)</span>。若<span
class="math inline">\(w&#39;=w+k\)</span>，则需证明 <span
class="math display">\[
B2T_{w+k}([x_{w-1},...,x_{w-1},x_{w-1},x_{w-2},...,x_0])=B2T_w([x_{w-1},x_{w-2},...,x_0])
\]</span>
　　根据数学归纳法，若能证明符号扩展1位时数值不变，则符号扩展到任意位时数值也不变。
<span class="math display">\[
\begin{aligned}
B2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},...,x_0])&amp;=-x_{w-1}2^w+\sum^{w-1}_{i=0}x_i2^i\\[3px]
&amp;=-x_{w-1}2^w+x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i\\[3px]
&amp;=-x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i\\[3px]
&amp;=B2T_w([x_{w-1},x_{w-2},...,x_0])
\end{aligned}
\]</span></p>
<h4 id="截断数值">2.2.5 截断数值</h4>
<p>　　将<span class="math inline">\(w\)</span>位位向量截断为<span
class="math inline">\(k\)</span>位时，将丢弃高<span
class="math inline">\(w-k\)</span>位，这可能会改变其值。这种情况也属于溢出。</p>
<p>　　若<span class="math inline">\(w\)</span>位位向量<span
class="math inline">\(\vec{x}=[x_{w-1},w_{w-2},\cdots
,x_0]\)</span>，则截断为<span
class="math inline">\(k\)</span>位后的结果<span
class="math inline">\(\vec{x}&#39;=[x_{k-1},w_{k-2},\cdots
,x_0]\)</span>。令<span
class="math inline">\(x=B2U_w(\vec{x})\)</span>，<span
class="math inline">\(x&#39;=B2U_w(\vec{x}&#39;)\)</span>，则<span
class="math inline">\(x&#39;=x\bmod 2^k\)</span>。若<span
class="math inline">\(x’=B2T(\vec{x}&#39;)\)</span>，则<span
class="math inline">\(x&#39;=U2T_k(x\bmod 2^k)\)</span>，<span
class="math inline">\(U2T_k\)</span>将最高有效位<span
class="math inline">\(x_{k-1}\)</span>的权重从<span
class="math inline">\(2^{k-1}\)</span>转换为<span
class="math inline">\(-2^{k-1}\)</span>。 <span class="math display">\[
\begin{aligned}
B2U([x_{w-1},x_{w-2},...,x_0])\bmod
2^k&amp;=[\sum_{i=0}^{w-1}x_i2^i]\bmod 2^k\\[3px]
&amp;=[\sum_{i=0}^{k-1}x_i2^i]\bmod 2^k\\[3px]
&amp;=\sum^{k-1}_{i=0}x_i2^i\\[3px]
&amp;=B2U_k([x_{k-1},x_{k-2},...,x_0])
\end{aligned}
\]</span> 　　对于无符号数，所有截断的位都具有形如<span
class="math inline">\(2^i(i\geqslant
k)\)</span>的权重，这些权重都在模运算时会得到0。</p>
<h3 id="整数运算">2.3 整数运算</h3>
<h4 id="无符号运算">2.3.1 无符号运算</h4>
<p>　　对于位模式为<span
class="math inline">\(w\)</span>位的无符号数<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>，两者的运算<span
class="math inline">\(+^u_w\)</span>就是把和<span
class="math inline">\(x+y\)</span>的位模式截断为<span
class="math inline">\(w\)</span>位后的结果再转换为无符号数。当<span
class="math inline">\(x+y\geqslant
2^w\)</span>时，会发生溢出，溢出后的结果小于<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>。当执行C程序时，溢出不会导致错误。
<span class="math display">\[
x+^u_wy=
\begin{cases}
x+y&amp;&amp;{0\leqslant x+y&lt;2^w}\\
x+y-2^w&amp;&amp;{2^w\leqslant x+y&lt;2^{w+1}}
\end{cases}
\]</span>
　　模加法会形成<strong>阿贝尔群</strong>。阿贝尔群以挪威数学家Niels
Henrik Abel (1802~1829)
命名，它是可交换的和可结合的。阿贝尔群有1个单元0，并且每个元素都有1个加法逆元。对于位模式为<span
class="math inline">\(w\)</span>位的无符号数<span
class="math inline">\(x\)</span>，必有1个值<span
class="math inline">\(-^u_wx\)</span>满足<span
class="math inline">\(-^u_wx+^u_wx=0\)</span>。 <span
class="math display">\[
-^u_wx=
\begin{cases}
x&amp;&amp;{x=0}\\
2^w-x&amp;&amp;{0&lt;x\leqslant 2^w-1}
\end{cases}
\]</span></p>
<p>　　<span class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>的运算<span
class="math inline">\(*^u_w\)</span>也是将乘积<span
class="math inline">\(x\cdot y\)</span>的位模式 (<span
class="math inline">\(2w\)</span>位) 截断为<span
class="math inline">\(w\)</span>位后的结果再转换为无符号数。 <span
class="math display">\[
x*^u_wy=(x\cdot y)\bmod 2^w
\]</span></p>
<h4 id="有符号运算">2.3.2 有符号运算</h4>
<p>　　对于位模式为<span
class="math inline">\(w\)</span>位的有符号数<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>，两者的运算<span
class="math inline">\(+^t_w\)</span>就是把和<span
class="math inline">\(x+y\)</span>的位模式截断为<span
class="math inline">\(w\)</span>位后的结果再转换为有符号数。</p>
<p>　　<span class="math inline">\(+^t_w\)</span>与<span
class="math inline">\(+^u_w\)</span>有相同的位级表示，所以<span
class="math inline">\(+^t_w\)</span>等同于先将参数转换为无符号数进行<span
class="math inline">\(+^u_w\)</span>再转换为有符号数。 <span
class="math display">\[
\begin{aligned}
x+^t_wy&amp;=U2T_w(T2U_w(x)+^u_wT2U(y))\\[3px]
&amp;=U2T_w[(x_{w-1}2^w+x+y_{w-1}2^w+y)\bmod2^w]\\[3px]
&amp;=U2T_w[(x+y)\bmod 2^w]
\end{aligned}
\]</span> 　　假设<span class="math inline">\(z=x+y\)</span>，<span
class="math inline">\(z&#39;= z\bmod2^w\)</span>，<span
class="math inline">\(z&#39;&#39;= U2T(z&#39;)=x+^t_wy\)</span>。</p>
<p>　　● 当<span class="math inline">\(-2^w\leqslant
z&lt;-2^{w-1}\)</span>时，<span
class="math inline">\(z&#39;=z+2^w\)</span>，所以<span
class="math inline">\(0\leqslant z&#39;&lt;-2^{w-1}\)</span>，<span
class="math inline">\(z&#39;&#39;=z&#39;\)</span>，此时，两个负数相加得到正数，称为<strong>负溢出</strong>。</p>
<p>　　● 当<span class="math inline">\(-2^{w-1}\leqslant
z&lt;0\)</span>时，<span
class="math inline">\(z&#39;=z+2^w\)</span>，所以<span
class="math inline">\(2^{2-1}\leqslant z&#39;&lt;2^w\)</span>，<span
class="math inline">\(z&#39;&#39;=z\)</span>。</p>
<p>　　● 当<span class="math inline">\(0\leqslant
z&lt;2^{w-1}\)</span>时，<span
class="math inline">\(z&#39;=z\)</span>，所以<span
class="math inline">\(0\leqslant z&#39;&lt;2^{w-1}\)</span>，<span
class="math inline">\(z&#39;&#39;=z\)</span>。</p>
<p>　　● 当<span class="math inline">\(2^{w-1}\leqslant
z&lt;2^w\)</span>时，<span
class="math inline">\(z&#39;=z\)</span>，所以<span
class="math inline">\(2^{w-1}\leqslant z&#39;&lt;2^w\)</span>，<span
class="math inline">\(z&#39;&#39;=z-2^w\)</span>，此时，两个正数相加得到负数，称为<strong>正溢出</strong>。
<span class="math display">\[
x+^t_wy=
\begin{cases}
x+y+2^w&amp;&amp;{-2^w\leqslant x+y&lt;-2^{w-1}}\\
x+y&amp;&amp;{-2^{w-1}\leqslant x+y&lt;2^{w-1}}\\
x+y-2^w&amp;&amp;{2^{w-1}\leqslant x+y&lt;2^w}
\end{cases}
\]</span> 　　<span
class="math inline">\(TMin_w+TMin_w=-2^w\)</span>会导致负溢出，所以<span
class="math inline">\(TMin_w+^t_wTMin_w=0\)</span>。若<span
class="math inline">\(x&gt;Tmin_w\)</span>且<span
class="math inline">\(-x\)</span>可以表示为<span
class="math inline">\(w\)</span>位的补码，则<span
class="math inline">\(-x+x=0\)</span>。 <span class="math display">\[
-^t_wx=
\begin{cases}
TMin_w&amp;&amp;{x=-2^{w-1}}\\
-x&amp;&amp;{-2^{w-1}&lt;x\leqslant 2^{w-1}-1}
\end{cases}
\]</span> 　　获取<span
class="math inline">\(-^t_wx\)</span>的有2种方法。第1种方法是将<span
class="math inline">\(x\)</span>的位模式中的所有位取反并将结果加1。第2种方法是先找到<span
class="math inline">\(x\)</span>的位模式中的最右边的1并假设其位置为<span
class="math inline">\(k\)</span>，然后将<span
class="math inline">\(k\)</span>左边的位所有位取反。</p>
<p>　　对于<span class="math inline">\(w\)</span>位位向量<span
class="math inline">\(\vec{x}\)</span>和<span
class="math inline">\(\vec{y}\)</span>，<span
class="math inline">\(x=B2T_w(\vec{x})\)</span>，<span
class="math inline">\(y=B2T_w(\vec{y})\)</span>，<span
class="math inline">\(x&#39;=B2U_w(\vec{x})\)</span>，<span
class="math inline">\(y&#39;=B2U_w(\vec{y})\)</span>。 <span
class="math display">\[
\begin{aligned}
(x&#39;\cdot y&#39;)\bmod
2^w&amp;=[(x+x_{w-1}2^w)\cdot(y+y_{w-1}2^w)]\bmod 2^w\\[3px]
&amp;=[x\cdot y+(x_{w-1}y+y_{w-1}x)2^w+x_{w-1}y_{w-1}2^{2w}]\bmod
2^w\\[3px]
&amp;=(x\cdot y)\bmod 2^w
\end{aligned}
\]</span> 　　因此，无符号数和有符号数乘法运算的位级表示相同。</p>
<p>　　<span class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>的运算<span
class="math inline">\(*^t_w\)</span>也是将乘积<span
class="math inline">\(x\cdot y\)</span>的位模式 (<span
class="math inline">\(2w\)</span>位) 截断为<span
class="math inline">\(w\)</span>位后的结果再转换为有符号数。 <span
class="math display">\[
x*^t_wy=U2T_w((x\cdot y)\bmod 2^w)
\]</span></p>
<h4 id="除以2的幂">2.3.3 除以2的幂</h4>
<p>　　除以2的幂可以用右移操作来实现，逻辑右移和算术右移分别对应无符号数和有符号数。因此，大多数计算机都支持这2种右移，但这种方法并不适用于所有整数。</p>
<p>　　对于实数<span class="math inline">\(a\)</span>，<span
class="math inline">\(\lfloor a \rfloor\)</span>表示满足<span
class="math inline">\(a&#39;\leqslant a\leqslant
a&#39;+1\)</span>的唯一整数<span
class="math inline">\(a&#39;\)</span>，<span
class="math inline">\(\lceil a \rceil\)</span>表示满足<span
class="math inline">\(a&#39;-1 \leqslant a\leqslant
a&#39;\)</span>的唯一整数<span
class="math inline">\(a&#39;\)</span>。</p>
<p>　　整数除法通常向零舍入，即当结果为正时，向下舍入；当结果为负时，向上舍入。因此，当<span
class="math inline">\(x\geqslant 0\)</span>和<span
class="math inline">\(y&gt;0\)</span>，会得到<span
class="math inline">\(\lfloor \frac{x}{y} \rfloor\)</span>；当<span
class="math inline">\(x&lt;0\)</span>和<span
class="math inline">\(y&gt;0\)</span>时，会得到<span
class="math inline">\(\lceil \frac{x}{y} \rceil\)</span>。</p>
<h5 id="无符号数除以2的幂">2.3.3.1 无符号数除以2的幂</h5>
<p>　　若C变量<code>x</code>和<code>k</code>都是无符号数，值分别为<span
class="math inline">\(x\)</span>和<span
class="math inline">\(k\)</span>，<span
class="math inline">\(x\)</span>的位模式是<span
class="math inline">\([x_{w-1},x_{w-2},...,x_0]\)</span>且<span
class="math inline">\(0\leqslant
k&lt;w\)</span>，则<code>x &gt;&gt; k</code>会执行逻辑右移并向下舍入。</p>
<p>　　假设<span class="math inline">\(x&#39;\)</span>表示<span
class="math inline">\(x\)</span>的高<span
class="math inline">\(w-k\)</span>位的位模式，即<span
class="math inline">\([x_{w-1},x_{w-2},...,x_k]\)</span>，<span
class="math inline">\(x&#39;&#39;\)</span>表示<span
class="math inline">\(x\)</span>的低<span
class="math inline">\(k\)</span>位的位模式，即<span
class="math inline">\([x_{k-1},...,x_0]\)</span>，则<span
class="math inline">\(x=2^kx&#39;+x&#39;&#39;\)</span>，其中<span
class="math inline">\(0\leqslant
x&#39;&#39;&lt;2^k\)</span>。因此，<span class="math inline">\(\lfloor
\frac{x}{2^k} \rfloor=x&#39;\)</span>。</p>
<table>
<thead>
<tr>
<th><code>k</code></th>
<th><code>&gt;&gt; k</code> (二进制)</th>
<th>十进制</th>
<th><code>12340 / (2 ^ k)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0011000000110100</td>
<td>12340</td>
<td>12340.0</td>
</tr>
<tr>
<td>1</td>
<td><strong>0</strong>001100000011010</td>
<td>6170</td>
<td>6170.0</td>
</tr>
<tr>
<td>4</td>
<td><strong>0000</strong>001100000011</td>
<td>771</td>
<td>771.25</td>
</tr>
<tr>
<td>8</td>
<td><strong>00000000</strong>00110000</td>
<td>48</td>
<td>48.203125</td>
</tr>
</tbody>
</table>
<p>　　这是对12340的16位表示进行逻辑右移后的结果，粗体表示从左边移入的0。</p>
<h5 id="有符号数除以2的幂">2.3.3.2 有符号数除以2的幂</h5>
<p>　　若C变量<code>x</code>和<code>k</code>分别是有符号数和无符号数，值分别为<span
class="math inline">\(x\)</span>和<span
class="math inline">\(k\)</span>，<span
class="math inline">\(x\)</span>的位模式是<span
class="math inline">\([x_{w-1},x_{w-2},...,x_0]\)</span>且<span
class="math inline">\(0\leqslant
k&lt;w\)</span>，则<code>x &gt;&gt; k</code>会执行算术右移并向下舍入。</p>
<p>　　当<span class="math inline">\(x\geqslant 0\)</span>时，<span
class="math inline">\(x\)</span>的最高位是0，此时，算术右移与逻辑右移相同；当<span
class="math inline">\(x&lt;0\)</span>时，算术右移<span
class="math inline">\(k\)</span>位后，高<span
class="math inline">\(k\)</span>位都会变为1，刚好是<span
class="math inline">\(\lfloor \frac{x}{2^k}
\rfloor\)</span>的补码表示。</p>
<table>
<thead>
<tr>
<th><code>k</code></th>
<th><code>&gt;&gt; k</code> (二进制)</th>
<th>十进制</th>
<th><code>-12340 / (2 ^ k)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1100111111001100</td>
<td>-12340</td>
<td>-12340.0</td>
</tr>
<tr>
<td>1</td>
<td><strong>1</strong>110011111100110</td>
<td>-6170</td>
<td>-6170.0</td>
</tr>
<tr>
<td>4</td>
<td><strong>1111</strong>110011111100</td>
<td>-772</td>
<td>-771.25</td>
</tr>
<tr>
<td>8</td>
<td><strong>11111111</strong>11001111</td>
<td>-49</td>
<td>−48.203125</td>
</tr>
</tbody>
</table>
<p>　　这是对-12340的16位表示进行逻辑右移后的结果。对于不需要舍入的情况
(<span class="math inline">\(k=1\)</span>)，结果会是<span
class="math inline">\(\frac{x}{2^k}\)</span>。对于需要舍入的情况，算术右移会导致向下舍入。</p>
<p>　　为了保证整数除法向零舍入，算术右移前需要加上<span
style="background-color: yellow">偏置</span><span
class="math inline">\(2^k-1\)</span>，即<code>(x + (1 &lt;&lt; k) - 1) &gt;&gt; k</code>。</p>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 29%" />
<col style="width: 27%" />
<col style="width: 8%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr>
<th><code>k</code></th>
<th>偏置</th>
<th>-12340 + 偏置 (二进制)</th>
<th><code>&gt;&gt; k</code> (二进制)</th>
<th>十进制</th>
<th><code>-12340 / (2 ^ k)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1100111111001100</td>
<td>1100111111001100</td>
<td>-12340</td>
<td>-12340.0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>110011111100110<strong>1</strong></td>
<td><strong>1</strong>110011111100110</td>
<td>-6170</td>
<td>-6170.0</td>
</tr>
<tr>
<td>4</td>
<td>15</td>
<td>110011111101<strong>1011</strong></td>
<td><strong>1111</strong>110011111101</td>
<td>-771</td>
<td>-771.25</td>
</tr>
<tr>
<td>8</td>
<td>255</td>
<td>11010000<strong>11001011</strong></td>
<td><strong>11111111</strong>11010000</td>
<td>-48</td>
<td>−48.203125</td>
</tr>
</tbody>
</table>
<p>　　这是如何在算术右移前加上合适的偏置来保证向零舍入。在第3列中，展示了-12340与偏置相加的结果，其中粗体表示低<span
class="math inline">\(k\)</span>位，它们左边的位可能会增加，也可能不会增加。对于不需要舍入的情况
(<span
class="math inline">\(k=1\)</span>)，偏置只会影响那些会移动的位。对于需要舍入的情况，偏置会导致较高的位增加，即结果将向零舍入。</p>
<p>　　若<span class="math inline">\(x=qy+r\)</span>，其中<span
class="math inline">\(0\leqslant x&lt;y\)</span>，则<span
class="math inline">\(\frac{x+y-1}{y}=q+\frac{r+y-1}{y}\)</span>，所以<span
class="math inline">\(\lfloor\frac{x+y-1}{y}\rfloor=q+\lfloor\frac{r+y-1}{y}\rfloor\)</span>。当<span
class="math inline">\(r=0\)</span>时，<span
class="math inline">\(\lfloor\frac{r+y-1}{y}\rfloor\)</span>会得到0；当<span
class="math inline">\(r&gt;0\)</span>时，<span
class="math inline">\(\lfloor\frac{r+y-1}{y}\rfloor\)</span>会得到1。因此，对于整数<span
class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>
(<span class="math inline">\(y&gt;0\)</span>)，<span
class="math inline">\(\lceil\frac{x}{y}\rceil=\lfloor \frac{x+y-1}{y}
\rfloor\)</span>，偏置技术充分使用了这一点。当<span
class="math inline">\(y=2^k\)</span>时，<code>(x + (1 &lt;&lt; k) - 1) &gt;&gt; k</code>会先得到<span
class="math inline">\(x+2^k-1\)</span>，然后右移<span
class="math inline">\(k\)</span>位，最后得到<span
class="math inline">\(\lceil\frac{x}{2^k}\rceil\)</span>。</p>
<h3 id="浮点数">2.4 浮点数</h3>
<p>　　浮点数表示用于对形如<span class="math inline">\(V=x\times
2^y\)</span>的有理数进行编码。对于涉及非常大的数 (<span
class="math inline">\(|V|&gt;&gt;1\)</span>)、非常接近于0的数 (<span
class="math inline">\(0&lt;|V|&lt;&lt;1\)</span>)
以及更普遍的作为实数运算的近似值的计算，它很实用。</p>
<h4 id="二进制小数">2.4.1 二进制小数</h4>
<p>　　小数的十进制表示为<span class="math inline">\(d_md_{m-1}\cdots
d_1d_0.d_{-1}d_{-2}\cdots
d_{-n+1}d_{-n}\)</span>。数字的权是相对小数点符号定义，左边的数的权是10的正幂，得到整数值，而右边的数的权是10的负幂，得到小数值。
<span class="math display">\[
d=\sum^m_{i=-n}10^i\times d_i
\]</span> 　　类似十进制，小数的二进制也能表示为<span
class="math inline">\(b_mb_{m-1}\cdots b_1b_0.b_{-1}b_{-2}\cdots
b_{-n+1}b_{-n}\)</span>。小数点左边的数的权是2的正幂，右边的数的权是2的负幂。小数点左移<span
class="math inline">\(n\)</span>位相当于除以<span
class="math inline">\(2^n\)</span>，右移<span
class="math inline">\(n\)</span>位相当于乘<span
class="math inline">\(2^n\)</span>。 <span class="math display">\[
b=\sum^m_{i=-n}2^i\times b_i
\]</span>
　　对于有些小数，并不能确切地用二进制表示，只能近似地表示，但增加二进制表示的长度可以提高其精度。</p>
<h4 id="ieee浮点表示">2.4.2 IEEE浮点表示</h4>
<p>　　IEEE浮点标准用<span class="math inline">\(V=(-1)^s\times M\times
2^E\)</span>表示数字。</p>
<p>　　● <span
class="math inline">\(s\)</span>表示<strong>符号</strong>，<span
class="math inline">\(s=1\)</span>表示负数，<span
class="math inline">\(s=0\)</span>表示正数，其中数值0的符号位解释作为特殊情况处理。</p>
<p>　　● <span
class="math inline">\(M\)</span>表示<strong>尾数</strong>，它是二进制小数，其范围是<span
class="math inline">\(1\sim 2-\epsilon\)</span>或<span
class="math inline">\(0\sim 1-\epsilon\)</span>。</p>
<p>　　● <span
class="math inline">\(E\)</span>表示<strong>阶码</strong>，其作用是对浮点数加权，该权是<span
class="math inline">\(2^E\)</span>。</p>
<img src="/2022/10/05/computer-systems-a-programmer's-perspective-3e-chpt-2/standard_floating_pointer_format.svg" class="" title="standard_floating_pointer_format">
<p>　　在C语言中，单精度浮点数是32位，其中有1位符号、8位阶码和23位尾数。双精度浮点数是64位，其中有1位符号、11位阶码和52位尾数。</p>
<img src="/2022/10/05/computer-systems-a-programmer's-perspective-3e-chpt-2/categories_of_single_precision_floating_point_values.svg" class="" title="categories_of_single_precision_floating_point_values">
<p>　　对于C语言的单精度浮点数，阶码的值决定了其类别。此外，用<span
class="math inline">\(k\)</span>和<span
class="math inline">\(n\)</span>分别表示阶码和尾数的位模式长度。</p>
<p>　　●
最常见的情况是<strong>规格化</strong>数，其阶码的位模式不全为0或1。在这种情况下，阶码被解释为<strong>偏置</strong>形式表示的有符号整数，即阶码值<span
class="math inline">\(E=e-Bias\)</span>，其中<span
class="math inline">\(e\)</span>是无符号数，其位模式是<span
class="math inline">\(e_{k-1}\cdots e_1e_0\)</span>，<span
class="math inline">\(Bias\)</span>是偏置值<span
class="math inline">\(2^{k-1}-1\)</span>。因此，单精度浮点数的指数的取值范围是<span
class="math inline">\(-126\sim
+127\)</span>，双精度浮点数的指数范围是<span
class="math inline">\(-1022\sim +1023\)</span>。尾数被解释为小数<span
class="math inline">\(f\)</span> (<span class="math inline">\(0\leqslant
f&lt;1\)</span>)，其二进制表示为<span
class="math inline">\(0.f_{n-1}\cdots f_1f_0\)</span>。尾数定义为<span
class="math inline">\(M=1+f\)</span>，这种方式也称为<strong>隐含前导1</strong>表示，因为<span
class="math inline">\(M\)</span>的二进制表示为<span
class="math inline">\(1.f_{n-1}\cdots
f_1f_0\)</span>，这种表示方法可以获得额外精度。由于可以调整阶码<span
class="math inline">\(E\)</span>来保证尾数<span
class="math inline">\(M\)</span>在<span class="math inline">\(1\leqslant
M&lt;2\)</span>范围内，所以无需显示地表示前导位。</p>
<p>　　●
当阶码位模式全为0时，表示<strong>非规格化</strong>数。在这种情况下，阶码值<span
class="math inline">\(E=1-Bias\)</span>，尾数值<span
class="math inline">\(M=f\)</span>。它有2个用途，第1个用途是表示数值0，因为规格化数的尾数<span
class="math inline">\(M\geqslant1\)</span>，不能表示0。实际上，+0.0的位模式全为0，但位模式的符号位为1，其他位全为0时表示-0.0。对于IEEE浮点格式，+0.0和-0.0在某些方面不同，其他方面相同。第2个用途是表示很接近0的数，提供了一个称为<strong>渐进下溢</strong>的属性，即可能的数值均匀分布在0.0附近。</p>
<p>　　●
当阶码位模式全为1时，表示特殊值。当尾数位模式全为0时，表示无穷大，符号位是0时表示<span
class="math inline">\(+\infty\)</span>，符号位为1时表示<span
class="math inline">\(-\infty\)</span>。当两个很大的数相乘或除以0时，无穷大表示<span
style="background-color: yellow">溢出</span>。当尾数位模式不全为0时，表示<strong>非数字</strong>，某些运算结果不为实数或无穷大时，返回非数字。在某些应用程序中，它们可用于表示未初始化的数据。</p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 19%" />
<col style="width: 17%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>阶码</th>
<th>尾数</th>
<th>数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>最小的正非规格化数</td>
<td><span class="math inline">\(M=f=2^{-n}\)</span></td>
<td><span class="math inline">\(E=-2^{k-1}+2\)</span></td>
<td><span class="math inline">\(V=2^{-n-2^{k-1}+2}\)</span></td>
</tr>
<tr>
<td>最大的正非规格化数</td>
<td><span class="math inline">\(M=f=1-2^{-n}\)</span></td>
<td><span class="math inline">\(E=-2^{k-1}+2\)</span></td>
<td><span class="math inline">\(V=(1-2^{-n})\cdot
2^{-2^{k-1}+2}\)</span></td>
</tr>
<tr>
<td>最小的正规格化数</td>
<td><span class="math inline">\(M=1+f=1\)</span></td>
<td><span class="math inline">\(E=-2^{k-1}+2\)</span></td>
<td><span class="math inline">\(V=2^{-2^{k-1}+2}\)</span></td>
</tr>
<tr>
<td>最大的正规格化数</td>
<td><span class="math inline">\(M=1+f=2-2^{-n}\)</span></td>
<td><span class="math inline">\(E=2^{k-1}-1\)</span></td>
<td><span class="math inline">\(V=(1-2^{-n-1})\cdot
2^{2^{k-1}}\)</span></td>
</tr>
</tbody>
</table>
<p>　　以基于IEEE浮点格式的6位浮点表示为例，其中有3位阶码和2位尾数，所以偏置值<span
class="math inline">\(Bias=2^{3-1}-1=3\)</span>。对于规格化数，阶码值的取值范围是<span
class="math inline">\(-2\sim3\)</span>，尾数值的取值范围是<span
class="math inline">\(1\sim \frac{7}{4}\)</span>，最大值是<span
class="math inline">\(\pm14\)</span>，最小值是<span
class="math inline">\(\pm\frac{1}{4}\)</span>。对于非规格化数，阶码值是<span
class="math inline">\(-2\)</span>，尾数值的取值范围是<span
class="math inline">\(0\sim \frac{3}{4}\)</span>，最大值是<span
class="math inline">\(\pm \frac{3}{16}\)</span>，最小值是<span
class="math inline">\(\pm
0\)</span>。非规格数聚集在0附近，它们并不是均匀分布，而是越靠近原点越密集。对比规格数的最小值和非规格数的最大值，可以发现两者之间的<span
style="background-color: yellow">平滑过渡</span>，因为非规格化数的阶码值<span
class="math inline">\(E\)</span>定义为<span
class="math inline">\(1-Bias\)</span>，这样弥补了非规格化数的尾数没有隐含前导1。</p>
<img src="/2022/10/05/computer-systems-a-programmer's-perspective-3e-chpt-2/simple_example_of_converting_a_signed_number_to_a_floating_point_number.svg" class="" title="simple_example_of_converting_a_signed_number_to_a_floating_point_number">
<p>　　将整数转换为浮点形式对理解浮点表示很有用。以数值12345为例，其二进制表示为<span
class="math inline">\([11000000111001]\)</span>，对应的规格化表示为<span
class="math inline">\(1.1000000111001_2\cdot
2^{13}\)</span>。为了用IEEE单精度浮点表示，将二进制小数点左移13位，丢弃开头的1并在结尾增加10个0，然后计算尾数<span
class="math inline">\(e=E+Bias=13+127=140\)</span>并转换为二进制，最后加上符号位。</p>
<h4 id="浮点运算">2.4.3 浮点运算</h4>
<p>　　浮点运算只能近似于实数运算，因为表示的范围和精度有限。因此，对于值<span
class="math inline">\(x\)</span>，需要系统的方法来查找浮点格式能表示的最近接的值<span
class="math inline">\(x&#39;\)</span>，这是<strong>舍入</strong>的任务。</p>
<p>　　IEEE浮点格式定义了4种舍入模式。向最近值舍入也称为向偶数舍入，是默认方式，它向上或向下舍入来尽量保证结果的最低有效位为偶数。当有2个可能的舍入值时，选择最低有效位为偶数的舍入值。以保留整数为例，1.40会舍入到1，1.50和2.50都会舍入到2，因为2是偶数。其他3种方式会在实际值上产生<span
style="background-color: yellow">确界</span>，分别是向上舍入、向零舍入和向下舍入。</p>
<p>　　向偶数舍入也能运用在二进制小数上 (0是偶数)。通常位模式形如<span
class="math inline">\(XX\cdots X.YY\cdots Y100\cdots\)</span>的数
(最右边的<span class="math inline">\(Y\)</span>是待舍入的位置)
才可能会有2个舍入值。以保留2位小数为例，<span
class="math inline">\(10.00011_2(2\frac{3}{32})\)</span>会舍入到<span
class="math inline">\(10.00_2(2)\)</span>，<span
class="math inline">\(10.00110_2(2\frac{3}{16})\)</span>会舍入到<span
class="math inline">\(10.01_2(2\frac{1}{4})\)</span>，<span
class="math inline">\(10.11100_2(2\frac{7}{8})\)</span>会舍入到<span
class="math inline">\(11.00_2(3)\)</span>，<span
class="math inline">\(10.10100_2(2\frac{5}{8})\)</span>会舍入到<span
class="math inline">\(10.10(2\frac{1}{2})\)</span>。</p>
<p>　　将一组数据舍入后进行平均值计算时会引入统计偏差，无论向上舍入、向零舍入还是向下舍入，都会增大统计偏差，而向偶数舍入可以减小甚至消除统计偏差，因为大约一半的数据向上舍入，大约一半数据向下舍入。</p>
<p>　　IEEE规定了用于确定算术运算结果的规则，即若将浮点数<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>视为实数，则算术运算<span
class="math inline">\(\odot\)</span>的结果应该是实际值的舍入结果<span
class="math inline">\(Round(x\odot y)\)</span>。</p>
<p>　　整数 (包括无符号和补码)
加法会形成阿贝尔群，实数加法也会形成阿贝尔群，但需要考虑舍入。将<span
class="math inline">\(x+^fy\)</span>定义为<span
class="math inline">\(Round(x+y)\)</span>，该运算会根据<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>的所有取值定义，虽然<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>都是实数，但由于溢出可能得到无穷大。对于所有<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>的值，该运算是可交换的，<span
class="math inline">\(x+^fy=y+^fx\)</span>。但是，该运算是不可结合的，例如，对于单精度浮点数，有<span
class="math inline">\((3.14+10^{10})-10^{10}=0.0\)</span>，舍入会导致3.14会丢失，而<span
class="math inline">\(3.14+(10^{10}-10^{10})=3.14\)</span>。大多数在浮点加法时有逆元，<span
class="math inline">\(x+^f-x=0\)</span>，无穷大和非数字是例外，因为<span
class="math inline">\(+\infty-\infty=NaN\)</span>，<span
class="math inline">\(NaN+^fx=NaN\)</span>。</p>
<p>　　浮点加法满足单调性，即若<span class="math inline">\(a\geqslant
b\)</span>，则<span class="math inline">\(x+^fa\geqslant x+^fb(x\neq
NaN)\)</span>。</p>
<p>　　由于浮点加法不具有结合性，<code>x = a + b + c</code>可能会被编译器替换为<code>t = b + c</code>和<code>x = a + t</code>。在大多数情况下，这种差异无关紧要。编译器无法得知如何取舍效率和保留原始程序的确切行为，所以编译器通常很保守，避免任何可能对功能产生影响的优化。</p>
<p>　　浮点乘法也有常规乘数的很多属性。将<span
class="math inline">\(x\cdot^fy\)</span>定义为<span
class="math inline">\(Round(x\cdot y)\)</span>，该运算会在乘法下闭合
(虽然可能产生无穷大或非数字)，它是可交换的并且有1.0作为乘法恒等式。由于溢出或舍入而导致精度丢失，该运算是不可结合和不可分配的。该运算满足单调性，对于不为非数字的<span
class="math inline">\(a\)</span>、<span
class="math inline">\(b\)</span>和<span
class="math inline">\(c\)</span>，其中<span
class="math inline">\(a\geqslant b\)</span>，若<span
class="math inline">\(c\geqslant 0\)</span>，则<span
class="math inline">\(a\cdot^fc \geqslant b \cdot^f c\)</span>；若<span
class="math inline">\(c\leqslant0\)</span>，则<span
class="math inline">\(a\cdot^f c\leqslant b\cdot^f c\)</span>。</p>
<h4 id="c语言相关支持-1">2.4.4 C语言相关支持</h4>
<p>　　C语言提供了<code>float</code>和<code>double</code>来支持浮点数，其舍入模式是向偶数舍入。C语言并不要求计算机使用IEEE浮点格式，所以没有标准方法来更改舍入方式和获取特殊值，但大多数系统提供了头文件引入和过程库的结合来提供这些支持，具体实现因系统而异。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>　　这段代码会让GCC定义常数<code>INFINTY</code>和<code>NAN</code>。</p>
<p>　　<code>int</code>转换为<code>float</code>时，可能会舍入。<code>int</code>或<code>float</code>转换为<code>double</code>时，不会有精度损失。<code>double</code>转换为<code>float</code>时，可能会溢出为<span
class="math inline">\(\pm\infty\)</span>或者舍入。<code>float</code>或<code>double</code>转换为<code>int</code>时，可能会向零舍入，也可能会溢出，C语言没有为这种情况指定固定结果。Intel兼容的CPU会指定位模式<span
class="math inline">\([10\cdots00]\)</span>为<strong>整数不定值</strong>，若从浮点数转换为整数时，没有合理的整数近似值，则会产生该值。因此，<code>(int)+1e10</code>会得到-21483648，即从正数变成负数。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第11章 网络编程</title>
    <url>/2023/09/22/computer-systems-a-programmer&#39;s-perspective-3e-chpt-11/</url>
    <content><![CDATA[<p>　　互联网起源于1957年，正处于冷战最激烈的时期，苏联第1颗人造卫星的发射震惊世界。作为响应，美国成立了高级研究计划署，其任务是重建美国在科学和技术上领导地位。1967年，ARPA的Lawrence
Roberts提出了建立ARPANET网络的计划。第1个ARPANET节点在1969年建立并运行。到1971年，已有13个ARPANET节点，电子邮件作为其第1个重要的网络应用出现。</p>
<p>　　1972年，Robert
Kahn提供了互联网的基本原则，即一组互联的网络通过称为 "路由器"
的黑盒子按照 "尽力而为原则"
在相互独立处理的网络间通信。1974年，Kahn和Vinton
Cerf发表了TCP/IP的第1本详细资料，到1982年，它成为了ARPANET的标准网络互联协议。1983年1月1日，ARPANET的每个节点都切换到了TCP/IP，这标志着全球互联网的诞生。</p>
<p>　　1985年，Paul
Mockapetris发明了DNS，此时，有1000多台主机。1986年，(美国)
国家科学基金会用56KB/s的电话线连接了13个节点来构建NSFNET的骨干网，其速率在1988年升级到1.5MB/s，1991年又升级到45MB/s。在1988年，有超过50000台主机。1989年，原始ARPANET正式退休。1995年，有几乎千万台主机，此时，NSF取消了NSFNET并用现代互联网架构取代它，该架构基于公共网络接入点连接的私有商业骨干网。</p>
<p>　　所有网络应用程序都基于<strong>客户端-服务器</strong>模型。在该模型中，有1个服务器进程和若干个客户端进程。服务器管理一些<span
style="background-color: yellow">资源</span>并通过控制这些资源来为客户端提供一些服务。例如，Web服务器管理一组磁盘文件并代表客户端检索和执行这些文件。</p>
<p>　　Web客户端和服务器通过基于文本的应用层协议HTTP来通信。HTTP是简单的协议。Web客户端
(即浏览器)
打开到服务器的连接并请求一些内容，然后，服务器响应内容并关闭连接，最后，浏览器读取内容并显示在屏幕上。</p>
<img src="/2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/a_client-server_transaction.svg" class="" title="a_client-server_transaction">
<p>　　客户端-服务器模型中的基本操作是<strong>事务</strong>
(这里的事务和数据库里的事务毫无关联)，它是客户端和服务器执行的一系列步骤。</p>
<p>　　1)
当客户端需要服务时，它通过发送<strong>请求</strong>给服务器来初始化事务。例如，浏览器需要某个文件，它会发送请求给Web服务器。</p>
<p>　　2)
服务器收到请求，解析它并通过合适的方式操作其资源。例如，当Web服务器收到浏览器的请求，它会读磁盘文件。</p>
<p>　　3)
服务器发送<strong>响应</strong>给客户端，然后等待下一个请求。例如，Web服务器将文件发回给浏览器。</p>
<p>　　4)
客户端收到响应并处理。例如，浏览器收到来自服务器的页面并将其显示到屏幕上。</p>
<span id="more"></span>
<p>　　客户端和服务器是<span
style="background-color: yellow">进程</span>而非主机。1个主机可以同时运行多个不同的客户端和服务器。1个事务可以在相同或不同的主机上。客户端-服务器模型与客户端和服务器到主机的映射无关。</p>
<p>　　全球IP互联网最早起源于1969年。虽然互联网的内部架构很复杂且不断变化，但自20世纪80年代以来，客户端-服务器应用程序的组织一直保存着非常稳定的状态。</p>
<p>　　所有互联网主机都运行实现<span
style="background-color: yellow">TCP/IP</span>的软件。互联网客户端和服务器通过<strong>套接字接口</strong>和Unix
I/O函数来通信。套接字函数通常实现为嵌入内核的系统调用，它能调用TCP/IP中的各种内核模式函数。</p>
<p>　　套接字接口是加州大学伯克利分校的研究人员于20世纪80年代早期提出，所以也称为伯克利套接字。伯克利的研究人员使得套接字适用于任何底层协议。第1个实现是针对TCP/IP，该实现包含在Unix
4.2 BSD的内核中，并且分发给了很多大学和实验室。</p>
<p>　　瑞士物理实验室CERN的软件工程师Tim
Berners-Lee发明了万维网。在1989年，Berners-Lee开发了1个内部备忘录，提出了能连接
"用链接组成的笔记网络"
的分布式超文本系统，该系统旨在帮助CERN的科学家分享和管理信息。在之后的2年内，在Berners-Lee实现了首个Web服务器和浏览器后，在CERN内部和其他一些网站中，Web拥有了小规模的拥护者。在1993年发生了关键事件，Marc
Andreesen (之后成立Netscape和Andreessen Horowitz)
和他在NCSA的同事发布了图形化的浏览器MOSAIC，该浏览器可用于Linux、Windows和Macintosh。自此以后，Web网站以每年10倍或更高的数量暴增。</p>
<p>　　互联网的官方信息资源存储在一组可免费获取的带编号的文档中，这些文档称为<span
style="background-color: yellow">RFC</span>。</p>
<h3 id="网络">11.1 网络</h3>
<p>　　客户端和服务器通常运行在不同的主机上，通过<strong>计算机网络</strong>的硬件和软件资源来通信。网络是复杂的系统，这里只介绍一些简单的内容。</p>
<p>　　对于主机，网络只是I/O设备，作为数据的源和接收器。插在I/O总线扩展槽的网络适配器提供网络的物理接口。从网络接收的数据会从适配器通过I/O和内存总线复制到内存，通常通过DMA传输。同样，也能从内存复制到网络。</p>
<p>　　从物理角度，网络是按地理领进性组织的层次结构系统。最底层是跨越建筑或校区的<strong>局域网</strong>。迄今为止最流行的LAN技术是在Xerox
PARC于20世纪70年代中期开发的<strong>以太网</strong>。以太网有出色的弹性，支持的速率从3Mb/s到10Gb/s。</p>
<p>　　<strong>以太网段</strong>由一组电缆 (通常是双绞线)
和1个称为<strong>集线器</strong>的小盒子组成。以太网段通常跨越房间或楼层等较小的区域。每根电缆都有相同的最大位带宽，通常是100Mb/s或1Gb/s。电缆的一端连接着主机的网络适配器，另一端连接着集线器上的<strong>端口</strong>。集线器将端口收到的每个位直接复制到所有其他端口。因此，每个端口都能看到每个位。</p>
<p>　　每个以太网适配器都有存储在内置非易失存储器中的全球唯一的48位地址。主机可以发送一组位
(称为<strong>帧</strong>)
到以太网段上的其他主机。每个帧都有固定的首部字段来表示其源、目的地和大小，其后是存储数据的有效载荷。每个主机适配器都可以看到帧，但只有对应的目的主机能读。</p>
<img src="/2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/bridged_ethernet_segments.svg" class="" title="bridged_ethernet_segments">
<p>　　多个以太网段可以通过一组电缆和称为<strong>网桥</strong>的小盒子来连接到更大的以太网中，称为<strong>桥接以太网</strong>。桥接以太网能跨越整个建筑物或校区。在桥接以太网中，有些电缆连接网桥和网桥，其他电缆连接网桥和集线器。</p>
<p>　　网桥比集线器更能充分利用线路带宽。通过巧妙的分配算法，它们能随着时间自动学习哪些端口可以访问哪些主机，然后仅在必要时可选地将帧从某个端口复制到其他端口。
例如，若主机A需要发送帧到主机B，两者在同一网段，当该帧到达网桥X的输入端口时，网桥X会直接丢弃，这样可以节约其他网段的带宽。若主机A需要发送帧到主机C，两者不在同一网段，当帧到达网桥X的输入端口时，网桥X只会将帧复制到通往网桥Y的端口，网桥Y只会将帧复制到通往主机C所属网段的端口。</p>
<p>　　在层次结构的较高层中，多个兼容的LAN通过称为<strong>路由器</strong>的特殊计算机连接来形成互联网络。每个路由器对它连接的每个网络都有1个适配器
(端口)。路由器也能连接<strong>广域网</strong>等高速点对点电话连接。广域网比局域网有更大的地理覆盖范围。路由器通常可以使用任意LAN和WAN集合来构建互联网络。</p>
<p>　　为了让源主机跨越不兼容的网络发送数据给目的主机，需要使用一层消除底层网络差异的<strong>协议软件</strong>
(运行在所有主机和路由器上)，该软件会实现能协调控制主机和路由器来传输数据的协议。该协议必须提供<span
style="background-color: yellow">命名方案</span>和<span
style="background-color: yellow">传输机制</span>。</p>
<p>　　●
不同的LAN技术通过不同且不兼容的方式来分配主机地址，网络协议需要通过定义统一的地址格式来消除这些差异。每个主机必须分配最少1个<strong>网络地址</strong>，该地址唯一地标识该主机。</p>
<p>　　●
不同的网络技术通过不同且不兼容的方式来编码电缆上的位并将这些位封装成帧。网络协议需要通过定义统一的将数据位封装成独立的片
(称为<strong>分组</strong>)
的方法来消除这些差异。分组包括首部和有效载荷，首部包含分组大小、源主机地址和目的主机地址，有效载荷包含数据位。</p>
<img src="/2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/how_data_travel_from_one_host_to_another_on_an_internet.svg" class="" title="how_data_travel_from_one_host_to_another_on_an_internet">
<p>　　为了简化，这里用较粗的线表示集线器、网桥以及连接它们的电缆。客户端运行在主机A上，主机A连接到LAN1。服务器运行在主机B上，主机B连接到LAN2。客户端发送数据到服务器需要8个步骤，这里仅介绍主要部分，省去了很多细节，例如，如何处理不同网络的帧大小不同的情况、如何路由和丢包后的处理。</p>
<p>　　1)
主机A的客户端通过系统调用来复制客户端虚拟内存中的数据到内核缓冲区。</p>
<p>　　2)
主机A的协议软件将网络分组首部和LAN1帧首部附加到数据来生成LAN1帧。分组首部的地址是主机B的地址。LAN1帧的地址是路由器的地址。这里LAN1帧的有效载荷是分组，分组的有效载荷才是数据。这种<strong>封装</strong>是网络互联的基本方法之一。</p>
<p>　　3) LAN1适配器将帧复制到网络。</p>
<p>　　4)
当帧到达路由器时，路由器的LAN1适配器会从电缆上读取帧并将其传递给协议软件。</p>
<p>　　5)
路由器的协议软件从分组首部提取目的网络地址，根据网络地址路由分组。路由器去除原来的LAN1帧首部，生成地址为主机B地址的LAN2帧首部，然后将它们封装成帧并发送到适配器。</p>
<p>　　6) 路由器的LAN2适配器复制帧到网络。</p>
<p>　　7)
当帧到达主机B时，它的适配器会从电缆上读取帧并将其传递给协议软件。</p>
<p>　　8)
主机B的协议软件去除帧首部和分组首部。当服务器通过系统调用来读数据时，协议软件会复制数据到服务器虚拟内存。</p>
<h3 id="全球ip互联网">11.2 全球IP互联网</h3>
<p>　　TCP/IP实际是一组协议，其中的每个协议负责不同的功能。IP负责基础的命名方案和传输机制，IP对应的分组称为<strong>数据报</strong>。当数据报丢失或重复时，IP不会尝试恢复，所以IP的传输机制是不可靠的。UDP稍微扩展了IP，它会在进程之间传输数据报而非主机之间。TCP是基于IP构建的复杂协议，可在进程之间提供可靠的全双工连接。这里为了简化，这里会将TCP/IP视为单个协议，忽略其内部细节和UDP，仅介绍TCP和IP为应用程序提供的部分基础功能。</p>
<p>　　地址是32位的IP称为<strong>IPv4</strong>。在1996年，IETF提出了用于代替IPv4的地址是128位的新版本IP，称为<strong>IPv6</strong>。这里的内容还是基于IPv4。</p>
<p>　　从程序员角度，可以将互联网视为带有如下属性的全球主机集合：</p>
<p>　　● 主机集合映射到32位IP地址集。</p>
<p>　　● IP地址集映射到一组称为<strong>域名</strong>的标识符。</p>
<p>　　●
主机上的进程通过<strong>连接</strong>与其他主机上的进程通信。</p>
<h4 id="ip地址">11.2.1 IP地址</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* IP地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> s_addr; <span class="comment">/* 大端对齐 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　IP地址是无符号的32位整数。由于主机可以有不同的字节顺序，TCP/IP为所有整数数据项定义了统一的<strong>网络字节顺序</strong>，即<span
style="background-color: yellow">大端对齐</span>。在结构体<code>in_addr</code>中存储标量地址是早期实现中不幸的产物，将其定义为标量类型更有意义，但现在更改已经太迟了，因为已经有大量应用程序基于该结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 转换为网络字节顺序 */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 转换为主机字节顺序 */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>htonl()</code>和<code>htons()</code>会将参数从主机字节顺序转换到网络字节顺序。函数<code>ntohl()</code>和<code>ntohs()</code>会将参数从网络字节顺序转换到主机字节顺序。</p>
<p>　　IP地址通常以<strong>点分十进制表示法</strong>的形式呈现给人。例如，128.2.194.242是地址<code>0x8002f2f2</code>的点分十进制表示形式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(AF_INET, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>; <span class="comment">/* 若成功则返回1，若src是非法点分十进制则返回0，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(AF_INET, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>; <span class="comment">/* 若成功则返回执行点分十进制的指针，若失败则返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>inet_pton()</code>会将点分十进制形式的字符串<code>src</code>转换为网络字节顺序的二进制形式的IP地址<code>dst</code>。若<code>src</code>没有指向合法的点分十进制字符串，则返回0；若出错，则返回-1并设置<code>errno</code>。函数<code>inet_ntop()</code>会将网络字节顺序的二进制形式的IP地址<code>src</code>转换为对应的点分十进制形式的字符串，并将得到的以<code>NULL</code>结尾的字符串中的最多<code>size</code>字节复制到<code>dst</code>。</p>
<h4 id="域名">11.2.2 域名</h4>
<p>　　客户端和服务器通过IP地址通信，但是IP地址并不易于记忆，于是就有了域名。</p>
<p>　　域名集形成1个层次结构，每个域名编码它在层次结构中的位置。</p>
<img src="/2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/subset_of_the_internet_domain_name_hierarchy.svg" class="" title="subset_of_the_internet_domain_name_hierarchy">
<p>　　域名的层次结构展示为树。树的节点表示域名，子树表示子域名。1级域名由非盈利组织ICANN定义，通用1级域名包括<code>com</code>、<code>edu</code>、<code>gov</code>、<code>org</code>和<code>net</code>。2级域名按照先到先服务的原则由ICANN代理分配，例如，<code>cmu.edu</code>。当机构收到2级域名后，该机构就可以免费创建该2级域名的所有子域名，例如，<code>cs.cmu.edu</code>。</p>
<p>　　互联网定义了域名集到IP地址集的映射。1988年前，域名映射通过手动维护文本文件<code>hosts.txt</code>实现。1988年后，域名映射通过称为<strong>域名系统</strong>的分布式全球数据库实现。DNS包含数百万条主机条目，每个条目定义一组域名和一组IP地址的映射，在数学意义上，每个主机条目可以视为域名和IP地址的等式。可以通过命令<code>nslookup</code>来查看DNS映射：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nslookup localhost</span><br></pre></td></tr></table></figure>
<p>　　每个主机都有本地定义的域名<code>localhost</code>，该域名会映射到<strong>环回地址</strong>127.0.0.1，这对同一主机运行客户端和服务器的情况很有用。命令<code>hostname</code>可以查看主机的通用域名和IP地址。</p>
<p>　　在最简单的情况下，域名和IP地址之间是一对一映射。有时，多个域名会映射到同一IP地址。通常，多个域名会映射到同一组IP地址。</p>
<h4 id="网络连接">11.2.3 网络连接</h4>
<p>　　客户端和服务器通过连接发送和接收字节流来通信。连接是点对点的，因为它连接2个进程。连接是全双工的，因为数据能同时在2个方向流动。连接是可靠的，因为发送的数据总能被接收，除非出现切断电缆等灾难性故障。</p>
<p>　　套接字是连接的端点。每个套接字都有对应的<strong>套接字地址</strong>，套接字地址由IP地址和16位的整数端口组成，其格式为<code>地址:端口</code>。</p>
<p>　　当客户端发起连接请求时，内核会自动分配客户端套接字地址中的端口，该端口是<span
style="background-color: yellow">临时端口</span>。服务器套接字地址中的端口通常是与服务永久关联的<span
style="background-color: yellow">知名端口</span>。例如，Web服务器通常使用端口80，邮件服务器通常使用端口25。与知名端口关联的服务有对应的<span
style="background-color: yellow">知名服务名</span>。例如，Web服务也称为http，邮件服务也称为smtp。知名服务名和知名端口之间的映射存储在文件<code>etc/services</code>中。</p>
<p>　　连接的唯一标识是形如<code>(客户端地址:客户端端口, 服务器地址:服务器端口)</code>的<strong>套接字对</strong>，即2个端口的套接字地址。</p>
<h3 id="套接字接口">11.3 套接字接口</h3>
<img src="/2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/overview_of_network_applications_based_on_the_sockets_interface.svg" class="" title="overview_of_network_applications_based_on_the_sockets_interface">
<p>　　套接字接口是一组函数，用于与Unix
I/O函数同时使用来构建网络应用程序。大多数现代操作系统中已经实现了套接字接口，包括Unix的所有版本、Windows和Macintosh。</p>
<p>　　对于网络连接，进程关闭其连接端点后，连接的另一个端口的进程试图从该连接读取数据时，会出现EOF。</p>
<h4 id="套接字地址">11.3.1 套接字地址</h4>
<p>　　从Linux内核角度，套接字就是连接的端点。从Linux程序角度，套接字就是具有对应标识符的打开的文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 互联网套接字地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> sin_family;     <span class="comment">/* 协议族 (总是AF_INET) */</span></span><br><span class="line">    <span class="type">uint16_t</span> sin_port;       <span class="comment">/* 网络字节顺序的端口号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* 网络字节顺序的IP地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通用套接字地址 (对于函数connect、bind和accept) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> sa_family; <span class="comment">/* 协议族 */</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];   <span class="comment">/* 地址数据 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　互联网套接字地址存储在16B的结构体<code>sockaddr_in</code>中，这里的后缀<code>_in</code>表示互联网而非输入。对于网络应用程序，<code>sin_family</code>字段是<code>AF_INET</code>，<code>sin_port</code>字段是16位端口号，<code>sin_addr</code>字段是32位IP地址。IP地址和端口号总是按照网络字节顺序存储。</p>
<p>　　函数<code>connect()</code>、<code>bind()</code>和<code>accept()</code>所需的指针指向协议专属的套接字地址。套接字接口设计者当时碰到的问题是如何让这些函数能适用于各种类型的套接字地址，那时，通用指针<code>void *</code>还不存在。当时的解决方法是定义结构体<code>sockaddr</code>，然后要求应用程序将所有协议专属的套接字地址转换为该结构体。为了简化，这里将结构体<code>sockaddr</code>定义为如下类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">SA</span>;</span></span><br></pre></td></tr></table></figure>
<h4 id="函数socket">11.3.2 函数<code>socket()</code></h4>
<p>　　客户端和服务器通过函数<code>socket()</code>创建<strong>套接字描述符</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>; <span class="comment">/* 若成功则返回非负描述符，若失败则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　若需要让套接字成为连接的端点，可以带有如下参数调用函数<code>socket()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clientfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>　　<code>AF_INET</code>表示使用32位IP地址，<code>SOCK_STREAM</code>表示套接字会成为连接端点。不过，最好的方法是调用函数<code>getaddrinfo()</code>来自动生成这些参数，这样代码就与协议无关。</p>
<p>　　函数<code>socket()</code>返回的描述符<code>clientfd</code>只是部分打开的，还无法进行读写。</p>
<h4 id="函数connect">11.3.3 函数<code>connect()</code></h4>
<p>　　客户端调用函数<code>connect()</code>来与服务器建立连接。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> clientfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>connect()</code>会与服务器建立套接字地址为<code>addr</code>的连接。参数<code>addrlen</code>是<code>sizeof(sockaddr_in)</code>。函数<code>connect()</code>会阻塞，直到连接成功建立或出错。若成功，则描述符<code>clientfd</code>可以进行读写，得到的连接对应的套接字对为<code>(x:y, addr.sin_addr:addr.sin_port)</code>，这里<code>x</code>是客户端的IP地址，<code>y</code>是客户端的端口号。同函数<code>socket()</code>一样，最好的方法是调用函数<code>getaddrinfo()</code>来为函数<code>connect()</code>提供参数。</p>
<h4 id="函数bindlisten和accept">11.3.4
函数<code>bind()</code>、<code>listen()</code>和<code>accept()</code></h4>
<p>　　服务器调用函数<code>bind()</code>、<code>listen()</code>和<code>accept()</code>来与客户端建立连接。</p>
<p>　　客户端是初始化连接请求的主动实体，服务器是等待客户端连接请求的被动实体。默认情况下，内核假设通过函数<code>socket()</code>创建的描述符对应客户端上的<strong>主动套接字</strong>。服务器调用函数<code>listen()</code>来告知内核描述符会被服务器使用，调用函数<code>accept()</code>来等待客户端的连接请求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> listenfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> *addrlen)</span>; <span class="comment">/* 若成功则返回非负描述符，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>bind()</code>会请求内核将服务器的套接字地址<code>addr</code>与套接字描述符<code>sockfd</code>关联。参数<code>addrlen</code>是<code>sizeof(sockaddr_in)</code>。同函数<code>socket()</code>和<code>connect()</code>一样，最好的方法是调用函数<code>getaddrinfo()</code>来为函数<code>bind()</code>提供参数。</p>
<p>　　函数<code>listen()</code>会将<code>sockfd</code>从主动套接字转换为可以接收客户端的连接请求的监听套接字。参数<code>backlog</code>是关于内核在开始拒绝请求前应排队的未完成的连接请求数的提示，其具体含义需要根据超出本书范围的TCP/IP内容，这里将其设置为1024等较大的值。</p>
<p>　　函数<code>accept()</code>会等待客户端的连接请求到达<strong>监听描述符</strong><code>listenfd</code>，然后填充<code>addr</code>中的客户端套接字地址并返回<strong>已连接描述符</strong>。已连接描述符可以用于调用Unix
I/O函数来与客户端通信。</p>
<p>　　监听描述符作为客户端请求连接的端点，它通常只会被创建1次并在服务器的生命周期内会一直存在。已连接描述符是客户端和服务器已建立的连接的端口，它会在服务器每次接收请求连接时被创建并只会在服务器服务对应的客户端时存在。</p>
<img src="/2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/the_roles_of_the_listending_and_connected_descriptors.svg" class="" title="the_roles_of_the_listending_and_connected_descriptors">
<p>　　监听描述符和已连接描述符的作用如图所示。</p>
<p>　　1)
服务器调用函数<code>accept()</code>来等待连接请求到达监听描述符<code>listenfd</code>。由于标准文件占用描述符0~2，这里假设监听描述符的描述符号是3。</p>
<p>　　2)
客户端调用函数<code>connect()</code>来发起到<code>listenfd</code>的连接请求。</p>
<p>　　3)
函数<code>accept()</code>打开新的已连接描述符<code>connfd</code>
(这里假设为描述符4)，建立<code>cliendfd</code>和<code>connfd</code>的连接，然后将<code>connfd</code>返回给应用程序。客户端也从函数<code>connect()</code>返回。此时，客户端和服务器可以读写<code>cliendfd</code>和<code>connfd</code>来传输数据。</p>
<p>　　监听描述符和已连接描述符看似没有必要区分，但事实证明区分两者会很有用，因为这样可以建立能同时处理多个客户端连接的并发服务器。例如，每当连接请求到达监听描述符时，可以派生新进程来通过已连接描述符与客户端通信。</p>
<h4 id="主机和服务的转换">11.3.5 主机和服务的转换</h4>
<p>　　Linux提供了函数<code>getaddrinfo()</code>和<code>getnameinfo()</code>来完成二进制套接字地址与主机名、主机地址、服务名和端口号的字符串形式的相互转换。当它们与套接字接口一同使用时，可以使应用程序独立于IP协议版本。这2个函数分别包含函数<code>inet_pton()</code>和<code>inet_ntop()</code>的功能，而且它们提供独立于任何特定地址格式的更高级抽象。</p>
<h5 id="函数getaddrinfo">11.3.5.1 函数<code>getaddrinfo()</code></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *service, <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **result)</span>; <span class="comment">/* 若成功则返回0，若出错则返回非0错误码 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo *result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">gai_strerror</span><span class="params">(<span class="type">int</span> errcode)</span>; <span class="comment">/* 返回错误信息 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>getaddrinfo()</code>会将主机名、主机地址、服务名和端口号的字符串形式转换为套接字地址，它是过时的函数<code>gethostbyname()</code>和<code>getservbyname()</code>的替代函数。和这些过时的函数不同，该函数是可重入且独立于任何协议的。</p>
<img src="/2023/09/22/computer-systems-a-programmer's-perspective-3e-chpt-11/data_structure_returned_by_function_getaddrinfo.svg" class="" title="data_structure_returned_by_function_getaddrinfo">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> ai_flags;             <span class="comment">/* 提示参数标志 */</span></span><br><span class="line">    <span class="type">int</span> ai_family;            <span class="comment">/* 函数socket的第1个参数 */</span></span><br><span class="line">    <span class="type">int</span> ai_socktype;          <span class="comment">/* 函数socket的第2个参数 */</span></span><br><span class="line">    <span class="type">int</span> ai_protocol;          <span class="comment">/* 函数socket的第3个参数 */</span></span><br><span class="line">    <span class="type">char</span> *ai_canonname;       <span class="comment">/* 规范主机名 */</span></span><br><span class="line">    <span class="type">size_t</span> ai_addrlen;        <span class="comment">/* 结构体ai_addr的大小 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span> <span class="comment">/* 指向套接字地址的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span> <span class="comment">/* 指向后继项的指针 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　给定参数<code>host</code>和<code>service</code>，函数<code>getaddrinfo()</code>返回的<code>result</code>会指向由结构体<code>addrinfo</code>组成的链表，其中的每个元素指向的套接字地址都对应<code>host</code>和<code>service</code>。若函数<code>getaddrinfo()</code>返回非0的错误码，则应用程序可以调用函数<code>gai_strerror()</code>来将错误码转换为错误字符串。默认情况下，函数<code>getaddrinfo()</code>返回的套接字地址能被客户端作为调用函数<code>connect()</code>的主动套接字。</p>
<p>　　参数<code>host</code>可以是主机名和点分十进制IP地址等数字形式的地址。参数<code>service</code>可以是http等服务名和十进制端口号。若无需将主机名转换IP地址，则可以将参数<code>host</code>设置为<code>NULL</code>。服务名也是同样。但是，参数<code>host</code>和<code>service</code><span
style="background-color: yellow">不能</span>全为<code>NULL</code>。</p>
<p>　　可选的参数<code>hints</code>是结构体<code>addrinfo</code>，可以提供对函数<code>getaddrinfo()</code>返回的套接字地址列表的更好的控制。当传递该参数时，只有成员<code>ai_flags</code>、<code>ai_family</code>、<code>ai_socktype</code>和<code>ai_protocol</code>能设置，其他成员必须设置为0或<code>NULL</code>。实际中，可以调用函数<code>memset</code>将结构体<code>addrinfo</code>的所有成员设置为0，然后再按需设置成员。</p>
<p>　　成员<code>ai_flags</code>是用于修改默认行为的位掩码，可以设置为多个值的或运算。</p>
<p>　　●
<code>AI_ADDRCONFIG</code>表示仅当本地主机配置了IPv4时，函数<code>getaddrinfo()</code>会返回IPv4地址。IPv6也是同样。</p>
<p>　　●
<code>ÀI_CANONNAME</code>会让函数<code>getaddrinfo()</code>将列表中第1个结构体<code>addrinfo</code>中的成员<code>ai_cannonname</code>指向主机的规范主机名。</p>
<p>　　●
<code>AI_NUMERICSERV</code>会强制参数<code>service</code>为端口号。</p>
<p>　　●
<code>AI_PASSIVE</code>会让函数<code>getaddrinfo()</code>返回的套接字能被服务器用作监听套接字。这种情况下，参数<code>host</code>必须为<code>NULL</code>。返回的套接字地址的地址字段将会是<span
style="background-color: yellow">通配符地址</span>，通配符地址会告知内核此服务器将接收对此主机的任何IP地址的请求。</p>
<p>　　当函数<code>getaddrinfo()</code>在输出列表创建结构体<code>addrinfo</code>时，会填充除成员<code>ai_flags</code>外的所有成员。成员<code>ai_addr</code>指向套接字地址，成员<code>ai_addrlen</code>表示该套接字地址的大小，成员<code>ai_next</code>指向列表中的下一个结构体<code>addrinfo</code>。</p>
<p>　　默认情况下，函数<code>getaddrinfo()</code>能返回IPv4和IPv6套接字地址。可以将成员<code>ai_family</code>设置为<code>AF_INET</code>来限制为仅返回IPv4地址，或设置为<code>AF_INET6</code>来限制为仅返回IPv6地址。</p>
<p>　　默认情况下，对于主机关联的每个唯一地址，函数<code>getaddrinfo()</code>能返回最多3个结构体<code>addrinfo</code>，它们的成员<code>ai_socktype</code>都不同，分别用于连接、数据报和原始套接字。可以将成员<code>ai_socktype</code>设置为<code>SOCK_STREAM</code>来限制为每个唯一地址最多1个结构体<code>addrinfo</code>，该结构体对应的套接字地址能用作连接端点。</p>
<p>　　当客户端调用函数<code>getaddrinfo()</code>后，会遍历列表并依次尝试套接字地址，直到成功调用函数<code>socket()</code>和<code>connect()</code>并完成连接建立。同样，服务器也会尝试列表中的每个套接字地址，直到成功调用函数<code>socket()</code>和<code>bind()</code>并将描述符绑定到合法的套接字地址。为了防止内存泄漏，应用程序最后必须调用函数<code>freeaddrinfo()</code>来释放列表。</p>
<p>　　函数<code>getaddrinfo()</code>的优点之一是结构体<code>addrinfo</code>的字段是不透明的，因为它们可以直接传递给套接字接口中的函数，应用程序代码无需任何进一步的操作。例如，成员<code>ai_family</code>、<code>ai_socktype</code>和<code>ai_protocol</code>能直接传递给函数<code>socket()</code>。同样，成员<code>ai_addr</code>和<code>ai_addrlen</code>能直接传递给函数<code>connect()</code>和<code>bind()</code>。这个属性允许客户端和服务器独立于任何版本的IP协议。</p>
<h5 id="函数getnameinfo">11.3.5.2 函数<code>getnameinfo()</code></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen, <span class="type">char</span> *host, <span class="type">size_t</span> hostlen, <span class="type">char</span> *service, <span class="type">size_t</span> servlen, <span class="type">int</span> flags)</span>; <span class="comment">/* 若成功则返回0，若出错则返回非0错误码 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>getnameinfo()</code>和函数<code>getaddrinfo()</code>是相反的。该函数会将套接字地址转换为主机名和服务名的字符串形式，它是过时的函数<code>gethostbyaddr()</code>和<code>getservbyport()</code>的替代函数。与这些过时的函数不同，该函数是可重入且独立于任何协议的。</p>
<p>　　参数<code>sa</code>指向<code>salen</code>字节的套接字地址，参数<code>host</code>指向<code>hostlen</code>字节的字符串，参数<code>service</code>指向<code>servlen</code>字节的字符串。若函数<code>getnameinfo()</code>返回非0的错误码，应用程序可以调用函数<code>gai_strerror()</code>将其转换为字符串。</p>
<p>　　若不需要主机名，则可以将<code>host</code>设置为<code>NULL</code>并将<code>hostlen</code>设置为0。服务名也是同样。但是，参数<code>host</code>和<code>service</code><span
style="background-color: yellow">不能</span>全为<code>NULL</code>。</p>
<p>　　参数<code>flags</code>是用于修改默认行为的位掩码，可以设置为多个值的或运算。</p>
<p>　　●
<code>NI_NUMERICHOST</code>会让函数<code>getnameinfo()</code>在参数<code>host</code>中返回数字形式的地址。</p>
<p>　　●
<code>NI_NUMERICSERV</code>会强制函数<code>getnameinfo()</code>跳过查询<code>/etc/services</code>并简单地返回端口号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">p</span>, *<span class="title">listp</span>, <span class="title">hints</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">int</span> rc, flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;domain name&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取结构体addrinfo列表 */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_family = AF_INET;       <span class="comment">/* 仅限IPv4 */</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">/* 仅限连接 */</span></span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(argv[<span class="number">1</span>], <span class="literal">NULL</span>, &amp;hints, &amp;listp)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;getaddrinfo error: %s\n&quot;</span>, gai_strerror(rc));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历列表并输出每个IP地址 */</span></span><br><span class="line">    flags = NI_NUMERICHOST; <span class="comment">/* 输出地址字符串而非域名 */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        Getnameinfo(p-&gt;ai_addr, p-&gt;ai_addrlen, buf, MAXLINE, <span class="literal">NULL</span>, <span class="number">0</span>, flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放 */</span></span><br><span class="line">    Freeaddrinfo(listp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会调用函数<code>getaddrinfo()</code>和<code>getnameinfo()</code>来输出域名和IP地址的映射，它和<code>nslookup</code>类似。首先，初始化函数<code>getaddrinfo()</code>的参数<code>hints</code>，这里是用于连接端点的32位IP地址
(第15~16行)。因为这里只需要获取域名，所以将函数<code>getaddrinfo()</code>的参数<code>service</code>设置为<code>NULL</code>。</p>
<p>　　调用函数<code>getaddrinfo()</code>后，会遍历结构体<code>addrinfo</code>列表并通过函数<code>getnameinfo()</code>将每个套接字地址转换为点分十进制地址字符串。遍历完成后，会调用函数<code>freeaddrinfo()</code>来释放该列表
(尽管对这个示例不是必需的)。</p>
<h4 id="套接字接口的辅助函数">11.3.6 套接字接口的辅助函数</h4>
<p>　　函数<code>getaddrinfo()</code>和套接字接口看似有些麻烦，这里会实现更高级的包装它们的辅助函数<code>open_clientfd()</code>和<code>open_listenfd()</code>，客户端和服务器可以使用这2个函数来进行通信。</p>
<h5 id="函数open_clientfd">11.3.6.1
函数<code>open_clientfd()</code></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 若成功则返回描述符，若出错则返回-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param hostname 服务器的主机名</span></span><br><span class="line"><span class="comment"> * @param port 服务器的端口号</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open_clientfd</span><span class="params">(<span class="type">char</span> *hostname, <span class="type">char</span> *port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> clientfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">listp</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取潜在的服务器地址列表 */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">/* 打开连接 */</span></span><br><span class="line">    hints.ai_flags = AI_NUMERICSERV; <span class="comment">/* 使用数字端口号参数 */</span></span><br><span class="line">    hints.ai_flags |= AI_ADDRCONFIG;</span><br><span class="line">    Getaddrinfo(hostname, port, &amp;hints, &amp;listp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历列表来获取可连接的服务器 */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 创建套接字描述符 */</span></span><br><span class="line">        <span class="keyword">if</span> ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* 连接失败，尝试下一个 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 连接服务器 */</span></span><br><span class="line">        <span class="keyword">if</span> (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* 成功 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        Close(clientfd); <span class="comment">/* 连接失败，尝试其他 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放 */</span></span><br><span class="line">    Freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">/* 所有连接失败 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* 最后1个连接成功 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> clientfd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　客户端可以调用函数<code>open_clientfd()</code>来与运行在主机<code>hostname</code>上的监听端口<code>port</code>上的连接请求的服务器建立连接，它会返回打开的套接字描述符，该套接字描述符可以通过Unix
I/O函数来进行输入和输出。</p>
<p>　　调用函数<code>getaddrinfo()</code>后，返回的由结构体<code>addrinfo</code>组成的列表中的每个元素都指向可用于建立连接的套接字地址。然后，遍历该列表中的每个元素，直到成功调用函数<code>socket()</code>和<code>connect()</code>。若调用函数<code>connect()</code>失败，则会在尝试下一个元素前关闭套接字描述符；若调用函数<code>connect()</code>成功，则释放列表并返回套接字描述符给客户端。</p>
<h5 id="函数open_listenfd">11.3.6.2
函数<code>open_listenfd()</code></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LISTENQ 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 若成功则返回描述符，若出错则返回-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param port 端口号</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open_listenfd</span><span class="params">(<span class="type">char</span> *port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">listp</span>, *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">int</span> listenfd, optval = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取潜在的服务器地址列表 */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;             <span class="comment">/* 接受连接 */</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; <span class="comment">/* 任何IP地址 */</span></span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV;            <span class="comment">/* 使用端口号 */</span></span><br><span class="line">    Getaddrinfo(<span class="literal">NULL</span>, port, &amp;hints, &amp;listp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历列表来获取可绑定的服务器 */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 创建套接字描述符 */</span></span><br><span class="line">        <span class="keyword">if</span> ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* 调用函数socket失败，尝试下一个 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 消除函数bind中的地址已使用错误 */</span></span><br><span class="line">        Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (<span class="type">const</span> <span class="type">void</span> *)&amp;optval, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将描述符和地址绑定 */</span></span><br><span class="line">        <span class="keyword">if</span> (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* 成功 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        Close(listenfd); <span class="comment">/* 调用函数bind失败，尝试下一个 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放 */</span></span><br><span class="line">    Freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">/* 没有合适的地址 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 让监听套接字准备好接收连接请求 */</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, LISTENQ) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Close(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　服务器可以调用函数<code>open_listenfd()</code>来获取可以接收端口<code>port</code>上的连接请求的监听描述符。</p>
<p>　　与函数<code>open_clientfd()</code>有些类似，调用函数<code>getaddrinfo()</code>后，会遍历结果列表，直到成功调用函数<code>socket()</code>和<code>connect()</code>。第29行的函数<code>setsockopt()</code>会设置服务器，使其能被终止、被重启和立即重新接收连接请求。默认情况下，重启服务器后大约30s内不会接受连接请求，这会严重妨碍调试。</p>
<p>　　调用函数<code>getaddrinfo()</code>时，参数<code>flag</code>中有<code>AI_PASSIV</code>，参数<code>host</code>为<code>NULL</code>，所以每个套接字地址中的地址字段都会被设置为通配符地址，即告知内核此服务器将接收对此主机的任何IP地址的请求。</p>
<p>　　最后，调用函数<code>listen()</code>将<code>listenfd</code>转换为监听描述符并将其返回给调用者。若调用函数<code>listen()</code>失败，会在返回前将描述符关闭来避免内存泄漏。</p>
<h4 id="echo客户端和服务器示例">11.3.7 echo客户端和服务器示例</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief echo客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> clientfd;</span><br><span class="line">    <span class="type">char</span> *host, *port, buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;host&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    host = argv[<span class="number">1</span>];</span><br><span class="line">    port = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    clientfd = Open_clientfd(host, port);</span><br><span class="line">    Rio_readinitb(&amp;rio, clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Rio_writen(clientfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        Rio_readlineb(&amp;rio, buf, MAXLINE);</span><br><span class="line">        Fputs(buf, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(clientfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于echo客户端，在建立与服务器的连接后，它会进入从标准输入读取文本行，发送文本行到服务器，从服务器读取echo行以及输出结果到标准输出的循环。当函数<code>fget()</code>在标准输入遇到EOF、键盘输入Ctrl+D或读取完重定向输入文件的文本行时，循环终止。</p>
<p>　　当循环终止时，客户端会关闭描述符，这会导致发送EOF通知给服务器。当服务器从函数<code>rio_readlineb()</code>中收到的返回值为0时，它就检测该通知。关闭描述符后，客户端会终止。当程序关闭时，内核会关闭程序打开的描述符，所以，第29行的函数<code>close()</code>不是必要的。但是，显式关闭打开的描述符是良好的编程习惯之一。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 读并回显文本行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param connfd 已连接描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %d bytes\n&quot;</span>, (<span class="type">int</span>)n);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief echo服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span> <span class="comment">/* 足够的空间来容纳任何地址 */</span></span><br><span class="line">    <span class="type">char</span> client_hostname[MAXLINE], client_port[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Getnameinfo((SA *)&amp;clientaddr, clientlen, client_hostname, MAXLINE, client_port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connected to (%s, %s)\n&quot;</span>, client_hostname, client_port);</span><br><span class="line">        echo(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于echo服务器，在打开监听描述符后，它会进入无限循环。每次迭代会等待来自客户端的连接请求，输出客户端的主机名和端口，然后调用函数<code>echo()</code>来服务客户端。从函数<code>echo()</code>返回后，服务器会关闭已连接描述符。一旦客户端和服务器关闭各自的描述符后，连接会终止。这里的服务器每次只能处理1个客户端，这种类型的服务器称为<strong>迭代服务器</strong>。相反，同时能处理多个客户端的服务器称为<strong>并发服务器</strong>。</p>
<p>　　第28行的变量<code>clientaddr</code>是将作为参数传递给函数<code>accept()</code>的套接字地址。在函数<code>accept()</code>返回前，会用客户端的套接字地址来填充<code>clientaddr</code>，这里<code>clientaddr</code>的类型是<code>struct sockaddr_storage</code>，该类型足以容纳任何类型的套接字地址，这样代码就与协议无关。</p>
<p>　　函数<code>echo()</code>会反复读写文本行，直到函数<code>rio_readlineb()</code>遇到EOF
(第13行)。</p>
<h3 id="web服务器">11.4 Web服务器</h3>
<p>　　相比FTP等常规的文件检索服务，Web服务的内容使用的是HTML。HTML页包含指示浏览如何显示各种文本和图形对象的标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Make me bold!<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.cmu.edu/index.html&quot;</span>&gt;</span>Carnegie Mellon<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　第1行代码会告知浏览器将<code>&lt;b&gt;</code>和<code>&lt;/b&gt;</code>标签之间的文本加粗。第2行代码会告知浏览器高亮<code>&lt;a&gt;</code>和<code>&lt;/a&gt;</code>标签之间的文本并创建到HTML文件<code>index.html</code>的超链接，该HTML文件存放在Web服务器上。若用户点击高亮的文本对象，浏览器会从Web服务器请求对应的HTML文件并显示它。</p>
<h4 id="web内容">11.4.1 Web内容</h4>
<p>　　对于Web客户端和服务器，<strong>内容</strong>就是关联MIME类型的字节序列。</p>
<table>
<thead>
<tr>
<th>MIME类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>text/html</code></td>
<td>HTML页</td>
</tr>
<tr>
<td><code>text/plain</code></td>
<td>未格式化的文本</td>
</tr>
<tr>
<td><code>application/postscript</code></td>
<td>Postscript文档</td>
</tr>
<tr>
<td><code>image/gif</code></td>
<td>GIF格式编码的二进制图像</td>
</tr>
<tr>
<td><code>image/png</code></td>
<td>PNG格式编码的二进制图像</td>
</tr>
<tr>
<td><code>image/jpeg</code></td>
<td>JPEG格式编码的二进制图像</td>
</tr>
</tbody>
</table>
<p>　　Web服务器通过以下2种方式提供内容给客户端：</p>
<p>　　● <span
style="background-color: yellow">取磁盘文件并将其内容返回给客户端</span>。该磁盘文件称为<strong>静态内容</strong>。将磁盘文件返回给客户端的过程称为<strong>服务静态内容</strong>。</p>
<p>　　● <span
style="background-color: yellow">运行可执行文件并将其输出返回给客户端</span>。可执行文件在运行时产生的输出称为<strong>动态内容</strong>。运行程序并将其输出返回给客户端的过程称为<strong>服务动态内容</strong>。</p>
<p>　　Web服务器返回的每条内容都关联其管理的某些文件，这些文件都有称为URL的唯一名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.google.com:80/index.html</span><br></pre></td></tr></table></figure>
<p>　　该URL标识主机<code>www.google.com</code>上的HTML文件<code>/index.html</code>，该文件由监听80端口的Web服务器管理。</p>
<p>　　可执行文件的URL能包含程序参数，即文件名加上<code>?</code>，再加上<code>&amp;</code>分隔的参数。参数中不允许出现特殊字符，这些特殊字符需要转换为ASCII码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://bluefish.ics.cs.cmu.edu:8000/cgi-bin/adder?15000&amp;213</span><br></pre></td></tr></table></figure>
<p>　　该URL标识可执行文件<code>/cgi-bin/adder</code>，并且带有2个参数字符串<code>15000</code>和<code>213</code>。</p>
<p>　　在事务中，客户端和服务器使用URL的不同部分。例如，客户端使用前缀<code>https://www.google.com:80</code>来决定服务器的类型、位置和监听端口。服务器使用后缀<code>/index</code>来在文件系统中查找文件并决定请求的是静态内容还是动态内容。</p>
<p>　　没有标准规定来确定URL引用的静态内容还是动态内容，所以每个服务器都有自己的规定。经典方法之一是将所有可执行文件存放在某组目录。</p>
<p>　　URL中的<code>/</code>并不表示Linux的根目录，它表示请求内容类型的主目录。例如，某个服务器可能设置为将所有静态内容和所有动态内容分别存储在<code>/usr/httpd/html</code>和<code>/usr/httpd/cgi-bin</code>中。</p>
<p>　　URL中最短的后缀是<code>/</code>，所有服务器会将其扩展为某个默认的主页，例如，<code>/index.html</code>。因此，可以直接在浏览器输入域名来访问主页。浏览器会给URL附上缺失的<code>/</code>并传递给服务器，服务器将其扩展给某个默认的文件名。</p>
<h4 id="http事务">11.4.2 HTTP事务</h4>
<p>　　由于HTTP是基于网络连接的文本行，可以使用Linux的程序<code>telnet</code>来与网络上的所有Web服务器执行事务。<code>telnet</code>程序在很大程度被远程登录工具ssh取代，但对于调试通过基于连接的文本行来与客户端通信的服务器很有用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linux&gt; telnet www.aol.com 80        客户端: 打开到服务器的连接</span><br><span class="line">Trying 205.188.146.23...            telnet打印3行到终端</span><br><span class="line">Connected to aol.com.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">GET / HTTP/1.1                      客户端: 请求行</span><br><span class="line">Host: www.aol.com                   客户端: 请求的HTTP/1.1首部</span><br><span class="line">                                    客户端: 终止首部的空行</span><br><span class="line">HTTP/1.0 200 OK                     服务器: 响应行</span><br><span class="line">MIME-Version: 1.0                   服务器: 紧接的5行响应首部</span><br><span class="line">Date: Mon, 8 Jan 2010 4:59:42 GMT</span><br><span class="line">Server: Apache-Coyote/1.1</span><br><span class="line">Content-Type: text/html             服务器: 响应体预计是HTML</span><br><span class="line">Content-Length: 42092               服务器: 响应体预计有42092字节</span><br><span class="line">                                    服务器: 终止响应首部的空行</span><br><span class="line">&lt;html&gt;                              服务器: 响应体中第1行HTML</span><br><span class="line">...                                 服务器: 766行HTML未展示</span><br><span class="line">&lt;/html&gt;                             服务器: 响应体中最后1行HTML</span><br><span class="line">Connection closed by foreign host.  服务器: 关闭连接</span><br><span class="line">linux&gt;                              服务器: 关闭连接和终端</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，第1行会打开到AOL
Web服务器的连接。<code>telnet</code>打印3行输出到终端，打开连接并等待用户输入
(第5行)。当输入文本行并按下enter键时，<code>telnet</code>读该行，附上回车符和换行符
(C语言中的<code>\r\n</code>)
并发送给服务器。这与HTTP标准相符，HTTP标准要求每个文本行都<span
style="background-color: yellow">以回车符和换行符结尾</span>。为了初始化事务，输入HTTP请求
(第5~7行)。服务器返回HTTP响应并关闭连接 (第8~18行)。</p>
<h5 id="http请求">11.4.2.1 HTTP请求</h5>
<p>　　HTTP请求由请求行 (第5行)、若干行请求首部 (第6行)、终止首部的空行
(第7行) 和请求体组成。请求行的格式为<code>方法 URI 版本</code>。</p>
<p>　　HTTP支持多种<strong>方法</strong>，包括<code>PUT</code>、<code>POST</code>、<code>OPTIONS</code>、<code>HEAD</code>、<code>PUT</code>、<code>DELETE</code>和<code>TRACE</code>。</p>
<p>　　●
<code>GET</code>方法指示服务器生成并返回由URI标识的内容。当服务器请求内容时，URI是对应URL的后缀
(包括文件名和参数)。但是，代理服务器请求内容时，URI必须是完整的URL。</p>
<p>　　● <code>POST</code>方法的参数通过请求体传递。</p>
<p>　　请求行的<strong>版本</strong>表示请求的HTTP版本。HTTP/1.0诞生于1996年，HTTP/1.1在其基础上加上了额外的首部，用于提供缓存、安全以及允许客户端和服务器在同一<span
style="background-color: yellow">持久连接</span>上执行多个事务等功能。实际上，这2个版本是兼容的，HTTP/1.0会直接忽略HTTP/1.1首部。</p>
<p>　　综上所述，第5行的请求行会请求服务器返回HTML文件<code>/index.html</code>，并且版本为HTTP/1.1。</p>
<p>　　请求首部会提供额外信息给服务器，例如，浏览器的品牌名和MIME类型。请求首部的格式为<code>首部名: 首部数据</code>。这里仅关注首部<code>Host</code>
(第6行)，该首部是HTTP/1.1必需的。<strong>代理缓存</strong>会使用首部<code>Host</code>，代理缓存有时作为浏览器和管理被请求文件的<strong>原始服务器</strong>之间的中转。客户端和原始服务器之间可以有多个代理，称为<strong>代理链</strong>。首部<code>Host</code>的数据标识原始服务器的域名，使得代理链中的代理能够判断它是否可以在本地缓存中拥有所请求内容的副本。</p>
<p>　　第7行的空行 (通过输入回车键生成)
终止首部并指示服务器发送所请求的HTML文件。</p>
<h5 id="http响应">11.4.2.2 HTTP响应</h5>
<p>　　HTTP响应与HTTP请求类似，HTTP响应包含响应行
(第8行)、若干行响应首部 (第9~13行)、终止首部的空行 (第14行) 以及响应体
(第15~17行)。响应行的格式为<code>版本 状态码 状态信息</code>。</p>
<p>　　版本字段表示响应体的支持的HTTP版本。状态码字段是表示请求状态的3位数的正整数。状态信息字段表示错误码的英文描述。</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th>状态码</th>
<th>状态信息</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK</td>
<td>请求被正常处理</td>
</tr>
<tr>
<td>301</td>
<td>Moved permanently</td>
<td>内容已移动到首部<code>Location</code>中的主机名</td>
</tr>
<tr>
<td>400</td>
<td>Bad request</td>
<td>服务器无法解析请求</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器无权访问所请求的文件</td>
</tr>
<tr>
<td>404</td>
<td>Not found</td>
<td>服务器找不到所请求的文件</td>
</tr>
<tr>
<td>501</td>
<td>Not implemented</td>
<td>服务器不支持请求方法</td>
</tr>
<tr>
<td>505</td>
<td>HTTP version not supported</td>
<td>服务器不支持所请求的版本</td>
</tr>
</tbody>
</table>
<p>　　响应首部提供关于响应的额外信息
(第9~13行)，这里仅介绍首部<code>Content-Type</code>和<code>Content-Length</code>。前者表示响应体中的内容的MIME类型，后者表示响应体中的内容的大小
(单位是字节)。</p>
<p>　　第14行的空行终止首部，其后是包含所请求内容的响应体。</p>
<h4 id="服务动态内容">11.4.3 服务动态内容</h4>
<p>　　CGI定义了CGI程序在运行时可以设置的很多环境变量。</p>
<table>
<thead>
<tr>
<th>环境变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QUERY_STRING</code></td>
<td>程序参数</td>
</tr>
<tr>
<td><code>SERVER_PORT</code></td>
<td>父进程正在监听的端口</td>
</tr>
<tr>
<td><code>REQUEST_METHOD</code></td>
<td><code>GET</code>或<code>POST</code></td>
</tr>
<tr>
<td><code>REMOTE_HOST</code></td>
<td>客户端域名</td>
</tr>
<tr>
<td><code>REMOTE_ADDR</code></td>
<td>客户端点分十进制IP地址</td>
</tr>
<tr>
<td><code>CONTENT_TYPE</code></td>
<td>请求体的MIME类型 (仅限<code>POST</code>方法)</td>
</tr>
<tr>
<td><code>CONTENT_LENGTH</code></td>
<td>请求体的以字节为单位的大小 (仅限<code>POST</code>方法)</td>
</tr>
</tbody>
</table>
<p>　　在服务器收到请求后，例如，<code>GET /cgi-bin/adder?15000&amp;213 HTTP/1.1</code>，它会调用函数<code>fork()</code>来创建子进程并在子进程的上下文调用函数<code>execve()</code>来运行程序<code>/cgi-bin/adder</code>。类似<code>adder</code>的程序通常称为<span
style="background-color: yellow">CGI程序</span>，因为它们遵循CGI标准。在调用函数<code>execve()</code>前，子进程会将环境变量<code>QUERY_STRING</code>设置为<code>15000&amp;213</code>，程序<code>adder</code>能在运行时使用Linux函数<code>getenv()</code>引用。</p>
<p>　　CGI程序会传递其动态内容到标准输出。在子进程加载和运行CGI程序前，它会调用Linux函数<code>dup2()</code>来将标准输出重定向到与客户端关联的已连接描述符。因此，CGI程序对标准输出的所有写操作会重定向到客户端。</p>
<p>　　父进程并不知道子进程生成内容的大小和类型，所以子进程需要生成响应首部中的<code>Content-Type</code>、<code>Content-Length</code>和终止响应首部的空行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *buf, *p;</span><br><span class="line">    <span class="type">char</span> arg1[MAXLINE], arg2[MAXLINE], content[MAXLINE];</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提取2个参数 */</span></span><br><span class="line">    <span class="keyword">if</span> ((buf = getenv(<span class="string">&quot;QUERY_STRING&quot;</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">        *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(arg1, buf);</span><br><span class="line">        <span class="built_in">strcpy</span>(arg2, p + <span class="number">1</span>);</span><br><span class="line">        n1 = atoi(arg1);</span><br><span class="line">        n2 = atoi(arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造响应体 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;QUERY_STRING=%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;Welcome to add.com: &quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;%sThe Internet addition portal.\r\n&lt;p&gt;&quot;</span>, content);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;%sThe answer is: %d + %d = %d\r\n&lt;p&gt;&quot;</span>, content, n1, n2, n1 + n2);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;%sThanks for visiting!\r\n&quot;</span>, content);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造HTTP响应 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Connection: close\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content-length: %d\r\n&quot;</span>, (<span class="type">int</span>)<span class="built_in">strlen</span>(content));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content-type: text/html\r\n\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, content);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会计算2个参数的和并返回带有结果的HTML文件给客户端。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linux&gt; telnet kittyhawk.cmcl.cs.cmu.edu 8000        客户端: 打开连接</span><br><span class="line">Trying 128.2.194.242...</span><br><span class="line">Connected to kittyhawk.cmcl.cs.cmu.edu.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">GET /cgi-bin/adder?15000&amp;213 HTTP/1.0               客户端: 请求行</span><br><span class="line">                                                    客户端: 终止首部的空行</span><br><span class="line">HTTP/1.0 200 OK                                     服务器: 响应行</span><br><span class="line">Server: Tiny Web Server                             服务器: 标识服务器</span><br><span class="line">Content-length: 115                                 Adder: 响应体预计有115字节</span><br><span class="line">Content-type: text/html                             Adder: 响应体预计是HTML</span><br><span class="line">                                                    Adder: 终止首部的空行</span><br><span class="line">Welcome to add.com: THE Internet addition portal.   Adder: 响应体中第1行HTML</span><br><span class="line">&lt;p&gt;The answer is: 15000 + 213 = 15213               Adder: 响应体中第2行HTML</span><br><span class="line">&lt;p&gt;Thanks for visiting!                             Adder: 响应体中第3行HTML</span><br><span class="line">Connection closed by foreign host.                  服务器: 关闭连接</span><br><span class="line">linux&gt;                                              客户端: 关闭连接和终端</span><br></pre></td></tr></table></figure>
<p>　　这个示例是某个HTTP事务，它提供程序<code>adder</code>的动态内容。</p>
<h3 id="tiny-web服务器">11.5 TINY Web服务器</h3>
<p>　　这里将实现称为TINY的Web服务器，它结合了进程控制、Unix
I/O、套接字接口和HTTP。虽然它缺乏了真实服务器的功能性、可靠性和安全性，但足以提供静态和动态内容给真实浏览器。TINY是基于HTTP/1.0的简单迭代服务器，使用<code>GET</code>方法提供静态内容和动态内容。</p>
<p>　　若服务器写已被客户端关闭的连接，第1次写会正常返回，第2次写会导致发送信号SIGPIPE，该信号的默认行为是关闭进程。若信号SIGPIPE被捕获或忽略，则第2次写操作会返回-1并将<code>errno</code>设置为<code>EPIPE</code>。函数<code>strerr()</code>和<code>perror()</code>会将错误<code>EPIPE</code>报告为
"Broken pipe"，这个信息并不直观。</p>
<h4 id="主函数">11.5.1 主函数</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">doit</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_requesthdrs</span><span class="params">(<span class="type">rio_t</span> *rp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">parse_uri</span><span class="params">(<span class="type">char</span> *uri, <span class="type">char</span> *filename, <span class="type">char</span> *cgiargs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_filetype</span><span class="params">(<span class="type">char</span> *filename, <span class="type">char</span> *filetype)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_static</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *filename, <span class="type">int</span> filesize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_dynamic</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *filename, <span class="type">char</span> *cgiargs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clienterror</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *cause, <span class="type">char</span> *errnum, <span class="type">char</span> *shortmsg, <span class="type">char</span> *longmsg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">char</span> hostname[MAXLINE], port[MAXLINE];</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查命令行参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Getnameinfo((SA *)&amp;clientaddr, clientlen, hostname, MAXLINE, port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);</span><br><span class="line">        doit(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是TINY的主函数，它监听连接请求的端口通过命令行传递。在调用函<code>open_listenfd()</code>打开监听套接字后，TINY会进行常规的服务器无限循环——反复接收连接请求
(第28行)、执行事务 (第31行) 和关闭连接端点 (第32行)。</p>
<h4 id="函数doit">11.5.2 函数<code>doit()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理HTTP事务</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param fd 文件描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">doit</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> is_static;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="type">char</span> filename[MAXLINE], cgiargs[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读请求行和首部 */</span></span><br><span class="line">    Rio_readinitb(&amp;rio, fd);</span><br><span class="line">    Rio_readlineb(&amp;rio, buf, MAXLINE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Request headers:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        clienterror(fd, method, <span class="string">&quot;501&quot;</span>, <span class="string">&quot;Not implemented&quot;</span>, <span class="string">&quot;Tiny does not implement this method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    read_requesthdrs(&amp;rio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从请求中解析URI */</span></span><br><span class="line">    is_static = parse_uri(uri, filename, cgiargs);</span><br><span class="line">    <span class="keyword">if</span> (stat(filename, &amp;sbuf) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clienterror(fd, filename, <span class="string">&quot;404&quot;</span>, <span class="string">&quot;Not found&quot;</span>, <span class="string">&quot;Tiny couldn&#x27;t find this file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_static)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 服务静态内容 */</span></span><br><span class="line">        <span class="keyword">if</span> (!(S_ISREG(sbuf.st_mode)) || !(S_IRUSR &amp; sbuf.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line">            clienterror(fd, filename, <span class="string">&quot;403&quot;</span>, <span class="string">&quot;Forbidden&quot;</span>, <span class="string">&quot;Tiny couldn&#x27;t read the file&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        serve_static(fd, filename, sbuf.st_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 服务动态内容 */</span></span><br><span class="line">        <span class="keyword">if</span> (!(S_ISREG(sbuf.st_mode)) || !(S_IXUSR &amp; sbuf.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line">            clienterror(fd, filename, <span class="string">&quot;403&quot;</span>, <span class="string">&quot;Forbidden&quot;</span>, <span class="string">&quot;Tiny couldn&#x27;t run the CGI program&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        serve_dynamic(fd, filename, cgiargs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>doit()</code>会处理HTTP事务。首先，读并解析请求行
(第16~19行)，这里使用函数<code>rio_readlineb()</code>来读取请求行。</p>
<p>　　TINY仅支持<code>GET</code>方法。若客户端请求其他方法，则发送错误信息并返回到主函数
(第20~24行)，主函数会关闭连接并等待下一个连接请求；否则，进行读操作并忽略所有请求首部
(第25行)。</p>
<p>　　然后，解析URI为文件名和CGI参数字符串，这里使用了1个标志来指示请求的是静态内容还是动态内容
(第28行)。若在磁盘上找不到所请求的文件，则立即发送错误信息给客户端并返回。</p>
<p>　　最后，当请求的是静态内容时，会验证该文件是否是普通文件以及是否有读权限
(第38行)，若是，则提供静态内容给客户端
(第43行)。当请求的是动态内容，会验证该文件是否是可执行文件，若是，则提供动态内容
(第53行)。</p>
<h4 id="函数clienterror">11.5.3 函数<code>clienterror()</code></h4>
<p>　　TINY缺乏真实服务器的多种错误处理功能。但是，它会检查一些常见的错误并反馈给客户端。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 发送错误信息给客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param fd 文件描述符</span></span><br><span class="line"><span class="comment"> * @param cause 原因</span></span><br><span class="line"><span class="comment"> * @param errnum 错误码</span></span><br><span class="line"><span class="comment"> * @param shortmsg 短信息</span></span><br><span class="line"><span class="comment"> * @param longmsg 长信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clienterror</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *cause, <span class="type">char</span> *errnum, <span class="type">char</span> *shortmsg, <span class="type">char</span> *longmsg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], body[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构建HTTP响应体 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;&lt;html&gt;&lt;title&gt;Tiny Error&lt;/title&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;body bgcolor=&quot;</span><span class="string">&quot;ffffff&quot;</span><span class="string">&quot;&gt;\r\n&quot;</span>, body);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s%s: %s\r\n&quot;</span>, body, errnum, shortmsg);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;p&gt;%s: %s\r\n&quot;</span>, body, longmsg, cause);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;hr&gt;&lt;em&gt;The Tiny Web server&lt;/em&gt;\r\n&quot;</span>, body);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印HTTP响应 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 %s %s\r\n&quot;</span>, errnum, shortmsg);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: text/html\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-length: %d\r\n\r\n&quot;</span>, (<span class="type">int</span>)<span class="built_in">strlen</span>(body));</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    Rio_writen(fd, body, <span class="built_in">strlen</span>(body));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>clienterror()</code>会发送HTTP响应给客户端，响应行会包含合适的状态码和状态信息，响应体会包含解释错误的HTML文件。</p>
<p>　　HTTP响应需要指明大小和内容类型，所以选择将HTTP内容构建为单个字符串，这样易于判断其大小。这里对所有的输出使用了函数<code>rio_writen()</code>。</p>
<h4 id="函数read_requesthdrs">11.5.4
函数<code>read_requesthdrs()</code></h4>
<p>　　TINY不会使用请求首部中的任何信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 读并忽略请求首部</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rp 指向读缓冲区的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_requesthdrs</span><span class="params">(<span class="type">rio_t</span> *rp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">    Rio_readlineb(rp, buf, MAXLINE);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;\r\n&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Rio_readlineb(rp, buf, MAXLINE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>read_requsethdrs()</code>会读并忽略请求首部。第11行会检查终止请求首部的空行
(以<code>\r\n</code>结束)。</p>
<h4 id="函数parse_uri">11.5.5 函数<code>parse_uri()</code></h4>
<p>　　TINY会假设静态内容的主目录是当前目录，可执行文件的主目录是<code>./cgi-bin</code>。所有包含字符串<code>./cgi-bin</code>的URI都会被假设为动态内容请求。默认文件名是<code>./home.html</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 解析HTTP URI</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param uri</span></span><br><span class="line"><span class="comment"> * @param filename 文件名</span></span><br><span class="line"><span class="comment"> * @param cgiargs CGI参数</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parse_uri</span><span class="params">(<span class="type">char</span> *uri, <span class="type">char</span> *filename, <span class="type">char</span> *cgiargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(uri, <span class="string">&quot;cgi-bin&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 静态内容 */</span></span><br><span class="line">        <span class="built_in">strcpy</span>(cgiargs, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(filename, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(filename, uri);</span><br><span class="line">        <span class="keyword">if</span> (uri[<span class="built_in">strlen</span>(uri) - <span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcat</span>(filename, <span class="string">&quot;home.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 动态内容 */</span></span><br><span class="line">        ptr = index(uri, <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(cgiargs, ptr + <span class="number">1</span>);</span><br><span class="line">            *ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(cgiargs, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(filename, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(filename, uri);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>parse_uri()</code>会将URI解析为文件名和可选的CGI参数字符串。若请求的是静态内容
(第13行)，则清除CGI参数字符串并将URI转换为对应的Linux路径名
(第16~17行)，若URI以<code>/</code>结尾，则附上默认文件名
(第21行)；若请求的是动态内容，则提取CGI参数 (第28~37行)
并将URI的剩余部分转换为相关的Linux文件名 (第38~39行)。</p>
<h4 id="函数serve_static">11.5.6 函数<code>serve_static()</code></h4>
<p>　　TINY提供5种类型的静态内容，即HTML文件、未格式化的文本文件、GIF格式图片、PNG格式图片和JPEG格式图片。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据文件名获取文件类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param filename 文件名</span></span><br><span class="line"><span class="comment"> * @param filetype 文件类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_filetype</span><span class="params">(<span class="type">char</span> *filename, <span class="type">char</span> *filetype)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">&quot;.html&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">&quot;.gif&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;image/gif&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">&quot;.png&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;image/png&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">&quot;.jpg&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 提供静态内容给客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param fd 文件描述符</span></span><br><span class="line"><span class="comment"> * @param filename 文件名</span></span><br><span class="line"><span class="comment"> * @param filesize 文件大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_static</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *filename, <span class="type">int</span> filesize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> srcfd;</span><br><span class="line">    <span class="type">char</span> *srcp, filetype[MAXLINE], buf[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送响应首部到客户端 */</span></span><br><span class="line">    get_filetype(filename, filetype);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%sServer: Tiny Web Server\r\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%sConnection: close\r\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%sContent-length: %d\r\n&quot;</span>, buf, filesize);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%sContent-type: %s\r\n\r\n&quot;</span>, buf, filetype);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Response headers:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送响应体到客户端 */</span></span><br><span class="line">    srcfd = Open(filename, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    srcp = Mmap(<span class="number">0</span>, filesize, PROT_READ, MAP_PRIVATE, srcfd, <span class="number">0</span>);</span><br><span class="line">    Close(srcfd);</span><br><span class="line">    Rio_writen(fd, srcp, filesize);</span><br><span class="line">    Munmap(srcp, filesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>serve_static()</code>会发送HTTP响应到客户端，响应体包含本地文件的内容。首先，根据文件名的后缀来决定文件类型
(第44行)，发送响应行和响应首部到客户端，这里包含终止首部的空行
(第45~50行)。</p>
<p>　　然后，将所请求的文件复制到已连接描述符<code>fd</code>来发送响应体。第55行会打开<code>filename</code>来读和获取描述符。第56行会调用函数<code>mmap()</code>来将所请求的文件映射到虚拟内存区域，即将文件<code>srcfd</code>的前<code>filesize</code>字节映射到虚拟内存中地址<code>srcp</code>处的私有只读区域。</p>
<p>　　将文件映射到内存后，就不会再使用它的描述符，所以需要关闭文件
(第57行)。第58行才会真正将文件传输给客户端。函数<code>rio_writen()</code>会将位置<code>srcp</code>处的<code>filesize</code>字节
(被映射到所请求的文件)
复制到客户端的已连接描述符。最后，第59行会释放映射的虚拟内存区域。</p>
<h4 id="函数serve_dynamic">11.5.7 函数<code>serve_dynamic()</code></h4>
<p>　　TINY通过派生子进程来提供任何类型的动态内容，然后在子进程的上下文中运行CGI程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 提供动态内容给客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param fd 文件描述符</span></span><br><span class="line"><span class="comment"> * @param filename 文件名</span></span><br><span class="line"><span class="comment"> * @param cgiargs CGI参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_dynamic</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *filename, <span class="type">char</span> *cgiargs)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], *emptylist[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送HTTP响应的第1部分 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Server: Tiny Web Server\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 子进程 */</span></span><br><span class="line">    <span class="keyword">if</span> (Fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 真实服务器会在这里设置所有的CGI变量 */</span></span><br><span class="line">        setenv(<span class="string">&quot;QUERY_STRING&quot;</span>, cgiargs, <span class="number">1</span>);</span><br><span class="line">        Dup2(fd, STDOUT_FILENO);              <span class="comment">/* 将标准输出重定向到客户端 */</span></span><br><span class="line">        Execve(filename, emptylist, environ); <span class="comment">/* 运行CGI程序 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    Wait(<span class="literal">NULL</span>); <span class="comment">/* 父进程等待并回收子进程 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>serve_dynamic()</code>会先给客户端发送表明成功的响应行和包含信息的首部<code>Server</code>。CGI程序负责发送HTTP响应的剩余部分。这里并没有考虑CGI程序可能会碰到某些错误。</p>
<p>　　在发送HTTP响应的第1部分后，会派生子进程
(第20行)。子进程会使用请求URI中的CGI参数来初始化环境变量<code>QUERY_STRING</code>，真实服务器还会在这里设置其他CGI环境变量
(这里为了简化，省略这一步)。</p>
<p>　　然后，子进程将其标准输出重定向到已连接描述符
(第24行)，加载并运行CGI程序
(第25行)。由于CGI程序运行在子进程的上下文，它可以访问调用函数<code>execve()</code>之前存在的所有打开的文件和环境变量。因此，CGI程序对标准输出的所有写操作会重定向到客户端，父进程调用函数<code>wait()</code>来阻塞自己并在子进程终止时将其回收
(第27行)。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第3章 程序的机器级表示</title>
    <url>/2023/01/02/computer-systems-a-programmer&#39;s-perspective-3e-chpt-3/</url>
    <content><![CDATA[<p>　　计算机执行<strong>机器代码</strong>，即字节序列编码的底层操作，包括操作数据、管理内存、从存储设备中读写和网络通信。编译器根据编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列阶段生成机器代码。GCC以<strong>汇编代码</strong>的形式生成输出，汇编代码是机器代码的文本表示，给出了程序的所有指令。然后，GCC调用<strong>汇编器</strong>和<strong>链接器</strong>根据汇编代码生成可执行的机器代码。</p>
<p>　　8086 (1978年，29K个晶体管)
是第1代16位处理器之一。8088是8086的变种，在其基础上增加了1个8位外部总线，作为最初的IBM个人计算机的心脏。1980年，Intel推出了8087浮点协处理器
(45K个晶体管)，它与8086或8088一同运行，执行浮点指令。8087建立了x86系列的浮点模型，称为x87。</p>
<p>　　80286 (1982年，134K个集体管) 增加了更多的寻址模式
(现已过时)，它是IBM
PC-AT个人计算机的基础，这种计算机是Windows最初的使用平台。</p>
<p>　　i386 (1985年，275K个晶体管) 将体系结构扩展到32位并增加了<span
style="background-color: yellow">平坦寻址模式</span>，这是Intel系列中首个全面支持Unix的机器。</p>
<p>　　i486 (1989年，1.2M个晶体管)
在提高性能的同时将浮点单元集成到了CPU芯片，但指令集没有明显的变化。</p>
<p>　　Pentium (1993年，3.1M个晶体管)
提高了性能，仅对指令集进行了小扩展。</p>
<p>　　PentiumPro (1995年，5.5M个晶体管)
采用了全新的CPU设计，在内部称为P6微体系架构，指令集增加了1类<span
style="background-color: yellow">条件移动</span>指令。</p>
<p>　　Pentium/MMX (1997年，4.5M个晶体管) 在Pentium
CPU中增加了1类新的处理整数向量的指令。每个数据可以是8、16或32位。每个向量都是64位。</p>
<p>　　Pentium II (1997年，7M个晶体管) 是P6微体系结构的延续。</p>
<p>　　Pentium III (1999年，8.2M个晶体管)
使用了SSE，这是1类处理整数或浮点数向量的指令。每个数据可以是8、16或32位，打包成128位的向量。由于芯片里有L2缓存，该芯片后来的版本最多使用了24M个晶体管。</p>
<p>　　Pentium 4 (2000年，42M个晶体管)
将SSE扩展到了SSE2，增加了新的数据类型 (包括双精度浮点)
以及相关的144条新指令。有了这些扩展，编译器可以使用SSE指令而非x87指令来编译浮点代码。</p>
<p>　　Pentium 4E (2004年，125M个晶体管)
增加了超线程和EM64T。EM64T是Intel对AMD开发的IA32的64位扩展的实现，称为x86-64。</p>
<p>　　Core 2 (2006年，291M个晶体管)
回归到类似于P6的微体系架构，也是Intel的首个多核CPU，但不支持超线程。</p>
<p>　　每个后继CPU的设计都是向后兼容的，所以指令集中有许多奇怪的东西。</p>
<span id="more"></span>
<p>　　虽然GCC在把程序中表达的计算转换到机器代码方面表项出色，但有些机器特性是C程序访问不到的。例如，每次x86-64
CPU执行算术或逻辑运算时，若得到的运算结果的低8位有偶数个1，则把1位的<span
style="background-color: yellow">奇偶标志</span>PF置1；否则，置0。C语言中计算这个信息至少需要7次移位、掩码和异或运算，而几行汇编代码就可以完成这项任务。硬件将奇偶标志的计算作为算术或逻辑运算的一部分来执行，但C程序无法得知PF的值。</p>
<p>　　在C语言程序中插入汇编代码有2种方法。第1种是编写完整的函数，放进单独的汇编代码文件中，并用汇编器和链接器将它和C语言代码合并。第2种方法是使用GCC的<span
style="background-color: yellow">内联汇编</span>，用关键字<code>asm</code>在C程序中加入简短的汇编代码，这种方法可以减少特定于机器的代码。</p>
<p>　　大多数指令都有<strong>操作数</strong>，表示源数据和结果的存储位置。</p>
<p>　　由于16位体系结构发展成了32位，Intel用<strong>字</strong>表示16位数据类型，所以32位数据类型称为<strong>双字</strong>，64位数据类型称为<strong>四字</strong>，128位数据类型称为<strong>八字</strong>。</p>
<p>　　之后内容使用的都是<span
style="background-color: yellow">ATT</span>格式汇编代码，根据曾经运营过贝尔实验室的公司AT&amp;T命名，这是GCC、OBJDUMP和其他工具的默认格式。其他一些编程工具
(包括Microsoft的工具)
以及来自Intel的文档，其汇编格式都是Intel格式，这2种格式在许多方面有所不同。</p>
<p>　　●
相比ATT汇编代码，Intel汇编代码省略了表示大小的后缀，例如，ATT汇编代码的<code>pushq</code>和<code>movq</code>指令对应Intel汇编代码的<code>push</code>和<code>mov</code>指令。</p>
<p>　　●
相比ATT汇编代码，Intel汇编代码省略了寄存器名称前的<code>%</code>，例如，ATT汇编代码中的寄存器<code>%rbx</code>对应Intel汇编代码中的<code>rbx</code>。</p>
<p>　　●
ATT汇编代码和Intel汇编代码描述内存中位置的方式不同，例如，ATT汇编代码中的<code>(%rbx)</code>对应Intel汇编代码中的<code>QWORD PTR [rbx]</code>。</p>
<p>　　●
对于有多个操作数的指令，ATT汇编代码和Intel汇编代码操作数的顺序相反。</p>
<p>　　逆向工程中理解汇编代码和源代码之间的关系的关键是找到程序值和寄存器之间的映射关系。GCC会重组计算，因为有些C语言代码中的变量在汇编代码中没有对应的值，有时会在汇编代码中加入源代码中不存在的值。此外，GCC还经常试图将多个程序值映射到1个寄存器上来最小化寄存器的使用。GCC执行的部分映射并非一定能提高性能，反而可能降低性能。</p>
<h3 id="程序编码">3.1 程序编码</h3>
<p>　　若某C程序有<code>p1.c</code>和<code>p2.c</code>两个文件，其编译指令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -Og -o p p1.c p2.c</span><br></pre></td></tr></table></figure>
<p>　　<code>gcc</code>表示GCC。命令行选项<code>-Og</code>表示GCC生成符合原始C语言代码体系优化等级的机器代码，因为使用较高级别优化生成的代码会严重变形，导致生成的机器代码和源代码之间看似毫无关联。从性能角度，<code>-O1</code>或<code>-O2</code>是更好的选择。</p>
<table>
<thead>
<tr>
<th>C语言声明 (x86-64)</th>
<th>Intel数据类型</th>
<th>汇编代码后缀</th>
<th>大小 (单位是B)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char</code></td>
<td>字节</td>
<td><code>b</code></td>
<td>1</td>
</tr>
<tr>
<td><code>short</code></td>
<td>字</td>
<td><code>w</code></td>
<td>2</td>
</tr>
<tr>
<td><code>int</code></td>
<td>双字</td>
<td><code>l</code></td>
<td>4</td>
</tr>
<tr>
<td><code>long</code></td>
<td>四字</td>
<td><code>q</code></td>
<td>8</td>
</tr>
<tr>
<td><code>char *</code></td>
<td>四字</td>
<td><code>q</code></td>
<td>8</td>
</tr>
<tr>
<td><code>float</code></td>
<td>单精度</td>
<td><code>s</code></td>
<td>4</td>
</tr>
<tr>
<td><code>double</code></td>
<td>双精度</td>
<td><code>l</code></td>
<td>8</td>
</tr>
</tbody>
</table>
<p>　　部分GCC生成的汇编代码中会有表示操作数大小的后缀。例如，数据移动指令<code>mov</code>有4个变种，即<code>movb</code>、<code>movw</code>、<code>movl</code>和<code>movq</code>，后缀<code>l</code>可以表示4B的<code>int</code>和8B的<code>double</code>，但这不会产生歧义，因为浮点数使用一组完全不同的指令和寄存器。</p>
<p>　　浮点数分为单精度和双精度，对应C语言中的<code>float</code>和<code>double</code>。x86系的CPU也支持特殊的80位
(10B)
浮点格式，在C语言中可以使用<code>long double</code>来声明，这种格式不能移植到其他类型的机器，而且也不如单精度和双精度浮点运算高效。</p>
<h4 id="机器级代码">3.1.1 机器级代码</h4>
<p>　　对机器级编程，有2种抽象模型很重要。第1种抽象是由<strong>指令集架构</strong>来定义机器级程序的格式和行为，它定义了CPU状态、指令格式以及每条指令对状态的影响。大多数ISA将程序的行为描述为每条指令按序执行，但CPU的硬件远不如此精简，它们并发执行指令，但可以保证整体行为与ISA指定的执行顺序一致。第2种抽象是机器级程序使用的内存地址是虚拟地址，提供的内存模型看似1个很大的字节数组。</p>
<p>　　x86-64的机器代码和原始的C语言代码差距很大，一些通常对C语言隐藏的处理状态都是可见的。</p>
<p>　　● <span style="background-color: yellow">程序计数器</span>
(在x86-64中用<code>%rip</code>表示)
给出待执行的下一条指令的内存地址。</p>
<p>　　● <span
style="background-color: yellow">整数寄存器</span>包含16个用于存储64位值的已命名的位置，可以存储地址
(对应C语言的指针)
或整型数据。有些寄存器用于记录某些重要的程序状态，其他寄存器用于存储临时数据，例如，过程中的参数和局部变量以及函数返回值。</p>
<p>　　● <span
style="background-color: yellow">条件码寄存器</span>保存最近执行的算术或逻辑指令的状态信息，用于实现控制或数据流中的条件改变，例如，<code>if</code>和<code>while</code>语句。</p>
<p>　　● 一组<span
style="background-color: yellow">向量寄存器</span>可以存储若干个整数或浮点值。</p>
<p>　　虽然C语言提供了1种不同数据类型可以声明和分配内存的模型，但机器代码只是将内存视为1个按字节寻址的大数组。C语言中的聚合类型
(例如，数组和结构)
在机器代码中用一组连续的字节表示。即使对标量数据类型，汇编代码也不区分有符号和无符号整数，不区分各种类型的指针，甚至不区分指针和整数。</p>
<p>　　程序内存包含程序的可执行机器代码、操作系统所需的信息、用于管理过程调用和返回的运行时栈和用户分配的内存块
(例如，通过库函数<code>malloc()</code>分配)。程序使用虚拟内存寻址，在任意给定的时刻，只有虚拟内存的部分区域有效。例如，x86-64的虚拟地址由1个64位的字表示，在目前的实现中，地址的高16位必须设置为0，所以地址的实际范围是<span
class="math inline">\(2^{48}\)</span>。操作系统负责管理虚拟内存地址并将其转换为内存中的物理地址。</p>
<p>　　1条机器指令仅执行很基本的操作，例如，将存储在寄存器中的两个数相加，在存储器和寄存器之间移动数据以及条件分支移动到新的指令地址，编译器必须生成指令的序列从而实现程序结构。</p>
<h4 id="代码示例">3.1.2 代码示例</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mstore.c */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span>, <span class="type">long</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> t = mult2(x, y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -Og -S mstore.c</span><br></pre></td></tr></table></figure>
<p>　　执行这条命令后，GCC会根据<code>mstore.c</code>生成汇编代码，但不会进一步执行编译流程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.file	&quot;010-mstore.c&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl	multstore</span><br><span class="line">	.type	multstore, @function</span><br><span class="line">multstore:</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	movq	%rdx, %rbx</span><br><span class="line">	call	mult2</span><br><span class="line">	movq	%rax, (%rbx)</span><br><span class="line">	addq	$32, %rsp</span><br><span class="line">	popq	%rbx</span><br><span class="line">	ret</span><br><span class="line">	.seh_endproc</span><br><span class="line">	.ident &quot;GCC: (Ubuntu 4.8.1-2ubuntu1~12.04) 4.8.1&quot;</span><br><span class="line">	.section .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>
<p>　　这是<code>mstore.s</code>的完整内容。<code>.</code>开头的行是<strong>汇编指示</strong>，用于引导汇编器和链接器，通常可以忽略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multstore:</span><br><span class="line">    pushq	%rbx</span><br><span class="line">    movq	%rdx,%rbx</span><br><span class="line">    call	mult2</span><br><span class="line">    movq	%rax,(%rbx)</span><br><span class="line">    popq	%rbx</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>　　为了更清楚地说明汇编代码，这里省略了大部分汇编指示。<code>mstore.c</code>中每个缩进的行都对应1条机器指令。例如，<code>pushq</code>指令表示将寄存器<code>%rbx</code>中的内容压入程序栈中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -Og -c mstore.c</span><br></pre></td></tr></table></figure>
<p>　　执行这条这条命令后，GCC会编译并汇编该代码，即生成目标代码文件<code>mstore.o</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3</span><br></pre></td></tr></table></figure>
<p>　　这是汇编指令对应的目标代码，从中可以看出，机器执行的程序只是字节序列，即一系列指令的编码。</p>
<p>　　<strong>反汇编器</strong>可以查看机器代码文件的内容，可以根据机器代码生成类似汇编格式的代码，例如，Linux系统中的<code>objdump</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d mstore.o</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;multstore&gt;:</span><br><span class="line">0:	53		push	%rbx</span><br><span class="line">1:	48 89 d3	mov	%rdx,%rbx</span><br><span class="line">4:	e8 00 00 00 00	callq	9 &lt;multstore+0x9&gt;</span><br><span class="line">9:	48 89 03	mov	%rax,(%rbx)</span><br><span class="line">c:	5b		pop	%rbx</span><br><span class="line">d:	c3		retq</span><br></pre></td></tr></table></figure>
<p>　　左边是前面看到的14个十六进制数，它们分成若干组，每组长度为1B~5B且对应右边的指令。</p>
<p>　　●
x86-64指令长度从1B~15B不等，常用或操作数较少的指令长度较短，不常用或操作数较多的指令长度较长。</p>
<p>　　●
指令格式是从某个给定位置开始将字节唯一地解码成机器指令的方式。例如，只有<code>pushq %rbx</code>以字节值53开始。</p>
<p>　　●
反汇编器只是基于机器代码文件中的字节序列来生成汇编代码，并不需要访问程序的源代码或汇编代码。</p>
<p>　　●
反汇编器使用的指令命名规则与GCC生成的汇编代码有细微差别。例如，反汇编输出中省略了部分指令的后缀<code>q</code>。指令<code>callq</code>和<code>retq</code>对应<code>call</code>和<code>ret</code>，后缀<code>q</code>只是为了强调这是x86-64指令而非IA32，在x86-64汇编代码中，两者没有区别。</p>
<p>　　生成实际可执行的代码需要对目标代码文件运行链接器，而目标代码文件中必须包含主函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span>, <span class="type">long</span>, <span class="type">long</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> d;</span><br><span class="line">    multstore(<span class="number">2</span>, <span class="number">3</span>, &amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2 * 3 --&gt; %d\n&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> s = a * b;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -Og -o prog main.c mstore.c</span><br></pre></td></tr></table></figure>
<p>　　<code>prog</code>的大小是8655B，因为它不仅包含编写的代码，还包括用于启动和终止程序以及与操作系统交互的代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d prog</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400540 &lt;multstore&gt;:</span><br><span class="line">400540:	53		push %rbx</span><br><span class="line">400541:	48 89 d3 	mov %rdx,%rbx</span><br><span class="line">400544:	e8 42 00 00 00	callq 40058b &lt;mult2&gt;</span><br><span class="line">400549:	48 89 03	mov %rax,(%rbx)</span><br><span class="line">40054c:	5b		pop %rbx</span><br><span class="line">40054d:	c3		retq</span><br><span class="line">40054e:	90		nop</span><br><span class="line">40054f:	90		nop</span><br></pre></td></tr></table></figure>
<p>　　这是反汇编器生成的代码的一部分，这段代码与<code>mstore.c</code>反汇编生成的代码几乎相同，但也有区别。第1个区别是左边列出的地址不同——链接器将这段代码的位置移动到一段不同的地址范围中。第2个区别是链接器填上了指令<code>callq</code>调用函数<code>mult2()</code>需要使用的地址
(第4行)，这体现了链接器的任务之一——为函数调用找到对应可执行代码的位置。第3个区别是结尾多了2行代码
(第8~9行)，它们对程序没有影响，因为出现返回指令 (第7行)
之后。插入这些指令是为了让函数代码变为16B，以便于更好地放置下一个代码块。</p>
<h3 id="访问信息">3.2 访问信息</h3>
<img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/16_integer_registers.svg" class="" title="16_integer_registers">
<p>　　x86-64
CPU包含16个64位的<strong>通用目的寄存器</strong>，这些寄存器用于存储整型数据和指针。它们都以<code>%r</code>开头，后面跟着一些根据不同命名规则命名的名称
(由于指令集历史的演化)。最初的8086有8个16位的寄存器，即<code>%ax</code>到<code>%sp</code>。每个寄存器都有特殊的用途，其名称反映了这些用途。扩展到IA32架构时，这些寄存器也扩展成32位寄存器，即从<code>%eax</code>到<code>%esp</code>。扩展到64位时，原来的8个寄存器也扩展成64位，即<code>%rax</code>到<code>%rsp</code>，此外，还增加了8个新寄存器，它们都根据新的命名规则命名，即<code>%r8</code>到<code>%r15</code>。</p>
<h4 id="操作数指示符">3.2.1 操作数指示符</h4>
<p>　　操作数中的源数据可以是常数，也可以从寄存器或内存中读取，结果可以存储在寄存器或内存中。因此，操作数大致可以分为3种类型。</p>
<p>　　●
第1种类型是<strong>立即数</strong>，用于表示常数。在ATT汇编代码中，立即数的格式是<code>$</code>加上用C语言风格表示的整数，例如，<code>$-577</code>或<code>$0x1F</code>。不同指令允许的立即数范围不同。汇编器会自动选择最紧凑的方式进行数组编码。</p>
<p>　　●
第2种类型是<strong>寄存器</strong>，用于表示寄存器的内容，16个寄存器的低8、16、32或64位都可以作为操作数。</p>
<p>　　● 第3种类型是<strong>内存引用</strong>，用于根据计算出来的地址
(通常称为<strong>有效地址</strong>)
访问某个内存位置。由于内存可以视很大的字节数组，所以这里用<span
class="math inline">\(M_b[Addr]\)</span>表示从地址<span
class="math inline">\(Addr\)</span>开始的<span
class="math inline">\(b\)</span>个字节值的引用。为了简便，可以省略<span
class="math inline">\(b\)</span>。</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 23%" />
<col style="width: 42%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr>
<th>类型</th>
<th>格式</th>
<th>操作数值</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>立即数</td>
<td><span class="math inline">\(\$Imm\)</span></td>
<td><span class="math inline">\(Imm\)</span></td>
<td>立即数寻址</td>
</tr>
<tr>
<td>寄存器</td>
<td><span class="math inline">\(r_a\)</span></td>
<td><span class="math inline">\(R[r_a]\)</span></td>
<td>寄存器寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><span class="math inline">\(Imm\)</span></td>
<td><span class="math inline">\(M[Imm]\)</span></td>
<td>直接/绝对寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><span class="math inline">\((r_a)\)</span></td>
<td><span class="math inline">\(M[R[r_a]]\)</span></td>
<td>间接寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><span class="math inline">\(Imm(r_b)\)</span></td>
<td><span class="math inline">\(M[Imm+R[r_b]]\)</span></td>
<td>(基址+偏移量) 寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><span class="math inline">\((r_b,r_i)\)</span></td>
<td><span class="math inline">\(M[R[r_b]+R[r_i]]\)</span></td>
<td>变址寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><span class="math inline">\(Imm(r_b,r_i)\)</span></td>
<td><span class="math inline">\(M[Imm+R[r_b]+[r_i]]\)</span></td>
<td>变址寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><span class="math inline">\((,r_i,s)\)</span></td>
<td><span class="math inline">\(M[R[r_i]\cdot s]\)</span></td>
<td>比例变址寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><span class="math inline">\(Imm(,r_i,s)\)</span></td>
<td><span class="math inline">\(M[Imm+R[r_i]\cdot s]\)</span></td>
<td>比例变址寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><span class="math inline">\((r_b,r_i,s)\)</span></td>
<td><span class="math inline">\(M[R[r_b]+R[r_i]\cdot s]\)</span></td>
<td>比例变址寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><span class="math inline">\(Imm(r_b,r_i,s)\)</span></td>
<td><span class="math inline">\(M[Imm+R[r_b]+R[r_i]\cdot
s]\)</span></td>
<td>比例变址寻址</td>
</tr>
</tbody>
</table>
<p>　　有不同的<strong>寻址模式</strong>允许不同形式的内存引用。<span
class="math inline">\(Imm(r_b,r_i,s)\)</span>是最常用的形式，<span
class="math inline">\(Imm\)</span>表示立即数偏移，<span
class="math inline">\(r_b\)</span>表示基址寄存器 (64位)，<span
class="math inline">\(r_i\)</span>表示变址寄存器 (64位)，<span
class="math inline">\(s\)</span>表示比例因子
(必须是1、2、4或8)，地址计算公式是<span
class="math inline">\(Imm+R[r_b]+R[r_i]\cdot
s\)</span>。引用数组时会用到这种通用形式，其他形式都是这种通用形式的变体
(省略部分元素)。</p>
<h4 id="数据移动指令">3.2.2 数据移动指令</h4>
<table>
<thead>
<tr>
<th>指令</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MOV  S, D</code></td>
<td><code>D</code> ← <code>S</code></td>
<td>移动</td>
</tr>
<tr>
<td><code>movb</code></td>
<td></td>
<td>移动字节</td>
</tr>
<tr>
<td><code>movw</code></td>
<td></td>
<td>移动字</td>
</tr>
<tr>
<td><code>movl</code></td>
<td></td>
<td>移动双字</td>
</tr>
<tr>
<td><code>movq</code></td>
<td></td>
<td>移动四字</td>
</tr>
<tr>
<td><code>movabsp  I, R</code></td>
<td><code>R</code> ← <code>I</code></td>
<td>移动完整的四字</td>
</tr>
</tbody>
</table>
<p>　　数据移动指令的源操作数可以是立即数、寄存器或内存引用，目的操作数可以是寄存器或内存引用。x86-64要求数据移动指令的操作数不能都是内存引用。将值从某个内存位置复制到其他内存位置需要2条指令——第1条指令将值加载到寄存器，第2条指令将值从寄存器写入到目的位置。</p>
<p>　　指令<code>movq</code>只能以32位值作为源操作数，它会把这个值符号扩展
(复制最高位)
到64位并移动目的位置。指令<code>movabsp</code>以64位值作为源操作数，但只能以寄存器作为目的操作数。</p>
<p>　　数据移动指令需要和整数寄存器的大小相匹配。大多数情况下，数据移动指令只会更新目的操作数指定的位置。唯一的例外是指令<code>movl</code>的目的操作数是寄存器时，它会把该寄存器的高4B置0，因为x86-64的惯例——任何为寄存器生成32位值的指令都会把该寄存器的<span
style="background-color: yellow">高位部分置0</span>。</p>
<table>
<thead>
<tr>
<th>零扩展数据移动指令</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MOVZ  S, R</code></td>
<td><code>R</code> ← <code>S</code> (零扩展)</td>
<td>以零扩展进行移动</td>
</tr>
<tr>
<td><code>movzbw</code></td>
<td></td>
<td>将零扩展后的字节移动到字</td>
</tr>
<tr>
<td><code>movzbl</code></td>
<td></td>
<td>将零扩展后的字节移动到双字</td>
</tr>
<tr>
<td><code>movzwl</code></td>
<td></td>
<td>将零扩展后的字移动到双字</td>
</tr>
<tr>
<td><code>movzbq</code></td>
<td></td>
<td>将零扩展后的字节移动到四字</td>
</tr>
<tr>
<td><code>movzwq</code></td>
<td></td>
<td>将零扩展后的字移动到四字</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 35%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr>
<th>符号扩展数据移动指令</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MOVS  S, R</code></td>
<td><code>R</code> ← <code>S</code> (符号扩展)</td>
<td>以符号扩展进行移动</td>
</tr>
<tr>
<td><code>movsbw</code></td>
<td></td>
<td>将符号扩展后的字节移动到字</td>
</tr>
<tr>
<td><code>movsbl</code></td>
<td></td>
<td>将符号扩展后的字节移动到双字</td>
</tr>
<tr>
<td><code>movswl</code></td>
<td></td>
<td>将符号扩展后的字移动到双字</td>
</tr>
<tr>
<td><code>movsbq</code></td>
<td></td>
<td>将符号扩展后的字节移动到四字</td>
</tr>
<tr>
<td><code>movswq</code></td>
<td></td>
<td>将符号扩展后的字移动到四字</td>
</tr>
<tr>
<td><code>movslq</code></td>
<td></td>
<td>将符号扩展后的双字移动到四字</td>
</tr>
<tr>
<td><code>cltq</code></td>
<td><code>%rax</code> ← <code>%eax</code> (符号扩展)</td>
<td>将<code>%eax</code>符号扩展到<code>%rax</code></td>
</tr>
</tbody>
</table>
<p>　　<span
style="background-color: yellow">零扩展数据移动指令</span>和<span
style="background-color: yellow">符号扩展数据移动指令</span>用于将较小的源操作数
(寄存器或内存引用) 复制到较大的目的操作数
(寄存器)。这2类指令的最后2个字符分别表示源操作数和目的操作数的大小。零扩展数据移动指令中并没有将4B源操作数移动到8B目的操作数的指令，因为指令<code>movl</code>可以实现这个功能。指令<code>cltq</code>没有操作数，因为源操作数只能是<code>%eax</code>，目的操作数只能是<code>%rax</code>，等同于<code>movslq  %eax, %rax</code>。</p>
<h4 id="压入和弹出栈数据">3.2.3 压入和弹出栈数据</h4>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 67%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr>
<th>指令</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pushq  S</code></td>
<td><code>R[%rsp]</code> ← <code>R[%rsp] - 8</code>;
<code>M[R[%rsp]]</code> ← <code>S</code></td>
<td>将四字压入栈</td>
</tr>
<tr>
<td><code>popq  D</code></td>
<td><code>D</code> ← <code>M[R[%rsp]]</code>; <code>R[%rsp]</code> ←
<code>R[%rsp] + 8</code></td>
<td>将四字弹出栈</td>
</tr>
</tbody>
</table>
<p>　　栈是后进先出的数据结构，可以添加或删除元素。通过指令<code>pushq</code>压入
(添加) 元素，通过指令<code>popq</code>弹出 (删除)
元素。栈可用于实现数组，总是从数组的一端 (称为<strong>栈顶</strong>)
插入和删除元素。在x86-64中，程序栈存储在内存中某个区域，栈向下增长，栈顶元素的地址值最小。栈指针<code>%rsp</code><span
style="background-color: yellow">总是</span>保存栈顶元素的地址。</p>
<p>　　将1个四字压入栈时，会先将栈指针减8，然后将值写入新的栈顶地址。因此，<code>pushq  %rbp</code>等价于以下2条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subq  $8, %rsp</span><br><span class="line">movq  %rbp, (%rsp)</span><br></pre></td></tr></table></figure>
<p>　　编码为机器代码后，指令<code>pushq</code>仅需1B，而这2条指令共需8B。</p>
<p>　　弹出1个四字时，会先从栈顶读出数据，然后将栈指针加8。因此，<code>popq  %rax</code>等价于以下2条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq  (%rsp), %rax</span><br><span class="line">addq  $8, %rsp</span><br></pre></td></tr></table></figure>
<img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/stack_operation.svg" class="" title="stack_operation">
<p>　　因为栈、程序代码和其他形式的程序数据都存储在同一内存中，所以程序可以用标准的内存寻址方式访问栈内的任意位置。</p>
<h4 id="代码示例-1">3.2.4 代码示例</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">exchange</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> x = *xp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exchange:</span><br><span class="line">	movq	(%rdi), %rax</span><br><span class="line">	movq	%rsi, (%rdi)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　这是是函数<code>exchange()</code>的C语言和汇编代码，寄存器<code>%rdi</code>和<code>%rsi</code>分别存储参数<code>xp</code>和<code>y</code>。C语言中的指针实际上是地址。<code>*xp</code>表示读取<code>xp</code>所指位置的值，该操作称为<strong>指针间接引用</strong>。操作符<code>*</code>执行指针间接引用，而操作符<code>&amp;</code>执行取址，例如，<code>&amp;a</code>会创建1个指针，该指针指向保存<code>a</code>的位置。</p>
<p>　　像<code>x</code>这样的局部变量通常保存储在寄存器中，因为寄存器的存取速度比内存的快很多。</p>
<p>　　在函数开始执行时，参数<code>xp</code>和<code>y</code>分别存储在寄存器<code>%rdi</code>和<code>%rsi</code>中。第2行指令从内存中读出<code>x</code>并将它存入寄存器<code>%rax</code>中，对应<code>x = *xp</code>。然后，寄存器<code>%rax</code>作为返回值，即<code>x</code>。第3行指令将<code>y</code>写入到寄存器<code>%rdi</code>中的<code>xp</code>指向的内存位置，对应<code>*xp = y</code>。</p>
<h3 id="算术和逻辑操作">3.3 算术和逻辑操作</h3>
<table>
<thead>
<tr>
<th>指令</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>leaq  S, D</code></td>
<td><code>D</code> ← <code>&amp;S</code></td>
<td>加载有效地址</td>
</tr>
<tr>
<td><code>INC  D</code></td>
<td><code>D</code> ← <code>D + 1</code></td>
<td>加1</td>
</tr>
<tr>
<td><code>DEC  D</code></td>
<td><code>D</code> ← <code>D - 1</code></td>
<td>减1</td>
</tr>
<tr>
<td><code>NEG  D</code></td>
<td><code>D</code> ← <code>- D</code></td>
<td>取负</td>
</tr>
<tr>
<td><code>NOT  D</code></td>
<td><code>D</code> ← <code>~ D</code></td>
<td>取补</td>
</tr>
<tr>
<td><code>ADD  S, D</code></td>
<td><code>D</code> ← <code>D + S</code></td>
<td>加</td>
</tr>
<tr>
<td><code>SUB  S, D</code></td>
<td><code>D</code> ← <code>D - S</code></td>
<td>减</td>
</tr>
<tr>
<td><code>IMUL  S, D</code></td>
<td><code>D</code> ← <code>D * S</code></td>
<td>乘</td>
</tr>
<tr>
<td><code>XOR  S, D</code></td>
<td><code>D</code> ← <code>D ^ S</code></td>
<td>异或</td>
</tr>
<tr>
<td><code>OR  S, D</code></td>
<td><code>D</code> ← <code>D | S</code></td>
<td>或</td>
</tr>
<tr>
<td><code>AND  S, D</code></td>
<td><code>D</code> ← <code>D &amp; S</code></td>
<td>与</td>
</tr>
<tr>
<td><code>SAL  k, D</code></td>
<td><code>D</code> ← <code>D &lt;&lt; k</code></td>
<td>左移</td>
</tr>
<tr>
<td><code>SHL  k, D</code></td>
<td><code>D</code> ← <code>D &lt;&lt; k</code></td>
<td>左移 (等同于<code>SAL</code>)</td>
</tr>
<tr>
<td><code>SAR  k, D</code></td>
<td><code>D</code> ← <code>D &gt;&gt; k</code></td>
<td>算术右移</td>
</tr>
<tr>
<td><code>SHR  k, D</code></td>
<td><code>D</code> ← <code>D &gt;&gt; k</code></td>
<td>逻辑右移</td>
</tr>
</tbody>
</table>
<p>　　x86-64整数和逻辑操作指令可分为<span
style="background-color: yellow">加载有效地址</span>、<span
style="background-color: yellow">一元操作</span>、<span
style="background-color: yellow">二元操作</span>和<span
style="background-color: yellow">移位</span>。</p>
<p>　　加载有效地址指令<code>leaq</code>实际上是<code>movq</code>的变体，其指令形式是从内存读数据到寄存器，但实际上不会引用内存。第1个操作数看似是内存引用，但并非从指定的位置读取数据，而是将有效地址写入到目的操作数，所以用C语言中的取址操作符<code>&amp;</code>表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">scale</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> t = x + y * <span class="number">4</span> + <span class="number">12</span> * z;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scale:</span><br><span class="line">	leaq	(%rdi,%rsi,4), %rax</span><br><span class="line">	leaq	(%rdx,%rdx,2), %rdx</span><br><span class="line">	leaq	(%rax,%rdx,4), %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　<code>leaq</code>指令能执行加法和有限形式的乘法，在编译简单的算术表达式时很有用。</p>
<p>　　一元操作指令只有1个操作数，这个操作数既是源操作数又是目的操作数，可以是寄存器或内存引用。</p>
<p>　　二元操作指令有2个操作数，第2个操作数既是源操作数又是目的操作数。第1个操作数可以是任何类型，第2个操作数可以是寄存器或内存引用。当第2个操作数是内存引用时，必须先从内存中读出数据并执行操作，然后把结果回写到内存。</p>
<p>　　移位操作指令的第1个操作数是移位量，第2个操作数是待移位的数。移位量可以是立即数或单字节寄存器<code>%cl</code>中的值
(最大移位量为<span
class="math inline">\(2^8-1\)</span>)。左移指令有<code>SAL</code>和<code>SHL</code>，两者效果相同，都是在右边填上0。右移指令有<code>SAR</code>和<code>SHR</code>，前者是算术右移
(填上符号位)，后者是逻辑右移 (填上0)。x86-64中，对<span
class="math inline">\(w\)</span>位的数据移位时，移位量由寄存器<code>%cl</code>中的低<span
class="math inline">\(m\)</span>位决定，其中<span
class="math inline">\(2^m=w\)</span>，高位会被忽略。例如，当寄存器<code>%cl</code>值为<code>0xFF</code>时，指令<code>salb</code>会左移7位，指令<code>salw</code>会左移15位，指令<code>sall</code>会左移31位，指令<code>salq</code>会左移63位。</p>
<p>　　2个64位有符号数或无符号数的乘积需要128位来表示。x86-64指令集对128位数据类型提供了支持。</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 75%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr>
<th>指令</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>imulq  S</code></td>
<td><code>R[%rdx], R[%rax]</code> ← <code>S * R[%rax]</code></td>
<td>有符号乘法</td>
</tr>
<tr>
<td><code>mulq  S</code></td>
<td><code>R[%rdx], R[%rax]</code> ← <code>S * R[%rax]</code></td>
<td>无符号乘法</td>
</tr>
<tr>
<td><code>clto</code></td>
<td><code>R[%rdx], R[%rax]</code> ← <code>R[%rax]</code> (符号扩展)</td>
<td>转换为八字</td>
</tr>
<tr>
<td><code>idivq  S</code></td>
<td><code>R[%rdx]</code> ←
<code>R[%rdx]:R[%rax] % S</code>；<code>R[%rax]</code> ←
<code>R[%rdx]:R[%rax] / S</code></td>
<td>有符号除法</td>
</tr>
<tr>
<td><code>divq  S</code></td>
<td><code>R[%rdx]</code> ←
<code>R[%rdx]:R[%rax] % S</code>；<code>R[%rax]</code> ←
<code>R[%rdx]:R[%rax] / S</code></td>
<td>无符号除法</td>
</tr>
</tbody>
</table>
<p>　　乘法指令除了双操作数指令，还有单操作数指令，即<code>mulq</code>和<code>imulq</code>。这2条指令都要求一个参数存储在寄存器<code>%rax</code>中，另一个参数数作为指令的源操作数给出。乘积的高64位存储在寄存器<code>%rdx</code>中，低64位存储在寄存器<code>%rax</code>中。指令<code>imulq</code>的操作数可以是1或2个，汇编器会根据操作数的数量来分辨。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> __int128 <span class="type">uint128_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">store_upord</span><span class="params">(<span class="type">uint128_t</span> *dest, <span class="type">uint64_t</span> x, <span class="type">uint64_t</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    *dest = x * (<span class="type">uint128_t</span>)y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">store_upord:</span><br><span class="line">	movq	%rsi, %rax</span><br><span class="line">	mulq	%rdx</span><br><span class="line">	movq	%rax, (%rdi)</span><br><span class="line">	movq	%rdx, 8(%rdi)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　存储乘积需要使用2次指令<code>movq</code>，分别存储低64位和高64位。由于生成这段代码的是小端机器，所以高64位存储在较大的地址。</p>
<p>　　除法指令也是单操作数指令，被除数的高64位存储在寄存器<code>%rdx</code>中，低64位存储在寄存器<code>%rax</code>中，除数作为操作数，商存储在寄存器<code>%rax</code>中，余数存储在寄存器<code>%rdx</code>中。</p>
<p>　　对于大多数64位应用程序，被除数通常也是64位，存储在寄存器<code>%rax</code>中，寄存器<code>%rdx</code>应该全为0
(无符号运算) 或符号位
(有符号运算)。64位有符号被除数符号扩展到128位可以通过指令<code>cqto</code>实现
(对应Intel格式中指令<code>cqo</code>)，该指令不需要操作数，默认读取寄存器<code>%rax</code>的符号位并复制到寄存器<code>%rdx</code>的所有位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remdiv</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> *qp, <span class="type">long</span> *rp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> q = x / y;</span><br><span class="line">    <span class="type">long</span> r = x % y;</span><br><span class="line">    *qp = q;</span><br><span class="line">    *rp = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remdiv:</span><br><span class="line">	movq	%rdx, %r8</span><br><span class="line">	movq	%rdi, %rax</span><br><span class="line">	cqto</span><br><span class="line">	idivq	%rsi</span><br><span class="line">	movq	%rax, (%r8)</span><br><span class="line">	movq	%rdx, (%rcx)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，会先把参数<code>qp</code>保存到寄存器<code>%r8</code>，因为除法会使用寄存器<code>%rdx</code>。然后准备被除数并进行符号扩展。除法完成后，将寄存器<code>%rax</code>中的商保存到<code>qp</code>，寄存器<code>%rdx</code>中的余数保存到<code>rp</code>。</p>
<h3 id="控制">3.4 控制</h3>
<p>　　机器代码提供了2种基本的底层机制来实现条件行为，即先判断数据值，再根据判断结果来改变控制流或数据流。</p>
<h4 id="条件码">3.4.1 条件码</h4>
<p>　　除了整数寄存器，CPU还维护着一组单个位的<strong>条件码</strong>寄存器，它们表示最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。</p>
<p>　　●
进位标志CF为1时，表示最近的操作使最高位产生了进位，可用来检测无符号操作的溢出。</p>
<p>　　● 零标志ZF为1时，表示最近的操作得到的结果为0。</p>
<p>　　● 符号标志SF为1时，表示最近的操作得到的结果为负。</p>
<p>　　● 溢出标志OF为1时，表示最近的操作导致补码溢出 (无论正负)。</p>
<p>　　指令<code>leaq</code>不会设置条件码寄存器，因为它用于取址。对于逻辑操作，CF和OF都会置0。对于移位操作，CF会设置为最后1个被移出的位，而OF会置0。指令<code>INC</code>和<code>DEC</code>会设置OF和ZF，但不会改变CF。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>基于</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CMP  S1, S2</code></td>
<td><code>S2 - S1</code></td>
<td>比较</td>
</tr>
<tr>
<td><code>cmpb</code></td>
<td></td>
<td>比较字节</td>
</tr>
<tr>
<td><code>cmpw</code></td>
<td></td>
<td>比较字</td>
</tr>
<tr>
<td><code>cmpl</code></td>
<td></td>
<td>比较双字</td>
</tr>
<tr>
<td><code>cmpq</code></td>
<td></td>
<td>比较四字</td>
</tr>
</tbody>
</table>
<p>　　指令<code>CMP</code>和<code>SUB</code>的行为相同，但<code>CMP</code>只设置条件码而不更新目的寄存器。若2个操作数相等，<code>CMP</code>会将ZF置1。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>基于</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TEST  S1, S2</code></td>
<td><code>S1 &amp; S2</code></td>
<td>判断</td>
</tr>
<tr>
<td><code>testb</code></td>
<td></td>
<td>判断字节</td>
</tr>
<tr>
<td><code>testw</code></td>
<td></td>
<td>判断字</td>
</tr>
<tr>
<td><code>testl</code></td>
<td></td>
<td>判断双字</td>
</tr>
<tr>
<td><code>testq</code></td>
<td></td>
<td>判断四字</td>
</tr>
</tbody>
</table>
<p>　　指令<code>TEST</code>和<code>AND</code>的行为相同，但<code>TEST</code>只设置条件码而不更新目的寄存器。指令<code>TEST</code>可用于判断两个操作数是否相同和实现掩码，例如，<code>testq  %rax, %rax</code>可用于检测寄存器<code>%rax</code>的正负。</p>
<h4 id="条件码的使用">3.4.2 条件码的使用</h4>
<p>　　条件码通常不会直接读取，常见的用法有<span
style="background-color: yellow">根据条件码将字节置0或1</span>、<span
style="background-color: yellow">条件跳转到程序某个部分</span>和<span
style="background-color: yellow">条件移动数据</span>。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>别名</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sete  D</code></td>
<td><code>setz</code></td>
<td><code>D</code> ← <code>ZF</code></td>
<td>相等或为0</td>
</tr>
<tr>
<td><code>setne  D</code></td>
<td><code>setnz</code></td>
<td><code>D</code> ← <code>~ZF</code></td>
<td>不等或非0</td>
</tr>
<tr>
<td><code>sets  D</code></td>
<td></td>
<td><code>D</code> ← <code>SF</code></td>
<td>为负</td>
</tr>
<tr>
<td><code>setns  D</code></td>
<td></td>
<td><code>D</code> ← <code>~SF</code></td>
<td>非负</td>
</tr>
<tr>
<td><code>setg  D</code></td>
<td><code>setnle</code></td>
<td><code>D</code> ← <code>~(SF ^ OF) &amp; ~ZF</code></td>
<td>大于 (有符号)</td>
</tr>
<tr>
<td><code>setge  D</code></td>
<td><code>setnl</code></td>
<td><code>D</code> ← <code>~(SF ^ OF)</code></td>
<td>大于等于 (有符号)</td>
</tr>
<tr>
<td><code>setl  D</code></td>
<td><code>setnge</code></td>
<td><code>D</code> ← <code>SF ^ OF</code></td>
<td>小于 (有符号)</td>
</tr>
<tr>
<td><code>setle  D</code></td>
<td><code>setng</code></td>
<td><code>D</code> ← <code>(SF ^ OF) | ZF</code></td>
<td>小于等于 (有符号)</td>
</tr>
<tr>
<td><code>seta  D</code></td>
<td><code>setnbe</code></td>
<td><code>D</code> ← <code>~CF &amp; ~ZF</code></td>
<td>大于 (无符号)</td>
</tr>
<tr>
<td><code>setae  D</code></td>
<td><code>setnb</code></td>
<td><code>D</code> ← <code>~CF</code></td>
<td>大于等于 (无符号)</td>
</tr>
<tr>
<td><code>setb  D</code></td>
<td><code>setnae</code></td>
<td><code>D</code> ← <code>CF</code></td>
<td>小于 (无符号)</td>
</tr>
<tr>
<td><code>setbe  D</code></td>
<td><code>setna</code></td>
<td><code>D</code> ← <code>CF | ZF</code></td>
<td>小于等于 (无符号)</td>
</tr>
</tbody>
</table>
<p>　　指令<code>SET</code>会根据条件码将字节置0或1，其后缀表示不同的条件。指令<code>SET</code>的操作数是单字节整数寄存器或单字节的内存位置，指令会将操作数置0或1。为了得到32或64位结果，必须将高位置0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">comp</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">comp:</span><br><span class="line">	cmpq	%rsi, %rdi</span><br><span class="line">	setl	%al</span><br><span class="line">	movzbl	%ral, %eax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，指令<code>movzbl</code>会把寄存器<code>%eax</code>的高3B和<code>%rax</code>的高4B置0。</p>
<p>　　假设有符号数<span class="math inline">\(a\)</span>、<span
class="math inline">\(b\)</span>和<span
class="math inline">\(t\)</span>的补码形式为<span
class="math inline">\(\alpha\)</span>、<span
class="math inline">\(\beta\)</span>和<span
class="math inline">\(\tau\)</span>且<span
class="math inline">\(\tau=\alpha-^t_w\beta\)</span>。对于指令<code>sete</code>，当<span
class="math inline">\(\tau=0\)</span>时，ZF为1。对于指令<code>setl</code>，在不溢出的情况下
(OF为0)，若<span
class="math inline">\(\tau&lt;0\)</span>，则SF为1；若<span
class="math inline">\(\tau\geqslant0\)</span>，则SF为0。在溢出的情况下
(OF为1)，若<span class="math inline">\(\tau&lt;0\)</span>
(SF为0)，则<span class="math inline">\(a&gt;b\)</span>；若<span
class="math inline">\(\tau&gt;0\)</span> (SF为1)，则<span
class="math inline">\(a&lt;b\)</span>。</p>
<p>　　假设无符号数<span class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的二进制形式是<span
class="math inline">\(\alpha\)</span>和<span
class="math inline">\(\beta\)</span>。在计算<span
class="math inline">\(\tau=\alpha-^u_w\beta\)</span>时，若<span
class="math inline">\(\tau&lt;0\)</span>时，指令<code>CMP</code>会将CF置1，所以无符号数的比较会使用CF和ZF的组合。</p>
<h4 id="跳转指令">3.4.3 跳转指令</h4>
<p>　　<strong>跳转</strong>指令可以让指令切换到指定位置。在汇编代码中，跳转目标通常用<strong>标签</strong>指明。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>别名</th>
<th>跳转条件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>jmp  Label</code></td>
<td></td>
<td></td>
<td>直接跳转</td>
</tr>
<tr>
<td><code>jmp  *Operand</code></td>
<td></td>
<td></td>
<td>间接跳转</td>
</tr>
<tr>
<td><code>je  Label</code></td>
<td><code>jz</code></td>
<td><code>ZF</code></td>
<td>相等或为0</td>
</tr>
<tr>
<td><code>jne  Label</code></td>
<td><code>jnz</code></td>
<td><code>~ZF</code></td>
<td>不等或非0</td>
</tr>
<tr>
<td><code>js  Label</code></td>
<td></td>
<td><code>SF</code></td>
<td>为负</td>
</tr>
<tr>
<td><code>jns  Label</code></td>
<td></td>
<td><code>~SF</code></td>
<td>非负</td>
</tr>
<tr>
<td><code>jg  Label</code></td>
<td><code>jnle</code></td>
<td><code>~(SF ^ OF) &amp; ~ZF</code></td>
<td>大于 (有符号)</td>
</tr>
<tr>
<td><code>jge  Label</code></td>
<td><code>jnl</code></td>
<td><code>~(SF ^ OF)</code></td>
<td>大于等于 (有符号)</td>
</tr>
<tr>
<td><code>jl  Label</code></td>
<td><code>jnge</code></td>
<td><code>SF ^ OF</code></td>
<td>小于 (有符号)</td>
</tr>
<tr>
<td><code>jle  Label</code></td>
<td><code>jng</code></td>
<td><code>(SF ^ OF) | ZF</code></td>
<td>小于等于 (有符号)</td>
</tr>
<tr>
<td><code>ja  Label</code></td>
<td><code>jnbe</code></td>
<td><code>~CF &amp; ~ZF</code></td>
<td>大于 (无符号)</td>
</tr>
<tr>
<td><code>jae  Label</code></td>
<td><code>jnb</code></td>
<td><code>~CF</code></td>
<td>大于等于 (无符号)</td>
</tr>
<tr>
<td><code>jb  Label</code></td>
<td><code>jnae</code></td>
<td><code>CF</code></td>
<td>小于 (无符号)</td>
</tr>
<tr>
<td><code>jbe  Label</code></td>
<td><code>jna</code></td>
<td><code>CF | ZF</code></td>
<td>小于等于 (无符号)</td>
</tr>
</tbody>
</table>
<p>　　指令<code>jmp</code>是无条件跳转指令，可以<strong>直接</strong>或<strong>间接</strong>跳转，例如，<code>jmp  .L1</code>和<code>jmp  *(%rax)</code>。其他跳转指令都是条件跳转指令，条件跳转只能是直接跳转。</p>
<p>　　跳转指令有2种编码方式。第1种编码方法是使用<strong>PC相对</strong>地址
(更常用)，即目标指令的地址相对跳转指令的下一条指令的偏移，偏移量可以编码为1、2或4B。第2种编码方法是使用绝对地址，用4B直接指定目标。汇编器和链接器会选择适当的跳转目的编码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	movq	%rdi, %rax</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L3:</span><br><span class="line">	sarq	%rax</span><br><span class="line">.L2:</span><br><span class="line">	testq	%rax, %rax</span><br><span class="line">	jg	.L3</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0:	48 89 f8		mov	%rdi, %rax</span><br><span class="line">3:	eb 03			jmp	8 &lt;loop+0x8&gt;</span><br><span class="line">5:	48 d1 f8		sar	%rax</span><br><span class="line">8:	48 85 c0		test	%rax, %rax</span><br><span class="line">b:	7f f8 			jg	5 &lt;loop+0x5&gt;</span><br><span class="line">d:	f3 c3 			repz retq</span><br></pre></td></tr></table></figure>
<p>　　这是根据同一C文件生成的汇编代码和反汇编代码。在反汇编代码中，第2行中跳转指令的跳转目标为<code>0x8</code>，第5行中跳转指令的跳转目标是<code>0x5</code>。第1个跳转指令的目标编码
(<span style="background-color: yellow">单字节补码形式</span>)
是<code>0x3</code>，加上<code>0x5</code>得到下一条指令 (第4行)
的地址<code>0x8</code>。同样，第2个跳转指令的目标编码为<code>0xf8</code>，加上<code>0xd</code>得到下一条指令
(第3行)
的地址<code>0x5</code>。当执行PC相对寻址时，PC的值是跳转指令的下一条指令的地址而非跳转指令本身的地址，这可以追溯到早期的实现，当时的CPU会将更新PC作为执行下一条指令的第1步。</p>
<p>　　<code>rep; ret</code>是为了避免指令<code>ret</code>成为条件跳转指令的目标，若没有指令<code>rep</code>
(表示空操作)，当分支不跳转时，指令<code>jg</code> (第7行)
会继续到<code>ret</code>指令。根据AMD的文档，当指令<code>ret</code>通过跳转指令到达时，CPU不能正确预测到指令<code>ret</code>的目的地。除了能使代码在AMD上运行更快外，这种组合不会改变其他行为。<code>repz retq</code>与之相同。</p>
<h4 id="用条件控制实现条件分支">3.4.4 用条件控制实现条件分支</h4>
<p>　　在汇编代码中实现条件分支的最常用的方式是结合有条件和无条件跳转指令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> lt_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> ge_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">absdiff_se</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        lt_cnt++;</span><br><span class="line">        result = y - x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ge_cnt++;</span><br><span class="line">        result = x - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">gotodiff_se</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> x_ge_y;</span><br><span class="line">    &#125;</span><br><span class="line">    lt_cnt++;</span><br><span class="line">    result = y - x;</span><br><span class="line">x_ge_y:</span><br><span class="line">    ge_cnt++;</span><br><span class="line">    result = x - y;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">absdiff_se:</span><br><span class="line">	cmpq	%rsi, %rdi</span><br><span class="line">	jge	.L2</span><br><span class="line">	addq	$1, lt_cnt(%rip)</span><br><span class="line">	movq	%rsi, %rax</span><br><span class="line">	subq	%rdi, %rax</span><br><span class="line">	ret</span><br><span class="line">.L2:</span><br><span class="line">	addq	$1, ge_cnt(%rip)</span><br><span class="line">	movq	%rdi, %rax</span><br><span class="line">	subq	%rsi, %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　第1段代码是计算两数之差绝对值的C语言代码，这里会增加2个计数器，即<code>lt_cnt</code>和<code>ge_cnt</code>。第3段代码是GCC生成的汇编代码，第2段代码是汇编代码的C语言版本
(省略了全局变量的声明)，使用了类似汇编无条件跳转指令的<code>goto</code>，这种风格称为goto代码，这种编程风格并不好，因为它会使代码难以阅读和理解。</p>
<h4 id="用条件移动实现条件分支">3.4.5 用条件移动实现条件分支</h4>
<p>　　在汇编代码中实现条件分支的传统方式是<span
style="background-color: yellow">控制</span>的条件移动，当条件满足时，沿对应的路线执行；当条件不满足时，沿其他路径执行。这种机制简单而通用，但在现代CPU上可能非常低效。代替方案是<span
style="background-color: yellow">数据</span>的条件移动，计算条件语句的多种结果并根据条件选取其中之一，该方案会受到一些限制，但更符合现代CPU的性能特性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">absdiff</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        result = y - x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = x - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">cmovdiff</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> rval = y - x;</span><br><span class="line">    <span class="type">long</span> eval = x - y;</span><br><span class="line">    <span class="type">long</span> ntest = x &gt;= y;</span><br><span class="line">    <span class="keyword">if</span> (ntest)</span><br><span class="line">    &#123;</span><br><span class="line">        rval = eval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">absdiff:</span><br><span class="line">	movq	%rsi, %rax</span><br><span class="line">	subq	%rdi, %rax</span><br><span class="line">	movq	%rdi, %rdx</span><br><span class="line">	subq	%rsi, %rdx</span><br><span class="line">	cmpq	%rsi, %rdi</span><br><span class="line">	cmovge	%rdx, %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　第1段代码是计算两数之差的绝对值，第3段代码是数据的条件移动版本的汇编代码，第2段代码是汇编代码的C语言版本。第2段代码中<code>if</code>语句
(第6~9行) 对应第3段代码中的指令<code>cmp</code>和<code>cmovge</code>
(第6~7行)。</p>
<p>　　CPU通过<strong>流水线</strong>来获取高性能。在流水线中，1条指令的处理要经过一系列阶段，每个阶段执行该过程的一小部分
(例如，从内存读取指令、确定指令类型、从内存读取数据、执行算术运算、将数据写入内存以及更新PC)。这种方式通过重叠连续指令的步骤来获取高性能，例如，从内存读取指令的同时执行前一条指令的算术运算。要做到这一点，要求能够<span
style="background-color: yellow">事先确定待执行的指令序列</span>，这样才能保证流水线里充满待执行的指令。当遇到条件分支
(即跳转)
时，只有当分支条件求值完成后，才能确定分支。CPU使用<strong>分支预测逻辑</strong>来预测分支，只有当预测可靠时
(90%的成功率)，流水线才会充满指令。当预测失误时，CPU会丢弃跳转指令后所有为指令已做的工作，再开始用从正确位置开始的指令去填充流水线。预测失误的代价较高，这会浪费大于15~30个时钟周期，导致程序性能严重下降。</p>
<p>　　以Intel Haswell
CPU上运行函数<code>absdiff()</code>为例，使用传统方式实现条件分支时，<code>x &lt; y</code>的结果不可预测，此外，2个分支中的计算都只需要1个时钟周期，所以预测是否正确决定该函数的性能。对于包含条件分支的x86-64代码，当分支易于预测时，每次调用函数需要大约8个时钟周期；当分支难以预测时，每次调用函数需要大约17.5个时钟周期。假设预测失误的概率是<span
class="math inline">\(p\)</span>。预测成功时，执行代码所需时间是<span
class="math inline">\(T_{OK}\)</span>。预测失误的代价是<span
class="math inline">\(T_{MP}\)</span>。 <span class="math display">\[
T_{avg}(p)=(1-p)T_{OK}+p(T_{OK}+T_{MP})=T_{OK}+pT_{MP}
\]</span> 　　当<span
class="math inline">\(p=\frac{1}{2}\)</span>，<span
class="math inline">\(T_{OK}=8\)</span>，<span
class="math inline">\(T_{ran}=17.5\)</span>时，<span
class="math inline">\(T_{ran}=T_{avg}(p)=T_{OK}+\frac{T_{MP}}{2}\)</span>，故<span
class="math inline">\(T_{MP}=19\)</span>。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>别名</th>
<th>移动条件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cmov  S, R</code></td>
<td><code>cmovz</code></td>
<td><code>ZF</code></td>
<td>相等或为0</td>
</tr>
<tr>
<td><code>cmovne  S, R</code></td>
<td><code>cmovnz</code></td>
<td><code>~ZF</code></td>
<td>不等或非0</td>
</tr>
<tr>
<td><code>cmovs  S, R</code></td>
<td></td>
<td><code>SF</code></td>
<td>为负</td>
</tr>
<tr>
<td><code>cmovns  S, R</code></td>
<td></td>
<td><code>~SF</code></td>
<td>非负</td>
</tr>
<tr>
<td><code>cmovg  S, R</code></td>
<td><code>cmovnle</code></td>
<td><code>~(SF ^ OF) &amp; ~ZF</code></td>
<td>大于 (有符号)</td>
</tr>
<tr>
<td><code>cmovge  S, R</code></td>
<td><code>cmovnl</code></td>
<td><code>~(SF ^ OF)</code></td>
<td>大于等于 (有符号)</td>
</tr>
<tr>
<td><code>cmovl  S, R</code></td>
<td><code>cmovnge</code></td>
<td><code>SF ^ OF</code></td>
<td>小于 (有符号)</td>
</tr>
<tr>
<td><code>cmovle  S, R</code></td>
<td><code>cmovlng</code></td>
<td><code>(SF ^ OF) | ZF</code></td>
<td>小于等于 (有符号)</td>
</tr>
<tr>
<td><code>cmova  S, R</code></td>
<td><code>cmovnbe</code></td>
<td><code>~CF &amp; ~ZF</code></td>
<td>大于 (无符号)</td>
</tr>
<tr>
<td><code>cmovae  S, R</code></td>
<td><code>cmovnb</code></td>
<td><code>~CF</code></td>
<td>大于等于 (无符号)</td>
</tr>
<tr>
<td><code>cmovb  S, R</code></td>
<td><code>cmovnae</code></td>
<td><code>CF</code></td>
<td>小于 (无符号)</td>
</tr>
<tr>
<td><code>cmovbe  S, R</code></td>
<td><code>cmovna</code></td>
<td><code>CF | ZF</code></td>
<td>小于等于 (无符号)</td>
</tr>
</tbody>
</table>
<p>　　条件移动指令都有2个操作数，即源寄存器或内存引用<code>S</code>和目的寄存器<code>R</code>，操作数可以是16、32或64位。条件移动指令没有指定操作数长度的后缀。不同于跳转指令和<code>SET</code>，条件移动指令的结果取决于条件码的值，只有当条件满足时才会进行移动。不同于条件跳转指令，CPU无需预测就可以执行条件移动指令，只需要检查条件码并根据情况进行移动。</p>
<p>　　并非所有的条件分支都可以用数据的条件移动来实现。由于无论结果如何，系统都会对所有分支进行计算。因此，当条件分支中的<span
style="background-color: yellow">任一</span>分支可能产生错误或副作用，就会出现非法的行为。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">cread</span><span class="params">(<span class="type">long</span> *xp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (xp ? *xp : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cread:</span><br><span class="line">	movq	(%rdi), %rax</span><br><span class="line">	testq	%rdi, %rdi</span><br><span class="line">	movl	$0, %edx</span><br><span class="line">	cmov	%rdx, %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　当第1段代码中的指针为空时，第2段代码这种实现是非法的，<code>movq</code>指令的间接引用会导致空指针错误。</p>
<p>　　使用数据的条件移动也并非总是能提高效率。若条件判断的计算很复杂，而当相应的条件不满足时，相关的工作就白费了。编译器必须在浪费的计算和分支预测失误之间取舍，但编译器没有具有足够的信息来决定，最后GCC还是选择<span
style="background-color: yellow">控制的条件移动</span>。</p>
<h4 id="循环">3.4.6 循环</h4>
<p>　　C语言提供了多种循环，即<code>do-while</code>、<code>while</code>和<code>for</code>。汇编没有对应的指令，但可以通过条件判断和跳转组合来实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_do</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        result *= n;</span><br><span class="line">        n = n - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (n &gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_do_goto</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">loop:</span><br><span class="line">    result *= n;</span><br><span class="line">    n = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fact_do:</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">.L2:</span><br><span class="line">	imulq	%rdi, %rax</span><br><span class="line">	subq	$1, %rdi</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jg	.L2</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure>
<p>　　第1段代码是阶乘的C语言代码
(<code>do-while</code>版本)，第3段代码是GCC生成的汇编代码，第2段代码是汇编代码的C语言版本。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_while</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result *= n;</span><br><span class="line">        n = n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_while_jm_goto</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> test;</span><br><span class="line">loop:</span><br><span class="line">    result *= n;</span><br><span class="line">    n = n - <span class="number">1</span>;</span><br><span class="line">test:</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fact_while_jm_goto:</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L3:</span><br><span class="line">	imulq	%rdi, %rax</span><br><span class="line">	subq	$1, %rdi</span><br><span class="line">.L2:</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jg	.L3</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_while_gd_goto</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">loop:</span><br><span class="line">    result *= n;</span><br><span class="line">    n = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fact_while_gd_goto:</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jle	.L3</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">.L2:</span><br><span class="line">	imulq	%rdi, %rax</span><br><span class="line">	subq	$1, %rdi</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jne	.L2</span><br><span class="line">	rep; ret</span><br><span class="line">.L3:</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　第1段代码是阶乘的C语言代码
(<code>while</code>版本)，但GCC有2种编译方法。第1种编译方法是第3段代码
(对应的C语言代码是第2段)，称为jump to
middle，先执行一个无条件跳转跳到循环结尾处的条件判断，以此来执行初始化的条件判断。第2种编译方法是第5段代码
(对应的C语言代码是第4段)，称为guarded-do，先进行条件判断，若不满足则跳过循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_for</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fact_for_jm_goto:</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	movl	$2, %edx</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L3:</span><br><span class="line">	imulq	%rdx, %rax</span><br><span class="line">	addq	$1, %rdx</span><br><span class="line">.L2:</span><br><span class="line">	cmpq	%rdi, %rdx</span><br><span class="line">	jle	.L3</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fact_for_gd_goto:</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jle	.L3</span><br><span class="line">	movl	$1, %edx</span><br><span class="line">	movl	$2, %eax</span><br><span class="line">.L2:</span><br><span class="line">	imulq	%rax, %rdx</span><br><span class="line">	addq	$1, %rax</span><br><span class="line">	cmpq	%rax, %rdi</span><br><span class="line">	jge	.L3</span><br><span class="line">	rep; ret</span><br><span class="line">.L3:</span><br><span class="line">	movl	$1, %edx</span><br><span class="line">	movl	$2, %eax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　C语言的<code>for</code>语句 (第1段代码) 也可以用jump to middle
(第2段代码) 和guarded-do (第3段代码) 编译。</p>
<h4 id="多重分支">3.4.7 多重分支</h4>
<p>　　C语言中的<code>switch</code>语句提供基于1个整数索引值的<strong>多重分支</strong>，在处理有多个可能结果的判断时很有用。为了保证高效，在实现多重分支时会使用<strong>跳转表</strong>。跳转表是1个数组，表项<code>i</code>是代码段的地址，对应的代码段会实现<code>switch</code>索引值等于<code>i</code>时程序应采取的行动。相比一组很长的<code>if-else</code>，跳转表执行<code>switch</code>语句的时间与<code>case</code>的数量无关。GCC会根据<code>case</code>的数量和<code>case</code>值的范围跨度来编译<code>switch</code>语句。当<code>case</code>数量较多
(4个以上) 且值的范围跨度较小时，会使用跳转表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switch_eg</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n, <span class="type">long</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> val = x;</span><br><span class="line">    <span class="keyword">switch</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">        val *= <span class="number">13</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">102</span>:</span><br><span class="line">        val += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">103</span>:</span><br><span class="line">        val += <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">104</span>:`</span><br><span class="line">    <span class="keyword">case</span> <span class="number">106</span>:</span><br><span class="line">        val *= val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switch_eg_impl</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n, <span class="type">long</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> *jt[<span class="number">7</span>] = &#123;&amp;&amp;loc_A, &amp;&amp;loc_def, &amp;&amp;loc_B, &amp;&amp;loc_C, &amp;&amp;loc_D, &amp;&amp;loc_def, &amp;&amp;loc_D&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> index = n - <span class="number">100</span>;</span><br><span class="line">    <span class="type">long</span> val;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> loc_def;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> *jt[index];</span><br><span class="line">loc_A:</span><br><span class="line">    val = x * <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">loc_B:</span><br><span class="line">    x = x + <span class="number">10</span>;</span><br><span class="line">loc_C:</span><br><span class="line">    val = x + <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">loc_D:</span><br><span class="line">    val = x * x;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">loc_def:</span><br><span class="line">    val = <span class="number">0</span>;</span><br><span class="line">done:</span><br><span class="line">    *dest = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch_eg:</span><br><span class="line">	subq	$100, %rsi</span><br><span class="line">	cmpq	$6, %rsi</span><br><span class="line">	ja	.L8</span><br><span class="line">	jmp	*.L4(,%rsi,8)</span><br><span class="line">.L3:</span><br><span class="line">	leaq	(%rdi,%rdi,2), %rax</span><br><span class="line">	leaq	(%rdi,%rax,4), %rdi</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L5:</span><br><span class="line">	addq	$10, %rdi</span><br><span class="line">.L6:</span><br><span class="line">	addq	$11, %rdi</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L7:</span><br><span class="line">	imulq	%rdi, %rdi</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L8:</span><br><span class="line">	movl	$0, %edi</span><br><span class="line">.L2:</span><br><span class="line">	movq	%rdi, (%rdx)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　第1段代码是C语言<code>switch</code>语句的示例，这个示例中包括<code>case</code>跨过不连续的区域，多个标签都是同一<code>case</code>以及没有<code>break</code>结尾的<code>case</code>。第3段代码是GCC生成的汇编代码，第2段代码是汇编代码的C语言版本。原始的C语言代码中有针对值100、102~104和106的<code>case</code>，但<code>switch</code>变量<code>n</code>可以为任意值。GCC会先将<code>n</code>减100来将取值范围转移到0~6，然后创建新变量<code>index</code>，通过比较<code>index</code>和6来进行跳转。</p>
<p>　　在第2段代码中，数组<code>jt</code> (第10行)
就是跳转表，有7个表项，每个表项都是1个代码块的地址。表项由代码指针指明，由前缀<code>&amp;&amp;</code>
(创建指向代码位置的指针)
加标签组成。GCC支持计算<code>goto</code>，这是对C语言的扩展。类似的操作在第3段代码中的第5行，<code>jmp</code>指令的操作数有前缀<code>*</code>
(表示间接跳转)，并且操作数指向内存位置，其索引由寄存器<code>%rsi</code>给出，该寄存器保存<code>index</code>的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.section .rodata</span><br><span class="line">	.align 8		# 地址按8字节对齐</span><br><span class="line">.L4:</span><br><span class="line">	.quad	.L3		# case 100: loc_A</span><br><span class="line">	.quad	.L8		# case 101: loc_def</span><br><span class="line">	.quad	.L5		# case 102: loc_B</span><br><span class="line">	.quad	.L6		# case 103: loc_C</span><br><span class="line">	.quad	.L7		# case 104: loc_D</span><br><span class="line">	.quad	.L8		# case 105: loc_def</span><br><span class="line">	.quad	.L7		# case 106: loc_D</span><br></pre></td></tr></table></figure>
<p>　　这是跳转表的汇编声明，在<code>.rodata</code> (read-only data)
的目标代码文件段中，其中有7个四字，每个四字的值都是对应的汇编代码标签
(例如，<code>.L3</code>)
的地址。标签<code>.L4</code>是这个区域的起始，该标签对应的地址会作为间接跳转
(汇编代码中的第5行) 的基址。</p>
<h3 id="过程">3.5 过程</h3>
<p>　　过程是软件中的重要抽象之一，它提供了1种封装代码的方式，用一组指定的参数和1个可选的返回值实现了某个功能。在不同编程语言中，过程的形式有多种，例如，函数、方法、子例程和处理函数。要提供过程的机器级支持，必须要处理很多不同的属性。</p>
<p>　　假设过程<code>P()</code>调用过程<code>Q()</code>，<code>Q()</code>执行后返回到<code>P()</code>，该过程至少包括以下机制中的1个：</p>
<p>　　●
<strong>转移控制权</strong>。在进入过程<code>Q()</code>时，PC必须设置为<code>Q()</code>的代码的起始地址，然后在返回时，把PC设置为<code>P()</code>中对<code>Q()</code>的调用的下一条指令的地址。</p>
<p>　　●
<strong>传递数据</strong>。<code>P()</code>必须能向<code>Q()</code>提供若干个参数，<code>Q()</code>必须能向<code>P()</code>返回1个值。</p>
<p>　　●
<strong>分配和释放内存</strong>。在开始时，<code>Q()</code>可能需要为局部变量分配空间，而在返回前，必须释放这些空间。</p>
<p>　　当<code>Q()</code>执行时，<code>P()</code>以及调用链中所有直到<code>P()</code>的过程都会暂挂。当<code>Q()</code>运行时，仅需要为局部变量分配新的存储空间或设置对其他过程的调用。当<code>Q()</code>返回时，它分配的所有局部变量都可以释放。因此，程序可以用栈来管理其过程所需的存储空间，栈和PC存储着转移控制权、传递数据和分配内存所需的信息。当<code>P()</code>调用<code>Q()</code>时，控制权和数据信息会添加到栈顶。当<code>P()</code>返回时，这些信息会释放。</p>
<p>　　寄存器是唯一所有过程都共享的资源。虽然在给定时刻只有1个过程是活跃的，但仍需确保当过程调用其他过程时，被调用者不会覆盖调用者之后会使用的寄存器的值。为此，x86-64了采用了所有过程
(包括程序库) 都必须遵守的使用惯例。</p>
<p>　　按照惯例，寄存器<code>%rbx</code>、<code>%rbp</code>以及<code>%r12</code>~<code>%r15</code>是<strong>被调用者保存</strong>寄存器。当过程<code>P()</code>调用过程<code>Q()</code>时，<code>Q()</code>必须保存这些寄存器的值，维持它们的值在<code>Q()</code>返回<code>P()</code>时与<code>Q()</code>被调用时一致。过程<code>Q()</code>要维持寄存器的值不变，要么不改变寄存器的值，要么将寄存器的旧值压入栈中，改变寄存器的值，然后在返回前弹出旧值。所有其他寄存器
(除栈指针外)
是<strong>调用者保存</strong>寄存器，顾名思义，调用者在调用前需要先保存寄存器的值，所以所有过程都可以修改这类寄存器。</p>
<h4 id="运行时栈">3.5.1 运行时栈</h4>
<img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/general_stack_frame_structure.svg" class="" title="general_stack_frame_structure">
<p>　　当x86-64过程需要的存储空间超出寄存器能存储的空间时，就会在栈上分配空间，该部分称为过程的<strong>栈帧</strong>。当前正在执行的过程总是在栈顶。<span
style="background-color: yellow">大多数</span>过程的栈帧都是定长的，在过程的开始就已分配。</p>
<p>　　当过程<code>P()</code>调用过程<code>Q()</code>时，会把返回地址压入栈中，表示从<code>Q()</code>返回时<code>P()</code>继续执行的位置，这个返回地址存储的是与<code>P()</code>相关的状态，所以属于<code>P()</code>的栈帧。<code>Q()</code>的代码会扩展到当前栈的边界，分配它的栈帧所需的空间，这个空间可用于保存寄存器的值、分配局部变量的值和为其调用的过程设置参数。</p>
<table>
<colgroup>
<col style="width: 36%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr>
<th>操作数大小 (单位是位)</th>
<th>参数1</th>
<th>参数2</th>
<th>参数3</th>
<th>参数4</th>
<th>参数5</th>
<th>参数6</th>
</tr>
</thead>
<tbody>
<tr>
<td>64</td>
<td><code>%rdi</code></td>
<td><code>%rsi</code></td>
<td><code>%rdx</code></td>
<td><code>%rcx</code></td>
<td><code>%r8</code></td>
<td><code>%r9</code></td>
</tr>
<tr>
<td>32</td>
<td><code>%edi</code></td>
<td><code>%esi</code></td>
<td><code>%edx</code></td>
<td><code>%ecx</code></td>
<td><code>%r8d</code></td>
<td><code>%r9d</code></td>
</tr>
<tr>
<td>16</td>
<td><code>%di</code></td>
<td><code>%si</code></td>
<td><code>%dx</code></td>
<td><code>%cx</code></td>
<td><code>%r8w</code></td>
<td><code>%r9w</code></td>
</tr>
<tr>
<td>8</td>
<td><code>%dil</code></td>
<td><code>%sil</code></td>
<td><code>%dl</code></td>
<td><code>%cl</code></td>
<td><code>%r8b</code></td>
<td><code>%r9b</code></td>
</tr>
</tbody>
</table>
<p>　　在x86-64中，可通过寄存器<span
style="background-color: yellow">最多传递6个</span>整型数据
(例如，整数和指针)。寄存器的使用有特定顺序，寄存器的选择取决于待传递的数据的数据类型的大小。若函数的参数超过6个，超出的部分需要用栈来传递，即把参数0~5复制到寄存器，把参数6~n压入栈
(参数6位于栈顶)。通过栈传递参数时，所有的数据的大小都需要向上舍入到<span
style="background-color: yellow">8的整数倍</span>，这部分参数需要在自己的栈帧中分配空间，称为<strong>参数构造区</strong>。</p>
<p>　　有时，局部数据必须存储在内存中：</p>
<p>　　● 寄存器不足以存储所有的本地数据。</p>
<p>　　●
对局部变量使用地址运算符<code>&amp;</code>，所以必须能够为其生成地址。</p>
<p>　　●
某些局部变量是数组或结构，所以必须能够通过数组或结构引用来访问它们。</p>
<p>　　一般情况下，过程通过减小栈指针来在栈上分配空间，该空间作为栈帧的一部分
(即<strong>局部变量</strong>)。</p>
<p>　　为了提高空间和时间使用率，x86-64仅分配自己所需的栈帧部分，例如，当过程的参数少于6个时，所有参数都可以通过寄存器传递。实际上，很多过程甚至不需要栈帧，例如，所有的局部变量都可以保存在寄存器且不调用其他过程的过程。</p>
<h4 id="转移控制权">3.5.2 转移控制权</h4>
<p>　　将控制权从过程<code>P()</code>转移到过程<code>Q()</code>仅需把PC设置为<code>Q()</code>的代码的起始位置。从<code>Q()</code>返回时，CPU需要记录<code>P()</code>继续执行的代码位置。在x86-64中，用指令<code>call  Q</code>调用过程<code>Q()</code>时会记录该信息，该指令会把地址<code>A</code>压入栈中，并把PC设置为<code>Q()</code>的起始地址。压入的地址<code>A</code>称为返回地址，是指令<code>call</code>的下一条指令的地址。指令<code>ret</code>会从栈中弹出地址<code>A</code>并把PC设置为<code>A</code>。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>call  Label</code></td>
<td>过程调用</td>
</tr>
<tr>
<td><code>call  *Operand</code></td>
<td>过程调用</td>
</tr>
<tr>
<td><code>ret</code></td>
<td>从过程调用中返回</td>
</tr>
</tbody>
</table>
<p>　　指令<code>call</code>有1个操作数，即被调过程的指令的起始地址。类似跳转，调用可以是直接，也可以是间接
(<code>*</code>加操作数指示符)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># leaf(long y)的反汇编代码</span><br><span class="line">0000000000400540 &lt;leaf&gt;:</span><br><span class="line">400540:	48 8d 47 02	lea	0x2(%rdi), %rax</span><br><span class="line">400544:	c3		retq</span><br><span class="line"></span><br><span class="line"># top(long x)的反汇编代码</span><br><span class="line">0000000000400545 &lt;top&gt;:</span><br><span class="line">400545:	48 83 ef 05	sub	$0x5, %rdi</span><br><span class="line">400549:	e8 f2 ff ff ff 	callq	400540 &lt;leaf&gt;</span><br><span class="line">40054e: 48 01 c0	add	%rax, %rax</span><br><span class="line">400551: c3		retq</span><br><span class="line"></span><br><span class="line"># 主函数调用top的反汇编代码</span><br><span class="line"># ...</span><br><span class="line">40055b: e8 e5 ff ff ff	callq	400545 &lt;top&gt;</span><br><span class="line">400560: 48 89 c2	mov	%rax, %rdx</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>
<table style="width:100%;">
<colgroup>
<col style="width: 14%" />
<col style="width: 10%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 22%" />
<col style="width: 14%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr>
<th>PC</th>
<th>指令</th>
<th><code>%rdi</code></th>
<th><code>%rax</code></th>
<th><code>%rsp</code></th>
<th><code>*%rsp</code></th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x40055b</code></td>
<td><code>callq</code></td>
<td>100</td>
<td></td>
<td><code>0x7fffffffe820</code></td>
<td></td>
<td>调用<code>top(100)</code></td>
</tr>
<tr>
<td><code>0x400545</code></td>
<td><code>sub</code></td>
<td>100</td>
<td></td>
<td><code>0x7fffffffe818</code></td>
<td><code>0x400560</code></td>
<td>进入<code>top</code></td>
</tr>
<tr>
<td><code>0x400549</code></td>
<td><code>callq</code></td>
<td>95</td>
<td></td>
<td><code>0x7fffffffe818</code></td>
<td><code>0x400560</code></td>
<td>调用<code>leaf(100)</code></td>
</tr>
<tr>
<td><code>0x400540</code></td>
<td><code>lea</code></td>
<td>95</td>
<td></td>
<td><code>0x7fffffffe810</code></td>
<td><code>0x40054e</code></td>
<td>进入<code>leaf</code></td>
</tr>
<tr>
<td><code>0x400544</code></td>
<td><code>retq</code></td>
<td></td>
<td>97</td>
<td><code>0x7fffffffe810</code></td>
<td><code>0x40054e</code></td>
<td><code>leaf</code>返回97</td>
</tr>
<tr>
<td><code>0x40054e</code></td>
<td><code>add</code></td>
<td></td>
<td>97</td>
<td><code>0x7fffffffe818</code></td>
<td><code>0x400560</code></td>
<td>继续<code>top</code></td>
</tr>
<tr>
<td><code>0x400551</code></td>
<td><code>retq</code></td>
<td></td>
<td>194</td>
<td><code>0x7fffffffe818</code></td>
<td><code>0x400560</code></td>
<td><code>top</code>返回194</td>
</tr>
<tr>
<td><code>0x400560</code></td>
<td><code>mov</code></td>
<td></td>
<td>194</td>
<td><code>0x7fffffffe820</code></td>
<td></td>
<td>继续主函数</td>
</tr>
</tbody>
</table>
<p>　　在这个示例中，主函数先调用<code>top(100)</code>，然后<code>top</code>调用<code>leaf(95)</code>。<code>leaf</code>向<code>top</code>返回97，然后<code>top</code>向主函数返回194。第3行将寄存器<code>%rax</code>设置为97，然后第4行返回，从栈中弹出<code>0x40054e</code>并将PC设置为这个弹出的值，控制权转移回<code>top</code>并将寄存器<code>%rax</code>置为194
(第11行)，最后第11行返回，它从栈中弹出<code>0x400560</code>并将PC设置为这个弹出的值。此时，<code>%rsp</code>也恢复为调用<code>top</code>前的值。</p>
<p>　　把返回地址压入栈的这种简单机制能让函数在之后返回到程序中正确的位置。C语言
(以及大多数编程语言)
标准的调用-返回机制刚好与栈提供的后进先出的内存管理方法吻合。</p>
<h4 id="传递数据">3.5.3 传递数据</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc</span><span class="params">(<span class="type">long</span> a1, <span class="type">long</span> *a1p, <span class="type">int</span> a2, <span class="type">int</span> *a2p, <span class="type">short</span> a3, <span class="type">short</span> *a3p, <span class="type">char</span> a4, <span class="type">char</span> *a4p)</span></span><br><span class="line">&#123;</span><br><span class="line">    *a1p += a1;</span><br><span class="line">    *a2p += a2;</span><br><span class="line">    *a3p += a3;</span><br><span class="line">    *a4p += a4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proc:</span><br><span class="line">	movq	16(%rsp), %rax</span><br><span class="line">	addq	%rdi, (%rsi)</span><br><span class="line">	addl	%edx, (%rcx)</span><br><span class="line">	addw	%r8w, (%r9)</span><br><span class="line">	movl	8(%rsp), %edx</span><br><span class="line">	addb	%dl, (%rax)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/stack_frame_for_function_proc.svg" class="" title="stack_frame_for_function_proc">
<p>　　函数<code>proc()</code>有8个参数，包括不同长度的整型数和指向这些整型数的指针，其中前6个参数通过寄存器传递，后2个参数通过栈传递。作为过程调用的一部分，返回地址被压入栈中，所以后2个参数位于相对栈指针距离为8和16的位置。</p>
<h4 id="栈上的局部存储">3.5.4 栈上的局部存储</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">call_proc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> x1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x2 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">short</span> x3 = <span class="number">3</span>;</span><br><span class="line">    <span class="type">char</span> x4 = <span class="number">4</span>;</span><br><span class="line">    proc(x1, &amp;x1, x2, &amp;x2, x3, &amp;x3, x4, &amp;x4);</span><br><span class="line">    <span class="keyword">return</span> (x1 + x2) * (x3 - x4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call_proc:</span><br><span class="line">	subq	$32, %rsp</span><br><span class="line">	movq	$1, 24(%rsp)</span><br><span class="line">	movl	$2, 20(%rsp)</span><br><span class="line">	movw	$3, 18(%rsp)</span><br><span class="line">	movb	$4, 17(%rsp)</span><br><span class="line">	leaq	17(%rsp), %rax</span><br><span class="line">	movq	%rax, 8(%rsp)</span><br><span class="line">	movl	$4, (%rsp)</span><br><span class="line">	leaq	18(%rsp), %r9</span><br><span class="line">	movl	$3, %r8d</span><br><span class="line">	leaq	20(%rsp), %rcx</span><br><span class="line">	movl	$2, %edx	</span><br><span class="line">	leaq	24(%rsp), %rsi</span><br><span class="line">	movl	$1, %edi</span><br><span class="line">	call	proc</span><br><span class="line">	movslq	20(%rsp), %rdx</span><br><span class="line">	addq	24(%rsp), %rdx</span><br><span class="line">	movswl	18(%rsp), %eax</span><br><span class="line">	movsbl	17(%rsp), %ecx</span><br><span class="line">	subl	%ecx, %eax</span><br><span class="line">	cltq</span><br><span class="line">	imulq	%rdx, %rax</span><br><span class="line">	addq	$32, %rsp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/stack_frame_for_function_call_proc.svg" class="" title="stack_frame_for_function_call_proc">
<p>　　函数<code>call_proc()</code>有4个局部变量，还需要向有8个参数的函数<code>proc()</code>传参。函数<code>call_proc()</code>的汇编代码中大部分代码
(第2~15行)
都是为调用函数<code>proc()</code>准备，包括为局部变量和函数参数分配空间以及将函数参数加载到寄存器。在栈帧上分配局部变量<code>x1</code>
(相对栈指针偏移量为24)、<code>x2</code>
(相对栈指针偏移量为20)、<code>x3</code> (相对栈指针偏移量为18)
和<code>x4</code>
(相对栈指针偏移量为17)。用<code>leaq</code>指令生成指向这些变量的指针
(第7、10、12和14行)。参数7 (值为4) 和参数8 (指向<code>x4</code>的指针)
存储在相对栈指针偏移量为0和8的位置。</p>
<p>　　在调用函数<code>proc()</code>时，参数7和参数8的位置会变成相对栈指针偏移量为8和16的位置，因为返回地址已经被压入栈帧中。调用函数<code>proc()</code>完成后，会获取4个局部变量的值
(第17~20行) 并计算最终结果。在函数结束前，把栈指针加32来释放栈帧。</p>
<h4 id="寄存器中的局部存储空间">3.5.5 寄存器中的局部存储空间</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">P</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> u = Q(y);</span><br><span class="line">    <span class="type">long</span> v = Q(x);</span><br><span class="line">    <span class="keyword">return</span> u + v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	subq	$8, %rsp</span><br><span class="line">	movq	%rdi, %rbp</span><br><span class="line">	movq	%rsi, %rdi</span><br><span class="line">	call	Q</span><br><span class="line">	movq	%rax, %rbx</span><br><span class="line">	movq	%rbp, %rdi</span><br><span class="line">	call	Q</span><br><span class="line">	addq	%rbx, %rax</span><br><span class="line">	addq	$8, %rsp</span><br><span class="line">	popq	%rbx</span><br><span class="line">	popq	%rbp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　函数<code>P()</code>调用了2次函数<code>Q()</code>，第1次调用前，必须保存<code>x</code>的值。同样，第2次调用前，必须保存<code>Q(y)</code>的值。在汇编代码中，寄存器<code>%rbp</code>和<code>%rbx</code>分别保存<code>x</code>和<code>Q(y)</code>
(第2~3行)，然后进行栈帧对齐
(第4行)。第1次调用<code>Q()</code>前，把<code>x</code>存入<code>%rbp</code>
(第5行)，第2次调用<code>Q()</code>前，把上次调用的返回结果存入<code>%rbx</code>
(第8行)。最后，把它们从栈帧中弹出
(第13~14行)，恢复这2个被调用者保存寄存器的值。</p>
<h4 id="递归">3.5.6 递归</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">rfact</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = n * rfact(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rfact:</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	movq	%rdi, %rbx</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	movq	$1, %rdi</span><br><span class="line">	jle	.L1</span><br><span class="line">	leaq	-1(%rdi), %rdi</span><br><span class="line">	call	rfact</span><br><span class="line">	imulq	%rbx, %rax</span><br><span class="line">.L1:</span><br><span class="line">	popq	%rbx</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　在函数<code>rfact()</code>的汇编代码中，寄存器<code>%rbx</code>用于保存参数<code>n</code>，先把已有的值压入栈帧
(第2行)，随后在返回前弹出
(第11行)。根据栈的特点和寄存器的保存规则，可以保证当递归调用<code>rfact(n - 1)</code>返回时，调用的结果会保存到寄存器<code>%rax</code>且参数<code>n</code>仍然在寄存器<code>%rbx</code>中。</p>
<p>　　递归调用与调用其他函数一样。栈的机制保证每次调用都有私有的状态信息
(保存的返回位置和被调用者保存寄存器的值)
存储空间。如果需要，它还可以提供局部变量的存储。栈的分配和释放规则很自然地与函数调用-返回的顺序匹配。这种实现函数调用和返回的方法更复杂的场景同样适用，包含相互递归调用
(例如，函数<code>P()</code>调用<code>Q()</code>，<code>Q()</code>再调用<code>P()</code>)。</p>
<h3 id="数组的分配和访问">3.6 数组的分配和访问</h3>
<p>　　C语言中的数组可用于将标量数据聚集成更大的数据类型。对于数据类型<code>T</code>和整型常数<code>N</code>，其对应数组的声明为<code>T A[N]</code>。在声明时，会先在内存中分配<span
class="math inline">\(L\cdot N\)</span>字节的连续区域，<span
class="math inline">\(L\)</span>是数据类型<code>T</code>的大小。然后，声明标识符<code>A</code>来作为指向数组起始位置的指针，其指针值为<span
class="math inline">\(x_A\)</span>。可以用0到<span
class="math inline">\(N-1\)</span>的整数索引来访问该数组元素。数组元素<code>i</code>的存储地址为<span
class="math inline">\(x_A+L\cdot i\)</span>。</p>
<p>　　C语言允许指针运算，若<code>p</code>是指向类型是<code>T</code>的数据的指针，<code>p</code>的值为<span
class="math inline">\(x_p\)</span>，则<code>p + i</code>的值为<span
class="math inline">\(x_p+L\cdot
i\)</span>。可以对数组和指针应用数组下标操作，数组引用<code>A[i]</code>等价于<code>*(A + i)</code>。</p>
<p>　　假设整型数组<code>E</code>的起始地址和整数索引<code>i</code>分别存储在寄存器<code>%rdx</code>和<code>%rcx</code>中。以下是一些与<code>E</code>有关的表达式以及对应的汇编代码实现，结果存储在寄存器<code>%eax</code>
(若是数据) 或寄存器<code>%rax</code> (若是指针) 中。</p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 10%" />
<col style="width: 21%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr>
<th>表达式</th>
<th>类型</th>
<th>值</th>
<th>汇编代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>E</code></td>
<td><code>int *</code></td>
<td><span class="math inline">\(x_E\)</span></td>
<td><code>movq  %rdx, %rax</code></td>
</tr>
<tr>
<td><code>E[0]</code></td>
<td><code>int</code></td>
<td><span class="math inline">\(M[x_E]\)</span></td>
<td><code>movl  (%rdx), %rax</code></td>
</tr>
<tr>
<td><code>E[i]</code></td>
<td><code>int</code></td>
<td><span class="math inline">\(M[x_E+4i]\)</span></td>
<td><code>movl  (%rdx,%rcx,4), %eax</code></td>
</tr>
<tr>
<td><code>&amp;E[2]</code></td>
<td><code>int *</code></td>
<td><span class="math inline">\(x_E+8\)</span></td>
<td><code>leaq  8(%rdx), %rax</code></td>
</tr>
<tr>
<td><code>E + i - 1</code></td>
<td><code>int *</code></td>
<td><span class="math inline">\(x_E+4i-4\)</span></td>
<td><code>leaq  -4(%rdx,%rcx,4), %rax</code></td>
</tr>
<tr>
<td><code>*(E + i - 3)</code></td>
<td><code>int</code></td>
<td><span class="math inline">\(M[x_E+4i-12]\)</span></td>
<td><code>movl  -12(%rdx,%rcx,4), %eax</code></td>
</tr>
<tr>
<td><code>&amp;E[i] - E</code></td>
<td><code>long</code></td>
<td><span class="math inline">\(i\)</span></td>
<td><code>movq  %rcx, %rax</code></td>
</tr>
</tbody>
</table>
<h4 id="嵌套数组">3.6.1 嵌套数组</h4>
<p>　　当创建嵌套数组时，数组的分配和引用一般原则也成立。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">row3_t</span>[<span class="number">3</span>];</span><br><span class="line"><span class="type">row3_t</span> A[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>　　这是二元数组的声明方式之一，数据类型<code>row3_t</code>定义为包含3个<code>int</code>的数组，数组<code>A</code>包含5个元素，所有元素都是12B，整个数组是60B。</p>
<p>　　访问多维数组时，GCC会生成代码来计算元素的偏移量，并以数组的起始地址为基址和以偏移量
(可能会伸缩)
为索引来执行数据移动指令。对于声明为<code>T D[R][C]</code>的数组，数组元素<code>D[i][j]</code>的地址为<span
class="math inline">\(x_0+L(C\cdot i+j)\)</span>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leaq	(%rsi,%rsi,2), %rax</span><br><span class="line">leaq	(%rdi,%rax,4), %rax</span><br><span class="line">movl	(%rax,%rdx,4), %eax</span><br></pre></td></tr></table></figure>
<p>　　这段代码会计算元素地址<span
class="math inline">\(x_A+12i+4j=x_A+4(3i+j)\)</span>，使用了x86-64地址运算的伸缩和加法特性。其中<code>A[i][j]</code>是<span
class="math inline">\(5\times
3\)</span>的整型数组，第1个元素的指针、<code>i</code>和<code>j</code>分别在寄存器<code>%rdi</code>、<code>%rsi</code>和<code>%rdx</code>中。</p>
<h4 id="定长数组">3.6.2 定长数组</h4>
<p>　　GCC能够优化定长数组上的操作代码，这里以优化等级<code>-O1</code>为例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 16</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> fix_matrix[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fix_prod_ele</span><span class="params">(fix_matrix A, fix_matrix B, <span class="type">long</span> i, <span class="type">long</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += A[i][j] * B[j][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fix_prod_ele_opt</span><span class="params">(fix_matrix A, fix_matrix B, <span class="type">long</span> i, <span class="type">long</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *Aptr = &amp;A[i][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> *Bptr = &amp;B[<span class="number">0</span>][k];</span><br><span class="line">    <span class="type">int</span> *Bend = &amp;B[N][k];</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        result += *Aptr * *Bptr;</span><br><span class="line">        Aptr++;</span><br><span class="line">        Bptr += N;</span><br><span class="line">    &#125; <span class="keyword">while</span> (Bptr != Bend);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fix_prod_ele:</span><br><span class="line">	salq	$6, %rdx</span><br><span class="line">	addq	%rdx, %rdi</span><br><span class="line">	leaq	(%rsi,%rcx,4), %rcx</span><br><span class="line">	leaq	1024(%rcx), %rsi</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">.L2:</span><br><span class="line">	movl	(%rdi), %edx</span><br><span class="line">	imull	(%rcx), %edx</span><br><span class="line">	addl	%edx, %eax</span><br><span class="line">	addq	$4, %rdi</span><br><span class="line">	addq	$64, %rcx</span><br><span class="line">	cmpq	%rsi, %rcx</span><br><span class="line">	jne	.L2</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure>
<p>　　第1段代码是计算矩阵<code>A</code>的行<code>i</code>和矩阵<code>B</code>的列<code>k</code>的内积的C语言版本，第3段代码是GCC生成的汇编代码，第2段代码是汇编代码的C语言版本。相比第1段代码，第3段代码省略了整数索引<code>j</code>，并把所有的数组引用都换成了指针间接引用，包括指向矩阵<code>A</code>的行<code>i</code>中元素的指针<code>Aptr</code>、指向矩阵<code>B</code>的列<code>k</code>中元素的指针<code>Bptr</code>以及终止循环的指针<code>Bend</code>。</p>
<h4 id="变长数组">3.6.3 变长数组</h4>
<p>　　过去，C语言仅支持大小在编译时就能确定的多维数组
(对第1维可能有些例外)。若需要实现变长数组，需要使用<code>malloc()</code>或<code>calloc()</code>等函数和行优先索引将多维数组映射到一维数组。ISO
C99加入了允许数组维度是表达式的功能，维度在数组被分配时才计算出来，声明为<code>int A[expr1][expr2]</code>，它可以作为局部变量或函数的参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">var_ele</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> A[n][n], <span class="type">long</span> i, <span class="type">long</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> A[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这段代码会访问<span class="math inline">\(n\times
n\)</span>数组的元素<code>A[i][j]</code>，参数<code>n</code>必须在参数<code>A[n][n]</code>之前，这样函数可以在遇到这个数组时计算出其维度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">var_prod_ele</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> A[n][n], <span class="type">int</span> B[n][n], <span class="type">long</span> i, <span class="type">long</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += A[i][j] * B[j][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">var_prod_ele</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> A[n][n], <span class="type">int</span> B[n][n], <span class="type">long</span> i, <span class="type">long</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> *Arow = A[i];</span><br><span class="line">    <span class="type">int</span> *Bptr = &amp;B[<span class="number">0</span>][k];</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += Arow[j] * *Bptr;</span><br><span class="line">        Bptr += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.L2:</span><br><span class="line">	movl	(%rsi,%rdx,4), %r8d</span><br><span class="line">	imull	(%rcx), %r8d</span><br><span class="line">	addl	%r8d, %eax</span><br><span class="line">	addq	$1, %rdx</span><br><span class="line">	addq	%r9, %rcx</span><br><span class="line">	cmpq	%rdi, %rax</span><br><span class="line">	jne	.L2</span><br></pre></td></tr></table></figure>
<p>　　第1段代码是计算<span class="math inline">\(n\times
n\)</span>矩阵<code>A</code>的行<code>i</code>和<span
class="math inline">\(n\times
n\)</span>矩阵<code>B</code>的列<code>k</code>的内积的C语言版本，第3段代码是GCC生成的汇编代码
(仅节选了循环部分)，第2段代码是汇编代码的C语言版本。第2段代码中，保留了循环变量<code>j</code>来判断循环是否结束以及作为到<code>A</code>的行<code>i</code>的元素组成的数组的索引。第3段代码中，使用了伸缩后的值<code>4n</code>
(存储在寄存器<code>%r9</code>)
来增加<code>Bptr</code>，也使用了值<code>n</code>来判断循环是否结束，C语言代码中并没有体现出需要这2个值，但是由于指针运算的伸缩才使用了它们。</p>
<p>　　若允许使用优化，GCC能够识别出程序访问多维数组时的步长，然后在生成代码时避免直接应用计算元素地址的等式而导致的乘法。不论生成基于指针的代码还是基于数组的代码，这些优化都能显著提供程序的性能。</p>
<h3 id="异质的数据结构">3.7 异质的数据结构</h3>
<p>　　C语言提供了2种将不同类型的对象组合起来创建数据类型的机制，即<strong>结构体</strong>和<strong>联合体</strong>。结构体允许将多个对象聚合到1个单元，用关键字<code>struct</code>声明。联合体允许用几种不同的类型来引用同一对象，用关键字<code>union</code>声明。</p>
<h4 id="结构体">3.7.1 结构体</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/structure_rec.svg" class="" title="structure_rec">
<p>　　结构体<code>rec</code>包括2个<code>int</code>、1个由2个<code>int</code>组成的数组和1个<code>int</code>指针。数组<code>a</code>是嵌入到该结构体的。</p>
<p>　　在汇编代码中访问结构体的字段时，需要在结构体的地址上加上合适的偏移量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r-&gt;p = &amp;r-&gt;a[r-&gt;i + r-&gt;j];</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl	4(%rdi), %eax</span><br><span class="line">addl	(%rdi), %eax</span><br><span class="line">ctlq</span><br><span class="line">leaq	8(%rdi,%rax,4), %rax</span><br><span class="line">movq	%rax, 16(%rdi)</span><br></pre></td></tr></table></figure>
<p>　　<code>r</code>的类型是<code>struct rec *</code>，存储在寄存器<code>%rdi</code>中。在汇编代码中，第1~2行会将元素<code>r-&gt;i</code>加上元素<code>r-&gt;j</code>，字段<code>i</code>的偏移量是0，其地址是<code>r</code>。字段<code>j</code>的偏移量是4，其地址是<code>r + 4</code>。第4行会计算<code>&amp;r-&gt;a[r-&gt;i + r-&gt;j]</code>。第5行会将结果移动到<code>r-&gt;p</code>。</p>
<p>　　结构体的各个字段的选取完全是在编译时处理的。汇编代码不包含任何关于字段名称或声明的信息。</p>
<h4 id="联合体">3.7.2 联合体</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　对于类型是<code>union U3 *</code>的指针<code>p</code>，<code>p-&gt;c</code>、<code>p-&gt;i[0]</code>和<code>p-&gt;v</code>引用的都是数据结构的起始地址。联合体的大小等于其<span
style="background-color: yellow">最大字段</span>的大小，所以<code>union U3</code>是8B。</p>
<p>　　在有些上下文中，联合体很有用。但是，它也能导致一些错误，因为它绕过了C语言的类型系统提供的安全措施。应用场景之一是事先知道数据结构中2个不同字段是互斥的，声明为联合体可以减少分配的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    N_LEAF,</span><br><span class="line">    N_INTERNAL</span><br><span class="line">&#125; <span class="type">nodetype_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">nodetype_t</span> type;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">left</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">right</span>;</span></span><br><span class="line">        &#125; internal;</span><br><span class="line">        <span class="type">double</span> data[<span class="number">2</span>];</span><br><span class="line">    &#125; info;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　以二叉树为例，每个叶子节点都有2个<code>double</code>数据。每个内部节点都有指向2个子节点的指针，但没有数据。<code>type</code>是4B，<code>info.internal</code>或<code>info.data</code>是16B，加上用于数据对齐的4B，这个结构体共需24B。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">double2bits</span><span class="params">(<span class="type">double</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> u;</span><br><span class="line">    &#125; temp;</span><br><span class="line">    temp.d = d;</span><br><span class="line">    <span class="keyword">return</span> temp.u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　联合体还可以用于访问不同数据类型的位模式。在这段代码中，会以某种数据类型来存储联合体中的参数，又以其他数据类型来访问，最后<code>u</code>和<code>d</code>会有相同的位模式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">uu2double</span><span class="params">(<span class="type">unsigned</span> word0, <span class="type">unsigned</span> word1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">unsigned</span> u[<span class="number">2</span>];</span><br><span class="line">    &#125; temp;</span><br><span class="line">    temp.u[<span class="number">0</span>] = word0;</span><br><span class="line">    temp.u[<span class="number">1</span>] = word1;</span><br><span class="line">    <span class="keyword">return</span> temp.d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　当用联合体将各种不同大小的数据类型结合时，字节顺序会变得很重要。对于这段代码，在小端机器上时，<code>word0</code>是<code>d</code>的低4B，<code>word1</code>是<code>d</code>的高4B，而在大端机器上相反。</p>
<h4 id="数据对齐">3.7.3 数据对齐</h4>
<p>　　很多计算机系统都对基本数据类型的合法地址做出了限制，要求<span
style="background-color: yellow"><span
class="math inline">\(K\)</span>字节的基本对象的地址必须是<span
class="math inline">\(K\)</span>的整数倍</span>。这种对齐限制简化了在CPU和内存系统之间形成接口的硬件设计。虽然无论数据是否对齐，x86-64硬件都能正常工作。</p>
<table>
<thead>
<tr>
<th><span class="math inline">\(K\)</span></th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>char</code></td>
</tr>
<tr>
<td>2</td>
<td><code>short</code></td>
</tr>
<tr>
<td>4</td>
<td><code>int</code>，<code>float</code></td>
</tr>
<tr>
<td>8</td>
<td><code>long</code>，<code>double</code>，<code>char *</code></td>
</tr>
</tbody>
</table>
<p>　　编译器会在汇编代码中加入用于指明数据对齐要求的汇编指示，例如，<code>.align 8</code>表示之后的数据的起始地址都是8的整数倍。</p>
<p>　　对于结构体，编译器可能需要在字段的分配中插入间隙来保证每个元素都满足其对齐要求，而结构本身也有对齐要求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/structure_s1_and_s2.svg" class="" title="structure_s1_and_s2">
<p>　　编译器在结构体<code>S1</code>和<code>S2</code>中都插入了3B的间隙来保证每个元素以及结构体的对齐。</p>
<p>　　对于大多数x86-64指令，数据对齐只会提升效率，并不会影响程序的行为。但是，当数据没有对齐时，某些型号的Intel和AMD
CPU将无法正确执行部分用于实现多媒体操作的SSE指令，这些指令会对16B数据块进行操作。在SSE单元和内存之间移动数据的指令要求内存地址必须是16的整数倍，不满足此要求会导致异常
(默认是程序终止)。因此，编译器和运行时系统必须确保为了读写SSE寄存器而分配的内存满足16B对齐。较新版本的x86-64
CPU加入了AVX多媒体指令，这类指令除了提供SSE指令的超集，还去除了对齐要求。</p>
<h3 id="在机器级程序中结合控制和数据">3.8
在机器级程序中结合控制和数据</h3>
<p>　　指针能以统一的方式对不同数据结构的元素产生引用。每个指针都对应1个类型，该类型表明该指针指向的对象。<code>int *p</code>是指向<code>int</code>的指针，<code>char **cpp</code>指向的对象是指向<code>char</code>的指针。通常，若对象类型是<code>T</code>，其指针是<code>T *</code>。特殊的<code>void *</code>表示通用指针。每个指针都有1个值，该值是某个指定类型的对象的地址。特殊的<code>NULL</code>
(0) 表示该指针没有指向任何位置。</p>
<p>　　将指针强制转换到其他类型时，仅改变其类型，不会改变其值。强制转换的效果之一是改变指针运算的伸缩。例如，若<code>p</code>是<code>char *</code>类型的指针，其值为<span
class="math inline">\(p\)</span>，则<code>(int *)p + 7</code>的结果为<span
class="math inline">\(p+28\)</span>。</p>
<p>　　指针也可以指向函数，函数指针的值是该函数机器代码表示中第1条指令的地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> *p)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span> *);</span><br><span class="line">fp = fun;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> result = fp(<span class="number">3</span>, &amp;y);</span><br></pre></td></tr></table></figure>
<p>　　第1段代码是函数<code>fun()</code>的函数原型。第2段代码会先声明指针<code>fp</code>，然后将它赋值为函数<code>fun()</code>。第3段代码会用指针<code>fp</code>来调用函数<code>fun()</code>。</p>
<h4 id="gdb的使用">3.8.1 GDB的使用</h4>
<p>　　GNU的调试器GDB提供了很多有用的特性，支持机器级程序的运行时评估和分析。启动GDB的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb prog</span><br></pre></td></tr></table></figure>
<p>　　GDB的常规使用方法是在程序中有需要的地方设置断点，断点可以设置在函数入口后或某个地址处。程序在执行时，遇到断点会停止并将控制权返回给用户。在断点处，可以以各种方式查看各个寄存器和内存位置，也可以单步跟踪程序，还可以1次仅执行几条指令或前进到下一断点。</p>
<table>
<colgroup>
<col style="width: 47%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>quit</code></td>
<td>退出GDB</td>
</tr>
<tr>
<td><code>run</code></td>
<td>运行程序 (在此给出命令行选项)</td>
</tr>
<tr>
<td><code>kill</code></td>
<td>停止程序</td>
</tr>
<tr>
<td><code>break multstore</code></td>
<td>在函数<code>multstore()</code>入口处设置断点</td>
</tr>
<tr>
<td><code>break *0400540</code></td>
<td>在地址<code>0x0400540</code>处设置断点</td>
</tr>
<tr>
<td><code>delete 1</code></td>
<td>删除断点1</td>
</tr>
<tr>
<td><code>delete</code></td>
<td>删除所有断点</td>
</tr>
<tr>
<td><code>stepi</code></td>
<td>执行1条指令</td>
</tr>
<tr>
<td><code>stepi 4</code></td>
<td>执行4条指令</td>
</tr>
<tr>
<td><code>nexti</code></td>
<td>类似于<code>stepi</code>，但以函数调用为单位</td>
</tr>
<tr>
<td><code>continue</code></td>
<td>继续执行</td>
</tr>
<tr>
<td><code>finish</code></td>
<td>运行到当前函数返回</td>
</tr>
<tr>
<td><code>disas</code></td>
<td>反汇编当前函数</td>
</tr>
<tr>
<td><code>disas multstore</code></td>
<td>反汇编函数<code>multstore()</code></td>
</tr>
<tr>
<td><code>disas 0x400544</code></td>
<td>反汇编地址位于<code>0x0400540</code>附近的函数</td>
</tr>
<tr>
<td><code>disas 0x400540, 0x40054d</code></td>
<td>反汇编地址在指定范围内的代码</td>
</tr>
<tr>
<td><code>print /x $rip</code></td>
<td>以十六进制输出PC的值</td>
</tr>
<tr>
<td><code>print $rax</code></td>
<td>以十进制输出寄存器<code>%rax</code>的值</td>
</tr>
<tr>
<td><code>print /x $rax</code></td>
<td>以十六进制输出寄存器<code>%rax</code>的值</td>
</tr>
<tr>
<td><code>print /t $rax</code></td>
<td>以二进制输出寄存器<code>%rax</code>的值</td>
</tr>
<tr>
<td><code>print 0x100</code></td>
<td>输出<code>0x100</code>的十进制表示</td>
</tr>
<tr>
<td><code>print /x 555</code></td>
<td>输出555的十六进制表示</td>
</tr>
<tr>
<td><code>print /x ($rsp+8)</code></td>
<td>以十六进制输出栈指针加8的内容</td>
</tr>
<tr>
<td><code>print *(long *) 0x7fffffffe818</code></td>
<td>输出地址是<code>0x7fffffffe818</code>的长整数</td>
</tr>
<tr>
<td><code>print *(long *) ($rsp + 8)</code></td>
<td>输出地址是栈指针加8的长整数</td>
</tr>
<tr>
<td><code>x/2g 0x7fffffffe818</code></td>
<td>检查地址始于<code>0x7fffffffe818</code>的双字</td>
</tr>
<tr>
<td><code>x/20b multstore</code></td>
<td>检查函数<code>multstore()</code>的前20B</td>
</tr>
<tr>
<td><code>info frame</code></td>
<td>当前栈帧的相关信息</td>
</tr>
<tr>
<td><code>info registers</code></td>
<td>所有寄存器的值</td>
</tr>
<tr>
<td><code>help</code></td>
<td>GDB的相关信息</td>
</tr>
</tbody>
</table>
<p>　　除了使用命令行接口来访问GDB，DDD也是选择之一，它是GDB的扩展，提供了图像用户界面。</p>
<h4 id="内存越界引用和缓存溢出">3.8.2 内存越界引用和缓存溢出</h4>
<p>　　C语言不会对数组引用进行边界检查，而且局部变量和状态信息都存储在栈中，这2种情况结合起来就能导致严重的程序错误。对越界的数组元素的写操作会损坏存储在栈中的状态信息，当程序使用这个已损坏的状态信息来重新加载寄存器或执行指令<code>ret</code>时，会导致严重的错误。</p>
<p>　　<strong>缓存溢出</strong>是常见的状态损坏之一，即在栈中分配字符数组来保存字符串时，字符串的长度超过了为数组分配的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">char</span> *dest = s;</span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; c != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        *dest++ = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == EOF &amp;&amp; dest == s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　库函数<code>gets()</code>会从标准输入读取1行
(遇到<code>\n</code>或错误时停止)，然后将这个字符串复制到参数<code>s</code>指向的位置并在字符串结尾加上<code>null</code>。函数<code>echo()</code>会从标准输入读取1行并回显到标准输出。由于<code>buf</code>仅有8B，任何超过7B的字符串都会导致越界。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo:</span><br><span class="line">	subq	$24, %rsp</span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	call	gets</span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	call	puts</span><br><span class="line">	addq	$24, %rsp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/stack_organization_for_function_echo.svg" class="" title="stack_organization_for_function_echo">
<p>　　在函数<code>echo()</code>的汇编代码中，会先把栈指针减24
(第2行)。栈指针 (即<code>buf</code>)
会被复制到<code>%rdi</code>作为调用<code>gets()</code>和<code>puts</code>的参数。<code>buf</code>和返回地址之间的16B是未使用的。用户输入的字符不超过7个时，函数<code>gets()</code>返回的字符串能放入<code>buf</code>分配的空间中。输入的字符不超过23个时，不会有严重的后果，但超过后会损坏存储在返回地址的值，导致指令<code>ret</code>
(第8行) 会跳转意想不到的位置。</p>
<p>　　在函数<code>echo()</code>中，更好的选择使用<code>fgets</code>函数，它包括1个参数来限制待读入的最大字节数。使用<code>gets()</code>或其他任何能导致溢出的函数通常都是不好的编程习惯，但很多常用的库函数
(包括<code>strcpy</code>、<code>strcat</code>和<code>sprintf</code>)
都不需要指定目标缓存的大小。</p>
<p>　　缓存溢出可用于让程序执行它本来不会执行的函数，这是常见的攻击方式之一。例如，给程序输入某个字符串，该字符串包含一些可执行代码的字节编码
(称为<strong>攻击代码</strong>)
和一些字节，这些字节能让指向攻击代码的指针覆盖返回地址，因此，执行指令<code>ret</code>会跳转到攻击代码。在某种攻击形式中，攻击代码会使用系统调用启动1个shell程序，给攻击者提供一组操作系统函数。在另一种攻击形式中，攻击代码会执行一些未授权的任务，修复对栈的损坏，然后再次执行指令<code>ret</code>，(表面上)
正常返回给调用者。</p>
<h4 id="对抗缓存溢出攻击">3.8.3 对抗缓存溢出攻击</h4>
<p>　　在系统中插入攻击代码时，既要插入代码，也要插入指向这段代码的指针，该指针也是攻击字符串的一部分，生成该指针需要知道这个字符串的栈地址。过去，程序的栈地址很容易预测。对于所有运行相同程序和操作系统版本组合的机器，栈位置是固定的。以传染病类比，许多系统都容易受到同一种病毒的攻击，这种现象称为<strong>安全单一化</strong>。</p>
<p>　　栈随机化的思想是使得栈的位置在程序每次运行时都有变化。实现方式是程序开始时，在栈上分配0~<span
class="math inline">\(n\)</span>字节的随机大小的空间来了让后续栈的地址变化
(程序不会使用它)。<span
class="math inline">\(n\)</span>需要足够大，才能保证栈地址的变化范围足够大，但又需要足够小，不至于浪费太多的空间。</p>
<p>　　在Linux中，栈随机化已经成为标准，它是<strong>地址空间布局随机化</strong>技术之一。采用ASLR，每次运行时程序的不同部分
(包括程序代码、库代码、栈、全局变量和堆数据)
都会加载到内存不同的区域。然而，可以通过暴力手段来克服随机化，常见方法之一是在实际的攻击代码前插入1段很长的<span
style="background-color: yellow">空操作</span>，执行这种指令除了使PC加1，没有其他效果。只要攻击者能够猜中这段序列中的某个地址，程序就会经过这个序列到达攻击代码，称为<span
style="background-color: yellow">空操作雪橇</span>。栈随机化和其他一些ASLR技术能够增加攻击难度，但并不能完全防御。</p>
<p>　　第2道防线是<strong>栈损坏检查</strong>。较新版本的GCC加入了<strong>栈保护者</strong>机制，其思想是在所有局部缓存和栈状态之间加入<span
style="background-color: yellow">金丝雀值</span> (也称为<span
style="background-color: yellow">哨兵值</span>)，该值每次运行时随机。在恢复寄存器状态和返回前，程序会检查金丝雀值是否改变，若改变，则程序异常终止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo:</span><br><span class="line">	subq	$24, %rsp</span><br><span class="line">	movq	%fs:40, %rax</span><br><span class="line">	movq	%rax, 8(%rsp)</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	movq	%rax, 8(%rsp)</span><br><span class="line">	call	gets</span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	call	puts</span><br><span class="line">	movq	8(%rsp), %rax</span><br><span class="line">	xorq	%fs:40, %rax</span><br><span class="line">	je		.L2</span><br><span class="line">	call	__stack_chk_fail</span><br><span class="line">.L2:</span><br><span class="line">	addq	$24, %rsp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/stack_organization_for_function_echo_with_stack_protector_enabled.svg" class="" title="stack_organization_for_function_echo_with_stack_protector_enabled">
<p>　　栈溢出示例的代码使用了命令行选项<code>-fno-stack-protector</code>，这段代码没有使用该命令行选项。这个版本的函数会在内存中读取1个值
(第3行)，再把它放到存储到相对栈指针偏移量为8的位置。指令操作数<code>%fs:40</code>表示金丝雀值是通过<span
style="background-color: yellow">段寻址</span>从内存中读取的。将金丝雀值存储在特殊的段并标记为只读，这样攻击者就不能覆盖。在恢复寄存器状态和返回前，函数会将存储在栈位置的值和金丝雀值比较
(第11行)。若相等，指令<code>xorq</code>会得到0，函数会正常执行；否则，将会调用错误处理例程。</p>
<p>　　栈保护者能防止缓存溢出攻击损坏存储在程序栈上的状态。它只会带来很小的性能损失，GCC只在函数中有局部<code>char</code>类型缓存时，才会插入这样的代码。</p>
<p>　　第3段防线是消除攻击者向系统中插入可执行代码的能力。方法之一是限制存储可执行代码的内存区域。在常规程序中，只有用于存储编译器生成的代码的内存区域才需要是可执行的，其他部分可以被限制为只读和写。虚拟内存空间在逻辑上划分为<span
style="background-color: yellow">页</span>，每页通常是2048或4096B。硬件支持多种形式的内存保护，指示用户程序和操作系统内核允许的访问形式。很多系统允许控制3种访问形式，即读
(从内存读取)、写 (写入到内存) 和执行 (将内存的内容视为机器级代码)。</p>
<p>　　过去，x86-64体系结构将读和执行访问控制位作为1个1位的标志位，所以任何被标记位可读的页也是可执行的。栈必须是既可读又可写，所以栈的数据也是可执行的。有很多已经实现的机制可以让页可读的同时不可执行，但这种机制通常会带来严重的性能损失。后来，AMD为其64位CPU的内存保加入了<span
style="background-color: yellow">不执行</span>位，将读和执行访问模式分开，Intel也跟进了该特性。有了该特性后，实现页可读的同时不可执行就不再有性能损失。</p>
<p>　　有些类型的程序要求动态生成和执行代码的能力，例如，<span
style="background-color: yellow">即时</span>编译技术动态地为解释型语言
(例如，Java) 编写的程序生成代码来提供程序性能。</p>
<h4 id="变长栈帧">3.8.4 变长栈帧</h4>
<p>　　有些函数需要的局部存储是变长的，例如，声明局部变长数组或调用标准库函数<code>alloca()</code>
(该函数类似函数<code>malloc()</code>，但该函数在运行时栈上分配空间，并且分配的空间会在返回时自动释放)。为了管理变长栈帧，x86-64使用寄存器<code>%rbp</code>作为<strong>帧指针</strong>，也称为<strong>基指针</strong>。帧指针是被调用者保存寄存器，所以需要先将其值保存在栈中并让帧指针指向该位置，在之后函数的整个执行过程中帧指针将一直指向该位置。对于固定长度的局部变量
(通常保存在与帧指针相邻且更靠近栈顶的位置)，可以通过其相对帧指针的偏移量来引用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">vframe</span><span class="params">(<span class="type">long</span> n, <span class="type">long</span> idx, <span class="type">long</span> *q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> *p[n];</span><br><span class="line">    p[<span class="number">0</span>] = &amp;i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *p[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vframe:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	subq	$16, %rsp</span><br><span class="line">	leaq	22(,%rdi,8), %rax</span><br><span class="line">	andq	$-16, %rax</span><br><span class="line">	subq	%rax, %rsp</span><br><span class="line">	leaq	7(%rsp), %rax</span><br><span class="line">	shrq	$3, %rax</span><br><span class="line">	leaq	0(,%rax,8), %r8</span><br><span class="line">	movq	%r8, %rcx</span><br><span class="line"># ...</span><br><span class="line"></span><br><span class="line">.L3:</span><br><span class="line">	movq	%rdx, (%rcx,%rax,8)</span><br><span class="line">	addq	$1, %rax</span><br><span class="line">	movq	%rax, -8(%rbp)</span><br><span class="line">.L2:</span><br><span class="line">	movq	-8(%rbp), %rax</span><br><span class="line">	cmpq	%rdi, %rax</span><br><span class="line">	jl	.L3</span><br><span class="line"># ...</span><br><span class="line">	</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/stack_frame_for_function_vframe.svg" class="" title="stack_frame_for_function_vframe">
<p>　　第1段代码是包含变长数组的示例的C语言代码，第2段代码是GCC生成的汇编代码
(节选了部分)。第1段代码中，函数声明了包含<span
class="math inline">\(n\)</span>个指针的局部数组<code>p</code>，<span
class="math inline">\(n\)</span>由第1个参数给出，每次调用都可能不同，编译器无法确定该分配给该函数的栈帧空间。此外，该函数还有1个对局部变量<code>i</code>的地址引用，所以该变量必须存储在栈中。在执行该函数时，必须能够访问局部变量<code>i</code>和数组<code>p</code>中的元素。返回时，该函数必须释放该栈帧，并让栈指针指向返回地址。</p>
<p>　　第2段代码中，会先把帧指针的值压入栈并让帧指针指向栈顶
(第2~3行)。然后，在栈上分配16B，其中前8B存储局部变量<code>i</code>，而后8B未使用。接着，为数组<code>p</code>分配空间
(第5~11行)，<span
class="math inline">\(s_1\)</span>是第4行代码执行后栈指针的值，<span
class="math inline">\(s_2\)</span>是第7行代码执行后栈指针的值，<span
class="math inline">\(p\)</span>是第10~11行中赋值给寄存器<code>%r8</code>和<code>%rcx</code>的值，用于引用数组<code>p</code>。第5行会通过指令<code>leaq</code>计算<span
class="math inline">\(8n+22\)</span>，第6行会通过指令<code>andq</code>将结果向下舍入到最接近的16的整数倍，<span
class="math inline">\(s_2\)</span>等于<span
class="math inline">\(s_1\)</span>减该值。第8~10行会将<span
class="math inline">\(s_2\)</span>向上舍入到最接近的8的整数倍。<span
class="math inline">\(p\)</span>是8的整数倍，<span
class="math inline">\(s_1\)</span>与<span
class="math inline">\(s_2\)</span>的差值是16的整数倍，而可能存在的空间<span
class="math inline">\(e_1\)</span>和<span
class="math inline">\(e_2\)</span>正是为了保证这一点。变量<code>i</code>的地址是<code>-8(%rbp)</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq	%rbp, %rsp</span><br><span class="line">popq	%rbp</span><br></pre></td></tr></table></figure>
<p>　　指令<code>leave</code>用于释放栈帧，等价于这2条指令，即先将栈指针设置为保存帧指针值的位置并将弹出帧指针。</p>
<p>　　在较早的x86-64代码中，每个函数调用都会使用帧指针。后来，只有栈帧长度可变的情况才使用。过去，大多数编译器在生成IA32代码时会使用帧指针，较新版本的GCC放弃了这一惯例。</p>
<h3 id="浮点代码">3.9 浮点代码</h3>
<p>　　由于1997年推出的Pentium/MMX，Intel和AMD都推出了持续数代的用于支持图形和图像处理的媒体指令。这些指令本意是允许多个操作以并行模式执行
(即<strong>单指令多数据</strong>)。在这种模式中，对多个不同数据并行执行同一操作。后来，经过长足的发展，名称也发生了变化，从MMX到SSE再到AVX。每一代中，都有一些不同的版本。这些版本都会管理寄存器组的数据，这些寄存器在MMX中称为MM寄存器，SSE中称为XMM寄存器，AVX中称为YMN寄存器。MM寄存器是64位，XMM寄存器是128位，YMM寄存器是256位。因此，每个YMM寄存器可以存储8个32位值或4个64位值，这些值可以是整数或浮点数。</p>
<p>　　2000年推出的Pentium
4中使用了SSE2，至此，媒体指令开始包括通过XMM和YMM寄存器的低32位或64位中的单个值操作标量浮点数据的指令。这个标量模式提供了一组寄存器和指令，它们更类似于其他CPU支持浮点数的方式。所有能够执行x86-64代码的CPU都支持SSE2或更高的版本，因此，x86-64浮点数是基于SSE或AVX的，包括传递过程参数和返回值的规则。</p>
<p>　　这里的内容基于AVX2，即AVX的第2个版本，在2013年Core i7 Haswell
CPU中使用。当给定<code>-mavx2</code>命令行选项时，GCC会生成AVX2代码。基于不同版本的SSE以及第1个版本的AVX的代码从概念上类似，不过指令名和格式有所不同。</p>
<img src="/2023/01/02/computer-systems-a-programmer's-perspective-3e-chpt-3/media_registers.svg" class="" title="media_registers">
<p>　　AVX浮点体系结构允许数据存储在16个YMM寄存器，它们的名称为<code>%ymm0</code>~<code>%ymm15</code>。每个YMM寄存器都是256位。当对标量数据操作时，这些寄存器仅保存浮点数，而且只使用低32
(对于<code>float</code>) 或64位
(对于<code>double</code>)。汇编代码用寄存器的SSE
XMM寄存器名称<code>%xmm0</code>~<code>%xmm15</code>来引用它们，每个XMM寄存器都是对应的YMM寄存器的低128位。</p>
<p>　　寄存器<code>%xmm0</code>~<code>%xmm7</code>用于传递浮点参数，按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。寄存器<code>%xmm0</code>还用于返回浮点值。所有的XMM寄存器都是调用者保存，被调用者可以不用保存就覆盖这些寄存器。</p>
<p>　　当函数参数包含指针、整数和浮点数时，指针和整数通过整数寄存器传递，浮点数通过XMM寄存器传递，寄存器的分配取决于参数的类型和排列顺序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> x, <span class="type">double</span> y, <span class="type">long</span> z)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">f2</span><span class="params">(<span class="type">double</span> y, <span class="type">int</span> x, <span class="type">long</span> z)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">f3</span><span class="params">(<span class="type">float</span> x, <span class="type">double</span> *y, <span class="type">double</span> *z)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>f1()</code>的参数<code>x</code>、<code>y</code>和<code>z</code>分别存储在寄存器<code>%edi</code>、<code>%xmm0</code>和<code>%rsi</code>，函数<code>f2()</code>和函数<code>f1()</code>的寄存器分配相同。函数<code>f3()</code>的参数<code>x</code>、<code>y</code>和<code>z</code>分别存储在寄存器<code>%xmm0</code>、<code>%rdi</code>和<code>%rsi</code>。</p>
<h4 id="浮点移动和转换操作">3.9.1 浮点移动和转换操作</h4>
<table>
<thead>
<tr>
<th>指令</th>
<th>源</th>
<th>目的</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vmovss</code></td>
<td><span class="math inline">\(M_{32}\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td>移动单精度数</td>
</tr>
<tr>
<td><code>vmovss</code></td>
<td><span class="math inline">\(X\)</span></td>
<td><span class="math inline">\(M_{32}\)</span></td>
<td>移动单精度数</td>
</tr>
<tr>
<td><code>vmovsd</code></td>
<td><span class="math inline">\(M_{64}\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td>移动双精度数</td>
</tr>
<tr>
<td><code>vmovsd</code></td>
<td><span class="math inline">\(X\)</span></td>
<td><span class="math inline">\(M_{64}\)</span></td>
<td>移动双精度数</td>
</tr>
<tr>
<td><code>vmovaps</code></td>
<td><span class="math inline">\(X\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td>移动对齐且已封装的单精度数</td>
</tr>
<tr>
<td><code>vmovapd</code></td>
<td><span class="math inline">\(X\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td>移动对齐且已封装的双精度数</td>
</tr>
</tbody>
</table>
<p>　　引用内存的指令是<span
style="background-color: yellow">标量</span>指令，表示其操作数是单个值而非封装后的值。数据要么保存在内存中
(在表中用<span class="math inline">\(M_{32}\)</span>和<span
class="math inline">\(M_{64}\)</span>表示)，要么保存在XMM寄存器中
(在表中用<span
class="math inline">\(X\)</span>表示)。无论数据是否对齐，这些指令都能正确执行，不过代码优化规则建议32位内存满足4B对齐，64位数据满足8B对齐。内存引用的指定方式与整数数据移动指令相同，包括偏移量、基址寄存器、变址寄存器和伸缩因子的所有可能的组合。</p>
<p>　　GCC只用标量移动操作从内存移动数据到XMM寄存器或从XMM寄存器移动数据到内存。对于在两个XMM寄存器之间移动数据，GCC会使用指令<code>vmovaps</code>和<code>vmovapd</code>，程序复制整个寄存器还是只复制低位并不会影响程序功能，也不会影响执行速度，所以使用这些指令还是针对标量数据的指令并没有实质上的差别。指令名称中<code>a</code>表示对齐，当用于读写内存时，若地址不满足16B对齐，则会导致异常。</p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 14%" />
<col style="width: 11%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr>
<th>指令</th>
<th>源</th>
<th>目的</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vcvttss2si</code></td>
<td><span class="math inline">\(X/M_{32}\)</span></td>
<td><span class="math inline">\(R_{32}\)</span></td>
<td>用截断的方法将单精度数转换成整数</td>
</tr>
<tr>
<td><code>vcvttsd2si</code></td>
<td><span class="math inline">\(X/M_{64}\)</span></td>
<td><span class="math inline">\(R_{32}\)</span></td>
<td>用截断的方法将双精度数转换成整数</td>
</tr>
<tr>
<td><code>vcvttss2siq</code></td>
<td><span class="math inline">\(X/M_{32}\)</span></td>
<td><span class="math inline">\(R_{64}\)</span></td>
<td>用截断的方法将单精度数转换成四字整数</td>
</tr>
<tr>
<td><code>vcvttsd2siq</code></td>
<td><span class="math inline">\(X/M_{64}\)</span></td>
<td><span class="math inline">\(R_{64}\)</span></td>
<td>用截断的方法将双精度数转换成四字整数</td>
</tr>
</tbody>
</table>
<p>　　浮点数转换整数指令有2个操作数，这类指令会把1个从XMM寄存器或内存中读出的浮点数进行<strong>截断</strong>，即向零舍入，然后将结果存入整数寄存器
(在表中用<span class="math inline">\(R_{32}\)</span>和<span
class="math inline">\(R_{64}\)</span>表示)。</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 25%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr>
<th>指令</th>
<th>源1</th>
<th>源2</th>
<th>目的</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vcvtsi2ss</code></td>
<td><span class="math inline">\(M_{32}/R_{32}\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td>将整数转换成单精度数</td>
</tr>
<tr>
<td><code>vcvtsi2sd</code></td>
<td><span class="math inline">\(M_{32}/R_{32}\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td>将整数转换成双精度数</td>
</tr>
<tr>
<td><code>vcvtsi2ssq</code></td>
<td><span class="math inline">\(M_{64}/R_{64}\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td>将四字整数转换成单精度数</td>
</tr>
<tr>
<td><code>vcvtsi2sdq</code></td>
<td><span class="math inline">\(M_{64}/R_{64}\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td>将四字整数转换成双精度数</td>
</tr>
</tbody>
</table>
<p>　　整数转换浮点数指令有3个操作数
(2个源和1个目的)，第1个操作数来自内存或整数寄存器，第2个操作数仅影响结果的高位，第3个操作数必须是XMM寄存器。在常见的使用场景中，第2个操作数和第3个操作数相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vunpcklps	%xmm0, %xmm0, %xmm0</span><br><span class="line">vcvtps2pd	%xmm0, %xmm0</span><br></pre></td></tr></table></figure>
<p>　　这2条指令会将单精度数转换为双精度数。指令<code>vunpckls</code>会交叉前2个寄存器的值并将结果放到第3个寄存器，若第1个寄存器的内容为字<span
class="math inline">\([s_3,s_2,s_1,s_0]\)</span>，第2个寄存器的内容是字<span
class="math inline">\([d_3,d_2,d_1,d_0]\)</span>，则第3个寄存器的内容是字<span
class="math inline">\([s_1,d_1,s_0,d_0]\)</span>。指令<code>vcvtps2pd</code>会把第1个寄存器中的2个低位单精度值扩展成第2个寄存器的2个双精度值，得到结果<span
class="math inline">\([dx_0,dx_0]\)</span>，而<span
class="math inline">\(dx_0\)</span>就是转换后的双精度数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmovddup	%xmm0, %xmm0</span><br><span class="line">vcvtpd2psx	%xmm0, %xmm0</span><br></pre></td></tr></table></figure>
<p>　　这2条指令会将双精度数转换为单精度数。若寄存器<code>%xmm0</code>保存着双精度值<span
class="math inline">\([x_1,x_0]\)</span>，指令<code>vmovddup</code>会将它设置为<span
class="math inline">\([x_0,x_0]\)</span>，指令<code>vcvtpd2psx</code>会把这2个值转换为单精度数，再打包到寄存器的低位一半，并将高位一半置0，得到结果<span
class="math inline">\([0.0,0.0,x_0,x_0]\)</span>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">fcvt</span><span class="params">(<span class="type">int</span> i, <span class="type">float</span> *fp, <span class="type">double</span> *dp, <span class="type">long</span> *lp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f = *fp;</span><br><span class="line">    <span class="type">double</span> d = *dp;</span><br><span class="line">    <span class="type">long</span> l = *lp;</span><br><span class="line">    *lp = (<span class="type">long</span>)d;</span><br><span class="line">    *fp = (<span class="type">float</span>)i;</span><br><span class="line">    *dp = (<span class="type">double</span>)l;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fcvt:</span><br><span class="line">	vmovss	(%rsi), %xmm0</span><br><span class="line">	movq	(%rcx), %rax</span><br><span class="line">	vcvttsd2siq	(%rdx), %r8</span><br><span class="line">	movq	%r8, (%rcx)</span><br><span class="line">	vcvtsi2ss	%edi, %xmm1, %xmm1</span><br><span class="line">	vmovss	%xmm1, (%rsi)</span><br><span class="line">	vcvtsi2sdq	%rax, %xmm1, %xmm1</span><br><span class="line">	vmovsd	%xmm1, (%rdx)</span><br><span class="line">	vunpcklps	%xmm0, %xmm0, %xmm0</span><br><span class="line">	vcvtps2pd	%xmm0, %xmm0</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　函数<code>fvct()</code>的所有参数都是通过整数寄存器传递，结果通过寄存器<code>%xmm0</code>返回。</p>
<h4 id="浮点运算操作">3.9.2 浮点运算操作</h4>
<table>
<thead>
<tr>
<th>单精度数指令</th>
<th>双精度数指令</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vaddss</code></td>
<td><code>vaddsd</code></td>
<td><code>D</code> ← <code>S2 + S1</code></td>
<td>浮点加法</td>
</tr>
<tr>
<td><code>vsubss</code></td>
<td><code>vsubsd</code></td>
<td><code>D</code> ← <code>S2 - S1</code></td>
<td>浮点减法</td>
</tr>
<tr>
<td><code>vmulss</code></td>
<td><code>vmulsd</code></td>
<td><code>D</code> ← <code>S2 * S1</code></td>
<td>浮点乘法</td>
</tr>
<tr>
<td><code>vdivss</code></td>
<td><code>vdivsd</code></td>
<td><code>D</code> ← <code>S2 / S1</code></td>
<td>浮点除法</td>
</tr>
<tr>
<td><code>vmaxss</code></td>
<td><code>vmaxsd</code></td>
<td><code>D</code> ← <code>max(S2, S1)</code></td>
<td>浮点最大值</td>
</tr>
<tr>
<td><code>vminss</code></td>
<td><code>vminsd</code></td>
<td><code>D</code> ← <code>min(S2, S1)</code></td>
<td>浮点最小值</td>
</tr>
<tr>
<td><code>sqrtss</code></td>
<td><code>sqrtsd</code></td>
<td><code>D</code> ← <code>sqrt(S1)</code></td>
<td>浮点数平方根</td>
</tr>
</tbody>
</table>
<p>　　对于浮点运算指令，每条指令都有1或2个源操作数以及1个目的操作数。第1个源操作数<code>S1</code>可以是XMM寄存器或内存引用，第2个源操作数<code>S2</code>和目的操作数必须是XMM寄存器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">funct</span><span class="params">(<span class="type">double</span> a, <span class="type">float</span> x, <span class="type">double</span> b, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a * x - b / i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">funct:</span><br><span class="line">	vunpcklps	%xmm1, %xmm1, %xmm1</span><br><span class="line">	vcvtps2pd	%xmm1, %xmm1</span><br><span class="line">	vmulsd	%xmm0, %xmm1, %xmm0</span><br><span class="line">	vcvtsi2sd	%edi, %xmm1, %xmm1</span><br><span class="line">	vdivsd	%xmm1, %xmm2, %xmm2</span><br><span class="line">	vsubsd	%xmm2, %xmm0, %xmm0</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　函数<code>funct()</code>的参数<code>a</code>、<code>x</code>和<code>b</code>通过寄存器<code>%xmm0</code>~<code>%xmm2</code>传递，参数<code>i</code>通过寄存器<code>%edi</code>传递。第2~3行会将参数<code>x</code>转换为双精度数，第5行会将参数<code>i</code>转换为双精度数，最后结果通过寄存器<code>%xmm0</code>返回。</p>
<h4 id="浮点常数">3.9.3 浮点常数</h4>
<p>　　AVX浮点操作不能将立即数作为操作数。相反，编译器必须为所有的常量值分配并初始化空间。然后，从内存读取这些值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">cel2fahr</span><span class="params">(<span class="type">double</span> temp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.8</span> * temp + <span class="number">32.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cel2fahr:</span><br><span class="line">	vmulsd	.LC0(%rip), %xmm0, %xmm0</span><br><span class="line">	vaddsd	.LC1(%rip), %xmm0, %xmm0</span><br><span class="line">	ret</span><br><span class="line">.LC0:</span><br><span class="line">	.long	3435973837</span><br><span class="line">	.long	1073532108</span><br><span class="line">.LC1:</span><br><span class="line">	.long	0</span><br><span class="line">	.long	1077936128</span><br></pre></td></tr></table></figure>
<p>　　函数<code>cel2fahr()</code>从标签<code>.LC0</code>处读取值1.8，从标签<code>.LC1</code>处读取值32.0，这些标签里都是一对<code>.long</code>声明和十进制表示的值。对于标签<code>.LC0</code>，这2个值的十六进制是<code>0xcccccccd</code>和<code>0x3ffccccc</code>，因为机器是小端模式，第1个值给出低4B，第2个值给出高4B。从高位字节提取指数字段<code>0x3ff</code>，减去偏移值1023得到指数0。将2个值的小数位组合起来，得到小数字段<code>0xccccccccccccd</code>，二进制小数表示为0.8，加上隐含的1得到1.8。</p>
<h4 id="浮点位级操作和比较操作">3.9.4 浮点位级操作和比较操作</h4>
<table>
<thead>
<tr>
<th>单精度数指令</th>
<th>双精度数指令</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vxorps</code></td>
<td><code>vxorpd</code></td>
<td><code>D</code> ← <code>S2 ^ S1</code></td>
<td>位级异或</td>
</tr>
<tr>
<td><code>vandps</code></td>
<td><code>vandpd</code></td>
<td><code>D</code> ← <code>S2 &amp; S1</code></td>
<td>位级与</td>
</tr>
</tbody>
</table>
<p>　　浮点位级指令类似于整数位级指令在整数寄存器上的操作，这类指令作用于封装后的数据，即更新整个目的XMM寄存器，对2个源寄存器的所有位都执行指定的位级操作。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>基于</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ucomiss  S1, S2</code></td>
<td><code>S2 - S1</code></td>
<td>比较单精度数</td>
</tr>
<tr>
<td><code>ucomissd  S1, S2</code></td>
<td><code>S2 - S1</code></td>
<td>比较双精度数</td>
</tr>
</tbody>
</table>
<p>　　浮点比较指令类似于整数比较指令，这类指令会比较操作数并设置条件码来表示它们的相对值。第1个参数可以是XMM寄存器或内存引用，第2个参数只能是XMM寄存器。</p>
<table>
<thead>
<tr>
<th>顺序为<code>S2 : S1</code></th>
<th>CF</th>
<th>ZF</th>
<th>PF</th>
</tr>
</thead>
<tbody>
<tr>
<td>无序</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><code>S2 &lt; S1</code></td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><code>S2 = S1</code></td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><code>S2 &gt; S1</code></td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>　　浮点比较指令会设置CF、ZF和PF。对于整数操作，当最近的算术或逻辑运算生成的值的最低位字节满足偶校验时
(该字节中有偶数个1)，会将PF置1。对于浮点比较，当操作数中有NaN时，会出现<span
style="background-color: yellow">无序</span>的情况，然后将PF置1。指令<code>jp</code>
(jump on parity)
通常用于条件跳转，条件就是浮点比较结果为无序，除了这种情况，其他情况下，CF和ZF的值都与对应的无符号比较情况相同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NEG,</span><br><span class="line">    ZERO,</span><br><span class="line">    POS,</span><br><span class="line">    OTHER</span><br><span class="line">&#125; <span class="type">range_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">range_t</span> <span class="title function_">find_range</span><span class="params">(<span class="type">float</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = NEG;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = ZERO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = POS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = OTHER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find_range:</span><br><span class="line">	vxorps	%xmm1, %xmm1, %xmm1</span><br><span class="line">	vucomiss	%xmm0, %xmm1</span><br><span class="line">	ja	.L5</span><br><span class="line">	vucomiss	%xmm1, %xmm0</span><br><span class="line">	jp	.L8</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	je	.L3</span><br><span class="line">.L8:</span><br><span class="line">	vucomiss	.LCO(%rip), %xmm0</span><br><span class="line">	setbe	%al</span><br><span class="line">	movzbl	%al, %eax</span><br><span class="line">	addl	$2, %eax</span><br><span class="line">	ret</span><br><span class="line">.L5:</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">.L3:</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　在函数<code>find_range()</code>的汇编代码中，会将<code>x</code>和<code>0.0</code>比较3次，即使1次就能获得所需信息。它还生成了2次浮点常数<code>0.0</code>，1次用于指令<code>vxorps</code>，1次从内存读取该值。</p>
<p>　　●
当<code>x &lt; 0.0</code>时，第4行的指令<code>ja</code>会选择跳转到结尾，返回值为<code>NEG</code>
(0)。</p>
<p>　　●
当<code>x = 0.0</code>时，第4行的指令<code>ja</code>和第6行的指令<code>jp</code>都不会跳转，第8行的指令<code>je</code>会跳转，返回<code>ZERO</code>
(1)。</p>
<p>　　●
当<code>x &gt; 0.0</code>时，这3个跳转指令都不会跳转。第11行的指令<code>setbe</code>会得到0，然后，第13行的指令<code>addl</code>会加2，返回<code>POS</code>
(2)。</p>
<p>　　●
当<code>x = NaN</code>时，第6行的指令<code>jp</code>会跳转，第10行的指令<code>vucomiss</code>会设置CF和ZF，所以第11行的指令<code>setbe</code>得到1，然后，第13行的指令<code>addl</code>会加2，返回值为<code>OTHER</code>
(3)。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第5章 优化程序性能</title>
    <url>/2023/04/01/computer-systems-a-programmer&#39;s-perspective-3e-chpt-5/</url>
    <content><![CDATA[<p>　　现代编译器通过复杂且精细的算法来确定程序中计算的值和用法，然后尽可能简化表达式，在多个不同的地方使用同一计算来减少特定计算的执行次数。GCC等大多数编译器向用户提供了一些编译器使用的优化的控制。最简单的控制就是指定<strong>优化级别</strong>，例如，命令行选项<code>-Og</code>会使用一组基本的优化，<code>-O1</code>或更高
(例如，<code>-O2</code>和<code>-O3</code>)
会使用更多的优化。这样做可以进一步提升程序的性能，但也可能增加程序大小，也可能使标准调试工具更难对程序进行调试。</p>
<p>　　CPU活动周期由提供某个频率的规律信号的时钟控制，通常用<strong>千兆赫兹</strong>表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vec_rec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> len;</span><br><span class="line">    <span class="type">data_t</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/vector_abstract_data_type.svg" class="" title="vector_abstract_data_type">
<p>　　向量由2个内存块表示，即头部和数据数组。这里声明<code>data_t</code>来表示基本元素的数据类型。</p>
<p>　　对于<span
class="math inline">\(\vec{a}=&lt;a_0,a_1,...,a_{n-1}&gt;\)</span>，前缀和<span
class="math inline">\(\vec{p}=&lt;p_0,p_1,...,p_{n-1}&gt;\)</span>定义为
<span class="math display">\[
\begin{align}
p_0&amp;=a_0\\[3px]
p_i&amp;=p_{i-1}+a_i&amp;&amp;1\leqslant i&lt;n
\end{align}
\]</span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">psum1</span><span class="params">(<span class="type">float</span> a[], <span class="type">float</span> p[], <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    p[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">psum2</span><span class="params">(<span class="type">float</span> a[], <span class="type">float</span> p[], <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    p[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> mid_val = p[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        p[i] = mid_val;</span><br><span class="line">        p[i + <span class="number">1</span>] = mid_val + a[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>psum1()</code>和<code>psum2()</code>都是计算长度为<code>n</code>的向量的前缀和。函数<code>psum1()</code>每次迭代计算结果向量的1个元素，而函数<code>psum2()</code>使用了<strong>循环展开</strong>，每次循环可以计算结果向量的2个元素。</p>
<p>　　这样的过程的运行时间可以用常数加上与被处理元素个数成正比的因子来表示。<code>psum1()</code>和<code>psum2()</code>的运行时间
(单位是时钟周期) 约等于<span
class="math inline">\(368+9.0n\)</span>和<span
class="math inline">\(368+6.0n\)</span>。当<span
class="math inline">\(n\)</span>较大时，运行时间主要由线性因子决定，这些项中的系数是<strong>每元素周期数</strong>。这里使用每元素周期数而非每循环周期数来衡量，因为像循环展开这样的方法能够使用较少的循环来完成计算。</p>
<span id="more"></span>
<h3 id="优化编译器的性能和局限">5.1 优化编译器的性能和局限</h3>
<p>　　编译器必须对程序只使用<span
style="background-color: yellow">安全</span>的优化。对于C语言，优化前后的版本必须有相同的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">twiddle1</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span></span><br><span class="line">&#123;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">twiddle2</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span></span><br><span class="line">&#123;</span><br><span class="line">    *xp += <span class="number">2</span> * *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>twiddle1()</code>和<code>twiddle2()</code>都是将指针<code>yp</code>指向的值2次加到指针<code>xp</code>指向的值。<code>twiddle1()</code>需要进行6次内存访问
(2次读<code>*xp</code>，2次读<code>*yp</code>，2次写<code>*xp</code>)，而<code>twiddle2()</code>只需要3次内存访问
(读<code>*xp</code>，读<code>*yp</code>，写<code>*xp</code>)。然而，当<code>xp</code>和<code>yp</code>相等时，<code>twiddle1()</code>相当于<code>4 * *xp</code>，而<code>twiddle2()</code>相当于<code>3 * *xp</code>。因此，函数<code>twiddle1()</code>无法优化为函数<code>twiddle2()</code>。</p>
<p>　　这种2个及以上指针指向同一内存位置的情况称为<strong>内存混叠</strong>。在执行安全的优化时，编译器必须假设可能出现内存混叠，这导致了优化障碍之一——程序的某些方面会严重降低编译器生成优化代码的机会。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">fun1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> f() + f() + f() + f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">fun2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> * f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>fun1()</code>调用了4次函数<code>f()</code>，函数<code>fun2()</code>只调用了1次函数<code>f()</code>。这2个函数看似相似，但函数<code>f()</code>有<span
style="background-color: yellow">副作用</span>——会修改全局变量<code>counter</code>，调用<code>fun1()</code>会返回<span
class="math inline">\(0+1+2+3=6\)</span>，调用<code>fun2()</code>会返回<span
class="math inline">\(0\cdot4=0\)</span>。因此，函数<code>fun1()</code>无法优化为函数<code>fun2()</code>。</p>
<p>　　函数调用是第2个优化阻碍。包含函数调用的代码可以通过<strong>内联替换</strong>
(简称<strong>内联</strong>) 来优化，即用函数体替换函数调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">funclin</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> t = counter++;</span><br><span class="line">    t += counter++;</span><br><span class="line">    t += counter++;</span><br><span class="line">    t += counter++;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">funclopt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> t = <span class="number">4</span> * counter + <span class="number">6</span>;</span><br><span class="line">    counter += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这里将函数<code>fun1()</code>中的4次函数调用展开为代码得到函数<code>funclin()</code>。这样可以降低函数调用的开销，也达到了优化效果，优化后得到函数<code>funclopt()</code>。对于GCC，可以通过命令函参数<code>-finline</code>或优化等级<code>-O1</code>以及更高等级的优化来进行内联替换，但这种方法只会对<span
style="background-color: yellow">同一文件</span>中定义的函数进行内联。</p>
<p>　　在使用GDB等符号调试器来调试代码和用代码剖析的方式来评估程序性能时，应该阻止编译器进行内联替换。因为内联替换后，对函数调用的追踪和设置的断点会失效。同样，内联替换后的函数调用无法正确剖析。</p>
<h4 id="提升循环效率">5.1.1 提升循环效率</h4>
<p>　　将执行多次但结果不会改变的计算移动到前面不会多次求值的部分的优化方法称为<strong>代码移动</strong>，例如，将循环中可提取的部分移动到循环外。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lower1</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lower2</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　理想情况下，编译器会将函数<code>lower1()</code>的循环中的<code>strlen()</code>提取出来，优化为函数<code>lower2()</code>。这需要很复杂的分析，因为<code>strlen()</code>会检查字符串的元素，随着<code>lower1()</code>的执行，这些值会改变。编译器需要检测到，即使字符串的长度在改变，也没有从非0变为0或从0变为非0。即使是使用内联替换，这样的分析也超出了最完善的编译器的能力，所以这样的代码移动必须手动进行。</p>
<p>　　这个示例说明了编程的常见问题之一——看似无足轻重的代码片段有隐藏的<strong>渐进低效</strong>。对于有超过百万个字符的字符串，这段代码将成为主要的性能瓶颈之一。</p>
<h4 id="消除不必要的内存引用">5.1.2 消除不必要的内存引用</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* OP和IDENT由宏定义声明，支持以下2种组合 */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">#define OP +</span></span><br><span class="line"><span class="comment">#define IDENT 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">#define OP *</span></span><br><span class="line"><span class="comment">#define IDENT 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">combine1</span><span class="params">(vec *v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *dest = *dest OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">combine2</span><span class="params">(vec *v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *data = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>combine1()</code>的每次循环都会对内存进行2次读和1次写，这样会浪费性能，因为每次迭代读的值都是上次写的值。这可以通过引入局部变量来解决，就是函数<code>combine2()</code>中的<code>acc</code>，这样可以将每次循环的内存操作减少为1次读。</p>
<h3 id="理解现代cpu">5.2 理解现代CPU</h3>
<p>　　当一系列操作必须严格按照顺序执行时，会遇到<strong>延迟界限</strong>，因为在下一条指令开始前，当前指令必须结束。当代码中的数据依赖限制了CPU的指令并行能力时，延迟界限会限制程序性能。<strong>吞吐量界限</strong>表征CPU功能单元的原始计算能力，这个界限是程序性能的终极界限。</p>
<p>　　最早的乱序CPU是1964年Control Data Corporation的6600
CPU。该CPU的指令由10个不同的功能单元处理，每个单元都能独立地执行。那时，这种时钟频率为10MHz的机器被认为是最好的科学计算机器。</p>
<p>　　1966年，IBM首先在IBM
360/91上实现了乱序处理，但仅用于执行浮点指令。在大约25年的时间里，乱序处理被认为是异类，仅在追求高性能的机器才会使用。直到1990年，IBM在RS/6000系列工作站中重新使用了该技术，并成为了IBM/Motorola
PowerPC系列的基础，1993年推出的型号601成为了首个使用乱序处理的单芯片CPU。Intel于1995年在PentiumPro中使用了乱序处理。</p>
<h4 id="整体操作">5.2.1 整体操作</h4>
<img src="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/block_diagram_of_an_out-of-order_cpu.svg" class="" title="block_diagram_of_an_out-of-order_cpu">
<p>　　这里展示的CPU设计并不是严格地基于较新的Intel CPU的结构 (这些Intel
CPU在工业界称为<strong>超标量</strong>，表示每个时钟周期可以执行多个操作，而且是<strong>乱序</strong>的，即指令执行顺序不一定与它们在机器级程序中的顺序一致)。乱序CPU有2个主要部分，即<strong>指令控制单元</strong>和<strong>执行单元</strong>。前者负责从内存读取指令序列并根据这些指令序列生成一组针对程序数据的基本操作，后者执行这些操作。相比第4章里的<strong>按序</strong>
(流水线)
CPU相比，乱序CPU需要更大、更复杂的硬件，但能更好地达到更高级的指令集并行。</p>
<p>　　ICU从<strong>指令缓存</strong>中读取指令，指令缓存是特殊的高速存储器，其中包含最近访问的指令。ICU通常会提前取出指令，这样才有足够的时间来译码并把操作发送给EU。当程序遇到
(条件移动指令)
分支时，会出现2个可能的方向。现代CPU会使用<strong>分支预测</strong>来预测分支及其目标地址。<strong>取指控制</strong>块包含分支预测，以确定待取出的指令。通过<strong>试探执行</strong>，在确定分支是否正确前，CPU就开始取出并译码预测分支的指令。若确定分支预测错误，会将状态重置为分支点的状态并开始取出和执行另一方向上的指令。</p>
<p>　　<strong>指令译码</strong>块会接收实际的程序指令并转换为一组基本操作
(称为<strong>微操作</strong>)。每个这样的操作仅完成1个简单的任务，例如，加法、从内存读数据和写数据到内存。对于x86等有复杂指令的机器，单条指令可以转换为多个操作，具体操作因机器而异，而且这个过程是高度保密的。</p>
<p>　　操作数都是寄存器的指令只会转换为1个操作。操作数包括内存引用的指令会转换为多个操作来将内存引用和算术运算分开，例如，<code>addq %rax, 8(%rdx)</code>会转换为3个操作，第1个操作将值从内存中加载到CPU，第2个操作将加载的值加上寄存器<code>%rax</code>的值，第3个操作将结果写回内存。这种译码逻辑会将指令拆分，以允许在一组专门的硬件单元之间进行分工，然后这些单元可以并行执行多个指令的不同部分。</p>
<p>　　EU接收来自取指单元的操作。每个周期通常会接收多个操作，这些操作会分派到一组<strong>功能单元</strong>来执行实际的操作。</p>
<p>　　读写内存由加载和存储单元实现，这里的实现中有2个加载单元和1个存储单元。加载单元负责从内存读，其中有加法器来完成地址计算。存储单元负责向内存写，其中也有加法器来完成地址计算。两者都通过<strong>数据缓存</strong>来访问内存，数据缓存是高速存储器，存放着最近访问的数据。加载单元的内部缓存可以存放72个待完成的加载操作，存储单元的内部缓存可以存放42个待完成的存储操作，两者都是<span
style="background-color: yellow">每个时钟周期执行1个操作</span>。</p>
<p>　　使用试探执行对操作求值时，结果不会立即存放到程序寄存器或数据存储器中，只有CPU确定实际应执行的指令时才会存放。分支操作会被送到EU，这样做是为了确定分支预测的正确性而非分支的目标。若预测错误，EU会丢弃分支点后计算的结果，然后发送信号给分支单元告知预测错误并指出正确的分支目标，最后分支单元开始在新的位置取指。由于不同程序之间所需的操作大不相同，算术操作功能单元设计为能执行各种整数和浮点操作的组合。</p>
<p>　　<strong>退役单元</strong>会记录正在执行的处理并确保其遵守机器级程序的顺序语义。除了<strong>寄存器文件</strong>，退役单元还包括整数、浮点以及最近的SSE和AVX寄存器，因为退役单元控制这些寄存器的更新。当指令的操作完成且跳转到该指令的分支点确认预测正确时，该指令会<strong>退役</strong>，<span
style="background-color: yellow">所有对程序寄存器的更新会实际执行</span>。相反，当跳转到该指令的分支点确认预测错误时，该指令会<strong>清空</strong>，丢弃所有计算出来的结果。指令译码时，指令的相关信息存放在1个队列中，直到该指令退役或清空。</p>
<p>　　<strong>操作结果</strong>是为了加快执行单元之间信息交换和将指令结果传递给其他指令的速度，是Y86-64流水线中数据转发的更复杂的形式。</p>
<p>　　控制操作数在执行单元之间移动的最常见的机制是<strong>寄存器重命名</strong>。当更新寄存器<code>r</code>的指令译码时，将生成标记<code>t</code>作为操作结果的唯一标识。同时，会将条目<code>(r, t)</code>加入到维持寄存器<code>r</code>和标记<code>t</code>的关系的<strong>重命名表</strong>。当之后以寄存器<code>r</code>为操作数的指令译码时，发送到执行单元的操作会包含<code>t</code>作为操作数值的源。当某个执行单元完成第1个操作时，会生成结果<code>(v, t)</code>，指明标记为<code>t</code>的操作产生值<code>v</code>。所有等待<code>t</code>做为源的操作都将使用<code>v</code>作为源值，这是数据转发的形式之一。通过这种机制，值可以从某个操作直接转发到其他操作而不必写到寄存器再读，这样第2个操作能在第1个操作完成后尽快完成。</p>
<p>　　重命名表只包含关于写操作的寄存器条目。当译码的指令需要寄存器<code>r</code>且重命名表中没有相关条目时，会直接从寄存器文件中读取。通过寄存器重命名，即使只有在CPU确定了分支结果后才能更新寄存器，也能试探性地执行整个操作序列。</p>
<h4 id="功能单元的性能">5.2.2 功能单元的性能</h4>
<table>
<thead>
<tr>
<th>算术运算</th>
<th>延迟</th>
<th>发出时间</th>
<th>容量</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数加法</td>
<td>1</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>整数乘法</td>
<td>3</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>整数除法</td>
<td>3~30</td>
<td>3~30</td>
<td>1</td>
</tr>
<tr>
<td>浮点加法</td>
<td>3</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>浮点乘法</td>
<td>5</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>浮点除法</td>
<td>3~15</td>
<td>3~15</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>　　这是Intel Core i7
Haswell参考机的一些算术运算的性能。<strong>延迟</strong>表示完成运算所需的时间，<strong>发出时间</strong>表示连续
的2个相同类型运算之间的最小时钟周期数，<strong>容量</strong>表示能够执行该运算的功能单元数。发出时间为1的功能单元是<strong>完全流水线化</strong>的。</p>
<p>　　发出时间常用于衡量功能单元的最大吞吐量，即发出时间的倒数。完全流水线化的功能单元有最大的吞吐量。具有多个功能单元可以进一步提高吞吐量。对于容量为<span
class="math inline">\(C\)</span>，发出时间为<span
class="math inline">\(I\)</span>的操作，CPU可能有每个时钟周期<span
class="math inline">\(\frac{C}{I}\)</span>个操作的吞吐量。</p>
<p>　　从整数运算到浮点运算，延迟是增加的。加法和乘法运算的发出时间都是1，即每个时钟周期内，CPU可以开始1条新的这样的运算。这种很短的发出时间是通过流水线实现的。流水线化的功能单元实现了一系列的<span
style="background-color: yellow">阶段</span>，每个阶段完成一部分的运算。例如，典型的浮点加法器包含3个阶段
(所以有3个周期的延迟)，分别用于处理指数值、将小数相加和结果舍入。算术运算可以连续通过各个阶段，只要执行的运算是连续且逻辑上独立的。</p>
<p>　　除法器 (用于整数/浮点除法和计算浮点平方根)
不是完全流水线化的，其发出时间等于延迟，这表示除法器必须完成当前除法后才能开始新的除法。此外，除法的延迟和发出时间不是固定的，因为某些除数和被除数的组合比其他组合需要更多的步骤。</p>
<p>　　这些算术运算的延迟、发出时间和容量会影响组合函数的性能，这里用CPE值的2个基本界限
(延迟和吞吐量) 来描述。</p>
<table>
<thead>
<tr>
<th>算术运算</th>
<th>延迟界限</th>
<th>吞吐量界限</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数加法</td>
<td>1.00</td>
<td>0.50</td>
</tr>
<tr>
<td>整数乘法</td>
<td>3.00</td>
<td>1.00</td>
</tr>
<tr>
<td>浮点加法</td>
<td>3.00</td>
<td>1.00</td>
</tr>
<tr>
<td>浮点乘法</td>
<td>1.00</td>
<td>0.50</td>
</tr>
</tbody>
</table>
<p>　　延迟界限为任何必须严格按照顺序执行组合操作的函数提供最小CPE值。吞吐量界限根据功能单元可以产生的最大速率为CPE提供最小界限。由于只有1个整数乘法器，其发出时间为1个时钟周期，CPU不可能支持每个时钟周期大于1条乘法的速率。相反，4个功能单元都可以执行整数加法，CPU可以维持每个时钟周期4个加法的速率。但是，2个加载单元限制了CPU每个时钟周期最多只能读2个数据值，所以吞吐量界限是0.50。</p>
<h4 id="cpu操作的抽象模型">5.2.3 CPU操作的抽象模型</h4>
<p>　　<strong>数据流</strong>是图形化的表示方法，可以展示不同操作之间的数据依赖关系如何约束其执行顺序。这些约束形成了图中的<strong>关键路径</strong>，从而成为了执行一组机器指令所需的时钟周期的下限。</p>
<table>
<thead>
<tr>
<th>算术运算</th>
<th><code>combine2()</code></th>
<th>延迟界限</th>
<th>吞吐量界限</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数加法</td>
<td>1.27</td>
<td>1.00</td>
<td>0.50</td>
</tr>
<tr>
<td>整数乘法</td>
<td>3.01</td>
<td>3.00</td>
<td>1.00</td>
</tr>
<tr>
<td>浮点加法</td>
<td>3.01</td>
<td>3.00</td>
<td>1.00</td>
</tr>
<tr>
<td>浮点乘法</td>
<td>5.01</td>
<td>5.00</td>
<td>0.50</td>
</tr>
</tbody>
</table>
<p>　　以函数<code>combine2()</code>为例，除了整数加法，这些值与CPU的延迟界限很接近。这表明函数的性能由其所执行的算术运算的延迟决定。计算<span
class="math inline">\(n\)</span>个元素的加法或乘法大约需要<span
class="math inline">\(L\cdot n+K\)</span>个时钟周期，其中<span
class="math inline">\(L\)</span>是组合操作的延迟，<span
class="math inline">\(K\)</span>是调用函数、初始化和终止循环的开销。因此，CPE约等于延迟界限<span
class="math inline">\(L\)</span>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.L25:</span><br><span class="line">    vmulsd  (%rdx), %xmm0, %xmm0</span><br><span class="line">    addq    $8, %rdx</span><br><span class="line">    cmpq    %rax, %rdx</span><br><span class="line">    jne .L25</span><br></pre></td></tr></table></figure>
<img src="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/graphical_representation_of_inner_loop_code_for_combine2.svg" class="" title="graphical_representation_of_inner_loop_code_for_combine2">
<p>　　这里将关注循环的计算，因为这是决定较大向量的性能的主要因素。以<code>double</code>类型的乘法组合运算为例
(其他数据类型和运算的组合的结构几乎相同)，循环编译出的代码有4条指令，寄存器<code>%rdx</code>存放指向数组<code>data</code>中第<code>i</code>个元素指针，<code>%rax</code>存放指向数组尾部的指针，<code>%xmm0</code>存放累积值<code>acc</code>。</p>
<p>　　这4条指令会译码为5个步骤，乘法指令会扩展为加载操作
(从内存读源操作数) 和乘法操作 (执行乘法)。</p>
<p>　　图左侧的方框和线给出了各个指令是如何使用和更新寄存器，顶部的方框表示循环开始时寄存器的值，底部的方框表示循环结束时寄存器的值。例如，寄存器<code>%rax</code>只作为操作<code>cmp</code>的源，所以该寄存器在循环结束时的值与循环开始时的值相同。在循环中，寄存器<code>%rdx</code>既被使用也被修改，其初始值被加载和加法操作使用，新值由加法操作产生，然后被操作<code>cmp</code>使用。同样，乘法操作先使用寄存器<code>%xmm0</code>的初始值作为源，然后修改它的值。</p>
<p>　　图右侧的弧线表示某些操作产生的值不对应任何寄存器。加载操作从内存读并把值传递给乘法操作。由于这2个操作是由指令<code>vmulsd</code>译码产生，所以它们之间传递的值没有相关的寄存器。操作<code>cmp</code>会更新CC，然后操作<code>jne</code>判断CC。</p>
<p>　　循环中访问的寄存器可分为<span
style="background-color: yellow">只读</span>、<span
style="background-color: yellow">只写</span>、<span
style="background-color: yellow">局部</span>和<span
style="background-color: yellow">循环</span>寄存器。</p>
<p>　　●
只读寄存器能作为源和数据，也能用于计算内存地址，但在循环中不会被修改，例如，函数<code>combine2()</code>中的寄存器<code>%rax</code>。</p>
<p>　　● 只写寄存器作为数据移动操作的目的地。</p>
<p>　　●
局部寄存器会在循环中被使用和更新，但迭代之间局部寄存器没有依赖，例如，函数<code>combine2()</code>中的CC，操作<code>cmp</code>会修改它们，然后操作<code>jne</code>会使用它们，不过这种依赖都是单次迭代之内。</p>
<p>　　●
循环寄存器能作为源和目的地，并且迭代之间循环寄存器有依赖，例如，函数<code>combine2()</code>中的寄存器<code>%rdx</code>和<code>%xmm0</code>，对应程序值<code>data + i</code>和<code>acc</code>。</p>
<img src="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/abstracting_combine2_operations_as_a_data_flow_graph.svg" class="" title="abstracting_combine2_operations_as_a_data_flow_graph">
<p>　　这是对图形表示的进一步改进，只给出影响执行时间的操作和数据依赖。此外，还重新排列了操作符，以更清晰地表示从顶部寄存器
(只读寄存器和循环寄存器) 到底部寄存器 (只写寄存器和循环寄存器)
的数据流。</p>
<p>　　图中将不属于循环寄存器依赖链的操作标记为<span
style="background-color: yellow">白色</span>。例如，图(a)的操作<code>cmp</code>和<code>jne</code>不直接影响程序中的数据流。这里假设指令控制单元分支预测正确，所以会继续循环。操作<code>cmp</code>和<code>jne</code>用于是判断分支条件和分支预测错误时通知ICU
(假设判断所需时间短到足以忽略不计)。</p>
<p>　　图(b)去除了图(a)中白色的操作，只保留了循环寄存器，得到表示单次迭代在循环寄存器之间的数据依赖的抽象模板。这里迭代之间有2个数据依赖，左侧的<code>acc</code>旧值乘以加载操作生成的数据元素得到<code>acc</code>新值，右侧<code>i</code>的旧值用于计算加载操作的地址，加法操作会增加<code>i</code>的旧值来计算<code>i</code>的新值。</p>
<img src="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/data_flow_representation_of_computation_by_n_iterations_of_the_inner_loop_of_combine2.svg" class="" title="data_flow_representation_of_computation_by_n_iterations_of_the_inner_loop_of_combine2">
<p>　　重复数据流图(b)的模板<span
class="math inline">\(n\)</span>次后，可以得到2条数据依赖链，分别对应乘法和加法操作对程序值<code>acc</code>和<code>data + i</code>的修改。假设浮点乘法延迟为5，整数加法延迟为1，左侧的依赖链会成为关键路径，因为左侧的依赖链需要<span
class="math inline">\(5n\)</span>个周期执行，而右侧的依赖链仅需要<span
class="math inline">\(n\)</span>个周期执行。</p>
<p>　　还有一些因素会限制性能，例如，可用的功能单元数量和任何给定步骤中能在功能单元之间传递的数据数量。将整数加法作为组合运算时，数据操作速度大于数据供应速度，所以每个元素的处理时间为1.27个周期。</p>
<h3 id="循环展开">5.3 循环展开</h3>
<p>　　循环展开能从2方面提升程序的性能，首先，减少了不直接影响程序结果的操作的数量，例如，循环索引计算和条件分支。其次，揭示了可以进一步转换代码以减少整体计算的关键路径中的操作数量的方法。</p>
<p>　　当优化等级达到3或更高时，GCC会执行循环展开。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine3</span><span class="params">(vec *v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        acc = (acc OP data[i]) OP data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *data = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是函数<code>combine2()</code>的<span
class="math inline">\(2\times
1\)</span>循环展开版本，即每次循环将循环索引加2并对向量元素<code>i</code>和<code>i + 1</code>使用组合运算。</p>
<img src="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/cpe_performance_for_k%C3%971_loop_unrolling.svg" class="" title="cpe_performance_for_k×1_loop_unrolling">
<p>　　对于<span class="math inline">\(k\times
1\)</span>循环展开，向量的长度不一定是<span
class="math inline">\(k\)</span>的整数倍，要确保循环时数值不会越界。为此，对于长度为<span
class="math inline">\(n\)</span>的数值，循环界限设置为<span
class="math inline">\(n-k+1\)</span>，每次循环时索引增加<span
class="math inline">\(k\)</span>，最后将剩下的元素以每次处理1个元素的方式进行循环。根据上图可以得到，对于整数加法，<span
class="math inline">\(2\times1\)</span>循环展开的性能就达到了峰值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.L35:</span><br><span class="line">    vmulsd  (%rax, %rdx, 8), %xmm0, %xmm0</span><br><span class="line">    vmulsd  8(%rax, %rdx, 8), %xmm0, %xmm0</span><br><span class="line">    addq    $2, %rdx</span><br><span class="line">    cmpq    %rdx, %rbp</span><br><span class="line">    jg  .L35</span><br></pre></td></tr></table></figure>
<p>　　这是当<code>data_t</code>为<code>double</code>且操作为乘法时函数<code>combine3()</code>循环部分对应的汇编代码。指令<code>vmulsd</code>出现了2次，分别将<code>data[i]</code>和<code>data[i + 1]</code>乘以<code>acc</code>。每条<code>vmulsd</code>指令会译码为加载操作和乘法操作。相比循环2次，这种<span
class="math inline">\(2\times1\)</span>循环展开仅减少了1个加法操作，而关键路径上的乘法操作并没有减少，所以并没有性能提升。</p>
<p>　　加法和乘法功能单元是完全流水线化的，硬件有能以更高速率执行加成和乘法的潜能，但之前的代码并不能利用这种能力，因为累积值存放在单独的变量<code>acc</code>中，受到组合操作的延迟的限制。</p>
<h4 id="多个累积变量">5.3.1 多个累积变量</h4>
<p>　　对于可交换和可结合的组合运算，可以将其分为2个及以上部分分别计算，最后将结果合并。</p>
<p>　　<span class="math inline">\(P_n\)</span>表示元素<span
class="math inline">\(a_0,a_1,...,a_{n-1}\)</span>的乘积。 <span
class="math display">\[
P_n=\prod^{n-1}_{i=0}a_i
\]</span> 　　若<span class="math inline">\(n\)</span>为偶数，<span
class="math inline">\(P_n\)</span>还可以写为<span
class="math inline">\(P_n=PE_n\times PO_n\)</span>，<span
class="math inline">\(PE_n\)</span>是索引值为偶数的元素的乘积，<span
class="math inline">\(PO_n\)</span>是索引值为奇数的元素的乘积。 <span
class="math display">\[
\begin{align}
PE_n&amp;=\prod^{n/2-1}_{i=0}a_{2i}\\[3px]
PO_n&amp;=\prod^{n/2-1}_{i=0}a_{2i+1}
\end{align}
\]</span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine4</span><span class="params">(vec *v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc0 = IDENT;</span><br><span class="line">    <span class="type">data_t</span> acc1 = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        acc0 = acc0 OP data[i];</span><br><span class="line">        acc1 = acc1 OP data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        acc0 = acc0 OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *data = acc0 OP acc1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/graphical_representation_of_inner_loop_code_for_combine4.svg" class="" title="graphical_representation_of_inner_loop_code_for_combine4">
<p>　　这是函数<code>combine2()</code>的<span
class="math inline">\(2\times
2\)</span>循环展开版本。相比函数<code>combine3()</code>，它将累积值拆分为<code>acc0</code>和<code>acc1</code>，最后再合并。</p>
<img src="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/abstracting_combine4_operations_as_a_data_flow_graph.svg" class="" title="abstracting_combine4_operations_as_a_data_flow_graph">
<p>　　函数<code>combin4()</code>的循环中指令<code>vmulsd</code>出现了2次，但是这些指令译码为读写不同寄存器的乘法操作，它们之间没有数据依赖。</p>
<img src="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/data_flow_representation_of_combine4_operating_on_a_vector_of_length_n.svg" class="" title="data_flow_representation_of_combine4_operating_on_a_vector_of_length_n">
<p>　　这里有2条关键路径，分别对应索引值为偶数的元素的乘积
(程序值<code>acc0</code>) 和索引值奇数的元素的乘积
(程序值<code>acc1</code>)。每条关键路径只包含<span
class="math inline">\(\frac{n}{2}\)</span>个操作，所以CPE也会减半。同样，延迟为<span
class="math inline">\(L\)</span>的操作的CPE约为<span
class="math inline">\(\frac{L}{2}\)</span>。整数加法由于循环开销，无法达到理论界限0.50。</p>
<img src="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/cpe_performance_for_k%C3%97k_loop_unrolling.svg" class="" title="cpe_performance_for_k×k_loop_unrolling">
<p>　　对于<span class="math inline">\(k\times
k\)</span>循环展开，当<span
class="math inline">\(k\)</span>足够大时，程序在任何情况几乎都能达到吞吐量界限。整数加法在<span
class="math inline">\(k=7\)</span>时，CPE达到0.54，接近2个加载单元的吞吐量界限0.5。整数乘法和浮点加法在<span
class="math inline">\(k=3\)</span>时，CPE达到1.01，接近其功能单元的吞吐量界限1.00。浮点乘法在<span
class="math inline">\(k=10\)</span>时，CPE达到0.51，接近2个浮点乘法器和2个加载单元的吞吐量界限0.50。</p>
<p>　　通常，只有程序能保持执行某个操作的所有功能单元的流水线都是满载时，才能达到该操作的吞吐量界限，即对于延迟为<span
class="math inline">\(L\)</span>，容量为<span
class="math inline">\(C\)</span>的操作，需满足循环展开因子<span
class="math inline">\(k\geqslant C\cdot L\)</span>。</p>
<p>　　在进行<span class="math inline">\(k\times
k\)</span>循环展开时，需要考虑结果与原始函数的是否相同。第2章提到过，补码运算是可交换和可结合的，即使溢出亦是如此。因此，整数类型<span
class="math inline">\(k\times k\)</span>循环展开前后结果<span
style="background-color: yellow">相同</span>。相反，由于舍入或溢出，浮点乘法和加法是不可结合的，因此，浮点类型<span
class="math inline">\(k\times k\)</span>循环展开前后结果<span
style="background-color: yellow">可能不同</span>。</p>
<h4 id="重新结合变换">5.3.2 重新结合变换</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine5</span><span class="params">(vec *v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        acc = acc OP (data[i] OP data[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *data = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　相比函数<code>combine3()</code>，函数<code>combine5()</code>仅改变了第10行代码中括号的位置，这种变换称为<strong>重新结合变换</strong>，因此，改变了向量元素和累积值<code>acc</code>的合并顺序，产生了<span
class="math inline">\(2\times 1a\)</span>循环展开。</p>
<img src="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/graphical_representation_of_inner_loop_code_for_combine5.svg" class="" title="graphical_representation_of_inner_loop_code_for_combine5">
<p>　　前2条指令译码的加载操作从内存中加载向量元素<code>i</code>和<code>i + 1</code>，第1个乘法操作将它们相乘，第2个乘法操作将结果乘以累积值<code>acc</code>。</p>
<img src="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/abstracting_combine5_operations_as_a_data_flow_graph.svg" class="" title="abstracting_combine5_operations_as_a_data_flow_graph">
<p>　　函数<code>combine5()</code>虽然有2个乘法操作，但只有1个乘法操作形成了循环寄存器之间的数据依赖链。</p>
<img src="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/data_flow_representation_of_combine5_operating_on_a_vector_of_length_n.svg" class="" title="data_flow_representation_of_combine5_operating_on_a_vector_of_length_n">
<p>　　函数<code>combine5()</code>的关键路径上只有<span
class="math inline">\(\frac{n}{2}\)</span>个操作，每次迭代的第1个乘法操作无需等待前一次迭代的结果就可以执行，所以CPE减半。</p>
<p>　　<span class="math inline">\(k\times
1a\)</span>循环展开的性能提升与<span class="math inline">\(k\times
k\)</span>循环展开的差不多。同样，整数类型在<span
class="math inline">\(k\times1a\)</span>循环展开前后结果相同，浮点类型在<span
class="math inline">\(k\times1a\)</span>循环展开前后结果可能不同。</p>
<h4 id="其他限制因素">5.3.3 其他限制因素</h4>
<p>　　循环并行性受到汇编代码描述计算的能力的限制。若并行度<span
class="math inline">\(p\)</span>超过了可用寄存器数量，编译器会诉诸<strong>溢出</strong>，将某些临时值存放在内存中，通常在运行时栈上分配空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmovsd	40(%rsp), %xmm0</span><br><span class="line">vmulsd	(%rdx), %xmm0, %xmm0</span><br><span class="line">vmovsd	%xmm0, 40(%rsp)</span><br></pre></td></tr></table></figure>
<p>　　这是函数<code>combine4()</code>的多累积变量模式扩展到<span
class="math inline">\(k=20\)</span>时循环部分对应的汇编代码，累积值<code>acc</code>保存在栈内，栈指针偏移量为40。程序必须从内存中读<code>acc</code>和<code>data[i]</code>，将它们相乘并将结果写回内存。相比扩展到<span
class="math inline">\(k=10\)</span>，这种循环展开性能更差。</p>
<p>　　一旦编译器诉诸寄存器溢出，维护多个累积变量带来的性能提升很可能消失。但是，x86-64有足够的寄存器，大多数循环在出现寄存器溢出前就达到了吞吐量限制。</p>
<p>　　现代CPU中的分支预测逻辑很擅长识别不同分支指令的<span
style="background-color: yellow">常规模式和长期趋势</span>。例如，在组合函数循环中分支预测逻辑通常会选择继续循环的分支，所以只有最后一次循环会出现分支预测错误。另一个例子就是检测数组边界的条件语句，分支预测逻辑通常会选择数组在界的分支。</p>
<p>　　很多判断是完全不可预测的，它们取决于数据的任意特征。例如，对于判断正负，若编译器能产生使用数据的条件移动的汇编代码，可以极大地提升性能。第3章提到过，编译器无法完成这种优化，所以只能手动优化。</p>
<h3 id="理解内存性能">5.4 理解内存性能</h3>
<p>　　包含加载操作的程序的性能受限于流水线的性能和加载单元的延迟。若函数<code>combine2()</code>在之前的乱序CPU上运行，由于每个待计算的元素都会从内存读1次值，无论如何优化，最后CPE都不会低于0.50。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_element</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">long</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">list_len</span><span class="params">(list_element *ls)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ls)</span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        ls = ls-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>list_len()</code>会计算链表的长度，在该函数的循环中<code>ls</code>的后继元素依赖指针引用<code>ls-&gt;next</code>读出的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ls存放在寄存器%rdi，len存放在寄存器%rax</span><br><span class="line">.L3:</span><br><span class="line">    addq    $1, %rax</span><br><span class="line">    movq    (%rdi), %rdi</span><br><span class="line">    testq   %rdi, %rdi</span><br><span class="line">    jne .L3</span><br></pre></td></tr></table></figure>
<p>　　这是函数<code>list_len()</code>循环部分对应的汇编代码。指令<code>movq</code>是该循环的瓶颈，因为之后寄存器<code>%rdi</code>的每个值都依赖加载操作的结果，但加载操作的地址是<code>%rdi</code>。因此，上一次循环的加载操作完成后才能开始下一次循环的加载操作，这也决定了该函数的CPE是4.00。</p>
<p>　　存储操作与加载操作对应，但存储操作只能能影响加载操作。</p>
<img src="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/detail_of_load_and_store_units.svg" class="" title="detail_of_load_and_store_units">
<p>　　存储单元有1个<strong>存储缓冲区</strong>，其中包含已经达到存储单元但还未完成
(这里的完成包括更新数据缓存)
的存储操作的地址和数据。通过存储缓冲区，可以执行一系列存储操作而无需等待每个操作都更数据缓存。当执行加载操作时，必须检测存储缓冲区中的条目以查找匹配的地址。若有匹配项
(表示正在写的数据和读的数据有相同的地址)，将取出对应的数据条目作为加载操作的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_read</span><span class="params">(<span class="type">long</span> *src, <span class="type">long</span> *dst, <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> cnt = n;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        *dst = val;</span><br><span class="line">        val = (*src) + <span class="number">1</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/graphical_representation_of_inner_loop_code_for_write_read.svg" class="" title="graphical_representation_of_inner_loop_code_for_write_read">
<p>　　函数<code>write_read()</code>的循环部分对应的汇编代码中，第1个指令<code>movq</code>译码为2个操作，操作<code>s_addr</code>计算存储操作的地址并在存储缓冲区插入1个条目
(包括设置该条目的地址字段)，操作<code>s_data</code>设置该条目的数据字段，这2个操作独立执行。</p>
<img src="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/abstracting_write_read_operations_as_a_data_flow_graph.svg" class="" title="abstracting_write_read_operations_as_a_data_flow_graph">
<p>　　图(a)中标签为 "1" 的线表示数据存储前必须计算出存储地址，标签为
"2"
的线表示加载操作必须先将其地址和所有待完成的存储操作的地址进行匹配，<span
style="background-color: yellow">若匹配</span>，则会出现标签为 "3"
的线，表示数据依赖。图(b)中有2条依赖链，左侧的是存储、加载和增加数据值
(地址匹配)
形成的数据依赖，右侧的是减小变量<code>cnt</code>形成的数据依赖。</p>
<img src="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/data_flow_representation_of_write_read.svg" class="" title="data_flow_representation_of_write_read">
<p>　　当函数<code>write_read()</code>的参数<code>src</code>和<code>dst</code>不同时
(对应左侧)，加载和存储操作可以独立进行，唯一的关键路径源于减小变量<code>cnt</code>，CPE为1。当函数<code>write_read()</code>的参数<code>src</code>和<code>dst</code>相同时
(对应右侧)，存储、加载和增加操作也形成了关键路径，CPE变为7。</p>
<h3 id="确认和消除性能瓶颈">5.5 确认和消除性能瓶颈</h3>
<p>　　至此，只考虑了优化较小的程序。在处理较大的程序时，确定待优化的地方并不简单。</p>
<p>　　<strong>代码剖析程序</strong>运行插入检测代码后的程序，以确定程序的各个部分执行所需时间，可以在实际基准数据上运行实际程序的同时进行剖析。</p>
<p>　　Unix系统提供了剖析程序GPROF。该程序会提供2种形式的信息。首先，它会确定每个函数的执行时间。其次，它计算每个函数的被调用次数并以调用函数来分类。Intel的VTUNE和Linux的VALGRIND是更完善的剖析程序，可以估计程序每个<strong>基本块</strong>
(没有控制转移的指令序列) 的性能。</p>
<h4 id="程序剖析">5.5.1 程序剖析</h4>
<p>　　用GPROF剖析需要3个步骤，这里以<code>prog.c</code>为例，其命令行参数为<code>file.txt</code>。</p>
<p>　　1)
程序在剖析前需要先编译和链接。对于GCC，就是简单地使用命令行选项<code>-pg</code>。为了保证不使用内联替换，使用优化等级<code>-Og</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -Og -pg prog.c -o prog</span><br></pre></td></tr></table></figure>
<p>　　2) 执行程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./prog file.txt</span><br></pre></td></tr></table></figure>
<p>　　3) 调用GPROF来分析<code>gmon.out</code>中的数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gprof prog</span><br></pre></td></tr></table></figure>
<p>　　剖析报告的第1部分是各个函数按降序排序的执行时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%       cumulative  self                self    total</span><br><span class="line">time    seconds     seconds calls       s/call  s/call  name</span><br><span class="line">97.58   203.66      203.66  1           203.66  203.66  sort_words</span><br><span class="line">2.32    208.50      4.85    965027      0.00    0.00    find_ele_rec</span><br><span class="line">0.14    208.81      0.30    12511031    0.00    0.00    Strlen</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，函数<code>sort_words()</code>仅被调用了1次，用时203.66秒，而函数<code>find_ele_rec()</code>被调用了965027次
(不包括递归调用)，用时4.85秒。函数<code>Strlen()</code>通过调用库函数<code>strlen()</code>来计算字符串的长度。GPROF的剖析报告中通常不显示库函数调用。<span
style="background-color: yellow">库函数执行时间通常计算在调用它们的函数内</span>。这里创建包装函数<code>Strlen()</code>来跟踪库函数<code>strlen()</code>的调用，库函数<code>strlen()</code>被调用了12511031次，用时0.30秒。</p>
<p>　　剖析报告的第2部分是函数的 (被) 调用历史。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                158655725           find_ele_rec [5]</span><br><span class="line">                4.85    0.10    965027/965027       insert_string [4]</span><br><span class="line">[5]     2.4     4.85    0.10    965027+158655725    find_ele_rec [5]</span><br><span class="line">                0.08    0.01    363039/363039       save_string [8]</span><br><span class="line">                0.00    0.01    363039/363039       new_ele [12]</span><br><span class="line">                                158655725           find_ele_rec [5]</span><br></pre></td></tr></table></figure>
<p>　　这是递归函数<code>find_ele_rec()</code>的 (被)
调用历史。前2行显示的是该函数的被调用信息，自身递归调用158655725次，被函数<code>insert_string()</code>调用965027次
(该函数本身被调用965027次)。函数<code>find_ele_rec()</code>也调用了其他函数，即函数<code>save_string()</code>和<code>find_ele_rec()</code>
(都是363039次)。</p>
<p>　　GPROF的计时基于简单的<strong>间隔计数</strong>机制，
编译后的程序为每个函数维护计数器来记录该函数的执行时间。操作系统会让程序在固定时间间隔<span
class="math inline">\(\delta\)</span>后中断1次
(通常是1.0~10.0ms)。当中断发生时，会将程序中正在执行的函数的计数器值增加<span
class="math inline">\(\delta\)</span>。对于执行时间小于<span
class="math inline">\(\delta\)</span>的函数，可能在其执行时发生中断，其执行时间会被设置为<span
class="math inline">\(\delta\)</span>，也可能刚好在中断间隔内完成执行，以至于根本没有记录执行时间。在没有执行内联替换时，编译后的程序会为每对调用者和被调用者维护计数器。每次调用过程时，其对应的计数器会加1。</p>
<h4 id="程序优化示例">5.5.2 程序优化示例</h4>
<p>　　这里以包括几个不同任务和数据结构的程序为例，该程序分析文本文档的n-gram统计信息，n-gram是文档中出现<span
class="math inline">\(n\)</span>个单词的序列。当<span
class="math inline">\(n=1\)</span>时，收集每个单词的统计信息，当<span
class="math inline">\(n=2\)</span>时，收集每对单词的统计信息，依此类推。对于给定的<span
class="math inline">\(n\)</span>，程序会读文本文档，创建不同的n-gram的表，包括每个n-gram出现的次数并按出现次数降序对单词排序。</p>
<p>　　作为基准程序，使用《莎士比亚全集》来运行该程序，《莎士比亚全集》共有965028个单词，其中有23706个不同的单词。当<span
class="math inline">\(n=1\)</span>时，即使性能很差的程序也能在1s内处理，所以这里设置<span
class="math inline">\(n=2\)</span>。在这种情况下，n-gram称为bigram。《莎士比亚全集》有363039个不同的bigram。最常见的是
"I am"，出现了1892次。</p>
<p>　　程序由多个部分组成，这里会创建多个版本，从各部分最简单的算法开始，逐渐换成更成熟完善的算法。</p>
<p>　　1)
从文件中读取每个单词并转换为小写。初始版本使用函数<code>lower1()</code>。</p>
<p>　　2) 对字符串使用散列函数，为有<span
class="math inline">\(s\)</span>个桶的散列表产生1个0到<span
class="math inline">\(s-1\)</span>之间的数。初始版本只是简单对字符的ASCII码求和再对<span
class="math inline">\(s\)</span>取模。</p>
<p>　　3)
每个散列桶都组成1个链表。程序对该链表扫描，寻找匹配的条目。若找到，该n-gram的频率加1。否则，创建1个新的链表元素。初始版本使用递归完成该操作，将新元素插在链表尾部。</p>
<p>　　4)
一旦生成这张表，根据频率对所有的元素排序。初始版本使用插入排序。</p>
<img src="/2023/04/01/computer-systems-a-programmer's-perspective-3e-chpt-5/profile_results_for_different_versions_of_bigram_frequency_counting_program.svg" class="" title="profile_results_for_different_versions_of_bigram_frequency_counting_program">
<p>　　Sort表示排序所需时间，List表示匹配链表所需时间，Lower表示转换为小写所需时间，Strlen表示计算字符串长度所需时间，Hash表示计算散列函数所需时间，Rest表示计算所有其他函数的和所需时间。</p>
<p>　　初始版本用时约3.5分钟，大多数时间都花在排序上。在第2个版本
"QuickSort"
中，使用了库函数<code>qsort()</code>来排序，该函数基于快速排序，其时间复杂度是<span
class="math inline">\(O(n\log_2n)\)</span>，该版本用时约5.4秒。</p>
<p>　　改进排序后，链表扫描成为瓶颈，这是由于函数的递归结构，这里用迭代结构替换，得到第3个版本
"Iter first"，该版本用时约7.5秒
(因为新元素插入到链表头部)。为了最大化性能，频率最高的n-gram应该在链表的头部，即新元素应该插入到链表尾部，得到第4个版本
"Iter last"，该版本用时约5.3秒。</p>
<p>　　然后，优化散列表的结构，初始版本只有1021个桶
(桶的个数通常是质数，以增强散列函数将关键字均匀分布在桶的能力)，这里将桶的数量增加到199999，得到第4个版本
"Big table"，该版本用时约5.1秒。</p>
<p>　　即使散列桶变大了，性能提升很小，这是因为散列函数性能较差。字母的最大编码值是122，<span
class="math inline">\(n\)</span>个字符产生的和最多是<span
class="math inline">\(122n\)</span>，而最长的bigram的和也只有3371，大部分桶都是未被使用的。此外，可交换的散列函数可能对不同的关键字生成相同的散列值，例如，"rat"
和 "tar"。散列函数替换为使用移位和异或的散列函数，得到第5个版本 "Better
hash"，该版本用时约0.6秒。</p>
<p>　　最后，将字母转换为小写成为瓶颈，将函数<code>lower1()</code>替换为函数<code>lower2()</code>得到第6个版本
"Linear lower"，该版本用时约0.2秒。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第4章 处理器体系架构</title>
    <url>/2023/03/06/computer-systems-a-programmer&#39;s-perspective-3e-chpt-4/</url>
    <content><![CDATA[<p>　　CPU支持的指令及其字节级编码称为该CPU的<strong>指令集体系结构</strong>。定义指令集体系结构包括定义各种状态单元、指令集、指令集编码、编码规范和异常事件处理。</p>
<p>　　x86-64也称为<span
style="background-color: yellow">复杂指令集计算机</span>，与<span
style="background-color: yellow">精简指令集计算机</span>相对。从历史角度，先出现了CISC
(发音为sisk)，它从最早的计算机演化而来。到20世纪80年代早期，随着计算机设计者加入了很多新指令来支持高级任务
(例如，处理循环缓存、执行十进制数计算和多项式求值)，计算机的指令集已经变得很庞大。最早的CPU出现在20世纪70年代早期，因为当时的集成电路技术极大地限制了芯片的功能，其指令集很有限。CPU发展得很快，到20世纪80年代早期，计算机的指令集复杂度一直都在增加。x86家族沿着这条道路发展到IA32，然后是x86-64。即使是x86系列也仍在不断地变化，基于新出现的应用的需求，增加新的指令类。</p>
<p>　　RISC (发音为risk)
的设计理念发展于20世纪80年代早期，作为上述发展趋势的代替方案。IBM的一些硬件和编译器专家深受IBM研究员John
Cocke的影响，认为可以为更简单的指令集形式生成高效的代码。实际上，很多加到指令集中的高级指令很难被编译器生成，所以很少被用到。较简单的指令集可以用更少的硬件实现，能以高效的流水线结构组织起来。直到多年后，IBM才将这个理念商品化，开发了Power和PowerPC
ISA。加州大学伯克利分校的David Patterson和斯坦福大学的John
Hennessy进一步发展了RISC的概念。Patterson将这种新的机器类型命名为RISC，而将之前的那种机器命名为CISC，因为以前没有必要为1种几乎通用的指令集命名。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>CISC</th>
<th>早期RISC</th>
</tr>
</thead>
<tbody>
<tr>
<td>指令数量很多。</td>
<td>指令数量很少，通常少于100个。</td>
</tr>
<tr>
<td>有些指令的执行时间很长，包括将整个块从内存的某个部分复制到其他部分的指令以及将多个寄存器的值复制到内存或从内存复制到多个寄存器的指令。</td>
<td>没有执行时间较长的指令。部分早期的RISC甚至没有整数乘法指令，要求编译器通过加法来实现。</td>
</tr>
<tr>
<td>编码长度可变，x86-64的指令长度可以是1~15B。</td>
<td>编码长度固定，通常所有的指令都编码为4B。</td>
</tr>
<tr>
<td>指定操作数的形式多样，x86-64中的内存引用可以包括偏移量、基址寄存器、变址寄存器和伸缩因子。</td>
<td>寻址方式简单，通常只有基址和偏移量寻址。</td>
</tr>
<tr>
<td>可以对内存引用和寄存器操作数进行算术和逻辑运算。</td>
<td>只能对寄存器操作数进行算术和逻辑运算。允许使用内存引用操作数的指令只有<code>load</code>和<code>store</code>，<code>load</code>是从内存读数据到寄存器，<code>store</code>是从寄存器写数据到内存，这种方法称为load/store体系结构。</td>
</tr>
<tr>
<td>实现细节对机器级程序不可见。ISA提供了程序和执行细节之间的清晰的抽象。</td>
<td>实现细节对机器级程序可见。有些RSIC机器禁止某些特殊的指令序列，而有些跳转指令要到下一条指令执行完后才会生效。编译器必须在这些约束条件下进行性能优化。</td>
</tr>
<tr>
<td>有条件码。作为指令执行的副产品，设置了一些特殊的标志位，用于条件跳转判断。</td>
<td>没有条件码。对于条件判断，要用明确的判断指令，这些指令会将判断结果存储1个普通寄存器中。</td>
</tr>
<tr>
<td>栈密集的过程链接。栈用于存取过程参数和返回地址。</td>
<td>寄存器密集的过程链接。寄存器用于存取过程参数和返回地址，所以有些过程无需内存引用。CPU通常有更多的寄存器
(最多32个)。</td>
</tr>
</tbody>
</table>
<p>　　20世纪80年代，计算机体系结构领域里关于RISC指令集和CISC指令集优缺点的争论十分激烈。RISC的支持者声称在给定硬件数量的情况下，通过结合简化的指令集设计、高级编译器技术和流水线化的CPU实现，RISC能获得更强的计算性能。CISC的拥趸反驳称完成给定任务需要的RISC指令更少，所以RISC有更强的总体性能。20世纪90年代早期，争论逐渐平息，因为事实很清楚，单独的RISC或CISC都不如结合两者的精华。CISC后来的发展中加入了很多的指令
(包括需要多个执行周期的指令)
和高性能流水线结构。现在的RISC指令集中有数百条指令，几乎与其名称不相匹配，而那种将实现细节暴露给机器级程序的思想已经被证明是目光短浅的。</p>
<p>　　大多数公司都推出了RISC CPU系列产品，包括Sun Microsystem
(SPARC)、IBM和Motorola (PowerPC) 以及Digital Equipment Corporation
(Alpha)。英国公司Acorn Computer Ltd.推出了自己的体系结构Acorn RISC
Machine (ARM)，广泛应用于嵌入式系统中。</p>
<p>　　Y86-64指令集兼具CISC和RISC指令集的特点。和CISC一样，它有条件码和长度可变的指令，并且用栈来保存返回地址。和RISC一样的是，它使用load/store体系结构和常规指令编码，并且通过寄存器来传递过程参数。Y86-64指令集可以视为根据某些RISC原理简化后CISC指令集
(x86)。</p>
<p>　　从头到尾执行1条指令所需的时间称为<strong>延迟</strong>。在现代逻辑设计中，电路延迟以微微秒或皮秒
(<span class="math inline">\(10^{-12}\)</span>s) 为单位来计算。</p>
<p>　　会导致异常的指令称为<strong>异常指令</strong>。</p>
<span id="more"></span>
<h3 id="y86-64指令级体系结构">4.1 Y86-64指令级体系结构</h3>
<p>　　Y86-64程序中的每条指令都会读取或修改CPU状态的某些部分，这些部分称为<strong>程序员可见状态</strong>
(这里的程序员包括用汇编代码编写程序的人和生成机器级代码的编译器)。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/y86-64_programmer_visible_state.svg" class="" title="y86-64_programmer_visible_state">
<p>　　Y86-64的状态类似于x86-64，有15个程序寄存器、3个1位的CC、PC、程序状态和内存。相比x86-64，Y86-64省略了寄存器<code>%r15</code>，每个寄存器存储64位的字。CC存储最近的算术或逻辑指令所造成影响的相关信息。PC存储当前正在执行指令的地址。程序状态表明程序执行的总体状态，指示程序是正常运行还是出现了异常。从概念角度，内存是很大的字节数组，保存着程序和数据。Y86-64程序用<strong>虚拟地址</strong>来引用内存。硬件和操作系统软件协同工作来将虚拟地址转换成实际/物理地址，指明数据实际存储位置。</p>
<table>
<thead>
<tr>
<th>十六进制数</th>
<th>寄存器名称</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x0</code></td>
<td><code>%rax</code></td>
</tr>
<tr>
<td><code>0x1</code></td>
<td><code>%rcx</code></td>
</tr>
<tr>
<td><code>0x2</code></td>
<td><code>%rdx</code></td>
</tr>
<tr>
<td><code>0x3</code></td>
<td><code>%rbx</code></td>
</tr>
<tr>
<td><code>0x4</code></td>
<td><code>%rsp</code></td>
</tr>
<tr>
<td><code>0x5</code></td>
<td><code>%rbp</code></td>
</tr>
<tr>
<td><code>0x6</code></td>
<td><code>%rsi</code></td>
</tr>
<tr>
<td><code>0x7</code></td>
<td><code>%rdi</code></td>
</tr>
<tr>
<td><code>0x8</code></td>
<td><code>%r8</code></td>
</tr>
<tr>
<td><code>0x9</code></td>
<td><code>%r9</code></td>
</tr>
<tr>
<td><code>0xA</code></td>
<td><code>%r10</code></td>
</tr>
<tr>
<td><code>0xB</code></td>
<td><code>%r11</code></td>
</tr>
<tr>
<td><code>0xC</code></td>
<td><code>%r12</code></td>
</tr>
<tr>
<td><code>0xD</code></td>
<td><code>%r13</code></td>
</tr>
<tr>
<td><code>0xE</code></td>
<td><code>%r14</code></td>
</tr>
<tr>
<td><code>0xF</code></td>
<td>无寄存器</td>
</tr>
</tbody>
</table>
<p>　　Y86-64的15个程序寄存器都有对应的<strong>寄存器ID</strong>
(范围在<code>0x0</code>~<code>0xE</code>之间)。程序寄存器存在CPU中的寄存器文件中，寄存器文件是以寄存器ID作为地址的存储器。当不需要存取寄存器时，用ID值<code>0XF</code>表示。</p>
<h4 id="y86-64指令">4.1.1 Y86-64指令</h4>
<p>　　Y86-64指令集可以视为是x86-64指令集的子集，它只包括8B整数操作，并且寻址方式和操作更少。由于仅使用8B的数据，所以把<span
style="background-color: yellow">8B的数据称为字</span>也不会有任何歧义。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/y86-64_instruction_set.svg" class="" title="y86-64_instruction_set">
<p>　　对于Y86-64，有些指令只有1B，而其他指令更长。首先，可能有额外的<strong>寄存器指示符字节</strong>，用于指定1或2个寄存器，即<code>rA</code>和<code>rB</code>。对于只有1个寄存器的指令，另一个寄存器ID为<code>0xF</code>。其次，可能有额外的8B<strong>常数字</strong>，可作为立即数、指令<code>rmmovq</code>和<code>mrmovq</code>的地址指示符的偏移量以及跳转指令和调用指令的目的地址。</p>
<p>　　Y86-64的跳转指令和调用指令的目的地址是<span
style="background-color: yellow">绝对地址</span>，而非像IA32中那样使用PC相对寻址。CPU使用PC相对寻址时，跳转指令的编码会更简洁，同时能允许代码从内存的某部分复制到其他部分而无需更新所有的分支目标地址。</p>
<p>　　Y86-64中的所有整数都是小端编码。例如，用十六进制编码<code>rmmovq  %rsp, 0x123456789abcd(%rdx)</code>时，第1个字节是<code>0x40</code>，栈指针在字段<code>rA</code>中，<code>%rdx</code>在字段<code>rB</code>中，需要偏移量在前面填上<code>0x0</code>使之变成8B，最后结果为<code>0x4042cdab896745230100</code>。</p>
<p>　　Y86-64的数据移动指令<code>movq</code>包括<code>irmovq</code>、<code>rrmovq</code>、<code>mrmovq</code>和<code>rmmovq</code>，其名称中的前2个字母分别表示源和目的操作数的格式，<code>i</code>表示立即数，<code>r</code>表示寄存器，<code>m</code>表示内存引用。内存引用是简单的基址和偏移量形式，<span
style="background-color: yellow">不支持</span>第2变址寄存器和寄存器值的伸缩。同x86-64一样，不允许将立即数移动到内存和直接将数据从某个内存位置移动到其他内存位置。</p>
<p>　　Y86-64的整数操作指令<code>OPq</code>包括<code>adq</code>、<code>subq</code>、<code>andq</code>和<code>xorq</code>，它们<span
style="background-color: yellow">只对寄存器数据进行操作</span>，会设置CC中的零标志ZF、符号标志SF和溢出标志OF。x86-64的同类指令还可以对内存数据进行操作。</p>
<p>　　Y86-64的跳转指令<code>jXX</code>包括<code>jmp</code>、<code>jle</code>、<code>jl</code>、<code>je</code>、<code>jne</code>、<code>jge</code>和<code>jg</code>，根据分支指令的类型和CC的值来选择分支，分支条件和x86-64相同。</p>
<p>　　Y86-64的条件移动指令<code>cmovXX</code>包括<code>cmovle</code>、<code>cmovl</code>、<code>cmove</code>、<code>cmovne</code>、<code>comvge</code>和<code>cmovg</code>，这些指令的操作数格式同指令<code>rrmovq</code>相同，但只有当CC满足条件时才更新目的寄存器的值。</p>
<p>　　Y86-64的指令<code>call</code>会将返回地址压入栈，然后跳转到目的地址，指令<code>ret</code>会从这样的调用中返回。指令<code>pushq</code>和<code>popq</code>同x86-64中相同。指令<code>halt</code>会停止指令的执行，对应x86-64中的指令<code>hlt</code>，但x86-64应用程序不允许使用该指令，因为它会导致整个系统暂停。对于Y86-64，指令<code>halt</code>会导致CPU停止并将状态码置为<code>HLT</code>。</p>
<p>　　大多数Y86-64指令以简单明了的方式修改程序状态，但有2条指令是例外，即<code>pushq</code>和<code>popq</code>。<code>pushq</code>会把栈指针减8并将寄存器值写入内存中。因此，当执行<code>pushq  %rsp</code>时，CPU的行为是不确定的，可能有2种情况，即压入栈指针的原始值和压入减8后栈指针的值，Y86-64采用了和x86-64一样的做法，<span
style="background-color: yellow">压入的是原始值</span>。同样，对于<code>popq  %rsp</code>，<span
style="background-color: yellow">弹出的是栈顶的值</span>。对于IA32，从Intel
286开始，<code>PUSH ESP</code>会将寄存器的原始值压入栈
(IA32体系结构的实地址模式和虚8086模式以及Intel
64位体系结构也是如此)，而Intel
8086压入的则是减后的值。然而，<code>POP ESP</code>不存分歧。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/function_codes_for_y86-64_instruction_set.svg" class="" title="function_codes_for_y86-64_instruction_set">
<p>　　Y86-64指令的字节级编码中的第1个字节表示指令的类型，其中高4位表示<span
style="background-color: yellow">代码</span>部分，低4位表示<span
style="background-color: yellow">功能</span>部分。代码部分的值为<code>0x0</code>~<code>0xB</code>，功能部分只有在代码部分相同时才有用。</p>
<p>　　Y86-64状态码Stat用于描述程序程序的总体状态。</p>
<table>
<thead>
<tr>
<th>Stat值</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>AOK</td>
<td>正常操作</td>
</tr>
<tr>
<td>2</td>
<td>HLT</td>
<td>执行<code>halt</code>指令</td>
</tr>
<tr>
<td>3</td>
<td>ADR</td>
<td>非法地址</td>
</tr>
<tr>
<td>4</td>
<td>INS</td>
<td>非法指令</td>
</tr>
</tbody>
</table>
<p>　　当Stat的值不为1时，表示发生了某种类型的<span
style="background-color: yellow">异常</span>，CPU会停止执行指令。在更完整的设计中，CPU通常会调用<strong>异常处理程序</strong>，该过程可以配置为不同的结果，例如，中止程序或调用用户自定义的<strong>信号处理程序</strong>。</p>
<h4 id="y86-64程序">4.1.2 Y86-64程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> *start, <span class="type">long</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += *start;</span><br><span class="line">        start++;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从地址0开始执行</span><br><span class="line">0x000:                          .pos 0</span><br><span class="line">0x000: 30f40002000000000000     irmovq stack, %rsp  # 设置栈指针</span><br><span class="line">0x00a: 803800000000000000       call main           # 执行主程序</span><br><span class="line">0x013: 00                       halt                # 结束程序</span><br><span class="line"></span><br><span class="line"># 包括4个元素的数组</span><br><span class="line">0x018:                          .align 8</span><br><span class="line">0x018:                      array: </span><br><span class="line">0x018: 0d000d000d000000         .quad 0x000d000d000d</span><br><span class="line">0x020: c000c000c0000000         .quad 0x00c000c000c0</span><br><span class="line">0x028: 000b000b000b0000         .quad 0x0b000b000b00</span><br><span class="line">0x030: 00a000a000a00000         .quad 0xa000a000a000</span><br><span class="line"></span><br><span class="line">0x038:                      main:</span><br><span class="line">0x038: 30f71800000000000000     irmovq  array, %rdi</span><br><span class="line">0x042: 30f60400000000000000     irmovq  $4, %rsi</span><br><span class="line">0x04c: 805600000000000000       call sum</span><br><span class="line">0x055: 90                       ret</span><br><span class="line"></span><br><span class="line"># long sum(long *start, long count)</span><br><span class="line"># start在寄存器%rdi, count在寄存器%rsi</span><br><span class="line">0x056:                      sum:</span><br><span class="line">0x056: 30f80800000000000000     irmovq  $8, %r8</span><br><span class="line">0x060: 30f90100000000000000     irmovq  $1, %r9</span><br><span class="line">0x06a: 6300                     xorq    %rax, %rax</span><br><span class="line">0x06c: 6266                     andq    %rsi, %rsi</span><br><span class="line">0x06e: 708700000000000000       jmp test</span><br><span class="line">0x077:                      loop:</span><br><span class="line">0x077: 50a70000000000000000     mrmovq  (%rdi), %r10</span><br><span class="line">0x081: 60a0                     addq    %r10, %rax</span><br><span class="line">0x083: 6087                     addq    %r8, %rdi</span><br><span class="line">0x085: 6196                     subq    %r9, %rsi</span><br><span class="line">0x087:                      test:</span><br><span class="line">0x087: 747700000000000000       jne loop;</span><br><span class="line">0x090: 90                       ret</span><br><span class="line"></span><br><span class="line"># 栈的起始地址</span><br><span class="line">0x200:                          .pos 0x200</span><br><span class="line">0x200:                      stack:</span><br></pre></td></tr></table></figure>
<p>　　<code>.pos</code> (第2行)
表示应该从地址0处开始生成代码，该地址是所有Y86-64程序的起始地址。接下来的指令
(第3行) 会初始化栈指针。在程序的结尾 (第40行)
声明了标签<code>stack</code>并用<code>.pos</code>表示地址<code>0x200</code>
(第39行)，所以栈会从该地址开始并向低地址增长。第8~13行会声明1个4字的数组，标签<code>array</code>表示数组的起始地址，标签<code>.align</code>表示按8B对齐。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 停在34步，PC = 0x13, status &#x27;HLT&#x27;, CC: Z = 1 O = 0</span><br><span class="line"># 寄存器的变化</span><br><span class="line">%rax:   0x0000000000000000  0x0000abcdabcdabcd</span><br><span class="line">%rsp:   0x0000000000000000  0x0000000000000200</span><br><span class="line">%rdi:   0x0000000000000000  0x0000000000000038</span><br><span class="line">%r8:    0x0000000000000000  0x0000000000000008</span><br><span class="line">%r9:    0x0000000000000000  0x0000000000000001</span><br><span class="line">%r10:   0x0000000000000000  0x0000a000a000a000</span><br><span class="line"></span><br><span class="line"># 内存的变化</span><br><span class="line">0x01f0: 0x0000000000000000  0x0000000000000055</span><br><span class="line">0x01f8: 0x0000000000000000  0x0000000000000013</span><br></pre></td></tr></table></figure>
<p>　　这是在通过Y86-64指令集模拟器执行函数<code>sum()</code>的Y86-64代码的输出。第1行表示执行情况以及PC和程序状态的值。之后的输出中左侧是原始值，右侧是改变后的值。栈指针的从<code>0x200</code>开始向低地址增长，栈的使用导致内存地址<code>0x01f0</code>~<code>0x0f18</code>中的值发生了变化。可执行代码的最大地址为<code>0x090</code>，所以出入栈不会损坏可执行代码。</p>
<h3 id="逻辑设计和硬件控制语言">4.2 逻辑设计和硬件控制语言</h3>
<p>　　在硬件设计中，电子电路用于计算位运算的函数以及在各种存储单元中存储位。大多数现代电路技术用信号线上的高电压或低电压来表示不同的位，例如，用1.0V左右的高电压表示逻辑1，用0.0V左右的低电压表示逻辑0。要实现数字系统需要<span
style="background-color: yellow">计算位操作函数的组合逻辑</span>、<span
style="background-color: yellow">存储位的存储器单元</span>和<span
style="background-color: yellow">控制存储器单元更新的时钟信号</span>。</p>
<p>　　过去，硬件设计者通过描绘示意性的逻辑电路图来进行电路设计
(最早是用纸和笔，后来用计算机图像终端)。现在，大多数设计都是用<strong>硬件描述语言</strong>。HDL属于文本表示，看上去类似汇编，但用于描述硬件结构而非程序行为。最常用的HDL是Verilog和VHDL，Verilog的语法类似于C语言，VHDL的语法类似于Ada语言。这些语言用于表示数字电路的模拟模型。20世纪80年代中期，出现了<strong>逻辑合成</strong>程序，它可以根据HDL的描述生成有效的电路设计。现在有很多商用的合成程序，已成为生成数字电路的主要技术。从手工设计电路到合成生成的转变类似从写汇编程序到写高级语言程序，再用编译器来生成机器代码的转变。</p>
<p>　　之后的内容使用的是<strong>硬件控制语言</strong>。HCL仅描述硬件设计的控制部分，支持的操作很有限，并且没有模块化。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/logic_gate_types.svg" class="" title="logic_gate_types">
<p>　　<strong>逻辑门</strong>是数字电路的基本计算单元。逻辑门总是活动的，一旦其输入发生了变化，在很短的时间内，输出就会相应地变化。</p>
<p>　　将很多个逻辑门组合在一起就能构成计算块，称为<strong>组合电路</strong>。</p>
<p>　　● 每个逻辑门要么连接到系统输入 (称为<span
style="background-color: yellow">主输入</span>)，要么是某个存储器单元或逻辑门的输出。</p>
<p>　　●
2个及以上的逻辑门的输出不能连接在一起，否则，可能会导致信号冲突。</p>
<p>　　● 组合电路必须是无环的，否则，可能会导致计算的函数有歧义。</p>
<h4 id="位级的组合电路">4.2.1 位级的组合电路</h4>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/combinational_circuit_to_test_for_bit_equality.svg" class="" title="combinational_circuit_to_test_for_bit_equality">
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool eq = (a &amp;&amp; b) || (!a &amp;&amp; !b);</span><br></pre></td></tr></table></figure>
<p>　　这是判断位相等的组合电路的的电路图和HCL函数。从HCL代码中可以看出，数据类型<code>bool</code>表示输出<code>eq</code>是位信号，输入是<code>a</code>和<code>b</code>。<code>!eq</code>是异或，即在输出前加上1个非门。HCL使用了C语言风格，但其并非将执行结果存储内存中，只是为表达式命名。C语言的逻辑表达式可能部分求值，对于<code>a &amp;&amp; fun(b)</code>，当<code>a</code>为0时，<code>fun(b)</code>就不会执行，但HCL不会这样，它只是响应输入的变化。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/single-bit_multiplexor_circuit.svg" class="" title="single-bit_multiplexor_circuit">
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool <span class="keyword">out</span> = (s &amp;&amp; a) || (!s &amp;&amp; b);</span><br></pre></td></tr></table></figure>
<p>　　这是位<strong>多路复用器</strong>的组合电路和HCL函数。2个数据信号是输入位<code>a</code>和<code>b</code>，控制信号是输入位<code>s</code>。当<code>s</code>为1时，输出是<code>a</code>；当<code>s</code>为0时，输出是<code>b</code>。</p>
<h4 id="字级的组合电路">4.2.2 字级的组合电路</h4>
<p>　　执行字运算的组合电路由逻辑门构成，根据输入字的每个位来计算输出字的每个位。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/combinational_circuit_to_test_for_word_equality.svg" class="" title="combinational_circuit_to_test_for_word_equality">
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool Eq = (A == B);</span><br></pre></td></tr></table></figure>
<p>　　这是判断字相等的组合电路和HCL函数，当且仅当2个字中的所有位都相等时，输出才为1，该电路将64个判断位相等的组合电路的输出和与门连接。此外，也可以通过将64个位异或的组合电路的输出和与门连接，最后在与门后连接1个非门来实现。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/word-level_multiplexor_circuit.svg" class="" title="word-level_multiplexor_circuit">
<p>　　这是字多路复用器的组合电路和HCL函数，根据输入控制位<code>s</code>，生成64位的字<code>Out</code>，等于<code>A</code>或<code>B</code>中的1个。该电路由64个位多路复用器组成，但这里仅使用了1个非门。</p>
<p>　　CPU中会使用很多种多路复用器，能够根据某些控制条件，从许多源中选出1个字。在HCL中，多路复用函数用<strong>情况表达式</strong>表示。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    select_1 : expr_1;</span><br><span class="line">    select_2 : expr_2;</span><br><span class="line">    ...</span><br><span class="line">    select_k : expr_k;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>　　情况表达式包含了多种情况，每种情况<code>i</code>都有布尔表达式<code>select_i</code>和整数表达式<code>expr_i</code>，前者表示选择该情况的条件，后者表示得到的值。与C语言中的<code>case</code>语句不同的时，情况表达式的布尔表达式之间不必互斥。从逻辑角度，这些选择表达式是按顺序计算的，第1个值为1的情况会被选择。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/four-way_multplexor.svg" class="" title="four-way_multplexor">
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word Out4 = </span><br><span class="line">[</span><br><span class="line">    !s1 &amp;&amp; !s0  : A; # <span class="number">00</span></span><br><span class="line">    !s1         : B; # <span class="number">01</span></span><br><span class="line">    !s0         : C; # <span class="number">10</span></span><br><span class="line">    <span class="number">1</span>           : D; # <span class="number">11</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　这是四路复用器的HCL，其中<code>#</code>开头的注释表示选择该情况时<code>s1</code>和<code>s0</code>的值。选择表达式有时可以简化，例如，第2个表达式简写为<code>!s1</code>而非<code>!s1 &amp;&amp; s0</code>，因为当<code>s0</code>为0的情况已经出现在第1个表达式中，同样，第3个表达式简写为<code>!s0</code>，第4个表达式简写为<code>1</code>。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/alu.svg" class="" title="alu">
<p>　　<strong>算术逻辑单元</strong>有2个数据输入 (A和B)
和1个控制输入，电路对数据输入执行的算术或逻辑操作根据控制输入决定。ALU的4个操作对应Y86-64指令集的4种整数操作指令。</p>
<h4 id="存储器和时钟">4.2.3 存储器和时钟</h4>
<p>　　实际上，组合电路不存储任何信息，相反，它们只是简单地响应输入信号，生成对应的输出。为了生成<strong>时序电路</strong>
(具有状态并对该状态进行计算的系统)，必须加入按位存储信息的设备。存储设备都是由同一<strong>时钟</strong>控制，时钟是周期性信号，决定何时把新值加载到设备中。</p>
<p>　　● <strong>时钟寄存器</strong> (简称寄存器)
存储单个位或字。时钟信号控制寄存器输入值的加载。</p>
<p>　　●
<strong>存储器</strong>存储多个字，用地址来决定待读写的字。例如，CPU的虚拟内存系统和寄存器文件。</p>
<p>　　寄存器在硬件和机器级编程的含义略有不同。在硬件中，寄存器直接将其输入和输出线连接到电路的其他部分。在机器级编程中，寄存器表示CPU中为数不多的可寻址的字，地址是寄存器ID，这些字通常存储在寄存器文件中，虽然硬件有时可以直接将字从某个指令移动到其他指令，以避免先写寄存器文件再读的延迟。为了避免歧义，这2类寄存器称为<span
style="background-color: yellow">硬件寄存器</span>和<span
style="background-color: yellow">程序寄存器</span>。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/register_operation.svg" class="" title="register_operation">
<p>　　硬件寄存器通常都保持在稳定状态<code>x</code>，其输出为其当前状态。信号会沿寄存器前面的组合逻辑传播，生成新的寄存器输入<code>y</code>，但只要时钟保持低电位，寄存器的输出不变。当时钟变为高电位时，输入信号加载到寄存器，寄存器变为下一个状态<code>y</code>，在下一个时钟上升沿前，寄存器的输出不变。寄存器作为电路不同部分中的组合逻辑之间的屏障。每当时钟上升沿时，值才会从寄存器的输入移动到输出。Y86-64会用时钟寄存器保存PC、CC和程序状态。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/register_file.svg" class="" title="register_file">
<p>　　寄存器文件有2个读端口 (A和B) 和1个写端口
(W)，这样的多端口存储器允许同时进行多个读或写操作。它可以读2个程序寄存器的值，同时更新第3个寄存器的状态。每个端口都有1个地址输入
(表示程序寄存器) 和1个数据输入/输出
(表示程序寄存器的值)。地址输入是寄存器ID。2个读端口都有地址输入
(<code>srcA</code>和<code>srcB</code>) 和数据输出
(<code>valA</code>和<code>valB</code>)。写端口有地址输入
(<code>dstW</code>) 和数据输入 (<code>valW</code>)。</p>
<p>　　寄存器文件不是组合电路，因为它有内部存储。不过，在这里的实现中，从寄存器文件读数据就好像它是以地址为输入、数据为输出的组合逻辑块。当<code>srcA</code>或<code>srcB</code>为某个寄存器ID时，在一段时间后，存储在对应程序寄存器的值就会出现在<code>valA</code>或<code>valB</code>。例如，将<code>srcA</code>置为<code>0x3</code>，就会读程序寄存器<code>%rbx</code>的值，这个值会出现在输出<code>valA</code>。</p>
<p>　　写寄存器文件由时钟信号控制，控制方式类似将值加载到时钟寄存器。每次时钟上升时，输入<code>valW</code>的值会写入到输入<code>dstW</code>的寄存器ID对应的程序寄存器。当<code>dstW</code>为<code>0xF</code>时，不会写任何寄存器。若更新某个寄存器的同时在读端口上用该寄存器ID，则会出现从旧值到新值的变化。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/data_memory.svg" class="" title="data_memory">
<p>　　CPU有1个存储器用于存储程序数据，该存储器有1个地址输入、1个数据输入和1个数据输出。同寄存器文件一样，该存储器的操作方式类似于组合逻辑，在地址输入中输入地址并将写控制信号置0，经过一段时间后，存储在该地址上的值会出现在数据输出。若地址超出范围
(这里的边界检查就是地址输入的函数，不涉及保存任何状态)，异常信号会置1；否则，置0。写该存储器是时钟控制的，在地址输入输入地址、数据输入输入数据和将写控制信号置1后，只要地址是合法的，就会更新对应的值。CPU还包括1个只读存储器，用于读指令。在大多数实际系统中，这2个存储器合并为1个具有双端口的存储器，分别用于读指令和读写数据。</p>
<h3 id="y86-64的顺序实现">4.3 Y86-64的顺序实现</h3>
<p>　　这里的实现以SEQ为例，每个时钟周期内，SEQ会执行处理1条指令所需的所有步骤，但这需要很长的时钟周期时间，所以时钟周期频率会很低。处理1条指令通常需要<strong>取指</strong>、<strong>译码</strong>、<strong>执行</strong>、<strong>访存</strong>、<strong>写回</strong>、<strong>更新PC</strong>。CPU会一直循环这几个阶段，这里简化了实现，当出现异常时
(执行指令<code>halt</code>/非法指令和读写非法地址)，CPU就会停止，在更完整的设计中，CPU会进入异常处理模式，开始执行异常类型决定的特殊代码。</p>
<p>　　●
在取指阶段，会以PC为内存地址来读取指令，再从指令中提取出指令指示符的2个4位的字段
(<strong>指令代码</strong>和<strong>指令功能</strong>)。这里可能会取出1B的寄存器ID字段，表示1或2个寄存器操作数指示符<code>rA</code>和<code>rB</code>。这里还可能取出8B的常数字段<code>valC</code>，用于计算下一条指令的地址<code>valP</code>
(<code>valP</code>的值为PC的值加上取出指令的长度)。</p>
<p>　　●
在译码阶段，会从寄存器文件读取最多2个操作数，得到值<code>val</code>和/或<code>valB</code>。通常，这里读指令中<code>rA</code>和<code>rB</code>字段指明的寄存器，不过有些指令读栈指针。</p>
<p>　　● 在执行阶段，ALU要么执行指令指明的操作数
(根据<code>ifun</code>)，计算内存引用的有效地址，加/减栈指针，得到值<code>valE</code>，这里可能会设置CC。对于条件移动指令，该阶段会检查CC和移动条件
(由<code>ifun</code>给出)，若条件成立，则更新目标寄存器。同样，条件跳转指令也会进行条件判断。</p>
<p>　　●
在访存阶段，可能会读写内存，这里将读取的值表示为<code>valM</code>。</p>
<p>　　● 在写回阶段，会写最多2个结果到寄存器文件。</p>
<p>　　● 在更新PC阶段，会将PC设置为下一条指令的地址。</p>
<p>　　SEQ并不能充分利用硬件单元，因为每个单元仅在整个时钟周期中的一部分时间才被使用。</p>
<h4 id="将处理组织成阶段">4.3.1 将处理组织成阶段</h4>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 32%" />
<col style="width: 32%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr>
<th>阶段</th>
<th style="text-align: left;"><code>Opq  rA, rB</code></th>
<th><code>rrmovq  rA, rB</code></th>
<th style="text-align: left;"><code>irmovq  V, rB</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>取指</td>
<td style="text-align: left;"><code>icode:ifun</code> ←
<code>M1[PC]</code>; <code>rA:rB</code> ← <code>M1[PC + 1]</code>;
<code>valP</code> ← <code>PC + 2</code></td>
<td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>ra:rB</code> ←
<code>M1[PC + 1]</code>; <code>valP</code> ← <code>PC + 2</code></td>
<td style="text-align: left;"><code>icode:ifun</code> ←
<code>M1[PC]</code>; <code>rA:rB</code> ← <code>M1[PC + 1]</code>;
<code>valC</code> ← <code>M8[PC + 2]</code>; <code>valP</code> ←
<code>PC + 10</code></td>
</tr>
<tr>
<td>译码</td>
<td style="text-align: left;"><code>valA</code> ← <code>R[rA]</code>;
<code>valB</code> ← <code>R[rB]</code></td>
<td><code>valA</code> ← <code>R[rA]</code></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td>执行</td>
<td style="text-align: left;"><code>valE</code> ←
<code>valB OP valA</code>; <code>Set CC</code></td>
<td><code>valE</code> ← <code>valA</code></td>
<td style="text-align: left;"><code>valE</code> ← <code>valC</code></td>
</tr>
<tr>
<td>访存</td>
<td style="text-align: left;"></td>
<td></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td>写回</td>
<td style="text-align: left;"><code>R[rB]</code> ←
<code>valE</code></td>
<td><code>R[rB]</code> ← <code>valE</code></td>
<td style="text-align: left;"><code>R[rB]</code> ←
<code>valE</code></td>
</tr>
<tr>
<td>更新PC</td>
<td style="text-align: left;">PC ← <code>valP</code></td>
<td>PC ← <code>valP</code></td>
<td style="text-align: left;">PC ← <code>valP</code></td>
</tr>
</tbody>
</table>
<p>　　这些指令都是计算1个值并将结果存储在寄存器中。<code>icode:ifun</code>表示指令代码和指令功能，<code>rA:rB</code>表示寄存器指示符字节中的<code>ra</code>和<code>rB</code>。<code>M1[x]</code>表示访存位置<code>x</code>处的1B，同理，<code>M8[x]</code>表示访问该位置的8B。</p>
<p>　　对于整数操作指令，其编码长度为2B，所以取指阶段中<code>valP</code>为<code>PC + 2</code>。在译码阶段，会读取2个操作数。在执行阶段，会将操作数和<code>ifun</code>一起提供给ALU，其中具体的整数操作由<code>ifun</code>指定，得到<code>valE</code>，这里会设置CC。整数操作指令不涉及内存访问，所以访存阶段什么也不做。在写回阶段，会将<code>valE</code>写回寄存器<code>rB</code>。在更新PC阶段，会将<code>PC</code>设置为<code>valP</code>。指令<code>rrmovq</code>和<code>irmivq</code>与之类似。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 4%" />
<col style="width: 47%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr>
<th>阶段</th>
<th><code>rmmovq  rA, D(rB)</code></th>
<th><code>mrmovq  D(rB), rA</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>取指</td>
<td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>rA:rB</code> ←
<code>M1[PC + 1]</code>; <code>valC</code> ← <code>M8[PC + 2]</code>;
<code>valP</code> ← <code>PC + 10</code></td>
<td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>rA:rB</code> ←
<code>M1[PC + 1]</code>; <code>valC</code> ← <code>M8[PC + 2]</code>;
<code>valP</code> ← <code>PC + 10</code></td>
</tr>
<tr>
<td>译码</td>
<td><code>valA</code> ← <code>R[rA]</code>; <code>valB</code> ←
<code>R[rB]</code></td>
<td><code>valB</code> ← <code>R[rB]</code></td>
</tr>
<tr>
<td>执行</td>
<td><code>valE</code> ← <code>valB + valC</code></td>
<td><code>valE</code> ← <code>valB + valC</code></td>
</tr>
<tr>
<td>访存</td>
<td><code>M8[valE]</code> ← <code>valA</code></td>
<td><code>valM</code> ← <code>M8[valE]</code></td>
</tr>
<tr>
<td>写回</td>
<td></td>
<td><code>R[rA]</code> ← <code>valM</code></td>
</tr>
<tr>
<td>更新PC</td>
<td>PC ← <code>valP</code></td>
<td>PC ← <code>valP</code></td>
</tr>
</tbody>
</table>
<p>　　指令<code>rmmovq</code>和<code>mrmovq</code>的流程和整数操作指令的类似，不过会用ALU来加<code>valC</code>和<code>valB</code>得到内存操作的有效地址。在访存阶段，会将寄存器值<code>valA</code>写到内存或从内存读到<code>valM</code>。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 4%" />
<col style="width: 47%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr>
<th>阶段</th>
<th><code>pushq  rA</code></th>
<th><code>popq  rA</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>取指</td>
<td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>rA:rB</code> ←
<code>M1[PC + 1]</code>; <code>valP</code> ← <code>PC + 2</code></td>
<td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>rA:rB</code> ←
<code>M1[PC + 1]</code>; <code>valP</code> ← <code>PC + 2</code></td>
</tr>
<tr>
<td>译码</td>
<td><code>valA</code> ← <code>R[rA]</code>; <code>valB</code> ←
<code>R[%rsp]</code></td>
<td><code>valA</code> ← <code>R[%rsp]</code>; <code>valB</code> ←
<code>R[%rsp]</code></td>
</tr>
<tr>
<td>执行</td>
<td><code>valE</code> ← <code>valB - 8</code></td>
<td><code>valE</code> ← <code>valB + 8</code></td>
</tr>
<tr>
<td>访存</td>
<td><code>M8[valE]</code> ← <code>valA</code></td>
<td><code>valM</code> ← <code>M8[valA]</code></td>
</tr>
<tr>
<td>写回</td>
<td><code>R[%rsp]</code> ← <code>valE</code></td>
<td><code>R[%rsp]</code> ← <code>valE</code>; <code>R[rA]</code> ←
<code>valM</code></td>
</tr>
<tr>
<td>更新PC</td>
<td>PC ← <code>valP</code></td>
<td>PC ← <code>valP</code></td>
</tr>
</tbody>
</table>
<p>　　对于指令<code>pushq</code>，在译码阶段，会用栈指针作为第2个操作数并赋值给<code>valB</code>。在执行阶段，会将栈指针减8，得到的值作为访存阶段中的内存地址。</p>
<p>　　指令<code>popq</code>的流程与指令<code>pushq</code>的类似，不同的是译码阶段会读取<span
style="background-color: yellow">2次</span>栈指针分别赋值给<code>valA</code>和<code>valB</code>。在执行阶段，会将栈指针加8，得到的值用于写回阶段中写回给栈指针。在访存阶段，会读取栈指针，得到的值用于写回阶段中写回寄存器<code>rA</code>。</p>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 35%" />
<col style="width: 35%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th>阶段</th>
<th><code>jxx  Dest</code></th>
<th><code>call  Dest</code></th>
<th><code>ret</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>取指</td>
<td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>valC</code> ←
<code>M8[PC + 1]</code>; <code>valP</code> ← <code>PC + 9</code></td>
<td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>valC</code> ←
<code>M8[PC + 1]</code>; <code>valP</code> ← <code>PC + 9</code></td>
<td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>valP</code> ←
<code>PC + 1</code></td>
</tr>
<tr>
<td>译码</td>
<td></td>
<td><code>valB</code> ← <code>R[%rsp]</code></td>
<td><code>valA</code> ← <code>R[%rsp]</code>; <code>valB</code> ←
<code>R[%rsp]</code></td>
</tr>
<tr>
<td>执行</td>
<td><code>Cnd</code> ← <code>Cond(CC, ifun)</code></td>
<td><code>valE</code> ← <code>valB - 8</code></td>
<td><code>valE</code> ← <code>valB + 8</code></td>
</tr>
<tr>
<td>访存</td>
<td></td>
<td><code>M8[valE]</code> ← <code>valP</code></td>
<td><code>valM</code> ← <code>M8[valA]</code></td>
</tr>
<tr>
<td>写回</td>
<td></td>
<td><code>R[%rsp]</code> ← <code>valE</code></td>
<td><code>R[%rsp]</code> ← <code>valE</code></td>
</tr>
<tr>
<td>更新PC</td>
<td>PC ← <code>Cnd ? valC : valP</code></td>
<td>PC ← <code>valC</code></td>
<td>PC ← <code>valM</code></td>
</tr>
</tbody>
</table>
<p>　　条件跳转指令的流程与整数操作指令的类似。在执行阶段，会检查CC和跳转条件来确定分支选择
(生成1位的信号<code>Cnd</code>)。在更新PC阶段，会根据<code>Cnd</code>来设置PC，若<code>Cnd</code>为1，则将PC设置为<code>valC</code>
(跳转目标)；若<code>Cnd</code>为0，则将PC设置为<code>valP</code>。</p>
<p>　　指令<code>call</code>和<code>ret</code>的流程与指令<code>pushq</code>和<code>popq</code>的类似，除了将栈指针压入和弹出栈。对于<code>call</code>指令，会将<code>valP</code>压入栈。在更新PC阶段，会将PC设置为<code>valC</code>。对于指令<code>ret</code>，在更新PC阶段，会PC设置为从栈中取出的值<code>valM</code>。</p>
<h4 id="seq">4.3.2 SEQ</h4>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/seq_hardware_structure.svg" class="" title="seq_hardware_structure">
<p>　　在SEQ中，<span
style="background-color: yellow">白色矩形表示时钟寄存器</span>，PC是这里唯一的时钟寄存器。<span
style="background-color: yellow">浅蓝色框表示硬件单元</span>，包括存储器和ALU，这里会使用黑盒
(忽视其细节设计) 来实现。<span
style="background-color: yellow">灰色圆角矩形表示控制逻辑块</span>，这些块用于从一组信号源中进行选择或计算布尔函数。<span
style="background-color: yellow">粗线表示字级别的数据</span>，每条这样的线实际表示1簇64根线，并列地连在一起，将1个字从硬件的某部分移动到其他部分。<span
style="background-color: yellow">细线表示字节级别或更小的数据</span>，根据具体待移动的值，每条这样的线实际表示1簇4或8根线。<span
style="background-color: yellow">虚线表示单个位</span>，表示单元与块之间移动的控制值。</p>
<h4 id="seq时序">4.3.3 SEQ时序</h4>
<p>　　SEQ的实现包括组合逻辑和2种存储器，即时钟寄存器 (PC和CC寄存器)
和<span style="background-color: yellow">随机存取存储器</span>
(寄存器文件、指令存储器和数据存储器)。组合逻辑不需要任何时序或控制，只要输入变化，值就通过组合电路传播。读存储器可以视为和组合逻辑一样的操作，根据地址输入生成输出，对于寄存器文件等较小的存储器，这是合理的假设，但对于较大的电路，可以用特殊的时钟电路来模拟。由于指令存储器仅用于读指令，该硬件单元可以视为组合逻辑。</p>
<p>　　这里还有4个硬件单元需要进行时序控制，即PC寄存器、CC寄存器、数据存储器和寄存器文件。这些单元通过同一时钟信号控制，该信号会触发将新值加载到寄存器和将值写入RAM。PC在每个时钟周期加载新指令的地址。仅当执行整数操作指令时，才会加载CC寄存器。只有执行指令<code>rmmovq</code>、<code>pushq</code>和<code>call</code>时，才会写数据存储器。寄存器文件的2个写端口允许每个时钟周期更新2个程序寄存器。</p>
<p>　　要控制CPU中活动的时序，只需控制寄存器和存储器的时钟。SEQ硬件实现了与指令执行顺序相同的效果，即使所有状态更新实际上同时发生且仅在时钟上升沿
(即下一个时钟周期的开始)。这种等价性得益于Y86-64指令集的本质——<span
style="background-color: yellow">从不回读</span>，即<span
style="background-color: yellow">CPU永远不需要读指令更新后的状态即可完成指令的处理</span>。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/tracing_two_cycles_of_execution_by_seq.svg" class="" title="tracing_two_cycles_of_execution_by_seq">
<p>　　标签1~4分别给出了第3~4行代码的开始和结束时的一些信息，包括4个状态单元以及组合逻辑和状态单元之间的连接。组合逻辑将CC寄存器包围，因为一些组合逻辑
(例如，ALU) 生成CC寄存器的输入，而其他部分 (例如，条件判断和PC选择逻辑)
将CC寄存器作为输入。寄存器文件和数据存储器有独立的读连接和写连接，因为读沿着这些单元传播，就好像它们是组合逻辑，而写操作由时钟控制。</p>
<p>　　这里假设处理从CC开始，CC的顺序是ZF、SF和OF，设置为100。在时钟周期3开始时
(标签1)，状态单元保持的是周期2中指令<code>irmovq</code>更新后的状态，该指令用浅灰色表示。组合逻辑用白色表示，表示还未对变化后的状态做出反应。时钟周期以地址<code>0x014</code>载入到PC开始，这样会取出并执行指令<code>addq</code>。值会沿着组合逻辑，包括RAM的读。在该周期结束时
(标签2)，组合逻辑会为CC生成了新值000、寄存器<code>%rbx</code>更新后的值和PC的新值<code>0x016</code>。此时，组合逻辑已经根据指令<code>addq</code>更新，但状态还保持着周期2中指令<code>irmovq</code>设置的值。</p>
<p>　　在时钟周期4开始时
(标签3)，会更新PC、寄存器文件和CC寄存器，所以用蓝色表示，但组合逻辑还未对这些变化做出反应，所以用白色表示。在该周期内，会取出并执行指令<code>je</code>，用深灰色表示。ZF为0，所以不会进行分支选择。在该周期结束时
(标签4)，PC的新值<code>0x01f</code>已经生成，组合逻辑已完成更新，但直到下个周期开始前，状态会保持指令<code>addq</code>设置的值。</p>
<h4 id="seq各阶段的实现">4.3.4 SEQ各阶段的实现</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>十六进制值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IHALT</code></td>
<td><code>0x0</code></td>
<td>指令<code>halt</code>的代码</td>
</tr>
<tr>
<td><code>INOP</code></td>
<td><code>0x1</code></td>
<td>指令<code>nop</code>的代码</td>
</tr>
<tr>
<td><code>IRRMOVQ</code></td>
<td><code>0x2</code></td>
<td>指令<code>rrmovq</code>的代码</td>
</tr>
<tr>
<td><code>IIRMOVQ</code></td>
<td><code>0x3</code></td>
<td>指令<code>irmovq</code>的代码</td>
</tr>
<tr>
<td><code>IRMMOVQ</code></td>
<td><code>0x4</code></td>
<td>指令<code>rmmovq</code>的代码</td>
</tr>
<tr>
<td><code>IMRMOVQ</code></td>
<td><code>0x5</code></td>
<td>指令<code>irmovq</code>的代码</td>
</tr>
<tr>
<td><code>IOPL</code></td>
<td><code>0x6</code></td>
<td>整数运算指令的代码</td>
</tr>
<tr>
<td><code>IJXX</code></td>
<td><code>0x7</code></td>
<td>跳转指令的代码</td>
</tr>
<tr>
<td><code>ICALL</code></td>
<td><code>0x8</code></td>
<td>指令<code>call</code>的代码</td>
</tr>
<tr>
<td><code>IRET</code></td>
<td><code>0x9</code></td>
<td>指令<code>ret</code>的代码</td>
</tr>
<tr>
<td><code>IPUSHQ</code></td>
<td><code>0xA</code></td>
<td>指令<code>pushq</code>的代码</td>
</tr>
<tr>
<td><code>IPOPQ</code></td>
<td><code>0xB</code></td>
<td>指令<code>popq</code>的代码</td>
</tr>
<tr>
<td><code>FNONE</code></td>
<td><code>0x0</code></td>
<td>默认功能码</td>
</tr>
<tr>
<td><code>RRSP</code></td>
<td><code>0x4</code></td>
<td>寄存器<code>%rsp</code>的ID</td>
</tr>
<tr>
<td><code>RNONE</code></td>
<td><code>0xF</code></td>
<td>不访问寄存器</td>
</tr>
<tr>
<td><code>ALUADD</code></td>
<td><code>0x0</code></td>
<td>加法运算</td>
</tr>
<tr>
<td><code>SAOK</code></td>
<td><code>0x1</code></td>
<td>正常操作状态码</td>
</tr>
<tr>
<td><code>SADR</code></td>
<td><code>0x2</code></td>
<td>地址异常状态码</td>
</tr>
<tr>
<td><code>SINS</code></td>
<td><code>0x3</code></td>
<td>非法指令异常状态码</td>
</tr>
<tr>
<td><code>SHLT</code></td>
<td><code>0x4</code></td>
<td><code>halt</code>状态码</td>
</tr>
</tbody>
</table>
<p>　　这是一些整数和布尔信号的定义，可以作为HCL操作的参数。它们都是必须显式引用的常数，按照惯例，常数值都是大写。</p>
<h5 id="取指阶段">4.3.4.1 取指阶段</h5>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/seq_fetch_stage.svg" class="" title="seq_fetch_stage">
<p>　　对于取指阶段，指令存储器会以PC作为第1个字节 (字节0)
的地址从存储器<span
style="background-color: yellow">读取10B</span>。第1个字节会解释为指令字节
(标签Split)，分为2个4位的数。然后，标签为icode和ifun的控制逻辑块会计算指令和功能代码，使之等于从指令存储器读取的值，或者指令地址越界时
(信号<code>imem_error</code>表示)，使之等于对应指令<code>nop</code>的值。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool need_regids =</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool need_valC =</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL &#125;;</span><br></pre></td></tr></table></figure>
<p>　　根据<code>icode</code>计算可以3个1位的信号
(虚线表示)，即<code>instr_valid</code>、<code>need_regids</code>和<code>need_valC</code>。第1个信号表示指令字节是否合法，第2个信号表示指令是否包含1个寄存器ID，第3个信号表示指令是否包含常数。</p>
<p>　　信号<code>instr_valid</code>和<code>imem_error</code>在访存阶段用于生成CC。</p>
<p>　　从指令存储器读出的剩余字节是寄存器ID和常数的组合编码
(标签Align)。若<code>need_regids</code>为1，则字节1会拆开并赋值给<code>rA</code>和<code>rB</code>，字节2~9用于生成<code>valC</code>；否则，<code>rA</code>和<code>rB</code>会设置为<code>0xF</code>，字节1~8用于生成<code>valC</code>。</p>
<p>　　若PC的当前值为<span
class="math inline">\(p\)</span>，<code>need_regids</code>的值为<span
class="math inline">\(r\)</span>，<code>need_valC</code>的值为<span
class="math inline">\(i\)</span>，则PC增加后的值为<span
class="math inline">\(p+1+r+8i\)</span>。</p>
<h5 id="译码和写回阶段">4.3.4.2 译码和写回阶段</h5>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/seq_decode_and_write-back_stage.svg" class="" title="seq_decode_and_write-back_stage">
<p>　　寄存器文件有4个端口，支持同时进行2个读操作 (端口A和B) 和2个写操作
(端口E和M)。每个端口都有1个地址连接和数据连接，地址连接是1个寄存器ID，数据连接是1簇64根线，既可以作为寄存器文件的输出字
(对读端口)，也可以作为输入字
(对写端口)。2个读端口的地址输入为<code>srcA</code>和<code>srcB</code>，而2个写端口的地址输入为<code>dstE</code>和<code>dstM</code>。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word srcA = </span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ &#125; : rA;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IPOPQ, IRET &#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word srcB = </span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IOPQ, IRMMOVQ, IMRMOVQ &#125; : rB;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"># 不考虑条件移动指令</span><br><span class="line">word dstE = </span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRRMOVQ, IIRMOVQ, IOPQ &#125; : rB;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"># 不考虑条件移动指令</span><br><span class="line">word dstM = </span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IMRMOVQ, IPOPQ &#125; : rA;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　<code>srcA</code>和<code>srcB</code>分别表示应该读取哪个寄存器来获取<code>valA</code>和<code>valB</code>。<code>desE</code>和<code>destM</code>分别是端口E和M的目的寄存器ID。</p>
<p>　　根据<code>icode</code>、<code>rA</code>和<code>rB</code>，可能还会在执行阶段计算<code>Cnd</code>。</p>
<h5 id="执行阶段">4.3.4.3 执行阶段</h5>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/seq_execute_stage.svg" class="" title="seq_execute_stage">
<p>　　对于执行阶段，ALU会根据<code>alufun</code>，对输入<code>aluA</code>和<code>aluB</code>进行加、减、与和异或运算，输出是<code>valE</code>。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word aluA =</span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRRMOVQ, IOPQ &#125; : valA;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ &#125; : valC;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; ICALL, IPUSHQ &#125; : -<span class="number">8</span>;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRET, IPOPQ &#125; : <span class="number">8</span>;</span><br><span class="line">    # 其他指令无需ALU</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word aluB =</span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRMMOVQ, IMRMOVQ, IOPQ, ICALL, IPUSHQ, IRET, IPOPQ &#125; : valB;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRRMOVQ, IIRMOVQ &#125; : <span class="number">0</span>;</span><br><span class="line">    # 其他指令无需ALU</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　执行阶段的第1步是ALU计算，列出的操作数中<code>aluB</code>在前面，<code>aluA</code>在后面，这样可以保证指令<code>subq</code>的执行。根据指令的类型，<code>aluA</code>的值可以是<code>valA</code>、<code>valC</code>和$$8。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word alufun =</span><br><span class="line">[</span><br><span class="line">    icode == IOPQ : ifun;</span><br><span class="line">    i : ALUADD;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool set_cc = icode <span class="keyword">in</span> &#123; IOPQ &#125;;</span><br></pre></td></tr></table></figure>
<p>　　在执行阶段中，ALU通常作为加法器使用，但对于整数操作指令，它还是会使用<code>ifun</code>编码的操作。CC只会在执行整数操作指令时才会设置。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word dstE = </span><br><span class="line">[</span><br><span class="line">    # 用IRRMOVQ实现条件移动指令</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRRMOVQ &#125; &amp;&amp; Cnd : rB;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IIRMOVQ, IOPQ &#125; : rB;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　标签为cond的硬件单元会根据CC和功能码来确定是否进行条件分支选择或条件数据移动。它还会生成<code>Cnd</code>，用于设置条件移动的<code>dstE</code>和条件分支中下一个PC的逻辑。对于其他指令，<code>Cnd</code>可以设置为0或1，这取决于指令的功能码和CC，但ALU会忽略它。</p>
<h5 id="访存阶段">4.3.4.4 访存阶段</h5>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/seq_memory_stage.svg" class="" title="seq_memory_stage">
<p>　　访存阶段的任务是读写程序数据。2个控制块用于生成存储器地址和存储器写入数据的值。另外2个块用于生成控制读写操作的控制信号。当执行读操作时，数据存储器会生成<code>valM</code>。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word mem_addr = </span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ &#125; : valE;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IPOPQ, IRET &#125; : valA;</span><br><span class="line">    # 其他指令无需地址</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word mem_data = </span><br><span class="line">[</span><br><span class="line">    # 寄存器的值</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRMMOVQ, IPUSHQ &#125; : valA;</span><br><span class="line">    # 返回PC</span><br><span class="line">    icode == ICALL : valP;</span><br><span class="line">    # 默认不写数据</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool mem_read = icode <span class="keyword">in</span> &#123; IMRMOVQ, IPOPQ, IRET &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool mem_write = icode <span class="keyword">in</span> &#123; IRMMOVQ, IPUSHQ, ICALL &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word Stat = </span><br><span class="line">[</span><br><span class="line">    imem_error || dmem_error : SADR;</span><br><span class="line">    !instr_valid : SINS;</span><br><span class="line">    icode == IHAT : SHLT;</span><br><span class="line">    <span class="number">1</span> : SAOK;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　访存阶段会根据取指阶段生成的<code>icode</code>、<code>imem_error</code>、<code>instr_valid</code>和数据存储器生成的<code>dmem_error</code>来计算<code>Stat</code>。</p>
<h5 id="pc更新阶段">4.3.4.5 PC更新阶段</h5>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/seq_pc_update_stage.svg" class="" title="seq_pc_update_stage">
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word new_pc = </span><br><span class="line">[</span><br><span class="line">    # Call指令：指令常数</span><br><span class="line">    icode == ICALL : valC;</span><br><span class="line">    # 条件跳转指令：指令常数</span><br><span class="line">    icode == IJXX &amp;&amp; Cnd : valC;</span><br><span class="line">    # 返回指令：使用栈值</span><br><span class="line">    icode == IRET : valM;</span><br><span class="line">    # 默认：PC增加</span><br><span class="line">    <span class="number">1</span> : valP;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　PC更新阶段会生成新PC。根据指令类型和是否执行条件跳转，新PC可能是<code>valC</code>、<code>valM</code>或<code>valP</code>。</p>
<h3 id="流水线的通用原理">4.4 流水线的通用原理</h3>
<p>　　流水线化设计的目的是保证<span
style="background-color: yellow">每个时钟周期都发出1条新指令</span>，即每个时钟周期都有1条新指令进入执行阶段并完成。要实现这一点需要吞吐量为每个时钟周期1条指令，也就是在取出当前指令后立即确定下一条指令的位置。若取出的指令是条件分支指令，则需要指令通过执行阶段后，才能知道是否选择分支。同样，若取出的指令是<code>ret</code>，则需要指令通过访存阶段后，才能确定返回地址。</p>
<p>　　通过预测PC的下一个值，在大多数情况下，能够达到流水线化设计的目的。对<span
style="background-color: yellow">大多数</span>类型的指令，这种预测是可靠的。</p>
<p>　　猜测分支方向并根据猜测开始取值的技术称为<strong>分支预测</strong>，实际上所有的CPU都采用某种形式的分支预测。这里只会使用简单的策略——<strong>总是选择</strong>条件分支，所以预测的PC值为<code>valC</code>，该策略的成功率大约是60%。相反，<strong>从不选择</strong>策略的成功率大约为40%。更复杂的<strong>反向选择、正向不选择</strong>策略的成功率大约为65%，这种策略源于事实：循环是由后向分支结束的，而循环通常会多次执行，前向分支用于条件操作，而这种选择的可能性较小。第3章提到过，分支预测错误会极大地降低程序性能，所以尽可能使用条件数据移动而非条件控制移动。</p>
<p>　　不同于条件移动指令，指令<code>ret</code>的PC新可能值几乎是无穷的，因为返回地址是位于栈顶的字，其内容不定。</p>
<p>　　对于大多数程序，预测返回值很容易，因为过程调用和返回是成对出现的。高性能CPU充分利用了该属性，在取指单元中加入<span
style="background-color: yellow">硬件栈</span>
(不属于程序员可见状态)，保存指令<code>call</code>生成的返回地址。每次执行指令<code>call</code>时，都会将其返回值压入栈中。当取出指令<code>ret</code>时，就从这个栈中弹出顶部的值，作为预测的返回值。同分支预测一样，预测错误时需要恢复机制，因为有时调用和返回不匹配。</p>
<h4 id="计算流水线">4.4.1 计算流水线</h4>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/unpipelined_computaion_hardware.svg" class="" title="unpipelined_computaion_hardware">
<p>　　假设未流水线化的计算硬件中组合逻辑和寄存器的处理时间分别是300ps和20ps，所以每条指令的延迟为320ps。这种实现中下一条指令只能在前一条指令执行完成后才能执行，指令执行周期为320ps，所以时钟周期为320ps。这里用<span
style="background-color: yellow">每秒千兆条指令</span>为单位来描述该系统的吞吐量。
<span class="math display">\[
\begin{align}
T_{unpipelined}&amp;=\frac{1条指令}{1条指令的时延}\times\frac{1000ps}{1ns}\\[3px]
&amp;=\frac{1}{320ps}\times\frac{1000ps}{1ns}\\[3px]
&amp;\approx3.12GIPS
\end{align}
\]</span></p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/three-stage_pipelining_timing.svg" class="" title="three-stage_pipelining_timing">
<p>　　在之前的基础上，若<span
style="background-color: yellow">将指令按延迟平均划分3个阶段</span>
(A、B和C)，每个阶段中组合逻辑的处理时间为100ps，而寄存器的处理时间为20ps，所以时钟周期为120ps，这样1条指令需要3个时钟周期来执行，延迟为360ps。从宏观角度，每个时钟周期可以执行1个阶段A、B和C，可视为每个时钟周期执行1条指令。
<span class="math display">\[
\begin{align}
T_{three}&amp;=\frac{1条指令}{1条指令的时延}\times\frac{1000ps}{1ns}\\[3px]
&amp;=\frac{1}{120ps}\times\frac{1000ps}{1ns}\\[3px]
&amp;\approx8.33GIPS
\end{align}
\]</span>
　　相比未流水线化设计，3阶段流水线设计的吞吐量大大增加，代价是增加了一些硬件和少量延迟。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/one_clock_cycle_of_pipeline_operation.svg" class="" title="one_clock_cycle_of_pipeline_operation">
<p>　　在时段240ps~360ps内，指令I1经过阶段C，I2经过阶段B，I3经过阶段A。在时刻239ps，阶段A中计算的指令I2的值已经到达第1个流水线寄存器的输入，但该寄存器的状态和输出还保持为指令I1的阶段A中计算的值。同样，指令I1在阶段B中计算的值已经到达第2个流水线寄存器的输入。在时刻241ps，流水线寄存器的输入载入其中，成为其输出。阶段A的输入设置为发起指令I3的计算。在时刻300ps，信号传播到各个阶段的组合逻辑，这里使用的是曲线化的波阵面，表示信号<span
style="background-color: yellow">可能以不同的速率</span>通过各个部分。在时刻359ps，结果值到达流水线寄存器的输入。</p>
<p>　　这里的流水线化设计是理想情况，实际中会出现一些降低流水线效率的因素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">irmovq	$50, %rax</span><br><span class="line">addq	%rax, %rbx</span><br><span class="line">mrmovq	100(%rbx), %rdx</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，每条相邻的指令之间都有<strong>数据依赖</strong>。指令<code>irmovq</code>会将结果存储在寄存器<code>%rax</code>中。指令<code>addq</code>会读寄存器<code>%rax</code>再将结果存储到寄存器<code>%rbx</code>。最后，指令<code>irmovq</code>会读寄存器<code>%rbx</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loop:</span><br><span class="line">	subq    %rdx, %rbx</span><br><span class="line">	jne     targ</span><br><span class="line">	irmovq  $10, %rdx</span><br><span class="line">	jmp     loop</span><br><span class="line">targ:</span><br><span class="line">	halt</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，指令<code>jne</code> (第3行)
有<strong>控制依赖</strong>。条件判断的结果会决定执行的下一条指令是<code>irmovq</code>
(第4行) 还是<code>halt</code> (第7行)。</p>
<p>　　在SEQ设计中，数据和控制依赖都是通过<span
style="background-color: yellow">反馈路径</span>解决。</p>
<h4 id="流水线的限制">4.4.2 流水线的限制</h4>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/limitations_of_pipelining_due_to_nonuniform_stages_daleys.svg" class="" title="limitations_of_pipelining_due_to_nonuniform_stages_daleys">
<p>　　这个示例与之前的流水线系统大致相同，但在阶段划分时<span
style="background-color: yellow">阶段的时间不等</span>。时钟周期为最长的阶段延迟，即阶段B的延迟170ps。对于时钟周期，阶段A和C会分别空闲
(表示为白色框)
100ps和50ps，根据这些可以计算出吞吐量为5.88GIPS。此外，单条指令的周期时间增加到了510ps。</p>
<p>　　对于硬件设计者，将系统计算设计划分为时间相等的多个阶段是个严峻的挑战。此外，CPU中的某些硬件单元
(例如，ALU和内存) 无法进一步划分，这使得划分时间相等的阶段更困难。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/limitations_of_pipelineing_due_to_overhead.svg" class="" title="limitations_of_pipelineing_due_to_overhead">
<p>　　这个示例与之前的流水线系统大致相同，但在阶段划分时<span
style="background-color: yellow">平均划分为6个阶段</span>。时钟周期为70ps，根据这些可以计算出吞吐量为14.29GIPS。相比3阶段流水线系统，时钟周期减半，但吞吐量并未加倍。</p>
<p>　　为了提高时钟频率，现代CPU采用了阶段很多 (15及更多阶段)
的流水线。CPU架构师将指令的执行划分为很多很简单的步骤，这样是为了保证每个阶段的延迟很小。电路设计师需要尽可能保证流水线寄存器的延迟足够小。芯片设计师需要小心地设计时钟传播网络以保证时钟在整个芯片上同时改变。所有这些因素都会增加CPU设计的难度。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/limitations_of_pipelining_due_to_logical_dependencies.svg" class="" title="limitations_of_pipelining_due_to_logical_dependencies">
<p>　　将反馈机制加入流水线后，在未流水线化的系统中，每条指令的结果都可以反馈给下一条指令。将该系统转化为3阶段流水线系统时
(每条指令的结果只能反馈给其后的第3条指令)，程序的行为将发生改变，所以必须以某种方式处理指令之间的数据和控制依赖来保证得到的行为符合ISA定义的模型。</p>
<h3 id="y86-64的流水线实现">4.5 Y86-64的流水线实现</h3>
<p>　　为了实现流水线化的Y86-64，首先，需要调整顺序SEQ中阶段的顺序，使得更新PC阶段在周期的开始执行，得到<span
style="background-color: yellow">SEQ+</span>。然后，在各个阶段之间加上流水线寄存器，得到<span
style="background-color: yellow">PIPE-</span>
(-表示性能比SEQ+更差)。最后，还需要一些修改来保证正确地处理各种数据和控制依赖。</p>
<h4 id="seq-1">4.5.1 SEQ+</h4>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/seq+_hardware_structure.svg" class="" title="seq+_hardware_structure">
<p>　　在SEQ+中，PC更新阶段会使用一组时钟寄存器来保存前一条指令执行过程中计算出来的信号，根据这些信号可以计算出PC值。这种模式是一个小小的例证——可以用不同于ISA隐含的概念模型的方式来实现CPU，只要CPU能正确执行机器语言程序。这种模式中无需将状态编码为程序员可见的状态指示形式，只要CPU能够为程序员可见状态生成正确的值。</p>
<p>　　SEQ到SEQ+中对状态单元的改变是一种很通用的改进方法的示例，这种改进称为<strong>电路重定时</strong>，重定时会改变系统的状态表示，但并不改变其逻辑行为，通常用于平衡流水线系统里各个阶段之间的延迟。</p>
<h4 id="pipe-">4.5.2 PIPE-</h4>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/pipe-_hardware_structure.svg" class="" title="pipe-_hardware_structure">
<p>　　在PIPE-中，<span
style="background-color: yellow">蓝色方框表示流水线寄存器</span>，每个寄存器包括不同的字段，用白色方框表示。同顺序处理CPU的硬件结构图不同，这些<span
style="background-color: yellow">白色方框表示实际的硬件组成</span>。大写的前缀表示流水线寄存器，所以<code>M_stat</code>表示流水线寄存器<code>M</code>的状态码字段。小写的前缀表示流水线的阶段，所以<code>m_stat</code>表示访存阶段中控制逻辑块生成的状态信号。</p>
<p>　　流水线寄存器<code>F</code>用于保存PC的预测值。流水线寄存器<code>D</code>用于保存最近取出的指令的信息。流水线寄存器<code>E</code>用于保存最近译码的指令和从寄存器文件中读出的值的信息。流水线寄存器<code>M</code>用于保存最近执行的指令的结果和处理条件判断和分支目标的信息。流水线寄存器<code>W</code>用于将反馈路径计算出来的值提供给寄存器文件和指令<code>ret</code>完成后向PC提供返回地址。</p>
<p>　　PIPE-取指阶段负责预测PC的下一个值和取指阶段实际的PC值。标签为Predict
PC的块会在PC增加后的值<code>valP</code>和根据取出的指令得到的值<code>valC</code>中进行选择，选择的值会作为PC的预测值并存储到流水线寄存器<code>F</code>中。标签为Select
PC的块类似于SEQ+中PC更新阶段中标签为PC的块，它会从预测的PC值、存储在流水线寄存器<code>M_valA</code>中的<code>valP</code>
(对于达到流水线寄存器<code>M</code>的不选择分支的指令)
和存储在流水线寄存器<code>W_valM</code>中的返回地址的值
(对于达到流水线寄存器<code>W</code>的指令<code>ret</code>)
中进行选择，得到PC值。</p>
<p>　　标签为Select
A的块会从流水线寄存器<code>D</code>中的<code>valP</code>和寄存器文件A端口中读出的值来中选择，得到值<code>valA</code>。这个块是为了减少要携带给寄存器<code>E</code>和<code>M</code>的状态数量。在所有指令中，只有<code>call</code>的访存阶段和跳转指令的执行阶段
(不需要执行跳转)
会需要值<code>valP</code>，而这2个指令都不从寄存器文件中读取值，所以将它们合并为值<code>valA</code>，这样就不需要标签为Data的块
(功能类似)。</p>
<p>　　SEQ+和PIPE-在译码阶段都生成了值<code>dstE</code>和<code>dstM</code>。SEQ+可以将这些值直接连接到寄存器文件写端口的地址输入。PIPE-会一直携带这些值，直到写回阶段才将其传递给寄存器文件，这样做是为了保证写端口的地址和数据输入来自同一条指令。</p>
<p>　　在SEQ和SEQ+中，同一时刻只能处理1条指令，所以<code>valC</code>、<code>srcA</code>和<code>valE</code>等值有唯一值。在PIPE-中，与各个指令相关联的这些值有多个版本，会随着指令一起流过系统，需要确保使用的是正确的值。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/simple_example_of_instruction_flow_through_pipeline.svg" class="" title="simple_example_of_instruction_flow_through_pipeline">
<p>　　这个示例描述了每条指令通过流水线各个阶段的行进过程，时间从左到右递增。周期1取出指令I1，然后该指令开始通过流水线各个阶段，到周期5结束后，其结果写入到寄存器文件，依此类推。下方是周期5的流水线的扩展，取指阶段在底部，写回阶段在顶部，同PIPE-一样，因为正常的程序是从上到下执行。</p>
<h4 id="流水线隐患">4.5.3 流水线隐患</h4>
<p>　　数据和控制依赖可能会导致流水线生成错误的计算，称为<strong>隐患</strong>。与依赖类似，隐患可以分为<strong>数据隐患</strong>和<strong>控制隐患</strong>。</p>
<p>　　●
程序寄存器出现数据隐患是因为寄存器文件的读写是在不同阶段进行的，导致不同指令之间可能出现意料之外的相互作用。</p>
<p>　　●
更新和读取PC之间的冲突会导致控制隐患。当取指阶段的逻辑在取下一条指令前正确地预测PC的新值，就不会导致控制隐患。</p>
<p>　　●
数据存储器的读写发生在访存阶段，在读存储器的指令到达这个阶段前，前面所有写存储器的指令都已完成该阶段。在访存阶段中的写数据的指令和在取指阶段中的读数据的指令之间会发生冲突，因为指令和数据存储器引用的是同一地址空间，只有包含自我修改代码的程序才会出现这种情况，在这样的程序中，指令写存储器的某部分，然后再从同一存储器中取出指令。有些系统有复杂的机制来检验和避免此类隐患，而有些系统只能简单强制要求程序不能使用自我修改代码。为了简便，这里<span
style="background-color: yellow">假设程序不能自我修改</span>。</p>
<p>　　●
整数操作指令会在执行阶段写CC寄存器。条件移动指令会在执行阶段读CC寄存器。条件跳转指令会在访存阶段读CC寄存器。在条件移动指令和条件跳转指令到达执行阶段前，前面所有的整数操作指令都已完成该阶段，所以CC寄存器不会有隐患。</p>
<p>　　●
指令通过流水线时，会影响程序状态。这里采用流水线中每条指令都与状态码相关联的机制，使得异常发生时，CPU能够有条理地停止。</p>
<h5 id="避免数据隐患">4.5.3.1 避免数据隐患</h5>
<p>　　<strong>暂停</strong>是避免隐患的常用技术之一，CPU会让部分指令暂停在它们所处的阶段，而允许其他指令继续通过流水线，直到构成的隐患条件不再满足。让指令暂停在译码阶段，直到生成其操作数的指令通过写回阶段，这样就能避免数据隐患。实现暂停的方式就是在执行阶段插入1个<strong>气泡</strong>，气泡就像自动生成的<code>nop</code>指令，代价是性能损失。</p>
<p>　　另一种避免数据隐患的技术是<strong>数据转发</strong>，也称为<strong>转发</strong>或<strong>旁路</strong>，即将值直接从当前阶段转发到更早阶段。数据转发需要在基本的硬件结构中增加一些额外的数据连接和控制逻辑。在PIPE-中加入数据转发会得到<span
style="background-color: yellow">PIPE</span>。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/pipe_hardware_structure.svg" class="" title="pipe_hardware_structure">
<p>　　相比PIPE-，PIPE在译码阶段中加入了标签为Sel+Fwd A和Fwd
B的2个块，标签为Sel+Fwd A的块是PIPE-中标签为Select
A的块和转发逻辑的结合，它会在PC增加后的值<code>valP</code>、寄存器文件A端口读出的值和某个转发过来的值中进行选择，得到流水线寄存器<code>E</code>中的<code>valA</code>。标签为Fwd
B的块是源操作数<code>valB</code>的转发逻辑。PIPE中有5个转发源
(<code>e_valE</code>、<code>M_valE</code>、<code>m_valE</code>、<code>W_valM</code>和<code>W_valE</code>)
和2个转发目的地 (<code>valA</code>和<code>valB</code>)。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/simple_example_of_load_or_use_hazard.svg" class="" title="simple_example_of_load_or_use_hazard">
<p>　　有1类数据隐患不能简单地用转发来避免，即<strong>加载/使用隐患</strong>，因为访存阶段是流水线中较晚的阶段。例如，这个示例中第5行的指令<code>irmovq</code>需要在周期8才能将值加载到寄存器<code>%rax</code>，而第6行的指令<code>addq</code>在周期7就需要使用寄存器<code>%rax</code>。用暂停来避免加载/使用隐患的方法称为<strong>加载互锁</strong>，加载互锁与转发结合起来可以避免所有的数据隐患，这个示例可以在第6行插入气泡来避免隐患。</p>
<h5 id="避免控制隐患">4.5.3.2 避免控制隐患</h5>
<p>　　控制隐患只会出现在指令<code>ret</code>和跳转指令，后者只有在条件跳转分支预测错误时才会导致问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000:      irmovq  stack, %rsp</span><br><span class="line">0x00a:      call    proc</span><br><span class="line">0x013:      irmovq  $10, %rdx</span><br><span class="line">0x01d:      halt</span><br><span class="line">0x020:  .pos 0x20</span><br><span class="line">0x020:  proc:</span><br><span class="line">0x020:      ret</span><br><span class="line">0x021:      rrmovq  %rdx, %rbx</span><br><span class="line">0x030:  .pos 0x30</span><br><span class="line">0x030:  stack:</span><br></pre></td></tr></table></figure>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/processing_instruction_ret.svg" class="" title="processing_instruction_ret">
<p>　　在这个示例中，周期3取出指令<code>ret</code>并沿着流水线继续执行，在周期7进入写回阶段。在其进行译码、执行和访存阶段时，流水线不能执行任何有用的活动，即在这3个周期插入气泡。由于<span
style="background-color: yellow">无法在取指阶段插入气泡</span>，只能在译码阶段插入气泡，PC的新值会预测为<code>0x021</code>
(第8行)，这个地址是错误的。一旦指令<code>ret</code>到达写回阶段，PC选择逻辑会将PC值设为返回地址，然后取指阶段就会取出位于返回点处
(地址<code>0x013</code>) 的指令<code>irmovq</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000:      xorq    %rax, %rax</span><br><span class="line">0x002:      jne     target </span><br><span class="line">0x00b:      irmovq  $1, %rax</span><br><span class="line">0x015:      halt</span><br><span class="line">0x016:  target:</span><br><span class="line">0x016:      irmovq  $2, %rdx</span><br><span class="line">0x020:      irmovq  $3, %rbx</span><br><span class="line">0x02a:      halt</span><br></pre></td></tr></table></figure>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/processing_mispredicted_branch_instruction.svg" class="" title="processing_mispredicted_branch_instruction">
<p>　　在这个示例中，指令<code>jne</code> (第2行)
并不会执行跳转，但由于预测跳转指令会跳转，所以周期3会取出位于跳转目标处的指令
(第6行)，周期4会取出跳转目标处指令的下一条指令
(第7行)。指令只有到了执行阶段才能改变程序员可见状态，所以通过在下一周期的译码阶段和执行阶段插入气泡并取出指令<code>jne</code>的下一条指令
(第3行) 来<strong>取消</strong> (也称为<strong>指令排除</strong>)
这2条预测错误的指令。</p>
<h4 id="pipe各阶段的实现">4.5.4 PIPE各阶段的实现</h4>
<p>　　PIPE的HCL代码类似于SEQ，不同的是给信号加上了类似PIPE中的前缀。例如，<code>D_</code>表示该信号来自流水线寄存器<code>D</code>，<code>d_</code>表示该信号在译码阶段生成。</p>
<h5 id="取指阶段-1">4.5.4.1 取指阶段</h5>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/pipe_fetch_stage.svg" class="" title="pipe_fetch_stage">
<p>　　PIPE取指阶段会选择PC的当前值并预测下一个PC值。从存储器中读指令和提取不同指令字段的硬件单元与SEQ的相同。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word f_pc =</span><br><span class="line">[</span><br><span class="line">    # 预测错误的分支</span><br><span class="line">    M_icode == IJXX &amp;&amp; !M_Cnd : M_valA;</span><br><span class="line">    # 完成ret指令</span><br><span class="line">    W_icode == IRET : W_valM;</span><br><span class="line">    # 默认使用PC预测值</span><br><span class="line">    <span class="number">1</span> : F_predPC;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　PC选择逻辑会从3个PC源中进行选择。当预测错误的分支进入访存阶段时，会从在流水线寄存器<code>M</code>中读取该指令的<code>valP</code>
(存储在<code>M_valA</code>，表示下一条指令的地址)。当指令<code>ret</code>进入写回阶段时，会从流水线寄存器<code>W</code>中读取返回地址
(存储在<code>W_valM</code>)。其他情况使用存储在寄存器<code>F</code>中的PC预测值
(存储在<code>F_predPC</code>)。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word f_predPC =</span><br><span class="line">[</span><br><span class="line">    f_icode <span class="keyword">in</span> &#123; IJXX, ICALL &#125; : f_valC;</span><br><span class="line">    <span class="number">1</span> : f_valP;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　当取出的指令为跳转指令或指令<code>call</code>时，PC预测逻辑会选择<code>valC</code>；否则，选择<code>valP</code>。</p>
<p>　　标签为Instr valid、Need regids和Need valC的块与SEQ中的相同。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word f_stat =</span><br><span class="line">[</span><br><span class="line">    imeme_error : SADR;</span><br><span class="line">    !instr_valid : SINS;</span><br><span class="line">    f_icode == IHALT : SHLT;</span><br><span class="line">    <span class="number">1</span> : SAOK;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　同SEQ不同，PIPE将指令状态的计算分为2部分。在取指阶段，可以检测非法指令、指令<code>halt</code>和指令地址越界导致的内存异常，但非法数据地址的检测必须推迟到访存阶段。</p>
<h5 id="译码和写回阶段-1">4.5.4.2 译码和写回阶段</h5>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/pipe_decode_and_write-back_stage.svg" class="" title="pipe_decode_and_write-back_stage">
<p>　　标签为dstE、dstM、srcA和srcB的块与SEQ中的相似。此外，提供给寄存器文件写端口的寄存器ID
(信号<code>W_dstE</code>和<code>W_dstM</code>)
来自写回阶段而非译码阶段，因为对目的寄存器的写操作由写回阶段中的指令指定。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word d_valA =</span><br><span class="line">[</span><br><span class="line">    D_icode <span class="keyword">in</span> &#123; ICALL, IJXX &#125; : D_valP;    # 选择增加后的PC</span><br><span class="line">    d_srcA == e_dstE : e_valE;              # 选择执行阶段的valE</span><br><span class="line">    d_srcA == M_dstM : m_valM;              # 选择访存阶段的valM</span><br><span class="line">    d_srcA == M_dstE : M_valE;              # 选择访存阶段的valE</span><br><span class="line">    d_srcA == W_dstM : W_valM;              # 选择写回阶段的valM</span><br><span class="line">    d_srcA == W_dstE : W_valE;              # 选择写回阶段的valE</span><br><span class="line">    <span class="number">1</span> : d_rvalA;                            # 选择寄存器文件A端口的值</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word d_valB =</span><br><span class="line">[</span><br><span class="line">    d_srcB == e_dstE : e_valE;              # 选择执行阶段的valE</span><br><span class="line">    d_srcB == M_dstM : m_valM;              # 选择访存阶段的valM</span><br><span class="line">    d_srcB == M_dstE : M_valE;              # 选择访存阶段的valE</span><br><span class="line">    d_srcB == W_dstM : W_valM;              # 选择写回阶段的valM</span><br><span class="line">    d_srcB == W_dstE : W_valE;              # 选择写回阶段的valE</span><br><span class="line">    <span class="number">1</span> : d_rvalB;                            # 选择寄存器文件B端口的值</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　PIPE译码阶段的复杂之处在于转发逻辑，之前提到过有5个不同的转发源，每个转发源都有1个数据字和1个目的寄存器ID。标签为Sel+Fwd
A的块除了负责源操作数<code>valA</code>的转发，还会将<code>valP</code>合并到<code>valA</code>。合并<code>valA</code>和<code>valP</code>的依据是只有指令<code>call</code>和跳转指令在后面的阶段需要<code>valP</code>，而且这两者都不需要从寄存器文件A端口读取值。</p>
<table>
<thead>
<tr>
<th>数据字</th>
<th>寄存器ID</th>
<th>源描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>e_valE</code></td>
<td><code>e_dstE</code></td>
<td>ALU输出</td>
</tr>
<tr>
<td><code>m_valN</code></td>
<td><code>M_dstM</code></td>
<td>数据存储器输出</td>
</tr>
<tr>
<td><code>M_valE</code></td>
<td><code>M_dstE</code></td>
<td>访存阶段中对端口E即将进行的写</td>
</tr>
<tr>
<td><code>W_valM</code></td>
<td><code>W_dstM</code></td>
<td>写回阶段中对端口M即将进行的写</td>
</tr>
<tr>
<td><code>W_valE</code></td>
<td><code>W_dstE</code></td>
<td>写回阶段中对端口E即将进行的写</td>
</tr>
</tbody>
</table>
<p>　　源操作数<code>valA</code>的转发逻辑中的<span
style="background-color: yellow">5个转发源的优先级很重要</span>，该优先级由HCL代码中检测5个目的寄存器ID的顺序来决定。若选择了其他顺序，则可能会导致某些程序的流水线出错。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/simple_example_of_forwarding_priority.svg" class="" title="simple_example_of_forwarding_priority">
<p>　　在这个示例中，前2条指令会写寄存器<code>%rdx</code>，第3条指令会将寄存器<code>%rdx</code>作为源操作数。当第3条指令到达译码阶段
(周期4)
时，转发逻辑必须在2个都以寄存器<code>%rdx</code>为目的地的值中选择一个。按照机器语言程序的行为，第3条指令应该从寄存器<code>%rdx</code>中读出3，所以流水线化的实现应该<span
style="background-color: yellow">保证流水线阶段最早的转发源有最高的优先级</span>。按照这一点，转发逻辑会先在执行阶段检测转发源，然后在访存阶段检测转发源，最后在写回阶段检测转发源。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word Stat =</span><br><span class="line">[</span><br><span class="line">    W_stat == SBUB : SAOK;</span><br><span class="line">    <span class="number">1</span> : W_stat;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　PIPE写回阶段正如图中所示，整个流水线的状态<code>Stat</code>根据流水线寄存器<code>W</code>中的状态值计算而来。之前提到过，状态码应该指明是正常操作或3种异常之一。流水线寄存器<code>W</code>保存着最近完成指令的状态，所以该值很适合用于表示整个流水线的状态。唯一要考虑的特殊情况是写回阶段出现气泡，但这也属于正常操作。</p>
<h5 id="执行阶段-1">4.5.4.3 执行阶段</h5>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/pipe_execute_stage.svg" class="" title="pipe_execute_stage">
<p>　　PIPE执行阶段中的块同SEQ中的相似，使用的信号也进行了适当的重命名。<code>e_valE</code>和<code>e_dstE</code>作为转发源，转发到译码阶段。与SEQ执行阶段不同的是标签为Set
CC的块以<code>W_stat</code>和<code>m_stat</code>作为输入，决定是否要更新CC，用于检测异常指令正在通过后续流水线阶段的情况。</p>
<h5 id="访存阶段-1">4.5.4.4 访存阶段</h5>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/pipe_memory_stage.svg" class="" title="pipe_memory_stage">
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word m_stat =</span><br><span class="line">[</span><br><span class="line">    dmem_error : SADR;</span><br><span class="line">    <span class="number">1</span> : M_stat;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　PIPE访存阶段与SEQ访存阶段相似，但没有标签为Data的块
(用于数据源<code>valP</code>和<code>valA</code>中进行选择)，因为其功能由译码阶段中标签为Sel+Fwd
A的块负责。该阶段中的其他块同SEQ中的相似，使用的信号进行了适当的重命名。之前提到过，访存阶段仅能检测非法数据地址。</p>
<h4 id="异常处理">4.5.5 异常处理</h4>
<p>　　在流水线系统中，异常处理包括一些细节问题。</p>
<p>　　1) 有时可能同时有多个异常指令，例如，<span
style="background-color: yellow">同一流水线周期</span>中取指阶段有<code>halt</code>指令和访存阶段出现指令数据地址越界。在这种情况下，基本原则是<span
style="background-color: yellow">异常指令所处流水线阶段越靠后，优先级越高</span>，所以应该反馈地址越界。</p>
<p>　　2)
当指令被取出并开始执行时导致了异常，但后来由于分支预测错误，取消了该指令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000:  6300                    |       xorq    %rax,%rax</span><br><span class="line">0x002:  741600000000000000      |       jne     target</span><br><span class="line">0x00b:  30f00100000000000000    |       irmovq  $1, %rax</span><br><span class="line">0x015:  00                      |       halt</span><br><span class="line">0x016:                          |   target:</span><br><span class="line">0x016:  ff                      |       .byte 0xFF</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，分支预测会取出第6行代码，所以译码阶段会出现非法指令异常。之后，流水线发现不应该选择分支，就会取消该指令。</p>
<p>　　3)
某条指令导致了异常，它后面的指令在异常指令完成前改变了部分状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">irmovq  $1, %rax</span><br><span class="line">xorq    %rsp, %rsp</span><br><span class="line">pushq   %rax</span><br><span class="line">addq    %rax, %rax</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，指令<code>xorq</code>会将栈指针和CC分别设置为<code>0x00</code>和100，指令<code>pushq</code>会减少栈指针进而导致地址异常，访存阶段会发现这个异常。在同一周期内，指令<code>addq</code>处于执行阶段，而它会将CC设置成新值。</p>
<p>　　处理异常的简单而可靠的机制是<span
style="background-color: yellow">携带指令的异常状态和其他信息一起通过流水线</span>。每个流水线寄存器中都有状态码<code>stat</code>，其功能是处理异常。若出现了异常，则<code>stat</code>会设置为表示异常的值并继续执行取指、译码和执行。当异常指令达到访存或写回阶段时，会采取措施禁止修改程序员可见状态，包括<span
style="background-color: yellow">禁止执行阶段中的指令设置CC</span>、<span
style="background-color: yellow">在访存阶段插入气泡以禁止写数据存储器</span>和<span
style="background-color: yellow">在写回阶段有异常指令时暂停写回阶段</span>。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/processing_invalid_memory_reference_exception.svg" class="" title="processing_invalid_memory_reference_exception">
<p>　　在这个示例的周期6中，指令<code>pushq</code>到达访存阶段并引起了内存异常，指令<code>addq</code>到达执行阶段并生成了新的CC。当访存或写回阶段中有异常指令时
(检测信号<code>m_stat</code>和<code>W_stat</code>)，会禁止设置CC
(将信号<code>set_cc</code>置0)。从整体角度，处理过程还包括在访存阶段插入气泡和暂停写回阶段。</p>
<h4 id="流水线控制逻辑">4.5.6 流水线控制逻辑</h4>
<p>　　流水线控制逻辑必须处理加载/使用隐患、指令<code>ret</code>、预测错误的分支和异常。</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr>
<th>特殊情况</th>
<th>触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>处理指令<code>ret</code></td>
<td><code>IRET in &#123; D_icode, E_icode, M_icode &#125;</code></td>
</tr>
<tr>
<td>加载/使用隐患</td>
<td><code>E_icode in &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp; E_dstM in &#123; d_srcA, d_srcB &#125;</code></td>
</tr>
<tr>
<td>预测错误分支</td>
<td><code>E_icode = IJXX &amp;&amp; !e_Cnd</code></td>
</tr>
<tr>
<td>异常</td>
<td><code>m_stat in &#123; SADR, SINS, SHLT &#125; || W_stat in &#123; SADR, SINS, SHLT &#125;</code></td>
</tr>
</tbody>
</table>
<h5 id="流水线控制机制">4.5.6.1 流水线控制机制</h5>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/additional_pipeline_register_operations.svg" class="" title="additional_pipeline_register_operations">
<p>　　相比非流水线寄存器，流水线寄存器加入了<span
style="background-color: yellow">暂停</span>和<span
style="background-color: yellow">气泡</span>这2个控制信号。在正常情况下，这2个控制信号都为0，寄存器会加载输入作为状态。当暂停为1时，寄存器不会更新状态。当气泡为1时，寄存器状态会设置为某个固定的<strong>复位配置</strong>
(等效于<code>nop</code>指令的状态)，复位配置的0/1模式由流水线寄存器中的字段的集合决定。若需要在流水线寄存器<code>D</code>中插入气泡，只需将<code>icode</code>设置为<code>INOP</code>。若需要在流水线寄存器<code>E</code>中插入气泡，需要将<code>icode</code>设置为<code>INOP</code>并将<code>dstE</code>、<code>dstM</code>、<code>srcA</code>和<code>srcB</code>设置为<code>RNONE</code>。此外，这里<span
style="background-color: yellow">将气泡和暂停都置为1视为出错</span>。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 15%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr>
<th>特殊情况</th>
<th>流水线寄存器<code>F</code></th>
<th>流水线寄存器<code>D</code></th>
<th>流水线寄存器<code>E</code></th>
<th>流水线寄存器<code>M</code></th>
<th>流水线寄存器<code>W</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>处理指令<code>ret</code></td>
<td>暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>加载/使用隐患</td>
<td>暂停</td>
<td>暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>预测错误的分支</td>
<td>正常</td>
<td>气泡</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
</tbody>
</table>
<p>　　这是在3种特殊情况下各个流水线寄存器应采取的行动。在时序方面，流水线寄存器的暂停和气泡控制输入都是由组合逻辑块生成，所以这些值必须是合法的，保证下个时钟周期开始时，每个流水线寄存器要么加载，要么暂停，要么气泡。</p>
<h5 id="控制条件的组合">4.5.6.2 控制条件的组合</h5>
<p>　　在之前的设计中都是假设单个时钟周期内最多只会出现1种特殊情况，这是常见的缺陷之一。</p>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/pipeline_states_for_special_control_conditions.svg" class="" title="pipeline_states_for_special_control_conditions">
<p>　　单个时钟周期可能出现2种特殊情况，因为大多数控制条件都是<span
style="background-color: yellow">互斥</span>的。例如，加载/使用隐患不能和预测错误的分支同时出现，因为加载/使用隐患要求执行阶段是加载指令
(<code>mrmovq</code>和<code>popq</code>)，而预测错误的分支要求执行阶段是跳转指令。同样，处于执行或访存阶段的指令<code>ret</code>也不能与加载/使用隐患或预测错误的分支同时出现。只有箭头标明的2种组合可能同时出现。</p>
<p>　　组合A中执行阶段是预测错误的跳转指令，而译码阶段是指令<code>ret</code>，流水线控制逻辑会发现分支预测错误，所以取消指令<code>ret</code>。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 15%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr>
<th>特殊情况</th>
<th>流水线寄存器<code>F</code></th>
<th>流水线寄存器<code>D</code></th>
<th>流水线寄存器<code>E</code></th>
<th>流水线寄存器<code>M</code></th>
<th>流水线寄存器<code>W</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>处理指令<code>ret</code></td>
<td>暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>预测错误的分支</td>
<td>正常</td>
<td>气泡</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>组合A</td>
<td>暂停</td>
<td>气泡</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
</tbody>
</table>
<p>　　这是出现组合A时的流水线应采取的行动
(假设气泡或暂停会覆盖正常)。组合A的处理与预测错误的分支处理相似，区别是取指阶段是暂停。同样，在下一周期，PC选择逻辑会选择正确的地址而非预测值，所以流水线寄存器F的行动不重要。</p>
<p>　　组合B包括加载/使用隐患，其中加载指令设置栈指针，然后指令<code>ret</code>将栈指针作为源操作数，因为它必须从栈中弹出返回地址。流水线控制逻辑应将指令<code>ret</code>暂停在译码阶段。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 14%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr>
<th>特殊情况</th>
<th>流水线寄存器<code>F</code></th>
<th>流水线寄存器<code>D</code></th>
<th>流水线寄存器<code>E</code></th>
<th>流水线寄存器<code>M</code></th>
<th>流水线寄存器<code>W</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>处理指令<code>ret</code></td>
<td>暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>加载/使用隐患</td>
<td>暂停</td>
<td>暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>组合B</td>
<td>暂停</td>
<td>气泡+暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>实际情况</td>
<td>暂停</td>
<td>暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
</tbody>
</table>
<p>　　这是出现组合B时的流水线应采取的行动，流水线控制逻辑会暂停指令<code>ret</code>来避免加载/使用隐患，同时又因为指令<code>ret</code>而在译码阶段插入气泡。PIPE控制逻辑原本的实现并不能正确处理组合B，因为流水线控制逻辑会将流水线寄存器<code>D</code>的气泡和暂停信号都置1。之前提到过，气泡和暂停信号不能都为1，所以译码阶段只采取针对加载/使用隐患的行动并将处理指令<code>ret</code>的行动推迟1个周期。</p>
<h5 id="控制逻辑实现">4.5.6.3 控制逻辑实现</h5>
<img src="/2023/03/06/computer-systems-a-programmer's-perspective-3e-chpt-4/pipe_pipeline_control_logic.svg" class="" title="pipe_pipeline_control_logic">
<p>　　根据来自流水线寄存器和流水线阶段的信号，控制逻辑生成流水线寄存器的暂停和气泡信号，同时也决定是否要更新CC寄存器。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool F_stall = </span><br><span class="line">    # 加载/使用隐患</span><br><span class="line">    E_icode <span class="keyword">in</span> &#123; IMRMOVQ, IPOPQ&#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123; d_srcA, d_srcB &#125; ||</span><br><span class="line">    # ret指令通过流水线</span><br><span class="line">    IRET <span class="keyword">in</span> &#123; D_icode, E_icode, M_icode &#125;;</span><br></pre></td></tr></table></figure>
<p>　　遇到加载/使用隐患或指令<code>ret</code>时，流水线寄存器<code>F</code>会暂停。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool D_stall = </span><br><span class="line">    # 加载/使用隐患</span><br><span class="line">    E_icode <span class="keyword">in</span> &#123; IMRMOVQ, IPOPQ&#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123; d_srcA, d_srcB &#125;;</span><br></pre></td></tr></table></figure>
<p>　　遇到加载/使用隐患时，流水线寄存器<code>D</code>会暂停。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool D_bubble = </span><br><span class="line">    # 预测错误的分支</span><br><span class="line">    (E_icode == IJXX &amp;&amp; !e_Cnd) ||</span><br><span class="line">    # 不能出现加载/使用隐患和ret指令组合</span><br><span class="line">    !(E_icode <span class="keyword">in</span> &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123; d_srcA, d_srcB &#125;) &amp;&amp; IRET <span class="keyword">in</span> &#123; D_icode, E_icode, M_icode &#125;;</span><br></pre></td></tr></table></figure>
<p>　　遇到预测错误的分支时，流水线寄存器<code>D</code>会插入气泡。不过，遇到加载/使用隐患和指令<code>ret</code>组合时，不会插入气泡。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool E_bubble = </span><br><span class="line">    # 预测错误的分支</span><br><span class="line">    (E_icode == IJXX &amp;&amp; !e_Cnd) ||</span><br><span class="line">    # 加载/使用隐患</span><br><span class="line">    E_icode <span class="keyword">in</span> &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123; d_srcA, d_srcB &#125;;</span><br></pre></td></tr></table></figure>
<p>　　遇到加载/使用隐患或预测错误的分支时，流水线寄存器<code>E</code>会插入气泡。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool set_cc = </span><br><span class="line">    E_icode == IOPQ &amp;&amp;</span><br><span class="line">    # 正常操作</span><br><span class="line">    !m_stat <span class="keyword">in</span> &#123; SADR, SINS, SHLT &#125; &amp;&amp; !W_stat <span class="keyword">in</span> &#123; SADR, SINS, SHLT &#125;;</span><br></pre></td></tr></table></figure>
<p>　　只有整数操作指令正常执行时才设置CC。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool M_bubble = </span><br><span class="line">    # 异常指令</span><br><span class="line">    m_stat <span class="keyword">in</span> &#123; SADR, SINS, SHLT &#125; || W_stat <span class="keyword">in</span> &#123; SADR, SINS, SHLT &#125;;</span><br></pre></td></tr></table></figure>
<p>　　遇到异常指令时，流水线寄存器<code>M</code>会插入气泡。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool W_stall = W_stat <span class="keyword">in</span> &#123; SADR, SINS, SHLT &#125;;</span><br></pre></td></tr></table></figure>
<p>　　遇到异常指令时，流水线寄存器<code>W</code>会暂停。若某个指令在访存阶段暂停过，则该指令不会达到写回阶段。</p>
<h5 id="测试和验证">4.5.6.4 测试和验证</h5>
<p>　　简单地模拟设计和运行一些典型的程序并不足以用于测试系统。相反，全面的测试需要一些方法来系统地生成很多测试，这些测试将尽可能多地使用不同指令和指令组合。在设计Y86-64时，还设计了很多测试脚本，每个脚本都会生成很多不同的测试，运行CPU模拟并比较得到的寄存器/存储器值和YIS指令集模拟器生成的值。</p>
<p>　　●
<strong>optest</strong>：运行49个不同的Y86-64指令的测试，包括不同的源和目的寄存器。</p>
<p>　　●
<strong>jtest</strong>：运行64个不同的跳转指令和指令<code>call</code>的测试，包括不同的分支组合。</p>
<p>　　●
<strong>cmtest</strong>：运行28个不同的条件移动指令的测试，包括不同的控制组合。</p>
<p>　　●
<strong>htest</strong>：运行600个不同的数据隐患可能性的测试，包括不同的源和目的指令的组合，在这些指令之间有不同的数量的<code>nop</code>指令。</p>
<p>　　● <strong>ctest</strong>：测试22个不同的控制组合。</p>
<p>　　●
<strong>etest</strong>：测试12种不同的异常指令和跟在其后可能改变程序员可见状态的指令组合。</p>
<p>　　即使设计通过了大量的测试，也不能保证它能正确运行所有程序。即使只考虑由较短的代码组成的测试，待测试的可能的程序的数量也很庞大。不过，<strong>形式化验证</strong>能够保证有工具能够严格地考虑到系统所有可能的行为并确定是否有设计错误。例如，形式化验证Y86-64的早期版本之一，建立框架来比较PIPE和SEQ，该框架能够证明对于任意的Y86-64程序，两者对程序员可见状态的影响完全相同，该过程使用归纳法。进行这种分析要求用<strong>符号方法</strong>来推导硬件。在符号方法中，所有的程序值都是任意整数，ALU抽象为黑盒并根据其参数计算某个未指定的函数。形式化验证还处于发展的早期阶段，并不能完全验证。</p>
<h4 id="性能分析">4.5.7 性能分析</h4>
<p>　　所有需要流水线控制逻辑进行特殊处理的条件，都会导致流水线不能实现每个时钟周期发出1条新指令，这通过确定往流水线中插入气泡的频率来衡量，因为插入1个气泡会导致1个流水线周期不被使用。返回指令会生成3个气泡，加载/使用隐患会生成1个气泡，预测错误的分支会生成2个气泡。异常的定义表明其出现频率很低，所以可以忽略。可以通过计算流水线执行1条指令所需的平均时钟周期的估计值来量化这些处罚的性能影响，这种衡量方法称为<strong>每指令周期数</strong>。</p>
<p>　　假设在某个CPU上运行某个基准程序并观察执行阶段的运行。每个周期中，执行阶段要么处理1条指令并继续剩下的阶段直到完成；要么处理3种特殊情况之一并插入气泡。若这个阶段一共处理了<span
class="math inline">\(C_i\)</span>条指令和<span
class="math inline">\(C_b\)</span>个气泡，则CPU共需要大约<span
class="math inline">\(C_i+C_b\)</span>个时钟周期来执行<span
class="math inline">\(C_i\)</span>条指令
(忽略了启动指令通过流水线的周期)。 <span class="math display">\[
CPI=\frac{C_i+C_b}{C_i}=1.0+\frac{C_b}{C_i}
\]</span> 　　CPI等于1.0加处罚项<span
class="math inline">\(\frac{C_b}{C_i}\)</span>，这个项表示执行1条指令需要插入的气泡的平均值。
<span class="math display">\[
CPI=1.0+lp+mp+rp
\]</span> 　　处罚项<span
class="math inline">\(\frac{C_b}{C_i}\)</span>可以分为3部分，<span
style="background-color: yellow">加载处罚<span
class="math inline">\(lp\)</span></span>表示由于加载/使用隐患造成暂停而插入的气泡的平均值，<span
style="background-color: yellow">预测错误的分支处罚<span
class="math inline">\(mp\)</span></span>表示由于预测错误的分支造成取消指令而插入的气泡的平均值，<span
style="background-color: yellow">返回处罚<span
class="math inline">\(rp\)</span></span>表示由于指令<code>ret</code>造成暂停而插入的气泡的平均值。</p>
<table>
<thead>
<tr>
<th></th>
<th>处罚</th>
<th>指令出现机率</th>
<th>造成特殊情况的机率</th>
<th>气泡数</th>
<th>乘积</th>
</tr>
</thead>
<tbody>
<tr>
<td>加载指令</td>
<td><span class="math inline">\(lp\)</span></td>
<td>0.25</td>
<td>0.20</td>
<td>1</td>
<td>0.05</td>
</tr>
<tr>
<td>跳转指令</td>
<td><span class="math inline">\(mp\)</span></td>
<td>0.20</td>
<td>0.40</td>
<td>2</td>
<td>0.16</td>
</tr>
<tr>
<td>指令<code>ret</code></td>
<td><span class="math inline">\(rp\)</span></td>
<td>0.02</td>
<td>1.00</td>
<td>3</td>
<td>0.06</td>
</tr>
<tr>
<td>总和</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0.27</td>
</tr>
</tbody>
</table>
<p>　　3种处罚的总和是0.27，得到CPI为1.27。若想要进一步降低CPI，则应该优化预测错误的分支。若使用成功率为65%的分支预测策略，则<span
class="math inline">\(mp=0.35\cdot0.20\cdot2=0.14\)</span>，这个提升并不大，但如果分支预测策略的成本不高，则这个提升还算值得。</p>
<h4 id="未完成的工作">4.5.8 未完成的工作</h4>
<p>　　PIPE还缺乏<span
style="background-color: yellow">多指令周期</span>和<span
style="background-color: yellow">存储系统接口</span>这些CPU设计中必须的关键特性。</p>
<p>　　Y86-64指令集的所有指令都包括一些整数加法等简单的操作。这些操作可以在执行阶段的单周期内处理完成。在一个更完整的指令集中，还将实现一些整数乘除和浮点运算等更复杂的指令。像PIPE这种性能中等的CPU中，这些操作的典型执行时间从浮点加法的3或4个周期到整数除法的64个周期。为了实现这些指令，还需要额外的硬件和协调这些指令的处理和流水线其他部分的机制。</p>
<p>　　实现多指令周期的方法之一是直接用整数和浮点运算单元扩展执行阶段逻辑的功能，但是这种方法需要指令在执行阶段停留多个周期，进而导致取指和译码阶段暂停，所以这种方法的性能并不好。</p>
<p>　　另一种实现多指令周期的方法是使用独立于主流水线的特殊硬件功能单元来处理较复杂的操作，这种方法的性能更好。通常，有1个功能单元来执行整数乘除，还有1个功能单元来执行浮点操作。当指令进入译码阶段时，可以将其发送给特殊单元。在特殊单元处理时，流水线会继续执行其他指令。通常，浮点单元本身也是流水线化的，所以多条指令可以在主流水线和各个单元中并发执行。不同单元的操作必须同步以避免出错，这可以通过暂停、气泡、转发和取消等机制来实现。</p>
<p>　　PIPE会假设取指单元和数据存储器都可以在单时钟周期内读写内存中的任意位置，并且忽略了自我修改代码可能造成的隐患。之前介绍过，CPU的存储系统由多个硬件存储器和管理内存的操作系统共同组成。存储系统被组织成层次结构，典型的CPU有2个L1缓存，分别用于读写指令和数据。另一种缓存是<strong>页表缓存</strong>，用于将虚拟地址快速转换为物理地址。将两者结合起来，在大多数情况下，可以在单周期内读指令并读写数据。</p>
<p>　　缓存总保存最常引用的存储器位置，但还是会出现<strong>未命中</strong>
(引用的位置不在缓存内)。在最好的情况下
(在更高级的缓存或内存中找到未命中的数据)，处理缓存未命中需要3~20个时钟周期。同时，流水线会将指令暂停在取指或访存阶段，直到缓存能够执行读写。</p>
<p>　　在部分情况下，被引用的存储器位置实际上是位于磁盘。此时，硬件会生成<strong>缺页</strong>异常信号。同其他异常一样，该异常会导致CPU调用操作系统的异常处理程序并发起1个磁盘到内存的移动操作。一旦完成，操作系统会返回到原来的程序并重新执行缺页的程序。因为磁盘存取需要数百万个周期，缺页中断处理程序执行所需的几百个时钟周期可以忽略不记。</p>
<p>　　在CPU角度，将暂停 (处理短时间的缓存未命中) 和异常
(处理长时间的缺页)
结合起来，能够解决访问存储器时由于存储器层次结构引起的所有不可预测性而导致的问题。</p>
<p>　　PIPE等5阶段流水线代表了20世纪80年代中期的CPU设计水平。伯克利的Patternson研究组开发的RISC
CPU原型是Sun Microsystem在1987年开发的第一个SPARC
CPU的基础。斯坦福的Hennessy研究组开发的CPU由MIPS Technologies
(Hennessy成立的公司)
在1986年商业化。这两者都使用的是5阶段流水线。i486也是5阶段流水线，只不过阶段之间的职责划分不太相同，它有2个译码阶段和1个合并的执行/访存阶段。这些流水线化设计的CPI也大于1.0。</p>
<p>　　较新的CPU支持<strong>超标量</strong>
(并行地取指、译码和执行多条指令)，可以实现小于1.0的CPI。当超标量CPU已经广泛使用时，性能测量标准变为了CPI的倒数——每周期执行指令数。最新的设计使用称为<strong>乱序</strong>的技术来并行地执行多条指令，顾名思义，执行的顺序可能完全不同于它们在程序中出现的顺序，但保留了顺序ISA模型的整体行为。在芯片上集成许多简单的CPU而非少量更复杂的CPU来提高整体计算能力的策略称为<strong>多核</strong>。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第8章 异常控制流</title>
    <url>/2023/06/17/computer-systems-a-programmer&#39;s-perspective-3e-chpt-8/</url>
    <content><![CDATA[<p>　　从CPU通电到断电，假设PC的值序列为<span
class="math inline">\(a_0,a_1,..,a_{n-1}\)</span>，其中<span
class="math inline">\(a_k\)</span>是对应的指令<span
class="math inline">\(I_k\)</span>的地址。那么，从<span
class="math inline">\(a_k\)</span>到<span
class="math inline">\(a_{k+1}\)</span>的过渡称为<strong>控制转移</strong>，这样的控制转移序列称为CPU的<strong>控制流</strong>。最简单的控制流就是平滑的序列，即<span
class="math inline">\(I_k\)</span>和<span
class="math inline">\(I_{k+1}\)</span>在内存中是相邻的。这种平滑流的突然变化通常由跳转、调用和返回等指令造成。</p>
<p>　　操作系统必须能够响应内部程序没有捕获的系统状态变化和不一定与程序执行相关的系统状态变化。例如，硬件定时器会定期产生信号，该事件必须得到处理。分组到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到收到数据已就绪的通知。当子进程终止时，其父进程必须收到通知。</p>
<p>　　现代系统通过让控制流发生突然变化来应对这些情况，这些突然变化称为<strong>异常控制流</strong>。ECF发生计算机系统的各个层级。例如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过切换上下文来在用户进程之间进行控制转移。在应用层，进程可以发送信号到其他进程，接收者会将控制突然转移到它的信号处理程序。单个程序可以通过回避通常的栈规则并执行到其他函数中任意位置的<strong>非本地</strong>跳转
(即违反常规的调用/返回栈规则的跳转) 来对响应错误。</p>
<p>　　<strong>异常</strong>是ECF的一种形式，由硬件和操作系统共同实现。</p>
<p>　　软件异常允许程序进行非本地跳转来响应。C++和Java等语言通过<code>try</code>、<code>catch</code>和<code>throw</code>语句来提供软件异常机制，C语言通过函数<code>setjmp()</code>和<code>longjmp()</code>来提供软件异常机制，前者的异常机制相对后者更结构化。<code>catch</code>语句可类比为函数<code>setjmp()</code>，<code>throw</code>语句可类比为函数<code>longjmp()</code>。</p>
<p>　　在CPU中，状态编码为不同的位和信号，状态变化称为<strong>事件</strong>。事件可能和当前执行的指令直接相关。</p>
<p>　　CPU通常通过控制寄存器的<strong>模式位</strong>来限制应用可执行的指令和可访问的地址空间范围。当设置了模式位后，进程就运行在<strong>内核模式</strong>
(也称为<strong>超级用户模式</strong>)，这样该进程可以访问指令集中的任何指令和系统中的任何内存位置。没有设置模式位时，进程运行在用户模式，该模式下不能执行<strong>特权指令</strong>，例如，停止CPU、改变模式位和发起I/O操作。此外，用户模式中的进程不能直接引用地址空间中内核区的代码和数据。</p>
<p>　　Linux提供了很多监控和控制进程的工具。</p>
<p>　　● STRACE：打印正在运行的程序 (及其子进程)
调用的每个系统调用的轨迹。</p>
<p>　　● PS：列出当前系统中的进程 (包括僵尸进程)。</p>
<p>　　● TOP：打印关于当前进程资源使用的信息。</p>
<p>　　● PMAP：显示进程的内存映射。</p>
<p>　　●
<code>proc/</code>：虚拟文件系统，以ASCII文本格式输出大量内核数据结构的信息，用户程序可以读取这些内容。</p>
<p>　　● <code>/sys</code>：Linux
2.6版本内核加入的文件系统，它能输出关于系统总线和设备的额外底层信息。</p>
<span id="more"></span>
<h3 id="异常">8.1 异常</h3>
<img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/anatomy_of_an_exception.svg" class="" title="anatomy_of_an_exception">
<p>　　当CPU检测到事件发生时，会通过称为<strong>异常表</strong>的跳转表来进行间接过程调用
(异常)，到专门设计来处理此类事件的称为<strong>异常处理程序</strong>的操作系统子程序。当异常处理程序完成处理后，根据引起异常的事件的类型，出现以下情况之一：</p>
<p>　　● 异常处理程序将控制权转移给<span
class="math inline">\(I_{curr}\)</span>，即异常发生时正在执行的指令。</p>
<p>　　● 异常处理程序将控制权转移给<span
class="math inline">\(I_{next}\)</span>，即异常发生时正在执行的指令的下一条指令。</p>
<p>　　● 异常处理程序中止被中断的程序。</p>
<h4 id="异常处理">8.1.1 异常处理</h4>
<p>　　系统中的每种异常都有唯一的非负整数<strong>异常号</strong>。部分异常号由CPU的设计者分配
(例如，除以0、缺页、内存访问越界、断点和算术运算溢出)，其他异常号由操作系统内核的设计者分配
(例如，系统调用和外部I/O设备的信号)。</p>
<p>　　当计算机启动或重启时，操作系统会分配和初始化异常表，使得条目<code>k</code>包含异常<code>k</code>对应的异常处理程序的地址。当CPU检测到事件并确定对应的异常号后，会触发异常，方法是通过异常表的条目来执行到对应异常处理程序的间接过程调用。</p>
<img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/generating_the_address_of_an_exception_handler.svg" class="" title="generating_the_address_of_an_exception_handler">
<p>　　对于异常表，索引就是异常号，其起始地址存放在<strong>异常表基址寄存器</strong>中。</p>
<p>　　一旦硬件触发了异常，剩下的工作都由异常处理程序在软件中完成。异常处理程序运行在<span
style="background-color: yellow">内核模式</span>下，所以它们对所有的系统资源都有完全的访问权限。异常处理程序完成处理后，通过特殊的中断返回指令，可选地返回到中断的程序，该指令将适当的状态弹回到CPU的控制和数据寄存器中。若异常中断的是用户程序，则将状态恢复到<span
style="background-color: yellow">用户模式</span>并将控制权转移给中断的程序。</p>
<h4 id="异常类别">8.1.2 异常类别</h4>
<p>　　异常按类型可以分为<span
style="background-color: yellow">中断</span>、<span
style="background-color: yellow">陷阱</span>、<span
style="background-color: yellow">故障</span>和<span
style="background-color: yellow">中止</span>，按同步和异步可以分为<span
style="background-color: yellow">同步异常</span> (陷阱、故障和中止)
和<span style="background-color: yellow">异步异常</span> (中断)。</p>
<table>
<thead>
<tr>
<th>异常类别</th>
<th>原因</th>
<th>异步/同步</th>
<th>返回行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断</td>
<td>来自I/O设备的信号</td>
<td>异步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>陷阱</td>
<td>有意的异常</td>
<td>同步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>故障</td>
<td>可能修复的错误</td>
<td>同步</td>
<td>可能返回到当前指令</td>
</tr>
<tr>
<td>中止</td>
<td>不可修复的错误</td>
<td>同步</td>
<td>不会返回</td>
</tr>
</tbody>
</table>
<p>　　陷阱、故障和中止是同步发生的，即执行当前指令的结果，而这类指令称为<strong>故障指令</strong>。</p>
<p>　　运行应用程序代码的进程初始默认用户模式，若需要变为内核模式，则需要通过中断、故障或陷阱这样的异常。</p>
<h5 id="中断">8.1.2.1 中断</h5>
<p>　　硬件中断不是由执行任何一条指令造成，所以它是异步的。硬件中断的异常处理程序称为<strong>中断处理程序</strong>。</p>
<img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/interrupt_handling.svg" class="" title="interrupt_handling">
<p>　　I/O设备向CPU芯片上的中断引脚发送信号并将异常号放到系统总线上来触发中断，该异常号标识了引起中断的设备。在当前指令完成后，CPU检测到中断引脚的电压变高，从系统总线读取异常号并调用对应的中断处理程序。当中断处理程序返回后，将控制权转移给下一条指令，然后程序像没有出现中断一样继续执行。</p>
<h5 id="陷阱">8.1.2.2 陷阱</h5>
<p>　　陷阱是执行某条指令的结果，最重要的用途是在用户程序和内核之间提供像过程一样的接口，称为<strong>系统调用</strong>。用户程序经常会向内核请求服务，例如，读文件<code>read()</code>、创建新进程<code>fork()</code>、加载新程序<code>execve()</code>和中止当前进程<code>exit()</code>，为了允许对此类服务的受控访问，CPU提供了特殊<code>syscall n</code>指令，当用户程序想要请求服务<code>n</code>时，可以执行该指令。</p>
<img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/trap_handling.svg" class="" title="trap_handling">
<p>　　执行<code>syscall</code>指令会导致陷阱，陷阱处理程序会解析参数并调用对应的内核程序。</p>
<p>　　从程序员角度，系统调用和普通的函数调用是一样的，但它们的实现不同。普通的函数运行在用户模式，用户模式限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的栈。系统调用运行在内核模式，内核模式允许系统执行特权指令，而且能访问定义在内核中的栈。</p>
<h5 id="故障">8.1.2.3 故障</h5>
<p>　　故障由错误情况引起，它可能能被故障处理程序修复。</p>
<img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/fault_handling.svg" class="" title="fault_handling">
<p>　　当故障发生时，CPU会将控制权转移给故障处理程序。若故障处理程序能够修复，则它会将控制权转移给导致故障的指令，然后重新执行该指令；否则，从故障处理程序返回到<code>abort</code>例程，该例程会中止导致故障的应用程序。</p>
<p>　　缺页异常就是典型的故障，当指令引用某个虚拟地址，但该虚拟地址对应的物理地址不在内存中，所以必须从磁盘中取出，此时就会发生故障。缺页处理程序会从磁盘加载对应的页面，然后将控制权转移给引起故障的指令。当指令再次执行时，对应的物理页面已驻留在内存中，指令就可以没有故障地完成了。</p>
<h5 id="中止">8.1.2.4 中止</h5>
<img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/abort_handling.svg" class="" title="abort_handling">
<p>　　中止是不可修复的故障导致的结果，通常是硬件故障，例如，DRAM/SRAM位被损坏时发生的奇偶错误。中止处理程序不会将控制权转移给应用程序。</p>
<h4 id="linuxx86-84系统中的异常">8.1.3 Linux/x86-84系统中的异常</h4>
<p>　　x86-64中有256种异常类型。异常号0~31是Intel架构师定义的异常，所以对所有x86-64系统都相同。异常号32~255是OS定义的中断和陷阱。</p>
<table>
<thead>
<tr>
<th>异常号</th>
<th>描述</th>
<th>异常类别</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>除法错误</td>
<td>故障</td>
</tr>
<tr>
<td>13</td>
<td>一般保护故障</td>
<td>故障</td>
</tr>
<tr>
<td>14</td>
<td>缺页</td>
<td>故障</td>
</tr>
<tr>
<td>18</td>
<td>机器检查</td>
<td>中止</td>
</tr>
<tr>
<td>32~255</td>
<td>OS定义的异常</td>
<td>中断或陷阱</td>
</tr>
</tbody>
</table>
<p>　　当除以0或除法指令的结果比目标操作数大很多时，就会发生除法错误，Unix会直接中止程序而非试图修复此类故障。shell通常把除法错误称为<strong>浮点异常</strong>。</p>
<p>　　很多原因都会导致一般保护故障，例如，引用未定义的虚拟内存区域和写只读的文件。Linux不会试图修复此类故障。shell通常把一般保护故障称为<strong>段故障</strong>。</p>
<p>　　执行会导致故障的指令时，若遇到硬件故障，则会发生机器检查。机器检查处理程序不会将控制权转移给应用程序。</p>
<p>　　Linux提供数百种系统调用。每种系统调用都有唯一的整数编号，每个编号都对应内核中跳转表的偏移。</p>
<table>
<thead>
<tr>
<th>(系统调用) 编号</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>read</code></td>
<td>读文件</td>
</tr>
<tr>
<td>1</td>
<td><code>write</code></td>
<td>写文件</td>
</tr>
<tr>
<td>2</td>
<td><code>open</code></td>
<td>打开文件</td>
</tr>
<tr>
<td>3</td>
<td><code>close</code></td>
<td>关闭文件</td>
</tr>
<tr>
<td>4</td>
<td><code>stat</code></td>
<td>获取文件信息</td>
</tr>
<tr>
<td>9</td>
<td><code>mmap</code></td>
<td>将内存页映射到文件</td>
</tr>
<tr>
<td>12</td>
<td><code>brk</code></td>
<td>重置栈顶</td>
</tr>
<tr>
<td>32</td>
<td><code>dup2</code></td>
<td>复制文件描述符</td>
</tr>
<tr>
<td>33</td>
<td><code>pause</code></td>
<td>挂起进程直到信号到达</td>
</tr>
<tr>
<td>37</td>
<td><code>alarm</code></td>
<td>调度报警信号的发送</td>
</tr>
<tr>
<td>39</td>
<td><code>getpid</code></td>
<td>获取进程ID</td>
</tr>
<tr>
<td>57</td>
<td><code>fork</code></td>
<td>创建进程</td>
</tr>
<tr>
<td>59</td>
<td><code>execve</code></td>
<td>执行程序</td>
</tr>
<tr>
<td>60</td>
<td><code>_exit</code></td>
<td>终止程序</td>
</tr>
<tr>
<td>61</td>
<td><code>wait4</code></td>
<td>等待进程终止</td>
</tr>
<tr>
<td>62</td>
<td><code>kill</code></td>
<td>发送信号到进程</td>
</tr>
</tbody>
</table>
<p>　　对于大多数系统调用，标准C语言库都提供了一组便利的包装函数。这些包装函数将参数打包到一起，以适当的系统调用指令陷入内核，然后将系统调用的返回传递给调用程序。系统调用及其对应的包装函数都称为<strong>系统级函数</strong>。</p>
<p>　　Linux的系统调用的参数都是通过寄存器传递，寄存器<code>%rax</code>存放系统调用号，最多可以有6个参数，按序分别存放在<code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%r10</code>、<code>%r9</code>和<code>%r8</code>中。从系统调用返回时，寄存器<code>%rcx</code>和<code>%r11</code>都会被清空，<code>%rax</code>存放返回值。-4095到-1的负数返回值表示出现错误，对应负的的<code>errno</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;hello, world\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .data</span><br><span class="line">string:</span><br><span class="line">  .ascii &quot;hello, world\n&quot;</span><br><span class="line">string_end:</span><br><span class="line">  .equ len, string_end - string</span><br><span class="line">.section .text</span><br><span class="line">.globl main</span><br><span class="line">main:</span><br><span class="line">  # 调用write</span><br><span class="line">  movq  $1, %rax  # write的系统调用号是1</span><br><span class="line">  movq  $1, %rdi  # 参数1，stdout的描述符是1</span><br><span class="line">  movq  $string, %rsi # 参数2</span><br><span class="line">  movq  $len, %rdx  # 参数3</span><br><span class="line">  syscall # 执行系统调用</span><br><span class="line">  # 调用_exit</span><br><span class="line">  movq  $60, %rax # _exit的系统调用号是60</span><br><span class="line">  movq  $0, %rdi  # 参数1</span><br><span class="line">  syscall # 执行系统调用</span><br></pre></td></tr></table></figure>
<p>　　这是使用了系统级函数的<code>hello</code>程序及其对应的汇编代码。函数<code>write()</code>的第1个参数将传递到<code>stdout</code>，第2个参数是待写的字节序列，第3个参数是待写的字节数。</p>
<h3 id="进程">8.2 进程</h3>
<p>　　进程的经典定义是正在执行的程序的<strong>实例</strong>。</p>
<p>　　即使系统中通常有很多其他程序在运行，进程也可以提供<span
style="background-color: yellow">看似独占地使用CPU</span>的假象。若使用调试器单步执行程序，会看到一系列的PC值，这些值唯一地对应程序的可执行文件或共享库中的指令。这个PC值的序列称为<strong>逻辑控制流</strong>，简称<strong>逻辑流</strong>。</p>
<p>　　进程为每个程序提供的另一个假象是<span
style="background-color: yellow">看似独占地使用系统地址空间</span>。在<span
class="math inline">\(n\)</span>位地址的计算机上，地址空间是<span
class="math inline">\(2^n\)</span>个可能地址的集合，即<span
class="math inline">\(0\)</span>到<span
class="math inline">\(2^n-1\)</span>。进程为每个程序提供其<strong>私有地址空间</strong>。一般情况下，和私有地址空间中的某个地址相关联的内存字节不能被其他进程访问。</p>
<img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/logical_control_flow.svg" class="" title="logical_control_flow">
<p>　　这里以运行3个进程的系统为例，CPU的物理控制流分为了3个逻辑流。每个竖直的流表示逻辑流的一部分，这里3个逻辑流是交错的。每个进程执行它的流一部分，然后被<strong>抢占</strong>
(暂挂) 并轮到其他进程。</p>
<p>　　内核为每个进程维护对应的上下文，<strong>上下文</strong>就是内核重新启动暂挂进程所需的状态，由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、PC、用户栈、状态寄存器和各种内核数据结构，例如，描述地址空间的<span
style="background-color: yellow">页表</span>、包含当前进程相关信息的<span
style="background-color: yellow">进程表</span>和包含当前进程已打开文件的信息的<span
style="background-color: yellow">文件表</span>。</p>
<p>　　对于流X和Y，当前仅当X在Y开始之后和Y结束之前开始或Y在X开始之后和X结束之前开始，它们才能称为相互<strong>并发</strong>执行，这2个流称为<strong>并发流</strong>。例如，进程A和B是并发执行，A和C也是并发执行，但B和C不是并发执行。</p>
<p>　　<strong>并发</strong>指多个流并发执行。<strong>多任务</strong>指多个进程轮流运行。进程执行其控制流的一部分的时间段称为<strong>时间片</strong>，所以多任务也称为<strong>时间分片</strong>。例如，进程A由2个时间片组成。操作系统内核通过<strong>上下文切换</strong>来实现多任务。</p>
<p>　　若多个流运行在CPU<span
style="background-color: yellow">不同核</span>上，则它们称为<strong>并行流</strong>，它们<strong>并行运行</strong>且<strong>并行执行</strong>。</p>
<p>　　在进程执行时，内核可以抢占当前进程并重新开始某个暂挂的进程，该过程称为<strong>调度</strong>，由内核中的调度器执行。当内核调度时，会使用上下文切换来将控制权转移给暂挂的进程，即先保存当前进程的上下文，恢复暂挂的进程之前保存的上下文并将控制权转移给该进程。</p>
<p>　　当内核代表用户执行系统调度时，可能会发生上下文切换。若系统调用因等待某个事件而阻塞，则内核可以让当前进程休眠，切换到其他进程。例如，若<code>read()</code>系统调用需要访问磁盘，内核就可以选择执行上下文切换来运行其他进程而非等待数据到达。<code>sleep()</code>系统调用可以显示地请求调用进程休眠。一般情况下，即使系统调用没有阻塞，内核也可以决定执行上下文切换而非将控制权转移给调用进程。</p>
<p>　　中断可能导致上下文切换。例如，所有系统都有产生周期性定时器中断的机制，间隔通常是1ms到10ms。每次发生定时器中断时，内核就能判断当前进程已经运行了足够长的时间，并切换到新进程。</p>
<h3 id="系统调用错误处理">8.3 系统调用错误处理</h3>
<p>　　当Unix系统级函数出错时，通常返回-1并设置全局整数变量<code>errno</code>来表示错误类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>strerror()</code>会返回与<code>errno</code>对应的错误的文本串。通过定义以下的<strong>错误报告函数</strong>，能简化这段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    unix_error(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　通过错误处理包装函数，可以进一步简化代码。对于给定的基本函数<code>foo()</code>，定义具有相同参数的包装函数<code>Foo()</code>
(首字母大写)，包装函数会调用基本函数，检查错误，若出错，则终止。以下是函数<code>fork()</code>的错误处理包装函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程控制">8.4 进程控制</h3>
<p>　　从程序员角度，进程总是处于以下3种状态之一：</p>
<p>　　●
<strong>运行</strong>。进程要么在CPU上执行，要么在等待被执行并最终被内核调度。</p>
<p>　　● <strong>停止</strong>。进程的执行被<span
style="background-color: yellow">挂起</span>且不会被调度。当收到信号SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU时，进程会停止并一直持续到收到信号SIGCONT，此时，进程再次开始运行。</p>
<p>　　●
<strong>终止</strong>。进程永远停止。只有当收到默认行为是终止进程的信号、从主程序返回或调用函数<code>exit()</code>时，进程才会终止。</p>
<p>　　Unix提供了C语言控制进程的系统调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>exit()</code>会以退出状态<code>status</code>来终止进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程PID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的父进程PID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 子进程返回0，父进程返回子进程PID，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　每个进程都有唯一的正整数进程ID
(PID)。在Linux中，<code>types.h</code>把<code>pid_t</code>定义为<code>int</code>。</p>
<p>　　<strong>父进程</strong>通过调用函数<code>fork()</code>来创建新的正在运行的<strong>子进程</strong>。子进程得到与父进程用户级虚拟地址空间相同但<span
style="background-color: yellow">独立</span>的副本，包括代码段、数据段、堆、共享库和用户栈。子进程还获得与父进程所有文件描述符相同的副本，这表示子进程可以读写父进程调用函数<code>fork()</code>时打开的所有文件。父进程和子进程之间最大的区别是PID。</p>
<p>　　函数<code>fork()</code>只会被调用1次，但父进程和子进程都会返回，
父进程中返回子进程PID，子进程中返回0。因为子进程PID总是非0，返回值可以分辨程序是在父进程还是在子进程中执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    pid = Fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child: x=%d\n&quot;</span>, ++x);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: x=%d\n&quot;</span>, --x);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/process_graph_for_the_example_program.svg" class="" title="process_graph_for_the_example_program">
<p>　　这个示例会使用函数<code>fork()</code>创建子进程。当函数<code>fork()</code>返回时
(第6行)，父进程和子进程中的<code>x</code>的值都为1，然后父子进程在自己的私有地址空间并发执行。子进程在第8行加1并输出其<code>x</code>的副本
(值为0)，父进程在第13行减1并输出其<code>x</code>的副本 (值为2)。</p>
<p>　　对于运行在单核CPU上的程序，进程图中所有顶点的<strong>拓扑排序</strong>都表示程序中对应的语句的可行总排序。当且仅当画出的每条边的方向都是从左到右时，该排列是拓扑排序。这里，父子进程的<code>printf()</code>语句可以以任意顺序执行，因为每种顺序都对应图顶点的某种拓扑排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    Fork();</span><br><span class="line">    Fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/process_graph_for_a_nested_fork.svg" class="" title="process_graph_for_a_nested_fork">
<p>　　这个示例的源码中调用了2次函数<code>fork()</code>，而进程图中实际运行了4个进程，每个都调用了1次函数<code>printf()</code>，这样函数<code>printf()</code>可以以任意顺序执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>; <span class="comment">/* 返回剩余待休眠秒数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 总是返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>sleep()</code>会将进程挂起指定时间，若已达到指定挂起时间，则返回0；若提前返回
(被信号中断)，则返回剩余待挂起时间
(单位为秒)。函数<code>pause()</code>也会让函数休眠直到进程收到信号。</p>
<h4 id="回收子进程">8.4.1 回收子进程</h4>
<p>　　当进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程一直保持终止状态直到被其父进程<strong>回收</strong>。当父进程回收终止的子进程时，内核会将子进程的退出状态传递给父进程，然后清除终止的子进程，此时，该子进程将不复存在。终止但未被回收的进程称为<strong>僵尸</strong>进程。</p>
<p>　　若父进程终止，则其子进程会成为<strong>孤儿</strong>进程，内核会让<code>init</code>进程领养孤儿进程。<code>init</code>进程PID为1，是系统启动时由内核创建，它不会终止，是所有进程的祖先。若孤儿进程是僵尸进程，则<code>init</code>进程会进行回收。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statusp, <span class="type">int</span> options)</span>; <span class="comment">/* 若成功则返回子进程PID，若WNOHANG则返回0，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statusp)</span>; <span class="comment">/* 若成功则返回子进程PID，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　进程可以通过调用函数<code>waitpid()</code>来等待其子进程终止。默认情况下
(参数<code>options</code>为0时)，函数<code>waitpid()</code>会挂起调用进程，直到其<strong>等待集合</strong>中的某个子进程终止。若等待集合中的某个进程在调用时就已终止，则函数<code>waitpid()</code>会立即返回。在这2种情况下，函数<code>waitpid()</code>会返回导致自身返回的已终止子进程PID。此时，已终止的子进程已被回收，内核会从系统中删除其所有痕迹。</p>
<p>　　等待集合的成员由参数<code>pid</code>确定：</p>
<p>　　●
若<code>pid</code>大于0，则等待集合就是1个单独的子进程，其PID等于<code>pid</code>。</p>
<p>　　● 若<code>pid</code>为-1，则等待集合就是父进程所有的子进程。</p>
<p>　　函数<code>waitpid()</code>还支持其他类型的等待集合，包括Unix进程组。</p>
<p>　　若调用进程没有子进程，则函数<code>waitpid()</code>会返回-1并将<code>errno</code>设置为<code>ECHILD</code>。若函数<code>waitpid()</code>被信号中断，则返回-1并将<code>errno</code>设置为<code>EINTR</code>。头文件<code>errno.h</code>中定义了<code>errno</code>相关的宏。</p>
<p>　　调用<code>wait(&amp;status)</code>等价于调用<code>waitpid(-1, &amp;status, 0)</code>。</p>
<h5 id="修改默认行为">8.4.1.1 修改默认行为</h5>
<p>　　可以将参数<code>options</code>设置为常量<code>WNOHANG</code>、<code>WUNTRACED</code>和<code>WCONTINUED</code>的各种组合修改来默认行为。</p>
<p>　　●
<code>WNOHANG</code>：若等待集合中的所有子进程都还没终止，则立即返回0。默认的行为是挂起调用进程，直到子进程终止。在等待子进程终止时还想进行其他工作，可以使用该选项。</p>
<p>　　●
<code>WUNTRACED</code>：挂起调用进程直到等待集合中的1个进程变为终止或停止。返回PID为导致返回的已终止或已停止的子进程PID。默认行为是只返回已终止的子进程。当需要检查已终止或已停止的子进程时，该选项会有用。</p>
<p>　　●
<code>WCONTINUED</code>：挂起调用进程直到等待集合中的1个正在运行的进程终止或等待集合中1个停止的进程收到信号SIGCONT重新开始执行。</p>
<p>　　这3个常量可以用或运算来组合。例如，<code>WNOHANG | WUNTRACED</code>：立即返回，若等待集合中的子进程都没有终止或停止，则返回0；若有1个进程终止或停止，则返回该子进程PID。</p>
<h5 id="检查已回收子进程的退出状态">8.4.1.2
检查已回收子进程的退出状态</h5>
<p>　　若参数<code>statusp</code>是非空，则函数<code>waitpid()</code>会设置<code>status</code>来表示导致返回的子进程的状态信息，这里<code>status</code>是<code>statusp</code>指向的值。头文件<code>wait.h</code>定义了<code>status</code>参数的几个宏：</p>
<p>　　●
<code>WIFEXITED</code>：若子进程调用<code>exit()</code>或<code>return</code>正常终止，则返回真。</p>
<p>　　●
<code>WEXITSTATUS</code>：返回1个正常终止的子进程的退出状态。只有在<code>WIFEXITED()</code>返回真时，才会定义该状态。</p>
<p>　　●
<code>WIFSIGNALED</code>：若子进程因1个未捕获的信号终止，则返回真。</p>
<p>　　●
<code>WTERMSIG</code>：返回导致子进程终止的信号的编号。只有在<code>WIFSIGNALED()</code>返回真时，才会定义该状态。</p>
<p>　　●
<code>WIFSTOPPED</code>：若导致返回的子进程已停止，则返回真。</p>
<p>　　●
<code>WIFCONTINUED</code>：若子进程收到信号SIGCONT重新运行，则返回真。</p>
<h5 id="相关示例">8.4.1.3 相关示例</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status, i;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程创建N个子进程 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">100</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程回收这N个子进程 (无特定顺序) */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated normally with exit status=%d\n&quot;</span>, pid, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated abnormally\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有当没有子进程时才正常终止 */</span></span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，使用了函数<code>waitpid()</code>来 (不按照特定顺序)
等待所有<code>N</code>个子进程终止。在第11行中，父进程创建了<code>N</code>个子进程，在第13行中，每个子进程以唯一的退出状态退出。</p>
<p>　　在第18行中，父进程用函数<code>waitpid()</code>作为<code>while</code>循环条件，等待其所有子进程终止。函数<code>waitpid()</code>的第1个参数是-1，所以对函数<code>waitpid()</code>的调用会阻塞，直到任意1个子进程终止。每当子进程终止时，对函数<code>waitpid()</code>的调用会返回该子进程PID。第20行会检查子进程退出状态，若是正常终止
(调用函数<code>exit()</code>退出)，则父进程提取退出状态并输出到<code>stdout</code>。</p>
<p>　　当回收所有子进程后，再调用函数<code>waitpid()</code>会返回-1并将<code>errno</code>设置为<code>ECHILD</code>。第31行会检查函数<code>waitpid()</code>是否正常终止，若不是，则返回错误信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status, i;</span><br><span class="line">    <span class="type">pid_t</span> pid[N], retpid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程创建N个子进程 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid[i] = Fork()) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">100</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程按序回收这N个子进程 */</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((retpid = waitpid(pid[i++], &amp;status, <span class="number">0</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated normally with exit status=%d\n&quot;</span>, retpid, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated abnormally\n&quot;</span>, retpid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有当没有子进程时才正常终止 */</span></span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是改进后版本，按照父进程创建子进程的顺序来回收这些子进程。父进程按照顺序存储了其子进程PID，然后通过适当的PID作为第1个参数来调用函数<code>waitpid()</code>，按照同样的顺序来等待每个子进程。</p>
<h4 id="加载并执行程序">8.4.2 加载并执行程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span>; <span class="comment">/* 若成功则不返回，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/organization_of_function_execve's_arguments.svg" class="" title="organization_of_function_execve" alt="s_arguments">
<p>　　函数<code>execve()</code>会加载并执行可执行文件<code>filename</code>，并且会带参数列表<code>argv</code>和环境变量列表<code>envp</code>。只有出错时
(找不到<code>filename</code>等)，函数<code>execve()</code>才会返回到调用程序。</p>
<p>　　参数<code>argv</code>指向以<code>NULL</code>结尾的指针数组，其中每个指针都指向1个参数字符串。按照惯例，<code>argv[0]</code>是可执行文件的名称。参数<code>envp</code>指向以<code>NULL</code>结尾的指针数组，其中每个指针指向1个环境变量字符串，每个字符串都是形如<code>name=value</code>的键值对。</p>
<p>　　函数<code>execve()</code>加载<code>filename</code>后，会调用7.7中介绍的系统启动函数。系统启动函数会设置栈并将控制权转移给程序的主函数，主函数有2种等价的原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *envp[])</span>;</span><br></pre></td></tr></table></figure>
<p>　　主函数有3个参数，参数<code>argc</code>表示<code>argv[]</code>中非空指针的数量，参数<code>argv</code>指向数组<code>argv[]</code>的第1个元素，参数<code>envp</code>指向数组<code>envp[]</code>的第1个元素。</p>
<img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/typical_organization_of_the_user_stack_when_a_new_program_starts.svg" class="" title="typical_organization_of_the_user_stack_when_a_new_program_starts">
<p>　　主函数开始执行时，栈底是以<code>NULL</code>结尾的环境变量字符串和命令行参数字符串。其后是以<code>NULL</code>结尾的指针数组，其中每个指针都指向1个环境变量字符串，全局变量<code>environ</code>指向该数组的第1个元素<code>envp[0]</code>。其后是另一个以<code>NULL</code>结尾的指针数组，其中每个指针都指向1个参数字符串。栈顶是系统启动函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 若存在则返回指向name的指针，若不存在则返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *newvalue, <span class="type">int</span> overwrite)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>getenv()</code>会在环境变量数组中搜索字符串<code>name=value</code>。若找到，则返回指向<code>value</code>的指针；否则，返回<code>NULL</code>。当环境变量数组中有形如<code>name=oldvalue</code>的字符串时，函数<code>unsetenv()</code>会删除它，此时，若<code>overwrite</code>非0，则函数<code>setenv()</code>会用<code>newvalue</code>替换<code>oldvalue</code>。若<code>name</code>不存在，则函数<code>setenv()</code>会把<code>name=newvalue</code>添加到环境变量数组。</p>
<h4 id="用fork和execve运行程序">8.4.3
用<code>fork()</code>和<code>execve()</code>运行程序</h4>
<p>　　Unix
shell和Web服务器等程序大量地使用了函数<code>fork()</code>和<code>execve()</code>。shell是交互型程序，它代表用户运行其他程序。最早的shell是<code>sh</code>，后来出现了一些变种，例如，<code>csh</code>、<code>tcsh</code>、<code>ksh</code>和<code>bash</code>。shell会执行一系列读/求值步骤，然后终止。读步骤会读来自用户的1个命令行。求值步骤会解析命令行并代表用户运行程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">char</span> *buf, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *delim; <span class="comment">/* 指向首个空格分隔符 */</span></span><br><span class="line">    <span class="type">int</span> argc;    <span class="comment">/* 参数数量 */</span></span><br><span class="line">    <span class="type">int</span> bg;      <span class="comment">/* 是否后台执行 */</span></span><br><span class="line"></span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27; &#x27;</span>; <span class="comment">/* 用空格替换结尾的\n */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略开头的空格 */</span></span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        buf++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构建参数列表 */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        argv[argc++] = buf;</span><br><span class="line">        *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        buf = delim + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 忽略空格 */</span></span><br><span class="line">        <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            buf++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略空行 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 是否后台执行 */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">builtin_commond</span><span class="params">(<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 退出命令行 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略分隔符&amp; */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *argv[MAXARGS]; <span class="comment">/* 函数execve参数列表 */</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];   <span class="comment">/* 保存修改后的命令行 */</span></span><br><span class="line">    <span class="type">int</span> bg;              <span class="comment">/* 是否后台运行 */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;           <span class="comment">/* 进程ID */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, cmdline);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略空行 */</span></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!builtin_commond(argv))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 子进程运行用户作业 */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 父进程等待前台作业终止 */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                unix_error(<span class="string">&quot;waitfg: waitpid error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %s&quot;</span>, pid, cmdline);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        Fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        eval(cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了简单shell的主函数。shell会打印1个命令行提示符，等待用户在<code>stdin</code>上输入命令行，然后对该命令行求值。这里并没有回收后台子进程。</p>
<p>　　函数<code>eval()</code>会对命令行求值，其首要任务是调用函数<code>parseline()</code>，这个函数会解析以空格为分隔符的命令行参数并构造最终会传递给函数<code>execve()</code>的参数<code>argv</code>。若函数<code>parseline()</code>的最后1个参数是<code>&amp;</code>，则会返回1
(在后台执行)；否则，返回0 (在前台执行)。</p>
<p>　　在解析完命令行后，函数<code>eval()</code>会调用函数<code>builtin_command()</code>，该函数会检查第1个命令行参数是否是内置shell命令，若是，则解释该命令并返回1；否则，返回0。</p>
<p>　　若函数<code>builtin_command()</code>返回0，则shell会创建子进程并在子进程中执行所请求的程序。若用户要求在后台运行该程序，则shell会返回到循环的顶部，等待下一个命令行；否则，shell会用函数<code>waitpid()</code>等待作业终止。当作业终止时，shell会开始下一轮迭代。</p>
<h3 id="信号">8.5 信号</h3>
<p>　　Linux<strong>信号</strong>是更高层的软件形式的异常，允许进程和内核中断其他进程。每种信号类型都对应某种系统事件。底层的硬件异常是由内核异常处理程序处理，正常情况下，对用户进程不可见，信号能通知用户进程发生了这些异常。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 14%" />
<col style="width: 33%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr>
<th>编号</th>
<th>名称</th>
<th>默认行为</th>
<th>对应事件 (默认处理操作)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIGHUP</td>
<td>终止</td>
<td>终端线挂断</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>终止</td>
<td>来自键盘的中断</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>终止</td>
<td>来自键盘的退出</td>
</tr>
<tr>
<td>4</td>
<td>SIGILL</td>
<td>终止</td>
<td>非法指令</td>
</tr>
<tr>
<td>5</td>
<td>SIGTRAP</td>
<td>终止并转存内核</td>
<td>追踪陷阱</td>
</tr>
<tr>
<td>6</td>
<td>SIGABRT</td>
<td>终止并转存内核</td>
<td>来自函数<code>abort()</code>的中止信号</td>
</tr>
<tr>
<td>7</td>
<td>SIGBUS</td>
<td>终止</td>
<td>总线错误</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>终止并转存内核</td>
<td>浮点异常</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>终止</td>
<td>杀死进程</td>
</tr>
<tr>
<td>10</td>
<td>SIGUSR1</td>
<td>终止</td>
<td>用户定义的信号1</td>
</tr>
<tr>
<td>11</td>
<td>SIGSEGV</td>
<td>终止并转存内核</td>
<td>无效的内存引用 (段故障)</td>
</tr>
<tr>
<td>12</td>
<td>SIGUSR2</td>
<td>终止</td>
<td>用户定义的信号2</td>
</tr>
<tr>
<td>13</td>
<td>SIGPIPE</td>
<td>终止</td>
<td>写没有读用户的管道</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>终止</td>
<td>来自函数<code>alarm()</code>的定时器信号</td>
</tr>
<tr>
<td>15</td>
<td>SIGTREM</td>
<td>终止</td>
<td>软件终止信号</td>
</tr>
<tr>
<td>16</td>
<td>SIGSTKFLT</td>
<td>终止</td>
<td>协处理器的栈错误</td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>忽略</td>
<td>1个子进程已停止或终止</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>忽略</td>
<td>继续运行停止的进程</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>停止直到下一个SIGCONT</td>
<td>不是来自终端的停止信号</td>
</tr>
<tr>
<td>20</td>
<td>SIGTSTP</td>
<td>停止直到下一个SIGCONT</td>
<td>来自终端的停止信号</td>
</tr>
<tr>
<td>21</td>
<td>SIGTTIN</td>
<td>停止直到下一个SIGCONT</td>
<td>后台进程从终端读</td>
</tr>
<tr>
<td>22</td>
<td>SIGTTOU</td>
<td>停止直到下一个SIGCONT</td>
<td>后台进程从终端写</td>
</tr>
<tr>
<td>23</td>
<td>SIGURG</td>
<td>忽略</td>
<td>套接字的紧急情况</td>
</tr>
<tr>
<td>24</td>
<td>SIGXCPU</td>
<td>终止</td>
<td>超出CPU时间限制</td>
</tr>
<tr>
<td>25</td>
<td>SIGXFSZ</td>
<td>终止</td>
<td>超出文件大小限制</td>
</tr>
<tr>
<td>26</td>
<td>SIGVTALRM</td>
<td>终止</td>
<td>虚拟定时器过期</td>
</tr>
<tr>
<td>27</td>
<td>SIGPROF</td>
<td>终止</td>
<td>剖析定时器过期</td>
</tr>
<tr>
<td>28</td>
<td>SIGWINCH</td>
<td>忽略</td>
<td>窗口大小变化</td>
</tr>
<tr>
<td>29</td>
<td>SIGIO</td>
<td>终止</td>
<td>在1个描述符上执行I/O操作</td>
</tr>
<tr>
<td>30</td>
<td>SIGPWR</td>
<td>终止</td>
<td>电源故障</td>
</tr>
</tbody>
</table>
<p>　　当进程除以0时，内核会发送信号SIGFPE给它。当进程执行非法指令时，内核会发送信号SIGILL给它。其他信号对应内核或用户进程中较高层的软件事件。例如，当键盘输入Ctrl+C时，内核会发送信号SIGINT给前台进程组的每个进程。同样，当键盘输入Ctrl+Z时，会发送信号SIGTSTP给前台进程组的每个进程。进程可以向其他进程发送信号SIGKILL信号来强制终止它。当子进程停止或终止时，内核会发送信号SIGCHLD给父进程。</p>
<p>　　转存内存 (dumping core)
是历史术语，表示将代码和数据内存段的映射写到磁盘上
(以前的内存用磁芯存储器来实现)。</p>
<p>　　信号的传输由<strong>发送信号</strong>和<strong>接收信号</strong>组成。</p>
<p>　　●
内核通过更新目的进程上下文中的某个状态来发送信号给目的进程。发送信号可以有2种原因，即内核检测到系统事件或进程调用函数<code>kill()</code>。进程可以发送信号给自己。</p>
<img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/signal_handling.svg" class="" title="signal_handling">
<p>　　●
当目的进程被内核强迫以某种方式来响应信号时，它就接收了信号。进程可以忽略该信号，也可以终止或通过执行称为<strong>信号处理程序</strong>的用户级函数来捕获该信号。信号SIGKILL和SIGSTOP既不能捕获，也不能忽略。</p>
<p>　　发出后未被接收的信号称为<strong>待处理信号</strong>。<span
style="background-color: yellow">同一类型的待处理信号最多只能有1个</span>。若进程有1个类型为<code>k</code>的待处理信号，则之后发送到该进程的类型为<code>k</code>的信号会直接被丢弃。进程可以有选择性地<strong>阻塞</strong>特定信号的接收。当信号被阻塞时，仍可以发送，但不会被接收，直到取消对应的阻塞。</p>
<p>　　内核为每个进程在<code>pengding</code>位向量中维护着待处理信号的集合，在<code>blocked</code>位向量
(也称为<strong>信号掩码</strong>)
中维护着阻塞的信号集合。当发送类型为<code>k</code>的信号时，内核会设置<code>pending</code>位向量中的第<code>k</code>位。当接收类型为<code>k</code>的信号时，内核会清除<code>pengding</code>位向量中的第<code>k</code>位。</p>
<h4 id="发送信号">8.5.1 发送信号</h4>
<p>　　Unix提供了大量向进程发送信号的机制，这些机制都是基于<strong>进程组</strong>。</p>
<p>　　每个进程都只属于1个进程组，进程组由1个正整数ID来标识。子进程的默认进程组是父进程的进程组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的进程组ID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>; <span class="comment">/* 返回上一个alarm剩余的秒数，若没有上一个alarm则返回0 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>getpgrp()</code>会返回当前进程的进程组ID。</p>
<p>　　函数<code>setpgid()</code>会将PID为<code>pid</code>的进程的进程组ID设置为<code>pgid</code>。若<code>pid</code>为0，则使用当前进程PID；若<code>pgid</code>为0，则将PID为<code>pid</code>的进程的进程组ID设置为<code>pid</code>；若<code>pid</code>和<code>pgid</code>都为0，则将调用进程的进程组ID设置为其PID。</p>
<p>　　函数<code>alarm()</code>会让内核在<code>secs</code>秒后发送信号SIGALRM给调用进程。每次调用函数<code>alarm()</code>时，若上一次调用该函数设置的延时还未结束，则会取消上一次调用该函数设置的延时并返回剩余时间；若上一次调用该函数设置的延时已结束，则返回0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>kill()</code>会发送编号为<code>sig</code>的信号给指定进程
(包括自己)。若<code>pid</code>大于0，则会发送编号为<code>sig</code>的信号给PID为<code>pid</code>的进程；若<code>pid</code>为0，则会发送编号为<code>sig</code>的信号给调用进程所属进程组中的每个进程；若<code>pid</code>小于0，则会发送编号为<code>sig</code>的信号给进程组ID为<code>pid</code><span
style="background-color: yellow">绝对值</span>的进程组中的所有进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 子进程休眠，直到收到SIGKILL，然后终止 */</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Pause();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;control should never reach here!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程发送SIGKILL给子进程 */</span></span><br><span class="line">    Kill(pid, SIGKILL);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，父进程会用函数<code>kill()</code>发送信号SIGKILL给其子进程。</p>
<p>　　<code>/bin/kill</code>程序可以向其他进程发送任意信号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/kill -9 15213</span><br><span class="line">/bin/kill -9 -15213</span><br></pre></td></tr></table></figure>
<p>　　第1条命令会发送信号9 (SIGKILL) 给进程15213。第2条命令会发送信号9
(SIGKILL) 给进程组15213中的每个进程。</p>
<p>　　shell使用<strong>作业</strong>来表示对命令行求值而创建的进程。前台作业只能有1个，后台作业可以有任意个。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls | sort</span><br></pre></td></tr></table></figure>
<p>　　这条命令会创建包括2个进程
(分别运行<code>ls</code>和<code>sort</code>程序)
的前台作业，这2个进程通过Unix管道连接。shell会为每个作业创建独立的进程组。进程组ID通常来自作业中的某个父进程。</p>
<img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/foreground_and_background_process_groups.svg" class="" title="foreground_and_background_process_groups">
<p>　　在这个示例中，shell有1个前台作业和2个后台作业。前台作业的父进程PID为20，进程组ID为20。父进程创建了2个子进程，子进程的进程组ID都是20。</p>
<h4 id="接收信号">8.5.2 接收信号</h4>
<p>　　当内核把进程<code>p</code>从内核模式切换到用户模式时，会检查进程<code>p</code>的未阻塞的待处理信号的集合。若集合为空
(通常情况下)，则内核将控制权转移给<code>p</code>的控制流中的下一条指令；若集合不为空，则选择集合中的某个信号
(通常是编号值最小)
并且强制<code>p</code>接收该信号。收到信号后进程会进行某些操作。一旦进程完成操作，那么控制权将转移给<code>p</code>的控制流的下一条指令。每个信号类型都有预定义的默认
(处理) 操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>; <span class="comment">/* 若成功则返回指向前一个处理程序的指针，若出错则返回SIG_ERR (不设置errno) */</span></span><br></pre></td></tr></table></figure>
<p>　　进程可以使用函数<code>signal()</code>修改信号的默认操作。信号SIGSTOP和SIGKILL的默认操作无法修改。</p>
<p>　　函数<code>signal()</code>通过以下3种方式之一来改变信号的默认操作：</p>
<p>　　●
若<code>handler</code>是SIG_IGN，则忽略编号为<code>signum</code>的信号。</p>
<p>　　●
若<code>handler</code>是SIG_DFL，则恢复编号为<code>signum</code>的信号的默认操作。</p>
<p>　　● 若<code>handler</code>是用户定义的函数
(称为<strong>信号处理程序</strong>)
的地址，只要进程接收到编号为<code>signum</code>的信号，就会调用该程序。通过把处理程序的地址传递给函数<code>signal()</code>从而改变其默认操作，称为<strong>设置信号处理程序</strong>。调用信号处理程序称为<strong>捕获信号</strong>。执行信号处理程序称为<strong>处理信号</strong>。</p>
<p>　　当进程捕获编号为<code>k</code>的信号时，会调用对应的信号处理程序并将1个整数参数设置为<code>k</code>，该参数允许同一处理程序捕获不同类型的信号。</p>
<p>　　当程序执行<code>return</code>语句时，控制权通常会转移给控制流中进程被信号中断处的指令，在某些系统中，被中断的系统调用会立即返回错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* SIGINT的信号处理程序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Cought SIGINT\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 设置信号处理程序 */</span></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, sigint_handler) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待接收信号 */</span></span><br><span class="line">    pause();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会捕获键盘输入Ctrl+C时发送的信号SIGINT，然后将其默认操作改为输出1条消息再终止该进程。</p>
<img src="/2023/06/17/computer-systems-a-programmer's-perspective-3e-chpt-8/signal_handler_can_be_interrupted_by_other_signal_handlers.svg" class="" title="signal_handler_can_be_interrupted_by_other_signal_handlers">
<p>　　信号处理程序可以被其他信号处理程序中断。在这个示例中，处理程序<code>S</code>和<code>T</code>都是信号处理程序。首先，主程序捕获到信号，信号会中断主程序，将控制权转移给处理程序<code>S</code>。处理程序<code>S</code>运行时，主程序捕获了另一个不同的信号，该信号会中断处理程序<code>S</code>，将控制权转移到处理程序<code>T</code>。从处理程序<code>T</code>返回时，处理程序<code>S</code>从它被中断的地方继续执行。最后，从处理程序<code>S</code>返回，将控制权转移给主程序，主程序从它被中断的地方继续执行。</p>
<h4 id="阻塞和解除阻塞信号">8.5.3 阻塞和解除阻塞信号</h4>
<p>　　Linux提供了隐式和显式的信号阻塞机制。</p>
<p>　　●
隐式阻塞机制就是内核默认阻塞与当前信号处理程序正在处理的信号的类型相同的所有待处理的信号。例如，程序捕获了信号<code>s</code>，当前正在运行信号处理程序<code>S</code>，若该进程收到了另一个信号<code>s</code>，则刚接收的<code>s</code>会变成待处理，并且在从<code>S</code>返回后才会被接收。</p>
<p>　　●
应用程序可以使用函数<code>sigprocmask()</code>及其辅助函数显式地阻塞和解除阻塞指定的信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下函数都是成功则返回0，出错则返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>; <span class="comment">/* 若是成员则返回1，不是则返回0，出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>sigprocmask()</code>会改变当前阻塞的信号集合。具体的行为取决于<code>how</code>的值：</p>
<p>　　●
<code>SIG_BLOCK</code>表示将<code>set</code>中的信号添加到<code>blocked</code>位向量。</p>
<p>　　●
<code>SIG_UNBLOCK</code>表示从<code>blocked</code>位向量中删除<code>set</code>中的信号。</p>
<p>　　●
<code>SIG_SETMASK</code>表示将<code>set</code>赋值给<code>blocked</code>位向量。</p>
<p>　　若<code>oldset</code>非空，则其中保存着<code>blocked</code>位向量的上一个值。</p>
<p>　　函数<code>sigemptyset()</code>会初始化<code>set</code>为空集合。函数<code>sigfillset()</code>会把每个信号都添加到<code>set</code>。函数<code>sigaddset()</code>会把编号为<code>signum</code>的信号添加到<code>set</code>。函数<code>sigdelset()</code>会从<code>set</code>中删除编号为<code>signum</code>的信号。函数<code>sigismember()</code>会判断编号为<code>signum</code>的信号是否在<code>set</code>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sigset_t</span> mask, prev_mask;</span><br><span class="line"></span><br><span class="line">Sigemptyset(&amp;mask);</span><br><span class="line">Sigaddset(&amp;mask, SIGINT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 阻塞信号SIGINT并保存blocked位向量的上一个值 */</span></span><br><span class="line">Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不会被信号SIGINT中断的代码段 */</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复blocked位向量的上一个值，解除阻塞信号SIGINT */</span></span><br><span class="line">Sigprocmask(SIG_SETMASK, &amp;prev_mask, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>　　这个示例会通过函数<code>sigprocmask()</code>来临时阻塞信号SIGINT。</p>
<h4 id="编写信号处理程序">8.5.4 编写信号处理程序</h4>
<p>　　信号处理程序的几个属性使得它们难以分析。首先，信号处理程序与主程序并发运行，共享全局变量，所以可能与主程序或其他处理程序相互干扰。其次，如何以及何时接收信号的规则是反常的。最后，不同系统有不同的信号处理语义。因此，编写信号处理程序时要保证函数尽可能简单，并且只调用<strong>异步信号安全</strong>的函数
(可重入或不能被信号处理程序中断)。</p>
<h5 id="安全的信号处理">8.5.4.1 安全的信号处理</h5>
<p>　　信号处理程序中调用函数<code>printf()</code>和<code>sprintf()</code>是异步信号不安全的，只能使用函数<code>write()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 通过标准输出来输出字符串，若成功则返回字节数，若出错则返回-1 */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> write(STDOUT_FILEND, s, sio_strlen(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过标准输出来输出长整型数，若成功则返回字节数，若出错则返回-1*/</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_putl</span><span class="params">(<span class="type">long</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    sio_ltoa(v, s, <span class="number">10</span>); <span class="comment">/* 基于K&amp;R的函数itoa */</span></span><br><span class="line">    <span class="keyword">return</span> sio_puts(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过标准输出来输出错误信息并退出 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sio_error</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    sio_puts(s);</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这里为了方便，用前缀<code>sio</code>表示函数是异步信号安全的I/O函数。例如，函数<code>sio_fun()</code>是I/O函数<code>fun()</code>的异步信号安全版本。第12行的函数<code>sio_ltoa()</code>基于能将整型数转换为字符串的函数<code>itoa()</code>。第20行的函数<code>_exit()</code>是函数<code>exit()</code>的异步信号安全版本。</p>
<p>　　许多Linux异步信号安全的函数都会在出错时设置<code>errno</code>。信号处理程序调用这样的函数可能干扰主程序中其他依赖<code>errno</code>的部分。解决方法是进入信号处理程序后先把<code>errno</code><span
style="background-color: yellow">保存</span>在某个局部变量中，在信号处理程序返回前恢复。若信号处理程序会调用函数<code>_exit()</code>终止该进程，则不必如此。</p>
<p>　　若信号处理程序和主程序或其他处理程序共享同一全局数据结构，则在访问该数据结构时，信号处理程序和主程序应该<span
style="background-color: yellow">暂时阻塞所有信号</span>。这是因为在主程序访问数据结构<code>d</code>通常需要一系列指令，若指令序列被需要访问<code>d</code>的信号处理程序中断，则信号处理程序可能会发现<code>d</code>的状态不一致，得到不可预知的结果。</p>
<p>　　假设信号处理程序和主函数共享全局变量<code>g</code>，信号处理程序更新<code>g</code>，主函数周期性地读<code>g</code>。对于编译器优化，主函数中<code>g</code>的值看似没变，所以使用缓存在寄存器中<code>g</code>的副来满足<code>g</code>的引用是安全的。若真如此，主函数将永远无法看到信号处理程序更新后的值。解决方法是用关键字<code>volatile</code>来修饰变量
(<code>volatile int g</code>)，该关键字指示编译器<span
style="background-color: yellow">不要缓存</span>该变量。同样，和访问全局数据结构相同，访问全局变量时也应该暂时阻塞所有信号。</p>
<p>　　在常见的信号处理程序设计中，信号处理程序会写全局标志来记录收到了信号。主程序周期性地读该标志，响应信号并清除该标志。整形数据类型<code>sig_atomic_t</code>保证<span
style="background-color: yellow">单个的读和写是原子 (不可中断)
的</span>。因此，这个全局标志可以声明为<code>volatile sig_atomic_t flag</code>。</p>
<h5 id="正确的信号处理">8.4.5.2 正确的信号处理</h5>
<p>　　每种类型的待处理信号最多只能有1个。因此，程序正在执行类型为<code>k</code>的信号的处理程序
(阻塞类型为<code>k</code>的信号)
时，若正好有2个类型为<code>k</code>的信号发送给该程序，第2个到达的信号会被直接丢弃。由此可得，不能用信号来对其他进程中发生的事件进行计数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sio_puts(<span class="string">&quot;Handler reaped child\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">    &#123;</span><br><span class="line">        Sio_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Sleep(<span class="number">1</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    <span class="type">char</span> buf[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGCHLD, handler) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建子进程 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello from child%d\n&quot;</span>, (<span class="type">int</span>)getpid());</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待终端输入并执行 */</span></span><br><span class="line">    <span class="keyword">if</span> ((n = read(STDIN_FILEND, buf, <span class="keyword">sizeof</span>(buf))) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent processing input\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    eixt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例在本质上类似shell和Web服务器等程序，基本结构是父进程创建一些子进程，这些子进程各自独立运行一段时间并终止。然后，父进程回收子进程以避免留下僵尸进程。为了不让父进程显式地等待子进程终止，这里使用了SIGCHLD信号处理程序来回收子进程。</p>
<h5 id="可移植的信号处理">8.4.5.3 可移植的信号处理</h5>
<p>　　不同Unix系统有不同的信号处理语义。</p>
<p>　　●
函数<code>signal()</code>的语义不同。有些较早版本的Unix系统在信号<code>k</code>被处理程序捕获后，会把信号<code>k</code>的默认操作重置。在这些系统上，每次处理程序运行后，必须调用函数<code>signal()</code>来显式地重新设置。</p>
<p>　　●
系统调用可以被中断。<code>read()</code>、<code>write()</code>和<code>accept</code>等系统调用会隐式地阻塞进程一段较长的时间，称为<strong>慢速系统调用</strong>。在有些较早版本的Unix系统中，当信号处理程序捕获到信号后，被中断的慢速系统调用在信号处理程序返回时不会再继续，而是立即返回错误条件并将<code>errno</code>设置为EINTR。在这些系统上，必须要包括手动重启被中断的系统调用的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　Posix标准定义了函数<code>sigaction()</code>来解决以上问题，该函数允许用户在设置信号的默认操作时，明确指定信号处理语义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">handler_t</span> *<span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">    action.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;action.sa_mask); <span class="comment">/* 阻塞信号处理程序正在处理的信号的类型 */</span></span><br><span class="line">    action.sa_flags = SA_RESTART; <span class="comment">/* 只要可能，重启中断的系统调用 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action))</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;Signal error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>sigaction()</code>应用并不广泛，因为它要求用户设置结构复杂的参数。更简洁的方法是函数<code>Signal()</code>，该函数最早由W.
Richard
Stevens提出，它是包装函数，会调用函数<code>sigaction()</code>，其调用方式与函数<code>signal()</code>相同。</p>
<p>　　函数<code>Signal()</code>会使用如下信号处理语义来设置信号处理程序：</p>
<p>　　● 只有与信号处理程序正在处理的信号的类型相同的信号会被阻塞。</p>
<p>　　● 信号不会排队。</p>
<p>　　● 只要可能，重启中断的系统调用。</p>
<p>　　●
一旦设置了信号处理程序，它会一直保持，直到<code>Signal()</code>带着<code>handler</code>参数为SIG_IGN或SIG_DFL被调用。</p>
<h4 id="同步流以避免并发漏洞">8.5.5 同步流以避免并发漏洞</h4>
<p>　　对于访问相同位置的并发流程序，流可能交错的数量与指令的数量呈指数关系。基本问题是以某种方式<span
style="background-color: yellow">同步</span>并发流来得到最大的可行的交错的集合，从而每个可行的交错都得到正确的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    Sigfillset(&amp;mask_all);</span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) <span class="comment">/* 回收子进程 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">        deletejob(pid); <span class="comment">/* 将子进程从作业列表删除 */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">    &#123;</span><br><span class="line">        Sio_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line"></span><br><span class="line">    Sigfillset(&amp;mask_all);</span><br><span class="line">    Signal(SIGCHLD, handler);</span><br><span class="line">    initjobs(); <span class="comment">/* 初始化作业列表 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) <span class="comment">/* 创建子进程 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            Execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);   <span class="comment">/* 父进程 */</span></span><br><span class="line">        addjob(pid);                               <span class="comment">/* 将子进程加入到作业列表 */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* 解除阻塞信号SIGCHLD */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了典型Unix
shell的结构。父进程通过全局作业列表中的条目来跟踪当前子进程
(每个作业1个条目)。函数<code>addjob()</code>和<code>deletejob()</code>分别向作业列表中添加和删除作业。</p>
<p>　　当父进程创建新子进程后，它就把该子进程添加到作业列表中。当父进程在SIGCHLD处理程序中回收终止的子进程时，就从作业列表删除该子进程。</p>
<p>　　这段代码看似正确，但可能会出现以下事件序列：</p>
<p>　　1)
父进程执行函数<code>fork()</code>时，内核调度会让新创建的子进程来执行该函数。</p>
<p>　　2)
在父进程能够再次运行前，子进程已终止并变为僵尸进程，使得内核发送信号SIGCHLD给父进程。</p>
<p>　　3)
父进程再次变为可运行但又在它执行前，内核发现到有未处理的信号SIGCHLD并通过在父进程中运行信号处理程序来接收该信号。</p>
<p>　　4)
信号处理程序回收终止的子进程并调用函数<code>deletejob()</code>，该函数什么也不做，因为子进程未添加到作业列表。</p>
<p>　　5)
信号处理程序运行完毕后，内核运行父进程，父进程从函数<code>fork()</code>返回，调用函数<code>addjob()</code>错误地把
(不存在的) 子进程添加到作业列表。</p>
<p>　　这种同步错误称为<strong>竞争</strong>。主函数中调用的函数<code>addjob()</code>和信号处理程序中调用的函数<code>deletejob()</code>之间存在竞争。若函数<code>addjob()</code>竞争获胜，则程序会正确运行；否则，程序出错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line"></span><br><span class="line">    Sigfillset(&amp;mask_all);</span><br><span class="line">    Sigemptyset(&amp;mask_one);</span><br><span class="line">    Sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line">    Signal(SIGCHLD, handler);</span><br><span class="line">    initjobs(); <span class="comment">/* 初始化作业列表 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); <span class="comment">/* 阻塞信号SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>)                      <span class="comment">/* 创建子进程 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* 解除阻塞信号SIGCHLD */</span></span><br><span class="line">            Execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);   <span class="comment">/* 父进程 */</span></span><br><span class="line">        addjob(pid);                               <span class="comment">/* 将子进程加入到作业列表 */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* 解除阻塞信号SIGCHLD */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是解决竞争的方法之一，在调用函数<code>fork()</code>前阻塞信号SIGCHLD，然后调用函数<code>addjob()</code>，最后取消阻塞该信号，这样保证在子进程添加到作业列表后回收该子进程。子进程继承了父进程的<code>blocked</code>位集合，所以在调用函数<code>execve()</code>前，必须解除子进程中阻塞的信号SIGCHLD。</p>
<h4 id="显式地等待信号">8.5.6 显式地等待信号</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>sigsuspend()</code>会暂时用参数<code>mask</code>替换当前<code>blocked</code>位集合，然后挂起该进程，直到收到处理操作是终止或运行信号处理程序的信号。若收到的信号的处理操作是终止，则进程会直接终止；若收到的信号的处理操作是运行信号处理程序，则会从信号处理程序返回到函数<code>sigsuspend()</code>，然后再从函数<code>sigsuspend()</code>返回，最后将<code>blocked</code>位集合恢复到调用<code>sigsuspend()</code>时的状态。</p>
<p>　　函数<code>sigsuspend()</code>等价于以下的代码的原子版本：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sigprocmask(SIG_SETMASK, &amp;mask, &amp;prev);</span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>　　原子属性消除了潜在的竞争，即在函数<code>sigprocmask()</code>后和<code>pause()</code>前收到信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    pid = Waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line"></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);</span><br><span class="line">    Signal(SIGINT, sigint_handler);</span><br><span class="line">    Sigemptyset(&amp;mask);</span><br><span class="line">    Sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); <span class="comment">/* 阻塞信号SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 等待接收信号SIGCHLD */</span></span><br><span class="line">        pid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pid)</span><br><span class="line">        &#123;</span><br><span class="line">            sigsuspend(&amp;prev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>); <span class="comment">/* (可选) 解除阻塞信号SIGCHLD */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，每次调用函数<code>sigsuspend()</code>前，都会阻塞信号SIGCHLD。函数<code>sigsuspend()</code>会暂时取消阻塞信号SIGCHLD，然后休眠，直到父进程捕获信号。在返回前，它会恢复之前的<code>blocked</code>位集合，然后再阻塞信号SIGCHLD。由于父进程捕获的信号可能是SIGCHLD，这里可以解除阻塞信号SIGCHLD，这对于有后台作业需要回收的shell可能有用。</p>
<h3 id="非本地跳转">8.6 非本地跳转</h3>
<p>　　C语言提供了称为<strong>非本地跳转</strong>的用户级异常控制流形式，它将控制权直接从某个函数转移给其他正在执行的函数，而不需要经过正常的调用/返回过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>; <span class="comment">/* 返回0 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savesigs)</span>; <span class="comment">/* 返回非0 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> retval)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>setjmp()</code>和<code>longjmp()</code>提供非本地跳转。函数<code>setjmp()</code>会在<code>env</code>缓冲区中保存当前<strong>调用环境</strong>
(包括PC、栈指针和通用目的寄存器)，以供后面的函数<code>longjmp()</code>使用。函数<code>setjmp()</code>的返回值<span
style="background-color: yellow">不能</span>用于赋值，但可以用于<code>switch</code>和<code>if</code>语句的判断。函数<code>longjmp()</code>会从<code>env</code>缓冲区中恢复调用环境并触发从最近1次初始化<code>env</code>的函数<code>setjmp()</code>调用的返回，然后函数<code>setjmp()</code>返回并带有非0的返回值<code>retval</code>。</p>
<p>　　函数<code>setjmp()</code>即使被调用1次，也会返回多次，调用函数<code>setjmp()</code>并将调用环境保存在缓冲区<code>env</code>时会返回1次，之后每个对应的函数<code>longjmp()</code>调用也会返回1次。函数<code>longjmp()</code>无论被调用多少次，都不会返回。</p>
<p>　　函数<code>longjmp()</code>允许其跳过所有中间调用的特性可能会产生意外的结果，例如，某些中间函数调用涉及了数据结构的释放，因为这些代码被跳过，所以会产生内存泄漏。</p>
<p>　　非本地跳转的重要应用之一就是允许从多层嵌套的函数调用中立即返回，通常是由于检测到错误。若在多层嵌套的函数调用中发现了错误，则可以使用非本地跳转直接返回到普通的本地化错误处理程序，而非费力地展开调用栈。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">jmp_buf buf;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> error1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> error2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>, <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (setjmp(buf))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        foo();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Detected an error1 condition in foo\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Detected an error2 condition in foo\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (error1)</span><br><span class="line">    &#123;</span><br><span class="line">        longjmp(buf, <span class="number">1</span>);</span><br><span class="line">        bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (error2)</span><br><span class="line">    &#123;</span><br><span class="line">        longjmp(buf, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，主函数会先调用函数<code>setjmp()</code>以保存当前的调用环境，然后调用函数<code>foo()</code>，函数<code>foo()</code>调用函数<code>bar()</code>。若函数<code>foo()</code>和<code>bar()</code>出错，则立即通过函数<code>longjmp()</code>从函数<code>setjmp()</code>返回。函数<code>setjmp()</code>的非0返回值指明了错误类型，可以做出相应的处理。</p>
<p>　　非本地跳转的另一个重要应用就是使信号处理程序跳转到特殊的代码位置，而非返回到信号到达时指令被中断的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sigjmp_buf buf;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    siglongjmp(buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sigsetjmp(buf, <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Signal(SIGINT, handler);</span><br><span class="line">        Sio_puts(<span class="string">&quot;starting\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Sio_puts(<span class="string">&quot;restarting\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sleep(<span class="number">1</span>);</span><br><span class="line">        Sio_puts(<span class="string">&quot;processing...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* 函数无法运行到异步信号不安全的exit函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，当键盘输入Ctrl+C时，会用信号和非本地跳转来实现软重启。函数<code>sigsetjmp()</code>和<code>setlongjmp()</code>是函数<code>setjmp()</code>和<code>longjmp()</code>的可供信号处理程序使用的版本。为了避免竞争，必须在调用函数<code>sigsetjmp()</code>之后设置信号处理程序。其次，函数<code>sigsetjmp()</code>和<code>siglongjmp()</code>不是异步信号安全的函数，因为函数<code>siglongjmp()</code>可以跳转到任意代码。因此，应该在<code>siglongjmp()</code>可达的代码中仅调用异步信号安全的函数。</p>
<p>　　当程序首次启动，对函数<code>sigsetjmp()</code>的初次调用会保存调用环境和信号的上下文
(包括<code>pending</code>和<code>blocked</code>位向量)。然后，主函数进入无限处理循环。当键盘输入Ctrl+C时，内核会发送信号SIGINT给该进程，该进程捕获信号。信号处理程序会执行非本地跳转，回到主函数的入口点。当运行该程序时，输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./restart</span><br><span class="line">starting</span><br><span class="line">processing...</span><br><span class="line">processing...</span><br><span class="line">Ctrl+C</span><br><span class="line">restarting</span><br><span class="line">processing...</span><br><span class="line">Ctrl+C</span><br><span class="line">restarting</span><br><span class="line">processing...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第6章 存储器层次结构</title>
    <url>/2023/04/22/computer-systems-a-programmer&#39;s-perspective-3e-chpt-6/</url>
    <content><![CDATA[<p>　　计算机的成功很大程度上源于存储技术的进步。早期的计算机只有几千字节的随机访问存储器。最早的IBM
PC没有磁盘，1982年推出的IBM
PC-XT才有10MB的磁盘。到2015年，常规计算机的磁盘容量是IBM
PC-XT的30万倍，而且磁盘容量以每2年加倍的速度增长。</p>
<p>　　存储器层次结构的本质是上一级存储器作为下一级存储器的缓存。每1级都需要管理逻辑，包括划分缓存、在不同层级之间传输块和判断是否命中及后续处理。管理逻辑可以是硬件、软件或两者的结合。大多数情况下，缓存都是自动运行的，无需程序具体或显式的操作。</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr>
<th>存储器类型</th>
<th>存储内容</th>
<th>位置</th>
<th>延迟 (时钟周期数)</th>
<th>管理者</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU寄存器</td>
<td>4B或8B的字</td>
<td>芯片上的CPU寄存器</td>
<td>0</td>
<td>编译器</td>
</tr>
<tr>
<td>TLB</td>
<td>地址转换</td>
<td>芯片上的TLB</td>
<td>0</td>
<td>硬件存储管理单元</td>
</tr>
<tr>
<td>L1缓存</td>
<td>64B块</td>
<td>芯片上的L1缓存</td>
<td>4</td>
<td>硬件</td>
</tr>
<tr>
<td>L2缓存</td>
<td>64B块</td>
<td>芯片上的L2缓存</td>
<td>10</td>
<td>硬件</td>
</tr>
<tr>
<td>L3缓存</td>
<td>64B块</td>
<td>芯片上的L3缓存</td>
<td>50</td>
<td>硬件</td>
</tr>
<tr>
<td>虚拟内存</td>
<td>4KB页</td>
<td>内存</td>
<td>200</td>
<td>硬件和OS</td>
</tr>
<tr>
<td>缓冲区缓存</td>
<td>部分文件</td>
<td>内存</td>
<td>200</td>
<td>OS</td>
</tr>
<tr>
<td>磁盘缓存</td>
<td>磁盘扇区</td>
<td>磁盘控制器</td>
<td>100000</td>
<td>控制器硬件</td>
</tr>
<tr>
<td>网络缓存</td>
<td>部分文件</td>
<td>本地磁盘</td>
<td>10000000</td>
<td>NFS客户端</td>
</tr>
<tr>
<td>浏览器缓存</td>
<td>网页</td>
<td>本地磁盘</td>
<td>10000000</td>
<td>浏览器</td>
</tr>
<tr>
<td>网页缓存</td>
<td>网页</td>
<td>远程服务器磁盘</td>
<td>1000000000</td>
<td>网页代理服务器</td>
</tr>
</tbody>
</table>
<p>　　早期计算机的存储器层次结构只有3级，即CPU寄存器、内存和磁盘。随着CPU和内存之间的存取速度差距的增加，系统设计者不得不在寄存器文件和内存之间加入SRAM缓存存储器
(L1缓存)，L1缓存的存取速度与寄存器的差不多。之后又在L1缓存和内存之间加入L2缓存，在L2缓存和内存之间加入L3缓存。</p>
<p>　　只存储指令的缓存称为<strong>指令缓存</strong>，只存储数据的缓存称为<strong>数据缓存</strong>。同时存储指令和数据的缓存称为<strong>统一缓存</strong>。</p>
<p>　　良好的计算机程序通常有良好的<strong>局部性</strong>，即倾向于引用<span
style="background-color: yellow">最近引用过的数据项附近的数据项</span>或<span
style="background-color: yellow">最近引用过的数据项本身</span>，这种倾向称为<strong>局部性原理</strong>。</p>
<p>　　局部性有<strong>时间局部性</strong>和<strong>空间局部性</strong>这2种形式。时间局部性好的程序中，被引用过1次的内存位置可能不久后再次被引用。空间局部性好的程序中，内存位置被引用后，可能不久后引用该位置附近的内存位置。</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumarray</span><span class="params">(<span class="type">int</span> a[n])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于函数<code>sumarray()</code>，变量<code>sum</code>每次迭代都会被引用，所以变量<code>sum</code>有良好的时间局部性。相反，变量<code>sum</code>没有空间局部性。对于数组<code>a</code>，其中的元素会按序被读取。数组<code>a</code>有良好的空间局部性和很差的时间局部性。总体而言，函数<code>sumarray()</code>有良好的局部性。</p>
<p>　　像函数<code>sumarray()</code>这样顺序访问数组的每个元素的模式称为<strong>步长为1的引用模式</strong>
(相对元素数据)，也称为<strong>顺序引用模式</strong>。同理，每次隔<span
class="math inline">\(k\)</span>个元素进行访问的模式就是<strong>步长为<span
class="math inline">\(k\)</span>的引用模式</strong>。一般情况下，随着步长的增加，空间局部性下降。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumarrayrows</span><span class="params">(<span class="type">int</span> a[m][n])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; i &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sumarraycols</span><span class="params">(<span class="type">int</span> a[m][n])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; i &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于引用多维数组的程序，步长会成为问题。函数<code>sumarrayrows()</code>按照<span
style="background-color: yellow">优先顺序</span>读数组元素，即先读第1行的元素，再读第2行的元素，依此类推，它有良好的空间局限性。函数<code>sumarraycols()</code>并非按照优先顺序的方式，使用的是步长为<span
class="math inline">\(n\)</span>的引用模式，所以它的空间局部性较差。</p>
<p>　　程序从存储系统读数据的速率称为<strong>读吞吐量</strong>或<strong>读带宽</strong>。若程序在<span
class="math inline">\(s\)</span>秒内读<span
class="math inline">\(n\)</span>字节，则读吞吐量为<span
class="math inline">\(\frac{n}{s}\)</span>，单位是MB/s。</p>
<p>　　<strong>存储器山</strong>是1个读带宽与时间和空间局部性的二维函数。</p>
<h3 id="存储技术">6.1 存储技术</h3>
<p>　　<strong>随机存取存储器</strong>分为静态和动态。SRAM比DRAM更快但更贵。SRAM用于CPU内外的缓存存储器，DRAM用于存储器和图形系统的帧缓冲区。常规桌面系统的SRAM的容量数量级是10MB，而DRAM的容量数量级可以达到1GB。</p>
<p>　　DRAM和SRAM在断电后会丢失信息，所以它们是<strong>易失</strong>的。<strong>非易失性存储器</strong>在断电后依然保存着信息。一类非易失性存储器是<strong>只读存储器</strong>，由于历史原因，虽然其中的部分类型即可读也可写，但是依然统称ROM。ROM按重编程
(写) 的次数和重编程所用的机制来区分。</p>
<p>　　●
<strong>可编程ROM</strong>只能被编程1次，其中的每个存储器单元都有<span
style="background-color: yellow">熔丝</span>，只能用大电流熔断1次。</p>
<p>　　●
<strong>可擦写可编程ROM</strong>有1个透明的石英窗口，允许光到存储单元。紫外线照射到窗口时，EPROM单元会置0。EPROM编程是通过把1写入EPROM的特殊设备完成的，它的擦除和重编程次数可以达到1000次。<strong>电可擦写PROM</strong>类似于EPROM，但无需物理上独立的编程设备，所以可以直接在印制电路卡上编程。EEPROM能编程的次数数量级可以达到<span
class="math inline">\(10^5\)</span>次。</p>
<p>　　另一类非易失性存储器是<strong>闪存</strong>，它基于EEPROM。<strong>固态硬盘</strong>是基于闪存的磁盘驱动器。</p>
<p>　　存储在ROM设备中的的程序称为<strong>固件</strong>。当计算机系统通电后，它会运行存储在ROM中的固件。一些系统中的固件中提供了少量基本I/O函数，例如，PC的BIOS例程。显卡和磁盘驱动控制器等复杂的设备也依赖固件来转换CPU的I/O请求。</p>
<p>　　不同的存储技术有不同的价格和性能折中，它们的价格和性能正在以截然不同的速度变化。SRAM、DRAM和磁盘的存取速度都滞后于CPU的存取速度，但SRAM的存取速度与CPU的存取速度的差距远小于其他两者的存取速度和CPU的存取速度的差距。</p>
<h4 id="随机存取存储器">6.1.1 随机存取存储器</h4>
<img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/inverted_pendulum.svg" class="" title="inverted_pendulum">
<p>　　SRAM将每个位存储在<strong>双稳态</strong>的存储器单元里，每个单元用六晶体管电路实现。六晶体管电路类似于倒转的钟摆，当钟摆在最左边或最右边时，它是稳定的。在其他任何地方，钟摆最终都会倒向一边。原则上，钟摆能在垂直位置无期限地保持平衡，但该状态是<strong>亚稳态</strong>的——最细微的扰动就会使它倒下且再也不会恢复到垂直状态。只有有电，它就会永远保持其值。即使有干扰扰乱电压，干扰消除后，电路会恢复到稳定值。</p>
<p>　　DRAM将每个位存储为给电容充电，该电容很小，通常只有<span
class="math inline">\(30\times
10^{-15}\)</span>F。DRAM可以制造得很密集——每个单元由1个电容和1个存取晶体管组成。与SRAM不同，DRAM存储单元的电容的电压被干扰后，就不会再恢复。暴露在光线下会导致电容的电压改变。实际上，数码照相机和摄像机中的传感器本质上就是DRAM单元阵列。</p>
<p>　　很多原因会导致漏电，使得DRAM单元在10~100ms内失去电荷。不过计算机运行的时钟周期是以ns来衡量的，所以相对而言这个保持时间是比较长的。存储器系统必须周期性地读写数据来刷新。有些系统会使用纠错码，其中的字的编码会多出几位，类似于CRC。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 13%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>每位晶体管数</th>
<th>相对存取时间</th>
<th>持续</th>
<th>敏感</th>
<th>相对花费</th>
<th>应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SRAM</td>
<td>6</td>
<td>1×</td>
<td>是</td>
<td>否</td>
<td>1000×</td>
<td>缓存存储器</td>
</tr>
<tr>
<td>DRAM</td>
<td>1</td>
<td>10×</td>
<td>否</td>
<td>是</td>
<td>1×</td>
<td>存储器和帧缓冲区</td>
</tr>
</tbody>
</table>
<h5 id="dram">6.1.1.1 DRAM</h5>
<p>　　DRAM芯片中的所有单元 (位) 被分为<span
class="math inline">\(d\)</span>个<strong>超单元</strong>，每个超单元都由<span
class="math inline">\(w\)</span>个DRAM单元组成。<span
class="math inline">\(d\times w\)</span>的DRAM共存储了<span
class="math inline">\(d\times w\)</span>位信息。超单元组织为<span
class="math inline">\(r\)</span>行<span
class="math inline">\(c\)</span>列的长方形阵列，其中<span
class="math inline">\(r\times c=d\)</span>。每个超单元有形如<span
class="math inline">\((i,j)\)</span>的地址，其中<span
class="math inline">\(i\)</span>表示行，<span
class="math inline">\(j\)</span>表示列。</p>
<p>　　DRAM阵列元素实际上并没有标准的名称，计算机架构师称之为
"单元"，表示DRAM存储单元。电路设计师称之为
"字"，表示存储器的1个字。这里为了避免混淆，采用了无歧义的术语
"超单元"。</p>
<img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/reading_the_contents_of_a_dram_supercell.svg" class="" title="reading_the_contents_of_a_dram_supercell">
<p>　　每个DRAM芯片都连接到称为<strong>存储控制器</strong>的电路，该电路可以单次将<span
class="math inline">\(w\)</span>位传入或传出DRAM芯片。为了读出超单元<span
class="math inline">\((i,j)\)</span>的内容，存储控制器先将行地址<span
class="math inline">\(i\)</span>发送给DRAM，再将列地址<span
class="math inline">\(j\)</span>发生给DRAM。最后，DRAM响应对应的内容。内容通过称为<strong>引脚</strong>的外部连接器传入或传出芯片。每个引脚携带1位的信号。行地址<span
class="math inline">\(i\)</span>称为<strong>行地址选通脉冲</strong>请求，列地址<span
class="math inline">\(j\)</span>称为<strong>列地址选通脉冲</strong>请求。</p>
<p>　　图中展示了从<span
class="math inline">\(16\times8\)</span>的DRAM中读出超单元<span
class="math inline">\((2,1)\)</span>的过程。在图a中，存储控制器发送行地址2，DRAM将行2的整个内容都复制到内部行缓冲区。在图b中，存储控制器发送列地址1，DRAM复制内部行缓存区中的超单元<span
class="math inline">\((2,1)\)</span>中的8位并发将其发送给存储控制器。这里有2组引脚，即8个数据引脚
(能传输1个字节) 和2个地址引脚
(能携带2位的行或列超单元地址)。其他携带控制信息的引脚没有显示出来。</p>
<p>　　若需要<span
style="background-color: yellow">连续读取超单元同一行</span>的<span
class="math inline">\(n\)</span> (<span
class="math inline">\(n&gt;1\)</span>) 个数据：</p>
<p>　　●
对于DRAM，存储控制器会发送RAS/CAS请求，将指定行复制到行缓冲区，读取指定的数据并丢弃其他数据，然后重复这个过程<span
class="math inline">\(n-1\)</span>次。</p>
<p>　　●
对于<strong>快页模式DRAM</strong>，存储控制器会发送RAS/CAS请求，将指定行复制到行缓冲区，然后读取指定数据。剩余<span
class="math inline">\(n-1\)</span>次<span
style="background-color: yellow">只会发送CAS请求</span>，读取指定数据，只有在最后1次读取时，才会丢弃其他数据。<strong>扩展数据输出DRAM</strong>是FPM
DRAM的增强型，允许各个CAS信号在时间上更紧密。</p>
<p>　　DRAM、FPM DRAM和DEO
DRAM都是异步，因为它们用一组显式控制信号来与存储控制器通信。<strong>同步DRAM</strong>用驱动存储控制器的同一外部时钟信号的上升沿代替了很多控制信号。这里不会深入细节，最终效果是SDRAM能比异步的存储器更快地输出超单元的内容。<strong>双数据率同步DRAM</strong>是SDRAM的增强型，它使用了2个时钟沿作为控制信号，从而使DRAM的速率翻倍。DDR
SDRAM按预取缓冲区 (可增加有效带宽) 容量区分类型，分别是DDR (2位)、DDR2
(4位) 和DDR3 (8位)。</p>
<p>　　<strong>显存</strong>用于图形系统的帧缓冲区，它类似于FPM
DRAM，但有2个不同。第1个不同是VRAM的输出是通过按序移动内部缓冲区的全部内容得到，第2个不同是VRAM允许并行地读写。因此，系统可以在写下一次更新的值的同时，用帧缓冲区的像素刷新屏幕
(读)。</p>
<p>　　直到1995年，大多数计算机都是使用FPM DRAM。1996到1999年，EDO
DRAM主导市场，FPM
DRAM几乎消失。SDRAM最早出现在1995年的高端系统中，到2002年，大多数计算机都是使用SDRAM和DDR
DRAM。到2010年，大多数服务器和桌面系统都是使用DDR3 SDRAM。</p>
<h5 id="存储模块">6.1.1.2 存储模块</h5>
<p>　　DRAM芯片封装在<strong>存储模块</strong>中，它插在主板的扩展槽上。Core
i7系统使用的240个引脚的<strong>双列直插存储模块</strong>以64位为块的形式将数据传入或传出存储控制器。</p>
<img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/reading_the_contents_of_a_memory_module.svg" class="" title="reading_the_contents_of_a_memory_module">
<p>　　这里用8个<span
class="math inline">\(8M\times8\)</span>的DRAM芯片来存储64MB，这些芯片编号为0~7。每个超单元存储内存的1B。对应超单元地址<span
class="math inline">\((i,j)\)</span>的8个超单元表示内存中字节地址A的64位字，其中DRAM0表示第1B，DRAM1表示第2B，依此类推。</p>
<p>　　当读取内存地址A的1个字时，存储控制器会将地址转换为超单元地址<span
class="math inline">\((i,j)\)</span>并发送到存储模块，然后存储模块将<span
class="math inline">\(i\)</span>和<span
class="math inline">\(j\)</span>广播到每个DRAM。每个DRAM输出超单元地址<span
class="math inline">\((i,j)\)</span>的1B，模块中的电路收集这些输出并合并成64位的字，最后响应给存储控制器。</p>
<p>　　将多个存储模块连接到存储控制器，能聚合成内存。在这种情况下，当控制器收到地址A时，控制器会选择包含A的模块，将A转换为该模块的超单元地址<span
class="math inline">\((i,j)\)</span>并发送给该模块。</p>
<h5 id="访问内存">6.1.1.3 访问内存</h5>
<p>　　数据通过称为<strong>总线</strong>的共享电子电路在CPU和DRAM之间传输。每次CPU和内存之间的数据传输都是通过称为<strong>总线事务</strong>的一系列步骤来完成的。<strong>读事务</strong>会将数据从内存传输到CPU，<strong>写事务</strong>会将数据从CPU传输到内存。</p>
<p>　　总线是一组并行的导线，能携带地址、数据和控制信号。根据总线的设计，数据和地址信号可以共享同一组总线，也可以使用不同的总线。2个及以上的设备可以共享同一总线，控制线携带的信号会同步事务并标识当前正在执行的事务的类型。第1章提到过，连接CPU和I/O桥接器的是<strong>系统总线</strong>，连接I/O桥接器和内存的是<strong>内存总线</strong>。</p>
<p>　　不同厂商的总线体系结构不同。部分Intel系统使用称为<strong>北桥</strong>和<strong>南桥</strong>的芯片组分别将CPU连接到内存和I/O设备。早期的Pentium和Core
2中，<strong>前端总线</strong>将CPU连接到北桥。AMD将FSB替换为<span
style="background-color: yellow">超传输</span>互联，Intel Core
i7使用的是<span
style="background-color: yellow">快速通道</span>互联。</p>
<img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/memory_read_transaction_for_a_load_operation.svg" class="" title="memory_read_transaction_for_a_load_operation">
<p>　　这是加载操作<code>movq A, %rax</code>的内存读事务，<span
style="background-color: yellow">总线接口</span>在总线上发起读事务。首先，CPU将地址放到系统总线上，I/O桥将信号传输到内存总线。然后，内存侦测到地址信号，从内存总线上读地址，从DRAM取出对应的字并放回内存总线。I/O桥将内存信号转换为系统总线信号，沿着系统总线传输。最后，CPU侦测到系统总线上的数据，从总线上读数据并复制到对应的寄存器。</p>
<img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/memory_write_transaction_for_a_store_operation.svg" class="" title="memory_write_transaction_for_a_store_operation">
<p>　　这是存储操作<code>movq %rax, A</code>的内存写事务，<span
style="background-color: yellow">CPU</span>发起写事务。首先，CPU将地址放到系统总线上，内存从内存总线上读地址并等待数据到达。然后，CPU从寄存器中复制数据到系统总线。最后，内存从内存总线上读数据并存储到DRAM中。</p>
<h4 id="磁盘">6.1.2 磁盘</h4>
<p>　　<strong>磁盘</strong>是用于保存大量数据的存储设备，容量数量级可达到1TB，而基于RAM的存储器的容量数量级只能达到1GB。读磁盘的速度数量级是1ms，比读DRAM慢10万倍，比读SRAM慢100万倍。为了区别基于闪存的SSD，磁盘也称为<strong>旋转磁盘</strong>。</p>
<img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/disk_geometry.svg" class="" title="disk_geometry">
<p>　　磁盘由<strong>盘片</strong>构成。每个盘片的双面称为<strong>表面</strong>，表面覆盖着磁性记录材料。盘片中央的<strong>主轴</strong>让盘片以固定的速率旋转
(通常是5400~15000转每分钟)。</p>
<p>　　如图a所示，每个盘面由一组称为<strong>磁道</strong>的同心圆组成。每个磁道划分为一组扇区，每个扇区包含等量的数据位
(通常是512B)，这些数据编码在扇区的磁性材料中。扇区由<strong>间隙</strong>分隔，间隙存储表示扇区的格式化位。如图b所示，磁盘通常包含若干个盘片并封装在密封的容器中，整个设备称为<strong>磁盘驱动器</strong>，简称磁盘。</p>
<p>　　磁盘制造商用术语<strong>柱面</strong>来描述多个盘片驱动器的构造，即所有盘面上到主轴中心的距离相等的磁道集合。例如，若某个驱动器有3个盘片，每个盘面上磁道的编号都一致，柱面<span
class="math inline">\(k\)</span>就是6个磁道<span
class="math inline">\(k\)</span>的集合。</p>
<p>　　磁盘容量由<strong>记录密度</strong>、<strong>磁道密度</strong>和<strong>面密度</strong>决定。记录密度是磁道1英寸的段中可以存储的位数。磁道密度是盘片中心半径1英寸的段内磁道数。面密度是记录密度和磁道密度的乘积。
<span class="math display">\[
磁盘容量=\frac{字节数}{扇区}\times\frac{平均扇区数}{磁道}\times\frac{磁道数}{表面}\times\frac{表面数}{盘片}\times\frac{盘片数}{磁盘}
\]</span>
　　磁盘制造商通过提高面密度来增加容量。最初的磁盘的面密度很低，每个磁道分为数量相同的扇区，扇区的数量由最靠近主轴的磁道的扇区数决定，所以越远离主轴的磁道的扇区的间隔越大。随着面密度的提高，扇区的间隙变得过于大。因此，现代大容量磁盘使用<strong>多区记录</strong>，即将柱面集合划分为称为<strong>记录区</strong>的不相交的子集合。每个区包含1组连续的柱面，这些柱面的所有磁道的扇区数都相同。</p>
<h5 id="磁盘操作">6.1.2.1 磁盘操作</h5>
<img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/disk_dynamics.svg" class="" title="disk_dynamics">
<p>　　如图a所示，磁盘用<strong>读/写磁头</strong>来读写存储在磁性盘面的位，磁头连接到<strong>传动臂</strong>的一端，通过运动轨迹呈圆弧的方式移动传动臂，驱动器可以将磁道定位在盘面上的任何磁道上，这样的机械运动称为<strong>寻道</strong>。一旦磁头定位到指定的磁道，磁道上的位通过其下方时，磁头可以感知到该位的值
(读该位)。如图b所示，对于有多个盘片的磁盘，每个盘面都有独立的磁头。磁头垂直排列并一致移动。在任何时刻，所有的磁头都位于同一柱面。</p>
<p>　　磁头和盘面之间有1层大约0.1ms的气垫，磁头的速度大约为80km/h。在这样小的间隙内，磁头碰到盘面上的灰尘都会停止并撞到盘面上，这种情况称为<strong>磁头碰撞</strong>。因此，磁盘是密封包装的。</p>
<p>　　为了读取指定扇区的内容，传动臂会先将磁头定位到指定扇区所在的磁道上方。移动传动臂所需的时间称为<strong>寻道时间</strong>。寻道时间<span
class="math inline">\(T_{seek}\)</span>取决于磁头之前的位置和传动臂在盘面上的移动速度。现代驱动器中的平均寻道时间<span
class="math inline">\(T_{avg \enspace
seek}\)</span>是通过对几千次对随机扇区的寻道取平均值，通常是3~9ms。单次寻道的最大时间<span
class="math inline">\(T_{max\enspace seek}\)</span>高达20ms。</p>
<p>　　一旦磁头到达指定扇区所在的磁道的上方，驱动器会等待指定扇区的第1个位到达磁头下方，这段时间称为<strong>旋转延迟</strong>。旋转延迟取决于磁盘的旋转速度和当磁头到达指定扇区所在的磁道时盘面的位置。在最差的情况下，磁盘刚错过指定扇区，必须等待磁盘旋转1整圈
(需要<span class="math inline">\(T_{max\enspace
rotaion}\)</span>)。平均旋转时间<span
class="math inline">\(T_{avg\enspace rotation}\)</span>是<span
class="math inline">\(T_{max\enspace rotation}\)</span>的一半。 <span
class="math display">\[
T_{max\enspace rotation}=\frac{1}{RPM}\times\frac{60s}{1min}
\]</span>
　　当指定扇区的第1个位到磁头下方时，驱动器就能开始访问该扇区的内容。扇区的<strong>传输时间</strong>取决于旋转速度和每条磁道的平均扇区数。
<span class="math display">\[
T_{avg\enspace
transfer}=\frac{1}{RPM}\times\frac{1磁道}{每条磁道平均扇区数}\times\frac{60s}{1min}
\]</span>
　　扇区内容的平均访问时间为平均寻道时间、平均旋转延迟和平均传输时间之和。</p>
<p>　　例如，某个磁盘的旋转速率为7200RPM，<span
class="math inline">\(T_{avg\enspace
seek}\)</span>为9ms，每条磁道平均有400个扇区。 <span
class="math display">\[
\begin{align}
T_{access}&amp;=T_{avg\enspace seek}+T_{avg\enspace
rotation}+T_{avg\enspace transfer}\\[3px]
&amp;=9ms+\frac{1}{2}\times\frac{60s}{1min\times7200RPM}\times1000ms/s+\frac{60s}{1min\times7200RPM}\times\frac{1磁道}{400扇区}\times1000ms/s\\[3px]
&amp;\approx9ms+4ms+0.02ms\\[3px]
&amp;=13.02ms
\end{align}
\]</span>
　　从这个示例中可以看出，存取时间中寻道时间和旋转延迟的占比极高。由于寻道时间和旋转延迟大致相等，可以直接将寻道时间翻倍来估算存取时间。</p>
<p>　　访问SRAM中的64位字大约需要4ns，访问DRAM中的64位字大约需要60ns。因此，访问SRAM中的512B大约需要256ns，访问DRAM中的512B大约需要4μs，而访问磁盘中的512B大约需要10ms，所以磁盘的访问时间大约是SRAM的4万倍，DRAM的2500倍。</p>
<h5 id="逻辑磁盘块">6.1.2.2 逻辑磁盘块</h5>
<p>　　现代磁盘有多个盘面，每个盘面有不同的记录区。为了对操作系统隐藏这些细节，现代磁盘将其结构呈现为<span
class="math inline">\(B\)</span>个扇区大小的<strong>逻辑块</strong>的序列，其编号为0到<span
class="math inline">\(B-1\)</span>。磁盘封装中有称为<strong>磁盘控制器</strong>的硬件/固件设备，用于维护逻辑块号和实际
(物理) 磁盘扇区间的映射。</p>
<p>　　磁盘控制器必须先格式化磁盘才能访问磁盘中的数据。格式化过程包括<span
style="background-color: yellow">用标识扇区的信息填写扇区之间的间隙</span>、<span
style="background-color: yellow">识别任何有故障的柱面并禁用</span>以及<span
style="background-color: yellow">在每个区预留1组柱面备用</span>。当区域内有柱面出现故障时，会使用备用柱面。因此，磁盘制造商所说的格式化容量比最大容量小。</p>
<p>　　当操作系统执行从磁盘读数据到内存等I/O操作时，会发送命令到磁盘控制器来让其访问某个逻辑块号。控制器上的固件会查找快速表来将逻辑块号转换为
<span style="background-color: yellow">(盘面，磁道，扇区)</span>
的三元组，该三元组唯一地标识对应的物理扇区。控制器上的硬件会根据该三元组移动磁头到对应的柱面，等待扇区移动到磁头下，然后将磁头感知的数据收集到控制器的缓冲区，最后将该数据复制到内存。</p>
<p>　　例如，某个磁盘有4个盘面，扇区容量为512B，旋转速率为13000RPM，<span
class="math inline">\(T_{avg\enspace
seek}\)</span>为6ms，每个磁道平均有5000个扇区。显然，<span
class="math inline">\(T_{max\enspace
rotation}\approx4.61\)</span>ms。若某程序需要 (顺序) 从该磁盘中读文件
(需要10000个逻辑块) ：</p>
<p>　　●
当逻辑块到磁盘扇区的映射是顺序时，文件的第1个位到达磁头下方后，就无需再移动磁头。因此，磁头需要2整圈就能读取所有数据。
<span class="math display">\[
\begin{align}
T_{contiguous}&amp;\approx T_{avg\enspace seek}+T_{avg\enspace
rotation}+2\times T_{max\enspace rotation}\\[3px]
&amp;\approx6ms+2.30ms+9.22ms\\[3px]
&amp;=17.52ms
\end{align}
\]</span> 　　●
当逻辑块到磁盘扇区的映射是乱序时，每次读取新逻辑块时都要移动磁头。 <span
class="math display">\[
\begin{align}
T_{random}&amp;\approx (T_{avg\enspace seek}+T_{avg\enspace
rotation})\times10000\\[3px]
&amp;\approx(6ms+2.30ms)\times10000\\[3px]
&amp;=83s
\end{align}
\]</span></p>
<h5 id="io总线">6.1.2.3 I/O总线</h5>
<p>　　系统总线和内存总线都与CPU相关，但Intel的<strong>外围组件互连</strong>总线等I/O总线与CPU无关。虽然I/O总线比系统总线和内存总线慢，但它可以容纳多种第三方I/O设备。</p>
<p>　　●
<strong>通用串行总线</strong>是广泛使用的标准，用于连接各种外围I/O设备，例如键盘、鼠标、调制解调器、数码相机、手柄、打印件、外部磁盘驱动器和固态硬盘。USB控制器是连接到USB的设备的中转。USB
3.0的最大带宽为625MB/s。USB 3.1的最大带宽为1250MB/s。</p>
<p>　　● <strong>显卡</strong> (适配器)
包含负责代表CPU在显示器上显示像素的硬件和软件逻辑。</p>
<p>　　●
<strong>主机总线适配器</strong>通过特殊的<strong>主机总线接口</strong>定义的通信协议将若干个磁盘连接到I/O总线，最常用的磁盘接口就是<strong>小型计算机系统接口</strong>和<strong>串行高级技术附件</strong>。SCSI磁盘通常比SATA磁盘更快但也更贵。SCSI主机总线适配器
(简称SCSI控制器) 可以支持多个磁盘，而SATA适配器只能支持1个磁盘。</p>
<p>　　其他设备 (包括网络设配器)
可以通过将适配器插在主板上的扩展槽来连接到I/O总线，这些插槽提供了到总线的直接电路连接。</p>
<p>　　在PCI模型中，系统中的所有设备共享总线，同一时刻只能有1个设备访问这些线路。在现代系统中，共享的PCI总线已经被PCI
Express (PCEe)
总线取代，PCIe是一组高速串行、通过交换机连接的点到点链路，类似于以太网。PCI总线的最大吞吐量是533MB/s，PCIe总线的最大吞吐量为16GB/s。</p>
<img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/reading_a_disk_sector.svg" class="" title="reading_a_disk_sector">
<p>　　如同a所示，CPU通过<strong>内存映射I/O</strong>来向I/O设备发送命令。在包含内存映射I/O的系统中，地址空间中有为I/O设备通信通信保留的地址，这样的地址称为<strong>I/O端口</strong>。当设备连接到总线时，会关联
(映射) 到若干个端口。</p>
<p>　　若磁盘控制器映射的端口是<code>0xa0</code>，则CPU可能需要执行3条对地址<code>0xa0</code>的存储指令来发起对磁盘的读。第1条指令发送1个命令字来告诉CPU发起读和其他参数
(例如，当读完成时是否中断CPU)。第2条指令指明应该读的逻辑块号。第3条指令指明应该存储磁盘扇区内容的内存地址。</p>
<p>　　当CPU发起了读请求后，在磁盘执行读时，CPU还会进行其他工作。1GHz的CPU时钟周期为1ns，在磁盘执行读的16ms内，CPU可以执行1600万条指令。</p>
<p>　　如同b所示，磁盘控制器收到CPU的读命令后，会将逻辑块号转换为扇区地址并读其中的内容，然后将这些数据通过DMA的方式来将传输到内存。</p>
<p>　　若图c所示，DMA传输完成，磁盘扇区的内容安全地存储在内存中后，磁盘控制器通过给CPU发送中断信号来通知CPU
(中断会发信号到CPU芯片的1个外部引脚上)。这会导致CPU暂停当前工作，跳转到1个操作系统例程，该例程会记录I/O已经完成并将控制权交回给CPU中断的位置。</p>
<h4 id="固态硬盘">6.1.3 固态硬盘</h4>
<img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/ssd.svg" class="" title="ssd">
<p>　　SSD插在I/O总线上的标准磁盘插槽上
(通常是USB和SATA)，行为同其他硬盘相同，处理来自CPU的读写逻辑磁盘块的读写请求。SSD由若干个闪存芯片和<strong>闪存转换层</strong>组成，闪存芯片对应磁盘中的机械驱动，FTL是硬件/固件设备，对应磁盘中的磁盘控制器。读SSD的速度比写SSD的速度快，这是由底层闪存的基本属性决定。</p>
<p>　　1个闪存由<span
class="math inline">\(B\)</span>个块的序列组成，每个块有<span
class="math inline">\(P\)</span>页。通常，页是512B~4KB，块有32~128页
(16KB~512KB)。数据以页为单元读写。只有在页所属的块<strong>擦除</strong>
(块的所有位置1)
后，才能写该页。块擦除后，块中的每个页都可以直接写。大约写10万次后，块会<strong>磨损</strong>并无法使用。</p>
<p>　　擦除块需要较长的时间
(1ms级)，比访问页所需的时间高1个数量级。若需要写已包含数据的页<span
class="math inline">\(p\)</span> (不全是1)，必须先将<span
style="background-color: yellow">与该页同块</span>的其他所有包含有效数据的页复制到新
(擦除过的)
块。制造商已经在FTL中实现了复杂的逻辑来抵消写块的高昂代价和最小化写时内部副本的数量，但是随机写的速度还是不如随机读。</p>
<p>　　SSD由半导体存储器构成，没有可移动的部件，所以随机存取时间比磁盘快，能耗更低，更坚固。但是，SSD会磨损，FTL中的<strong>磨损均衡</strong>逻辑通过将擦除均匀分布在所有块来最大化每个块的使用寿命，实际使用寿命有好几年。此外，SSD每个字节的价格比磁盘的贵。</p>
<h3 id="存储器层次结构">6.2 存储器层次结构</h3>
<p>　　<strong>高速缓存</strong> (简称<strong>缓存</strong>)
是小而存取速度快的存储设备，它作为存储在更大更慢的设备中的数据对象的缓存区域。使用缓存的过程称为<strong>缓存</strong>。</p>
<img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/the_basic_principle_of_caching_in_a_memory_hierarchy.svg" class="" title="the_basic_principle_of_caching_in_a_memory_hierarchy">
<p>　　如图所示，<span
class="math inline">\(k+1\)</span>级存储器划分为连续的数据对象块，称为<strong>块</strong>。每个块都有唯一的地址或名称。块可以是固定大小
(大多数情况下)，也可以是可变大小的
(例如，存储在Web服务器上的HTML文件)。例如，图中<span
class="math inline">\(k+1\)</span>级存储器划分为16个固定的块，编号为0~15。</p>
<p>　　<span
class="math inline">\(k\)</span>级存储器也划分为块，块的容量同<span
class="math inline">\(k+1\)</span>级的相同。<span
class="math inline">\(k\)</span>级缓存中的块始终是<span
class="math inline">\(k+1\)</span>级块的某个子集的副本。例如，图中<span
class="math inline">\(k\)</span>级缓存有4个块，即块4、9、14和3的副本。</p>
<p>　　数据总是以块为<strong>传输单元</strong>在<span
class="math inline">\(k\)</span>级和<span
class="math inline">\(k+1\)</span>级之间复制。在存储器层次结构中，任何相邻的层级之间的块的容量是固定的，但其他层级之间的块的容量可以不同。例如，寄存器和L1缓存之间的块的容量通常是1个字，而L1缓存和L2缓存之间、L2缓存和L3缓存之间以及L3缓存和内存之间的块的数量级通常是10B。内存和本地磁盘间块的数量级通常是100B或1KB。层次结构中层级较低
(离CPU较远)
的设备的存取时间较长，所以用较大的块来弥补较长的存取时间。</p>
<p>　　当程序需要<span
class="math inline">\(k+1\)</span>级的某个数据对象<code>d</code>，会先在<span
class="math inline">\(k\)</span>级当前存储的块中查找。若<span
class="math inline">\(k\)</span>级缓存中有<code>d</code>
(称为<strong>缓存命中</strong>)，程序会直接从<span
class="math inline">\(k\)</span>级中读取<code>d</code>。相反，若<span
class="math inline">\(k\)</span>级缓存中没有<code>d</code>
(称为<strong>缓存未命中</strong>)，程序会从<span
class="math inline">\(k+1\)</span>级中读取<code>d</code>并在<span
class="math inline">\(k\)</span>级中缓存<code>d</code>。若<span
class="math inline">\(k\)</span>级缓存已满，则会用<code>d</code>覆盖其中1个块。</p>
<p>　　覆盖现存的块的过程称为<strong>替换</strong>或<strong>驱逐</strong>，被替换的块称为<strong>牺牲块</strong>，缓存的<strong>替换策略</strong>决定牺牲块。例如，随机替换策略会选择随机牺牲块，而<strong>最近最少使用</strong>策略会选择最后访问时间距今最长的块，<strong>最不常用使用</strong>策略会选择某个过去时间窗口内引用次数最少的块。所有策略都需要额外的硬件和时间，但是层级越低的缓存出现未命中后，其代价越高。</p>
<p>　　当<span class="math inline">\(k\)</span>级缓存从<span
class="math inline">\(k+1\)</span>级中读取<code>d</code>后，程序以后就能直接从<span
class="math inline">\(k\)</span>级读取<code>d</code>。例如，假设需要读图中<span
class="math inline">\(k+1\)</span>级的块12的某个数据对象，会先出现缓存未命中并直接在<span
class="math inline">\(k+1\)</span>级中读取块12。当<span
class="math inline">\(k\)</span>级中缓存块12后，块12会留在<span
class="math inline">\(k\)</span>级等待后续的访问。</p>
<p>　　若<span class="math inline">\(k\)</span>级缓存为空
(称为<strong>冷缓存</strong>)，任何数据对象的访问都会未命中，此类未命中称为<strong>强制未命中</strong>或<strong>冷未命中</strong>。冷未命中通常是暂时的，当多次访问存储器后，缓存会<strong>热身</strong>并进入稳定态，之后不会再出现冷未命中。</p>
<p>　　一旦出现缓存未命中，<span
class="math inline">\(k\)</span>级缓存必须执行<strong>放置策略</strong>，确定从<span
class="math inline">\(k+1\)</span>级取出的块放置的位置。最灵活的替换策略是允许来自<span
class="math inline">\(k+1\)</span>级的块存储在<span
class="math inline">\(k\)</span>级的任何位置。对于存储器层级结构中层级较高的缓存，该策略的成本很高，因为随机放置的块定位成本高。因此，通常使用更简单的放置策略，即将<span
class="math inline">\(k+1\)</span>级的特定块限制为<span
class="math inline">\(k\)</span>级的块的子集
(有时只有1个块)。例如，图中使用的放置策略是<span
style="background-color: yellow"><span
class="math inline">\(k+1\)</span>级的块<span
class="math inline">\(m\)</span>必须放置在<span
class="math inline">\(k\)</span>级的块<span
class="math inline">\(n\)</span> (<span
class="math inline">\(n=m\bmod4\)</span>) 中</span>，所以<span
class="math inline">\(k+1\)</span>级中的块0、4、8、12会映射到<span
class="math inline">\(k\)</span>级中的块0，<span
class="math inline">\(k+1\)</span>级中的块1、5、9、13会映射到<span
class="math inline">\(k\)</span>级中的块1，依此类推。</p>
<p>　　这种简单的放置策略会导致<strong>冲突未命中</strong>，即使有足够的空间来存储<span
class="math inline">\(k+1\)</span>的块，由于这些块映射到同一位置，缓存会一直未命中。例如，依次读<span
class="math inline">\(k+1\)</span>级的块0、块4，然后循环这个过程。</p>
<p>　　程序通常是按照一系列阶段 (例如，循环)
来执行，每个阶段会存取某个合理且相对固定的缓存块集，例如，嵌套的循环可能反复访问同一数组的元素。这个块集合称为该阶段的<strong>工作集</strong>。当工作集大小超过缓存容量时，会出现<strong>容量未命中</strong>。</p>
<h3 id="缓存存储器">6.3 缓存存储器</h3>
<img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/general_organization_of_cache.svg" class="" title="general_organization_of_cache">
<p>　　若某计算机的每个存储器地址都是<span
class="math inline">\(m\)</span>位，则有<span
class="math inline">\(M=2^m\)</span>个地址。该计算机的缓存构成1个有<span
class="math inline">\(S=2^s\)</span>个<strong>缓存组</strong>的数组，每个缓存组有<span
class="math inline">\(E\)</span>个<strong>缓存行</strong>。每行有1位<strong>有效位</strong>
(表示是否包含有用信息)、<span
class="math inline">\(t\)</span>位<strong>标识位</strong>
(同一组内块的唯一标识) 和<span
class="math inline">\(B\)</span>字节数据块。</p>
<p>　　缓存结构可以用<span
class="math inline">\((S,E,B,m)\)</span>来表示，其容量 (<span
style="background-color: yellow">仅计算数据块</span>) <span
class="math inline">\(C=S\times E\times B\)</span>。</p>
<p>　　<span class="math inline">\(S\)</span>和<span
class="math inline">\(B\)</span>将<span
class="math inline">\(m\)</span>位的地址分为3部分，即<span
class="math inline">\(t\)</span>位标识、<span
class="math inline">\(s\)</span>位组索引 (无符号数) 和<span
class="math inline">\(b\)</span>位块偏移。第<span
class="math inline">\(i\)</span>组的组索引是<span
class="math inline">\(i\)</span>。当CPU读内存地址A的内容时，若设置了有效位，<span
class="math inline">\(t\)</span>位标识会指明块，<span
class="math inline">\(s\)</span>位组索引会指明块所属组，最后<span
class="math inline">\(b\)</span>位块偏移指明块的偏移量。若与标识匹配的块未设置有效位，则缓存未命中。</p>
<img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/why_caches_index_with_middle_bits.svg" class="" title="why_caches_index_with_middle_bits">
<p>　　若将地址的高位作为组索引，那么部分连续的缓存块将会映射到同一缓存组。如图所示，连续四个缓存块映射到同一缓存中。具有良好空间局部性的程序会顺序读取一个数组的元素，若每个组能容纳的行数很少时，会频繁出现缓存未命中。地址中间位作为组索引时，数组相邻的元素会映射到不同的缓存组。</p>
<p>　　抽取缓存行中的字的过程分为<strong>组选择</strong>、<strong>行匹配</strong>和<strong>字抽取</strong>。</p>
<p>　　例如，某32位计算机的缓存容量为1024B，每个缓存组有4个缓存行，每个数据块有8B。
<span class="math display">\[
\begin{align}
S&amp;=\frac{C}{E\times B}=\frac{1024B}{4\times8B}=32\\[3px]
s&amp;=\log_2S=\log_232=5\\[3px]
b&amp;=\log_2B=\log_28=3\\[3px]
t&amp;=m-s-b=32-5-3=24
\end{align}
\]</span></p>
<h4 id="缓存类型">6.3.1 缓存类型</h4>
<p>　　缓存组只有1行 (<span class="math inline">\(E=1\)</span>)
的缓存称为<strong>直接映射缓存</strong>。</p>
<img src="/2023/04/22/computer-systems-a-programmer's-perspective-3e-chpt-6/extracting_a_word_in_direct-mapped_cahe.svg" class="" title="extracting_a_word_in_direct-mapped_cahe">
<p>　　对于直接映射缓存，组选择就是根据组索引选择，这里是<span
class="math inline">\(i\)</span>。组选择完成后，会先判断有效位是否设置。若有效位已设置，则判断标识是否匹配，这里是0100，匹配则得到缓存命中；若有效位未设置或标识不匹配，则得到缓存未命中。最后，根据块偏移来判断数据的偏移量，这里是100
(假设字长是4B)。若缓存未命中，替换策略就替换组索引中唯一的1行。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 21%" />
<col style="width: 16%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr>
<th>地址 (十进制)</th>
<th>标识 (1位)</th>
<th>组索引 (2位)</th>
<th>块偏移 (1位)</th>
<th>块号 (十进制)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>00</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>00</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>01</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>01</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>10</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>0</td>
<td>10</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>0</td>
<td>11</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>7</td>
<td>0</td>
<td>11</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>1</td>
<td>00</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>9</td>
<td>1</td>
<td>00</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
<td>01</td>
<td>0</td>
<td>5</td>
</tr>
<tr>
<td>11</td>
<td>1</td>
<td>01</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>12</td>
<td>1</td>
<td>10</td>
<td>0</td>
<td>6</td>
</tr>
<tr>
<td>13</td>
<td>1</td>
<td>10</td>
<td>1</td>
<td>6</td>
</tr>
<tr>
<td>14</td>
<td>1</td>
<td>11</td>
<td>0</td>
<td>7</td>
</tr>
<tr>
<td>15</td>
<td>1</td>
<td>11</td>
<td>1</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>　　这是直接映射缓存的4位地址空间。标识和组索引组合是内存中的每个块的唯一标识。这里有8个内存块，但只有4组，所以有2个块会映射到同一组。映射到同一组的块由标识区分。例如，块0和块4会映射到同一组，块0的标识是0，块4的标识是1。</p>
<table>
<thead>
<tr>
<th>组</th>
<th>有效位</th>
<th>标识</th>
<th>块0</th>
<th>块1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>m[0]</td>
<td>m[1]</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>　　1)
初始时，缓存都是空的。第1次读地址0的字，出现缓存未命中，缓存从内存取出块0并返回m[0]。然后读地址1的字，出现缓存命中，缓存返回m[1]。</p>
<table>
<thead>
<tr>
<th>组</th>
<th>有效位</th>
<th>标识</th>
<th>块0</th>
<th>块1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>m[8]</td>
<td>m[9]</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td>m[12]</td>
<td>m[13]</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>　　2)
读地址13的字，出现缓存未命中，缓存从内存取出块6并返回m[13]。然后读地址8的字，出现缓存未命中，缓存从内存取出块4替换块0并返回m[8]。</p>
<table>
<thead>
<tr>
<th>组</th>
<th>有效位</th>
<th>标识</th>
<th>块0</th>
<th>块1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>m[0]</td>
<td>m[1]</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td>m[12]</td>
<td>m[13]</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>　　3)
读地址0的字，出现缓存未命中，缓存从内存取出块0替换块4并返回m[0]。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">dotprod</span><span class="params">(<span class="type">float</span> x[<span class="number">8</span>], <span class="type">float</span> y[<span class="number">8</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += x[i] * y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于参数<code>x</code>和<code>y</code>，函数<code>dotprod()</code>有良好的空间局部性，但访问这种<span
style="background-color: yellow">元素个数是2的幂的数组</span>通常会出现冲突未命中。这里假设浮点类型为4B，<code>x</code>存放在地址0开始的连续32B，<code>y</code>紧随其后，从地址32开始。变量<code>sum</code>存放在寄存器中。进一步假设缓存有2个组，每个块有16B。第1次迭代引用<code>x[0]</code>时会出现缓存未命中，将块<code>x[0]</code>到<code>x[3]</code>加载到组0，然后引用<code>y[0]</code>时再次出现缓存未命中，将块<code>y[0]</code>到<code>y[3]</code>加载到组0。在之后每次迭代都会如此，这种情况称为<strong>抖动</strong>，即缓存反复地加载和驱逐同一缓存块中的组。</p>
<p>　　这种抖动导致性能下降2或3倍并不罕见。若将<code>x</code>定义为<code>float x[12]</code>，则<code>x[i]</code>不会和<code>y[i]</code>映射到相同的组，也就不会再出现抖动。</p>
<p>　　缓存行数<span class="math inline">\(E\)</span>满足<span
class="math inline">\(1&lt;E&lt;\frac{C}{B}\)</span>的缓存称为<span
class="math inline">\(E\)</span>路<strong>组相联缓存</strong>。它的字抽取过程类似直接映射缓存的。出现缓存未命中时，若缓存组内有空行，则直接替换；反之，则使用替换策略。</p>
<p>　　缓存行数<span
class="math inline">\(E=\frac{C}{B}\)</span>的缓存称为<strong>全相联缓存</strong>，它只有1个缓存组，所以<span
style="background-color: yellow">地址中没有组索引</span>。它的抽取字过程类似直接映射缓存的，但缓存电路必须并行地搜索很多可能匹配的标识，所以构造大且快速的全相联缓存很困难且贵。全相联缓存只适合做较小的缓存
(例如，虚拟内存中的TLB)。</p>
<h4 id="写缓存">6.3.2 写缓存</h4>
<p>　　相比读缓存，写缓存更复杂。假设写一个已缓存的字
(<strong>写命中</strong>)，最简单的方法是<strong>透写</strong>，即该字的块直接写入到下一层级中，但这会占用总线流量。另一种方法是<strong>回写</strong>，即将该字的块写入到下一层级的时间推迟到替换这个更新后的块时。由于局部性，回写的总线流量占用远低于透写的总线流量占用，但它增加了复杂性，需要为每个缓存行维护额外的修改位，指明该缓存块是否被修改过。替换块时若块已修改，则将其写到下一层级再替换；否则，直接替换。</p>
<p>　　若出现写未命中，可以使用<strong>写分配</strong>，即先将下一层级的块先缓存再更新。这种方法充分利用了空间局部性，但每次未命中都会缓存下一层级的块。另一种方法是<strong>非写分配</strong>，即跳过缓存并直接更新下一层级的块。<strong>透写缓存</strong>通常使用非写分配，<strong>回写缓存</strong>通常使用写分配。</p>
<p>　　通常，由于较长的传输时间，存储器层次结构中层级较低的缓存更可能使用回写而非透写。此外，由于逻辑电路密度的提高，回写的复杂性越来越不成为障碍，回写缓存可以出现在存储器层次结构中各个层级。另一方面，与处理读的方式对应，回写缓存写分配更能利用局部性。</p>
<h4 id="缓存参数的性能影响">6.3.3 缓存参数的性能影响</h4>
<p>　　衡量缓存性能的指标有<strong>未命中率</strong>、<strong>命中率</strong>、<strong>命中时间</strong>和<strong>未命中处罚</strong>。</p>
<p>　　未命中率指未命中的内存引用比例。命中率指命中的内存引用比例。命中时间指从缓存传输1个字到CPU所用时间，包括组选择、行确认和字选择的时间。未命中处罚指由于未命中而所需的额外时间。L1缓存未命中时，从L2缓存得到服务的处罚是10个时钟周期，从L3缓存得到服务的处罚是50个时钟周期，从内存得到服务的处罚是200个时钟周期。</p>
<p>　　容量较大的缓存命中率较高，但命中时间也较长。</p>
<p>　　容量较大的缓存块更能利用空间局部性，进而提高命中率。但是，对于给定大小的缓存，缓存块越大表示缓存行数越少，这会降低时间局部性优于空间局部性的程序的命中率。此外，较大的缓存块会增加传输时间，进而增加未命中处罚。</p>
<p>　　较高的相联度 (即缓存行较多)
会降低由于冲突未命中出现的抖动的可能性，但实现成本较高且较复杂，进而导致存取速度更慢，每行都需要更多的标识位、额外的LRU状态位和额外的控制逻辑。此外，较高的相联度会增加命中时间和未命中处罚。</p>
<p>　　透写缓存更易实现，而且能使用独立于缓存的<span
style="background-color: yellow">写缓冲区</span>来更新存储器。回写缓存需要传输的数据更少，能让出更多的存储器带宽给执行DMA的I/O设备。</p>
<h3 id="缓存对程序性能的影响">6.4 缓存对程序性能的影响</h3>
<p>　　局部性较好的程序的命中率较高，命中率高的程序一般比命中率低的程序运行更快。因此，编写<strong>缓存友好</strong>的代码很重要，具体实现方法包括<span
style="background-color: yellow">让常见情况快速进行</span>和<span
style="background-color: yellow">尽量减少每个循环内部的缓存未命中次数</span>。</p>
<p>　　编译器会将局部变量缓存在寄存器文件中，所以应尽量使用局部变量。</p>
<p>　　假设缓存的块容量为<span
class="math inline">\(B\)</span>字节，步长为<span
class="math inline">\(k\)</span> (单位是字)
的引用模式每次迭代平均有<span
class="math inline">\(min(1,\frac{字长\times
k}{B})\)</span>次缓存未命中。当<span
class="math inline">\(k=1\)</span>时，它取最小值。</p>
<p>　　对于<span class="math inline">\(n\times n\)</span>矩阵乘法<span
class="math inline">\(C=AB\)</span>，当<span
class="math inline">\(n=2\)</span>时，有 <span class="math display">\[
\begin{align}
\begin{bmatrix}
c_{11} &amp; c_{12}\\
c_{21}&amp;c_{22}\\
\end{bmatrix}
&amp;=
\begin{bmatrix}
a_{11}&amp;a_{12}\\
a_{21}&amp;a_{22}\\
\end{bmatrix}
\begin{bmatrix}
b_{11}&amp;b_{12}\\
b_{21}&amp;b_{22}\\
\end{bmatrix}\\[3px]
c_{11}&amp;=a_{11}b_{11}+a_{12}b_{21}\\[3px]
c_{12}&amp;=a_{11}b_{12}+a_{12}b_{22}\\[3px]
c_{21}&amp;=a_{21}b_{11}+a_{22}b_{21}\\[3px]
c_{22}&amp;=a_{21}b_{12}+a_{22}b_{22}\\[3px]
\end{align}
\]</span> 　　矩阵乘法函数通常使用3个嵌套的循环来实现，这里分别用<span
class="math inline">\(i\)</span>、<span
class="math inline">\(j\)</span>和<span
class="math inline">\(k\)</span>来表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ijk版本 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += A[i][k] * B[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">        C[i][j] += sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* jik版本 */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += A[i][k] * B[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">        C[i][j] += sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* jki版本 */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        r = B[k][j];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i][j] += A[i][k] * r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* kji版本 */</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        r = B[k][j];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i][j] += A[i][k] * r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* kij版本 */</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        r = A[i][k];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i][j] += r * B[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ikj版本 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        r = A[i][k];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i][j] += r * B[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这6个函数成对地形成3个等价类，这里用内循环中访问的矩阵来区分。例如，<span
class="math inline">\(ijk\)</span>和<span
class="math inline">\(jik\)</span>版本是类AB，因为它们最内层循环中引用的是矩阵A和B。同理，<span
class="math inline">\(jki\)</span>和<span
class="math inline">\(kji\)</span>版本是类AC，<span
class="math inline">\(kij\)</span>和<span
class="math inline">\(ikj\)</span>版本是类BC。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 11%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr>
<th>矩阵乘法版本类</th>
<th>每次迭代加载次数</th>
<th>每次迭代存储次数</th>
<th>每次迭代A未命中次数</th>
<th>每次迭代B未命中次数</th>
<th>每次迭代C未命中次数</th>
<th>每次迭代未命中总次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>AB</td>
<td>2</td>
<td>0</td>
<td>0.25</td>
<td>1.00</td>
<td>0.00</td>
<td>1.25</td>
</tr>
<tr>
<td>AC</td>
<td>2</td>
<td>1</td>
<td>1.00</td>
<td>0.00</td>
<td>1.00</td>
<td>2.00</td>
</tr>
<tr>
<td>BC</td>
<td>2</td>
<td>1</td>
<td>0.00</td>
<td>0.25</td>
<td>0.25</td>
<td>0.50</td>
</tr>
</tbody>
</table>
<p>　　类AB以步长为1的引用模式扫描A的行，每个缓存块的容量是4个8B的字，每次迭代的命中率是0.25。内循环以步长为<span
class="math inline">\(n\)</span>的引用模式扫描数组B的列，每次对B的访问都未命中。因此，每次迭代共1.25次未命中。</p>
<p>　　对于类AC，每次迭代执行2次加载和1次存储。内循环以步长为<span
class="math inline">\(n\)</span>的引用模式扫描A和C的列，结果每次加载都未命中。因此，每次迭代共有2次未命中。相比AB，交换循环较低了空间局部性。</p>
<p>　　对于类BC，每次迭代执行2次加载和1次存储。内循环为步长为1的引用模式扫描B和C的行，每次迭代的命中率是0.25。因此，每次迭代共0.50次未命中。</p>
<p>　　<strong>分块</strong>可以提高循环的时间局部性，其基本思想是将程序中的数据结构组织为大的片，称为<strong>块</strong>
(此块非彼块)，这样使得单个片能加载到L1缓存并执行相关读写，完成后丢掉该片，加载下一片，依此类推。分块会使得代码更难阅读和理解，所以它只适合优化编译器和频繁执行的库函数。</p>
<p>　　有时循环中的数组远大于任何SRAM缓存，<span
style="background-color: yellow">预取</span>硬件能识别步长为1的引用模式以执行预取，并且其速度能跟上循环中的访问存储器的速度。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第7章 链接</title>
    <url>/2023/05/18/computer-systems-a-programmer&#39;s-perspective-3e-chpt-7/</url>
    <content><![CDATA[<p>　　<strong>链接</strong>是收集各种代码和数据并组合成单一文件的过程，合成的文件可以被加载
(复制)
到内存并执行。链接可以在编译时执行，即将源码转换为机器码时；也可以在加载时执行，即使用加载器将程序加载到内存并执行时；也可以在运行时执行，即由应用程序来执行。在早期计算机系统中，链接需要手动执行。在现代计算机系统中，链接由称为<strong>链接器</strong>的程序自动执行。</p>
<p>　　链接器使得程序能够<strong>分离编译</strong>，这样可以将大型程序拆解为更小且更易于管理的模块，这些模块可以单独修改和编译。当修改模块后，只需重新编译并链接该模块，无需编译其他模块。</p>
<p>　　<strong>目标模块</strong>是字节序列，<strong>目标文件</strong>是以文件形式存放在磁盘中的目标模块。目标文件按类型分为<span
style="background-color: yellow">可重定位目标文件</span>、<span
style="background-color: yellow">可执行 (目标) 文件</span>和<span
style="background-color: yellow">共享目标文件</span>。共享目标文件是特殊的可重定位目标文件，可以在加载或运行时动态地加载到内存并链接。</p>
<p>　　不同系统的<strong>目标文件格式</strong>不同。诞生于贝尔实验室的首个Unix系统使用的是<code>a.out</code>格式。直到今天，可执行文件仍然称为<code>a.out</code>文件。Windows使用<strong>可移植可执行</strong>格式。Mac
OS-X使用的是Mach-O格式。现代x86-64
Linux和Unix系统使用的是<strong>可执行可链接格式</strong>。</p>
<p>　　Linux
LD等<strong>静态链接器</strong>以一组可重定位目标文件和命令行参数作为输入，输出为可以加载和运行的完全链接的可执行文件。输入的可重定位目标文件由各种不同的代码和<strong>数据节</strong>组成，每个数据节都是连续的字节序列。指令占1节，已初始化的全局变量占1节，未初始化的变量占1节。</p>
<p>　　为了生成可执行文件，链接器必须进行<strong>符号解析</strong>和<strong>重定位</strong>。</p>
<p>　　●
目标文件定义和引用符号，每个符号都对应1个函数或1个全局变量或1个静态变量
(C语言中关键字<code>static</code>声明的变量)。符号解析将每个符号引用和对应的符号定义关联。</p>
<p>　　●
编译器和汇编器生成从地址0开始的代码和数据节。链接器把每个符号定义和1个内存位置关联，然后修改所有对这些符号的引用，使得它们指向对应的内存位置，这个过程就是重定位。链接器使用汇编器生成的<strong>重定位条目</strong>的详细指令来执行重定位。</p>
<p>　　C++和Java都允许重载方法，即函数名相同但参数列表不同，因为编译器将每个唯一的方法和参数列表组合编码为<span
style="background-color: yellow">对链接器唯一</span>的名称。这种编码过程称为<strong>倾轧</strong>，相反的过程称为<strong>还原</strong>。</p>
<p>　　C++和Java使用兼容的倾轧策略，倾轧过的类名由名称的字符数加上名称构成。例如，类<code>Foo</code>编码为<code>3Foo</code>。函数编码为函数名加上<code>_</code>，再加上倾轧过的类名，最后加上每个参数的类型的首字母。例如，函数<code>Foo::bar(int, long)</code>编码为<code>bar__3Fooil</code>。倾轧全局变量和模板名称的方法与之类似。</p>
<span id="more"></span>
<p>　　Linux中有很多工具可以用于理解和处理目标文件。GNU
binutils包就是其中之一，它可以运行在每个Linux平台上。</p>
<p>　　● AR：创建静态库，插入、删除、列出和提取成员。</p>
<p>　　● STRINGS：列出目标文件中所有可打印的字符串。</p>
<p>　　● STRIP：删除目标文件中的符号表信息。</p>
<p>　　● NM：列出目标文件中符号表中定义的符号。</p>
<p>　　● SIZE：列出目标文件中节的名称和大小。</p>
<p>　　● READELF：显示目标文件的完整结构，包含SIZE和NM的功能。</p>
<p>　　●
OBJDUMP：显示目标文件的所有信息。最大的作用是反汇编<code>.text</code>节中的二进制指令。</p>
<p>　　● LDD：列出可执行文件在运行时所需的共享库。</p>
<h3 id="编译器驱动程序">7.1 编译器驱动程序</h3>
<p>　　大多数编译系统提供<strong>编译器驱动程序</strong>，在需要时代表用户调用预处理器、编译器、汇编器和链接器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sum.c */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sum.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val = sum(<span class="built_in">array</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　编译以上源程序可以通过以下命令来调用GCC驱动程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -Og -o prog main.c sum.c</span><br></pre></td></tr></table></figure>
<p>　　驱动程序首先运行C预处理器，将源程序<code>main.c</code>转换为ASCII中间文件<code>main.i</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cpp [其他参数] main.c /tmp/main.i</span><br></pre></td></tr></table></figure>
<p>　　接下来，驱动程序运行C编译器，将<code>main.i</code>转换为ASCII汇编文件<code>main.s</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ccl /tmp/main.i -Og [其他参数] -o /tmp/main.s</span><br></pre></td></tr></table></figure>
<p>　　然后，驱动程序运行汇编器，将<code>main.s</code>转换为可重定位目标文件<code>main.o</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">as [其他参数] -o /tmp/main.o /tmp/main.s</span><br></pre></td></tr></table></figure>
<p>　　驱动程序以相同的步骤生成<code>sum.o</code>。最后，它运行链接器，将<code>main.o</code>、<code>sum.o</code>和一些必要的系统目标文件组合起来生成可执行文件<code>prog</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ld -o prog [系统目标文件和参数] /tmp/main.o /tmp/sum.o</span><br></pre></td></tr></table></figure>
<p>　　通过以下命令可以执行文件<code>prog</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./prog</span><br></pre></td></tr></table></figure>
<p>　　shell调用操作系统中的称为<strong>加载器</strong>的函数，将可执行文件<code>prog</code>中的代码和数据复制到内存，然后将控制权转移给该程序的开头。</p>
<h3 id="可重定位目标文件">7.2 可重定位目标文件</h3>
<img src="/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/typical_elf_relocatable_object_file.svg" class="" title="typical_elf_relocatable_object_file">
<p>　　<strong>ELF首部</strong>以16B的序列开始，该序列描述了生成该文件的系统的字长和字节顺序。ELF首部的剩余部分包含链接器语法分析和解释目标文件所需的信息
(包括ELF首部的大小、目标文件类型、机器类型、节首部表的文件偏移以及节首部表条目的数量和大小)。<strong>节首部表</strong>描述各个节的位置和大小，每个节都对应1个固定大小的条目。</p>
<p>　　在ELF首部和节首部表中间的是节。</p>
<p>　　● <code>.text</code>节存放已编译程序的机器代码。</p>
<p>　　●
<code>.rodata</code>节存放只读数据，例如，函数<code>printf()</code>中的格式串和<code>switch</code>语句中的跳转表。</p>
<p>　　● <code>.data</code>节存放已初始化的C语言全局和静态变量。</p>
<p>　　●
<code>.bss</code>节存放未初始化和初始化为0的C语言全局和静态变量。该节只是占位符，并不占用目标文件的空间。目标文件区分变量是否初始化是为了空间效率，未初始化变量不占用实际的磁盘空间，运行时由内存分配空间并赋予初始值0。</p>
<p>　　● <code>.symtab</code>节是符号表，存放程序中定义和引用的<span
style="background-color: yellow">函数和全局变量</span>的信息。每个可重定位目标文件的该节中都有符号表，除非使用命令<code>STRIP</code>去除。</p>
<p>　　●
<code>.rel.text</code>节是<code>.text</code>节中位置的列表，当链接器把该目标文件和其他文件组合时，会修改这些位置。任何调用外部函数和引用全局变量的指令都需要修改。调用本地函数的指令则无需修改。可执行文件中并不需要重定位信息，所以通常忽略，除非用户显示地指示链接器包含这些信息。</p>
<p>　　●
<code>rel.data</code>节存放模块定义和引用的所有全局变量的重定位信息。任何已初始化且初始值是全局变量地址或外部定义函数地址的变量都需要修改。</p>
<p>　　●
<code>.debug</code>节是调试符号表，其条目是程序中定义的局部变量、类型定义、定义/引用的全局变量和原始C源文件。只有使用命令行选项<code>-g</code>时，才会生成该表。</p>
<p>　　●
<code>.line</code>节是原始C源程序中的行号和<code>.text</code>节中机器指令之间的映射。只有使用命令行选项<code>-g</code>时，才会生成该表。</p>
<p>　　●
<code>.strtab</code>节是字符串表，包括<code>.symtab</code>节和<code>.debug</code>节中的符号表以及节首部中的节名称。字符串表是以<code>null</code>结尾的字符串序列。</p>
<p>　　<code>.bss</code>节的名称源自IBM 704汇编语言 (约1957年)
中块存储开始指令的首字母缩写，并沿用至今。</p>
<h3 id="符号和符号表">7.3 符号和符号表</h3>
<p>　　每个可重定位目标文件<code>m</code>都有1个符号表，该表包含<code>m</code>定义和引用的符号的信息。在链接器的上下文中，有3种不同的符号。</p>
<p>　　● 由模块<code>m</code>定义但由其他模块引用的<span
style="background-color: yellow">全局符号</span>，对应非静态的C语言函数和全局变量。</p>
<p>　　● 由其他模块定义但由模块<code>m</code>引用的<span
style="background-color: yellow">全局符号</span>，对应其他模块定义的非静态的C语言函数和全局变量。这种符号是<strong>外部</strong>的。</p>
<p>　　● 只被模块<code>m</code>定义和引用的<span
style="background-color: yellow">局部符号</span>，对应C语言静态函数和静态全局变量。这些符号仅在模块<code>m</code>中可见，不能被其他模块引用。</p>
<p>　　在C语言中，源文件对应模块，关键字<code>static</code>可用于隐藏模块内部的变量和函数声明，声明为<code>static</code>的全局变量或函数都是模块私有的。相反，任何不声明为<code>static</code>的全局变量或函数是公有的，可以被其他模块访问。</p>
<p>　　C语言中的局部变量在运行时由栈管理，与链接器无关。但是，声明为<code>static</code>的局部变量由链接器管理，链接器会为其在<code>.data</code>节或<code>.bss</code>节中分配空间并在符号表中创建1个有唯一名称的局部链接器符号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">g</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，2个函数都定义了静态局部变量<code>x</code>，编译器会向汇编器提供2个名称不同的局部链接器符号。例如，用<code>x.1</code>表示函数<code>f()</code>中定义的<code>x</code>，用<code>x.2</code>表示函数<code>g()</code>中定义的<code>x</code>。</p>
<p>　　汇编器根据编译器输出到<code>.s</code>汇编文件的符号来生成符号表。<code>.symtab</code>节中包含ELF符号表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf64_Symbol</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="type">char</span> type : <span class="number">4</span>, binding : <span class="number">4</span>;</span><br><span class="line">    <span class="type">char</span> reserved;</span><br><span class="line">    <span class="type">short</span> section;</span><br><span class="line">    <span class="type">long</span> value;</span><br><span class="line">    <span class="type">long</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　这是ELF符号表条目的格式，<code>name</code>表示字符串表中的字节偏移，指向符号的以<code>null</code>结尾的字符串名称。<code>value</code>是符号的地址。对于可重定位的模块，<code>value</code>是到定义目标的节的起始处偏移。对于可执行文件，<code>value</code>是绝对运行时地址。<code>size</code>是目标的大小
(以字节为单位)。<code>type</code>只能是数据或函数。符号表还可以包含各个节的条目和原始源文件的路径名的条目，所以这些目标的类型也有所不同。<code>binding</code>表示符号是局部还是全局。</p>
<p>　　每个符号都被分配到目标文件的某个节，由<code>section</code>表示，它是节首部表的索引。有3个特殊的<span
style="background-color: yellow">伪节</span>，它们在节首部表中没有条目，即<code>ABS</code>、<code>UNDEF</code>和<code>COMMON</code>。<code>ABS</code>表示不应该被重定位的符号。<code>UNDEF</code>表示未定义的符号，即本目标模块引用但由其他模块定义的符号。<code>COMMON</code>表示未分配空间的未初始化数据条目。对于<code>COMMON</code>符号，<code>value</code>指明对齐要求，<code>size</code>给出最小值。<span
style="background-color: yellow">只有可重定位目标文件才有伪节</span>，可执行文件没有。</p>
<p>　　<code>COMMON</code>和<code>.bss</code>节有细微差别。GCC会将<span
style="background-color: yellow">未初始化的全局变量</span>分配给<code>COMMON</code>，将未初始化的静态变量和初始化为0的全局/静态变量分配给<code>.bss</code>节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Num:	Value           Size	Type	Bind	Vis 	Ndx	Name</span><br><span class="line">  8: 0000000000000000	  24	FUNC	GLOBAL	DEFAULT   1	main</span><br><span class="line">  9: 0000000000000000	   8	OBJECT	GLOBAL	DEFAULT   3	array</span><br><span class="line"> 10: 0000000000000000	   0	NOTYPE	GLOBAL	DEFAULT UND	sum</span><br></pre></td></tr></table></figure>
<p>　　这个示例是7.1中的<code>main.o</code>的符号表中的最后3个条目。READELF用整数索引来标识每个节。<code>Ndx=1</code>表示<code>.text</code>节，<code>Ndx=3</code>表示<code>.data</code>节。全局符号<code>main</code>定义的条目是<code>.text</code>节中偏移为0处的24B的函数。其后是全局符号<code>array</code>的定义，它是<code>.data</code>节中偏移为0处的8B的目标。最后是对外部符号<code>sum</code>的引用。</p>
<h3 id="符号解析">7.4 符号解析</h3>
<p>　　链接器通过将每个引用和其输入重定位目标文件的符号表中的1个的符号定义关联来解析符号引用。对于那些定义和引用在同一模块的局部符号的引用，符号解析是直接明了的。编译器仅允许模块中每个局部符号有1个定义。编译器还确保有局部链接器符号的静态局部变量有唯一的名称。</p>
<p>　　当编译器遇到不在本模块定义的全局符号时，会假设该符号在其他模块中定义，生成链接器符号表条目并将其交给链接器处理。若链接器在它的所有输入模块中都找不到该符号的定义，就输出错误信息
(通常难以阅读)
并终止。有时多个目标文件可能定义名称相同的全局符号，此时，链接器要么标志错误，要么以某种方法选择1个定义并抛弃其他定位。Linux使用的方法涉及编译器、汇编器和链接器之间的协作。</p>
<h4 id="链接器解析重复的符号名称">7.4.1 链接器解析重复的符号名称</h4>
<p>　　在编译时，编译器会向汇编器提供所有全局符号，汇编器会隐式地把它们编码在可重定位目标文件的符号表中。函数和已初始化的全局变量是<strong>强</strong>符号，未初始化的全局变量是<strong>弱</strong>符号。</p>
<p>　　Linux链接器不允许多个同名的强符号。若1个强符号与多个弱符号同名，则选择强符号。若多个弱符号同名，则随机选择1个。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* foo.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> y = <span class="number">15212</span>;</span><br><span class="line"><span class="type">int</span> x = <span class="number">15213</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = 0x%x y = 0x%x \n&quot;</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* bar.c */</span></span><br><span class="line"><span class="type">double</span> x;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    x = <span class="number">-0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在x86-64/Linux机器上，<code>double</code>是8B，<code>int</code>是4B。当<code>x</code>和<code>y</code>的地址相邻且<code>x</code>的地址在<code>y</code>之前时，<code>bar.c</code>中第6行代码会用<span
style="background-color: yellow">0的双精度浮点表示</span>覆盖<code>foo.c</code>中定义的<code>x</code>和<code>y</code>，此时只会触发警告。当怀疑出现此类情况时，可以用<code>GCC-fno-common</code>等命令参数调用链接器，用于指示链接器遇到重名的全局符号时触发错误。也可以用命令行选项<code>-Werror</code>，将所有的警告变为错误。</p>
<h4 id="链接静态库">7.4.2 链接静态库</h4>
<p>　　用所有相关的目标模块打包成的单个文件称为<strong>静态库</strong>，它可以作为链接器的输入。当链接器生成作为输出的可执行文件时，只会复制静态库中被应用程序引用的的目标模块。</p>
<p>　　若不使用静态库，可以通过<span
style="background-color: yellow">让编译器识别标准函数并生成对应的代码</span>或<span
style="background-color: yellow">将所有标准函数都放在同一可重定位目标文件</span>来使用标准函数。Pascal
(仅提供了小部分标准函数)
使用的方法是前者，但C语言定义了大量的标准函数，若使用前者会显著增加编译器的复杂性，并且每次增删改标准函数时都需要更新编译器来适配。后者的优点是将编译器的实现和标准函数的实现分离，但需要每个可执行文件都包含1份标准函数集合的副本，并且增删改标准函数会要求库的开发者重新编译整个源文件，其改进方法是为每个标准函数生成独立的可重定位目标文件并把它们放在约定俗成的目录中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.c /usr/lib/printf.o /usr/lib/scanf.o ...</span><br></pre></td></tr></table></figure>
<p>　　静态库正是为了解决以上问题，相关的函数可以编译为单独的目标模块并封装在单独的静态库文件中。然后，应用程序可以在命令行中指定对应的文件名称来使用这些库中定义的函数。例如，以下命令用于使用了C标准库和数学库中的函数的应用程序编译和链接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.c /usr/lib/libm.a /usr/lib/libc.a</span><br></pre></td></tr></table></figure>
<p>　　实际上，C编译器驱动程序每次都会提供标准库文件<code>libc.a</code>给链接器，这里可以省略。</p>
<p>　　在Linux中，静态库存储为称为<strong>存档</strong>的特殊文件格式，其后缀名为<code>.a</code>。存档文件是一组串联的可重定位目标文件的集合，其首部指明其中每个目标文件的大小和位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* addarray.c */</span></span><br><span class="line"><span class="type">int</span> addcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addarray</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y, <span class="type">int</span> *z, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    addcnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        z[i] = x[i] + y[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* multarray.c */</span></span><br><span class="line"><span class="type">int</span> multcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multarray</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y, <span class="type">int</span> *z, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    multcnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        z[i] = x[i] * y[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　要创建函数<code>addarray()</code>和<code>multarray()</code>的静态库，可以使用AR工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c addarray.c multarray.c</span><br><span class="line">ar rcs libarray.a addarray.o multarray.o</span><br></pre></td></tr></table></figure>
<p>　　这里在头文件<code>array.h</code>中定义了这2个函数的函数原型。若需要使用这个库，只需要引入该头文件即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;array.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> z[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    addarray(x, y, z, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d]\n&quot;</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　为了创建可执行文件，需要编译和链接输入文件<code>main.o</code>和<code>libarray.a</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c main.c</span><br><span class="line">gcc -static -o prog main.o ./libarray.a</span><br></pre></td></tr></table></figure>
<p>　　第2条命令等价于以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -static -o prog main.o -L. -larray</span><br></pre></td></tr></table></figure>
<p>　　命令行选项<code>-static</code>指示链接器应生成完全链接的可执行文件，<code>-larray</code>是<code>libarray.a</code>的缩写，<code>-L.</code>指示链接器在当前目录查找<code>libarray.a</code>。</p>
<img src="/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/linking_with_static_libraries.svg" class="" title="linking_with_static_libraries">
<p>　　当链接器运行时，它发现<code>main.o</code>引用了<code>addarray.o</code>中定义的<code>addarray</code>符号，所以它会复制<code>addarray.o</code>到可执行文件。程序并没有引用<code>multarray</code>中定义的任何符号，所以链接器不会复制这个模块。链接器还会复制<code>libc.a</code>中的模块<code>printf.o</code>和运行时系统中的部分模块。</p>
<h4 id="链接器使用静态库解析引用">7.4.3 链接器使用静态库解析引用</h4>
<p>　　在符号解析阶段，链接器<span
style="background-color: yellow">从左到右按照它们在编译器驱动程序命令行上出现的顺序</span>来扫描可重定位目标文件和存档文件
(驱动程序自动将命令行中所有的<code>.c</code>文件转换为<code>.o</code>文件)。在扫描时，链接器会维护可重定位目标文件的集合<span
class="math inline">\(E\)</span>
(该集合中的文件会组合成可执行文件)、未解析的符号集合<span
class="math inline">\(U\)</span> (即引用了但未定义的符号)
和之前输入文件中已定义的符号集合<span
class="math inline">\(D\)</span>。初始时，<span
class="math inline">\(E\)</span>、<span
class="math inline">\(U\)</span>和<span
class="math inline">\(D\)</span>均为空。</p>
<p>　　对于命令行上的每个输入文件<span
class="math inline">\(f\)</span>，链接器会判断<span
class="math inline">\(f\)</span>是目标文件还是存档文件。</p>
<p>　　● 若<span class="math inline">\(f\)</span>是目标文件，则将<span
class="math inline">\(f\)</span>添加到<span
class="math inline">\(E\)</span>，更新<span
class="math inline">\(U\)</span>和<span
class="math inline">\(D\)</span>来表示<span
class="math inline">\(f\)</span>中的符号定义和引用。然后，链接器处理下一个输入文件。</p>
<p>　　● 若<span
class="math inline">\(f\)</span>是存档文件，则链接器尝试匹配<span
class="math inline">\(U\)</span>中未解析的符号和存档文件中的模块定义的符号。若存档文件中的某个模块<span
class="math inline">\(m\)</span>定义了符号解析<span
class="math inline">\(U\)</span>中引用的符号，则将<span
class="math inline">\(m\)</span>添加到<span
class="math inline">\(E\)</span>，修改<span
class="math inline">\(U\)</span>和<span
class="math inline">\(D\)</span>来表示<span
class="math inline">\(m\)</span>中的符号定义和引用。这个过程会一直持续到<span
class="math inline">\(U\)</span>和<span
class="math inline">\(D\)</span>不再发生变化。此时，存档文件中任何不包含在<span
class="math inline">\(E\)</span>的模块将会被丢弃。然后，链接器处理下一个输入文件。</p>
<p>　　当链接器完成对命令行中输入文件的扫描后，若<span
class="math inline">\(U\)</span>非空，则链接器会输出错误并终止；否则，它会合并和重定位<span
class="math inline">\(E\)</span>中的目标文件，生成作为输出的可执行文件。</p>
<p>　　文件出现在命令行的顺序至关重要，所以库一般放在命令行的结尾。若库的各个模块相互独立
(同一库的模块之间没有符号引用)，那么这些模块可以以任何顺序出现在命令行结尾处；相反，若同一库的模块之间存在符号引用，则必须对它们进行排序，保证<span
style="background-color: yellow">至少有1个符号的定义在该符号的引用之后</span>。</p>
<p>　　若<code>foo.c</code>调用了<code>libx.a</code>和<code>libz.a</code>中的函数，而这2个库又调用了<code>liby.a</code>中的符号，则命令行上<code>libx.a</code>和<code>libz.a</code>必须在<code>liby.a</code>之前。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc foo.c libx.a libz.a liby.a</span><br></pre></td></tr></table></figure>
<p>　　若<code>foo.c</code>调用了<code>libx.a</code>中的函数，<code>libx.a</code>调用了<code>liby.a</code>中的函数，<code>liby.a</code>调用了<code>libx.a</code>中的函数，则<code>libx.a</code>必须在命令行上重复出现。这种情况下，也可以将<code>libx.a</code>和<code>liby.a</code>合并。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc foo.c libx.a liby.a libx.a</span><br></pre></td></tr></table></figure>
<h3 id="重定位">7.5 重定位</h3>
<p>　　链接器完成符号解析后，会把代码的每个符号引用和对应的符号定义
(即它的1个输入目标模块的1个符号表条目)
关联起来。此时，链接器就知道器输入模块中的代码节和数据节的确切大小。然后，就可以进行重定位。重定位分为<span
style="background-color: yellow">重定位节和符号定义</span>以及<span
style="background-color: yellow">重定位节中的符号引用</span>。</p>
<p>　　●
在重定位节和符号定义时，链接器会将所有相同类型的节合并为同一类型的聚合节。例如，将所有输入模块的<code>.data</code>节合并为单个节作为输出
(可执行)
文件的<code>.data</code>节。然后，链接器将运行时内存地址赋值给聚合节以及输入模块定义的所有节和符号。完成后，程序中的所有指令和全局变量都有了唯一的运行时内存地址。</p>
<p>　　●
在重定位节的符号引用时，链接器会修改代码节和数据节中的所有符号引用，保证它们指向正确的运行时地址。完成这一步需要使用可重定位目标模块中的<span
style="background-color: yellow">重定位条目</span>。</p>
<h4 id="重定位条目">7.5.1 重定位条目</h4>
<p>　　当汇编器遇到最终位置未知的引用时，会生成<strong>重定位条目</strong>，用于告诉链接器在用目标文件合成可执行文件时如何修改该引用。代码的重定位条目存放在<code>.rel.text</code>节中，数据的重定位条目存放在<code>.rel.data</code>节中。</p>
<p>　　ELF定义了32种重定位类型，这里只介绍2种最基本的重定位类型，即R_X86_64_PC32和R_X86_64_32。前者用于重定位使用<span
style="background-color: yellow">32位PC相对地址</span>的引用，后者用于重定位使用<span
style="background-color: yellow">32位绝对地址</span>的引用。此外，两者都支持x86-64<strong>小型代码模型</strong>，该模型默认可执行文件中的代码和数据的总体大小小于2GB，所以在运行时可以用32位PC相对地址来访问。</p>
<p>　　GCC默认使用小型代码模型，更大的程序可以用<code>-mcmodel=medium</code>
(中型代码模型) 和<code>-mcmodel=large</code> (大型代码模型)
命令行参数来编译。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf64_Rela</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> offset;</span><br><span class="line">    <span class="type">long</span> type : <span class="number">32</span>, symbol : <span class="number">32</span>;</span><br><span class="line">    <span class="type">long</span> addend;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　这是ELF重定位条目的格式。<code>offset</code>是待修改的引用的节偏移。<code>type</code>指示链接器如何修改新引用。<code>symbol</code>标识修改后的引用指向的符号。<code>addend</code>是常数，部分类型的重定位用它来偏置修改后的引用的值。</p>
<h4 id="重定位符号引用">7.5.2 重定位符号引用</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">foreach section s </span><br><span class="line">&#123;</span><br><span class="line">    foreach relocation entry r </span><br><span class="line">    &#123;</span><br><span class="line">        refptr = s + r.offset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 重定位PC相对 (寻址) 引用 */</span></span><br><span class="line">        <span class="keyword">if</span> (r.type == R_X86_64_PC32)</span><br><span class="line">        &#123;</span><br><span class="line">            refaddr = ADDR(s) + r.offset; <span class="comment">/* 引用的运行时地址 */</span></span><br><span class="line">            *refptr = (<span class="type">unsigned</span>)(ADDR(r.symbol) + r.addend - refaddr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 重定位绝对 (寻找) 引用 */</span></span><br><span class="line">        <span class="keyword">if</span> (r.type == R_X86_64_32)</span><br><span class="line">        &#123;</span><br><span class="line">            *refptr = (<span class="type">unsigned</span>)(ADDR(r.symbol) + r.addend);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是链接器重定位算法的伪代码，其中节<code>s</code>是字节数组，重定位条目<code>r</code>是<code>Elf64_Rela</code>结构体。链接器为每个节和符号分配的运行时地址表示为<code>ADDR(s)</code>和<code>ADDR(r.symbol)</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:	48 83 ec 08         sub     $0x8, %rsp</span><br><span class="line">   4:	be 02 00 00 00      mov     $0x2, %esi</span><br><span class="line">   9:	bf 00 00 00 00      mov     $0x0, %edi</span><br><span class="line">                        a: R_X86_64_32 array</span><br><span class="line">   e:	e8 00 00 00 00      call    13 &lt;main+0x13&gt;</span><br><span class="line">                        f: R_X86_64_PC32 sum-0x4	</span><br><span class="line">  13:	48 83 c4 08         add     $0x8, %rsp</span><br><span class="line">  17:	c3                  retq</span><br></pre></td></tr></table></figure>
<p>　　这是用OBJDUMP根据7.1中的<code>main.c</code>生成的反汇编代码。主函数引用了2个全局符号，即<code>array</code>和<code>sum</code>。汇编器为它们都生成了对应的重定位体条目，显示在引用的后一行
(实际上重定位条目和指令存放在不同的节中，为了方便才将它们显示在一起)。这些重定位条目指示链接器对<code>sum</code>的引用使用32位PC相对地址来重定位，对<code>array</code>的引用使用32位绝对地址来重定位。</p>
<h5 id="重定位pc相对引用">7.5.2.1 重定位PC相对引用</h5>
<p>　　主函数调用了函数<code>sum()</code>，函数<code>sum()</code>是在模块<code>sum.o</code>中定义的。指令<code>call</code>从节偏移<code>0xe</code>处开始，包括1B的操作码<code>0xe8</code>，其后是对目标<code>sum</code>的32位PC相对引用的占位符。对应的重定位条目<code>r</code>由4个字段组成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r.offset = <span class="number">0xf</span>;</span><br><span class="line">r.symbol = sum;</span><br><span class="line">r.type = R_X86_64_PC32;</span><br><span class="line">r.addend = <span class="number">-4</span>;</span><br></pre></td></tr></table></figure>
<p>　　这些字段指示链接器修改偏移量<code>0xf</code>处的32位PC相对引用，这样在运行时它会指向<code>sum</code>例程。此时，假设链接器已经确定：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADDR(s) = ADDR(.text) = <span class="number">0x4004d0</span>;</span><br><span class="line">ADDR(r.symbol) = ADDR(sum) = <span class="number">0x4004e8</span>;</span><br></pre></td></tr></table></figure>
<p>　　使用链接器重定位算法，链接器先计算出引用的运行时地址
(第10行)，得到<code>refaddr = 0x4004df</code>。然后，更新该引用，使其在运行时指向<code>sum</code>
(第11行)，即<code>*refptr = 0x5</code>。在得到的可执行文件中，指令<code>call</code>有如下的重定位形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4004de:	e8 05 00 00 00      callq   4004e8 &lt;sum&gt;</span><br></pre></td></tr></table></figure>
<p>　　在运行时，指令<code>call</code>将存放在地址<code>0x4004de</code>。当CPU执行指令<code>call</code>时，PC的值是<code>0x4004e3</code>，即<code>call</code>的下一条指令的地址。为了执行这条指令，CPU会先将PC压入栈，再将PC值加上<code>0x5</code>得到新PC值。</p>
<h5 id="重定位绝对引用">7.5.2.2 重定位绝对引用</h5>
<p>　　重定位绝对引用更简单。在链接器重定位算法的反汇编代码中的第4行，指令<code>mov</code>将<code>array</code>地址
(32位立即数)
复制到寄存器<code>%edi</code>中。指令<code>mov</code>从节偏移<code>0x9</code>处开始，包括1B的操作码<code>0xbf</code>，其后是<code>array</code>的32位绝对引用的占位符。对应的重定位条目<code>r</code>由4个字段组成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r.offset = <span class="number">0xa</span>;</span><br><span class="line">r.symbol = <span class="built_in">array</span>;</span><br><span class="line">r.type = R_X86_64_32;</span><br><span class="line">r.addend = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>　　这些字段指示链接器要修改偏移量<code>0xa</code>的引用，这样在运行时它会指向<code>array</code>的首字节。此时，假设链接器已经确定：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADDR(r.symbol) = ADDR(<span class="built_in">array</span>) = <span class="number">0x601018</span>;</span><br></pre></td></tr></table></figure>
<p>　　链接器使用重定位算法修改引用，得到<code>*refptr = 0x601018</code>。在得到的可执行文件中，该引用有如下的重定位形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4004d9:	bf 18 10 60 00      mov $0x601018, %edi</span><br></pre></td></tr></table></figure>
<p>　　综上所述，最终可执行文件中已重定位的<code>.text</code>节和<code>.data</code>节如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 已重定位的.text节</span><br><span class="line">00000000004004d0 &lt;main&gt;:</span><br><span class="line">  4004d0:	48 83 ec 08     sub     $0x8, %rsp</span><br><span class="line">  4004d4:	be 02 00 00 00  mov     $0x2, %esi</span><br><span class="line">  4004d9:	bf 18 10 60 00  mov     $0x601018, %edi</span><br><span class="line">  4004de:	e8 05 00 00 00  callq   4004e8 &lt;sum&gt;</span><br><span class="line">  4004e3:	48 83 c4 08     add     $0x8, %rsp</span><br><span class="line">  4004e7:	c3              retq</span><br><span class="line"></span><br><span class="line">00000000004004e8 &lt;sum&gt;:</span><br><span class="line">  4004e8:	b8 00 00 00 00  mov     $0x0, %eax</span><br><span class="line">  4004ed:	ba 00 00 00 00  mov     $0x0, %edx</span><br><span class="line">  4004f2:	eb 09           jmp     4004fd &lt;sum+0x15&gt;</span><br><span class="line">  4004f4:	48 63 ca        movslq  %edx, %rcx</span><br><span class="line">  4004f7:	03 04 8f        add     (%rdi,%rcx,4), %eax</span><br><span class="line">  4004fa:	83 c2 01        add     $0x1, %edx</span><br><span class="line">  4004fd:	39 f2           cmp     %esi, %edx</span><br><span class="line">  4004ff:	7c f3           jl      4004f4 &lt;sum+0xc&gt;</span><br><span class="line">  400501:	f3 c3           repz retq</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 已重定位的.data节</span><br><span class="line">00000000004004e8 &lt;array&gt;:</span><br><span class="line">  601080:	01 00 00 00 02 00 00</span><br></pre></td></tr></table></figure>
<p>　　在加载时，加载器会将这些节中的数据直接复制到内存中，不加修改地执行这些指令。</p>
<h3 id="可执行文件">7.6 可执行文件</h3>
<img src="/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/typical_elf_executable_file.svg" class="" title="typical_elf_executable_file">
<p>　　可执行文件的格式类似可重定位目标文件，因为可执行文件是完全链接的，所以没有<code>rel</code>节。ELF首部描述文件的总体格式，它还包括程序的<strong>入口点</strong>，即程序运行时执行的首条指令的地址。<code>.init</code>节定义了函数<code>_init()</code>，即程序的初始化函数。<code>.text</code>节、<code>.rodata</code>节和<code>.data</code>节与可重定位目标文件中的相似，区别是这些节已经被重定位到其最终运行时地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 只读代码段</span><br><span class="line">LOAD off	0x0000000000000000 vaddr 0x0000000000400000 paddr 0x0000000000400000 align 2**21</span><br><span class="line">	filesz 	0x000000000000069c memsz 0x000000000000069c flags r-x</span><br><span class="line"># 读写代码段</span><br><span class="line">LOAD off	0x0000000000000df8 vaddr 0x0000000000600df8 paddr 0x0000000000600df8 align 2**21</span><br><span class="line">	filesz 	0x0000000000000228 memsz 0x0000000000000230 flags rw-</span><br></pre></td></tr></table></figure>
<p>　　这是可执行文件<code>prog</code>的程序首部表，由OBJDUMP显示。其中<code>off</code>是目标文件的偏移，<code>vaddr</code>和<code>paddr</code>是内存地址，<code>align</code>是对齐要求
(这里<code>2**21</code>表示<span
class="math inline">\(2^{21}\)</span>，即<code>0x200000</code>)，<code>filesz</code>是目标文件中的段大小，<code>memsz</code>是内存中的段大小，<code>flags</code>是运行时访问权限。根据这个程序首部表，有2个内存段将使用可执行文件的内容进行初始化。</p>
<p>　　第1个段 (第2~3行)
是代码段，有读和执行权限，从内存地址<code>0x400000</code>处开始，共占用<code>0x69c</code>字节，并用可执行文件的前<code>0x69c</code>字节初始化，其中包括ELF首部、程序首部表、<code>.init</code>节、<code>.text</code>节和<code>.rodata</code>节。</p>
<p>　　第2个段 (第5~6行)
是数据段，有读和写权限，从内存地址<code>0x600df8</code>处开始，共占用<code>0x230</code>字节，并用可执行文件中偏移量为<code>0xdf8</code>的<code>.data</code>节中的<code>0x228</code>字节初始化前<code>0x228</code>字节，剩下的8字节对应将在运行时初始化为0的<code>.bss</code>节数据。</p>
<p>　　对应任何段<code>s</code>，链接器必须选择起始地址<span
class="math inline">\(vaddr\)</span>，使得 <span class="math display">\[
vaddr\bmod align=off\bmod aligh
\]</span> 　　这里，<span
class="math inline">\(off\)</span>是目标文件中段的首个节的偏移，<span
class="math inline">\(align\)</span>是程序首部中指定的对齐要求。</p>
<h3 id="加载可执行文件">7.7 加载可执行文件</h3>
<p>　　每个Linux程序都可以调用函数<code>execve()</code>来调用加载器，加载器将可执行文件中的代码和数据从磁盘复制到内存中，然后跳转到程序的入口点来运行程序。这个将程序复制到内存并运行的过程称为<strong>加载</strong>。</p>
<img src="/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/linux_x86-64_run-time_memory_image.svg" class="" title="linux_x86-64_run-time_memory_image">
<p>　　每个Linux程序都有运行时内存映像。在Linux
x86-64系统中，代码段总是从地址<code>0x400000</code>处开始，其后是数据段。运行时堆在数据段之后，通过调用库<code>malloc</code>可以向上增长。堆后的区域是为共享库保留。用户级代码地址的最大值是<span
class="math inline">\(2^{48}-1\)</span>，向较小内存地址增长。栈后的区域是内核内存，从地址<span
class="math inline">\(2^{48}\)</span>开始，为<strong>内核</strong>中的代码段和数据保留。</p>
<p>　　由于<code>.data</code>节有对齐要求，所以代码段和数据段之间有间隙
(这里省略了该间隙)。在为栈、共享库和堆分配运行地址时，链接器会使用地址空间布局随机化，每次程序运行时这些区域的地址会改变，但它们的相对位置不变。</p>
<p>　　当加载器运行时，会创建运行时内存映像。在程序首部表的引导下，加载器将可执行文件的片复制到代码段和数据段。然后，加载器跳转到程序的入口点，即函数<code>_start()</code>的地址，该函数定义在系统目标文件<code>ctrl.o</code>中，对所有C语言程序都相同。函数<code>_start()</code>调用<code>libc.so</code>中定义的<span
style="background-color: yellow">系统启动函数</span><code>__libc_start_main()</code>，它会初始化执行环境，调用用户级函数<code>main()</code>，处理函数<code>main()</code>的返回值并在需要的时候把控制权转移给内核。</p>
<h3 id="动态链接共享库">7.8 动态链接共享库</h3>
<p>　　<strong>动态链接</strong>就是运行/加载时将目标模块加载到内存并和其中的程序链接，该目标模块称为<strong>共享库</strong>或<strong>共享目标</strong>。动态链接由称为<strong>动态链接器</strong>的程序执行，动态链接器本身就是共享库。共享库在Linux和Windows中的后缀分别是<code>.so</code>和<code>.dll</code>。</p>
<p>　　共享库以2种不同的形式共享。首先，在任何给定的文件系统中，1个库<span
style="background-color: yellow">只有1个</span><code>.so</code>文件，所以引用该库的可执行文件共享这个<code>.so</code>文件，而非像静态库的内容那样被复制并嵌入到它们的可执行文件中。其次，在内存中，共享库的<code>.text</code>节的同一副本可以被不同的正在运行的进程共享。</p>
<img src="/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/dynamic_linking_with_shared_libraries.svg" class="" title="dynamic_linking_with_shared_libraries">
<p>　　这是7.4.2中的示例的动态链接版本。为了生成示例中的数组例程的共享库<code>libarray.so</code>，需要调用编译器驱动程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared -fpic -o libarray.so addarray.c multarray.c</span><br></pre></td></tr></table></figure>
<p>　　命令行选项<code>-fpic</code>指示编译器生成位置无关代码，<code>-shared</code>指示链接器生成共享库文件。生成共享库后，需要链接到程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o prog main.c ./libarray.so</span><br></pre></td></tr></table></figure>
<p>　　这样就生成了可执行文件<code>prog</code>，该文件的形式使得它能在运行时和<code>libarray.so</code>链接。基本思想是在创建可执行文件时，静态执行部分链接，然后在程序加载时，动态完成剩余链接。静态链接时仅复制了一些重定位和符号表信息，使得它们在运行时可以解析对<code>libarray.so</code>中代码和数据的引用。</p>
<p>　　相比静态链接，动态链接生成的<code>prog</code>包含<code>.interp</code>节，该节包含动态链接器的路径名。加载器会直接加载和运行对应的动态链接器而非将控制权转移给程序，然后动态链接器执行以下的重定位来完成链接任务：</p>
<p>　　● 重定位<code>libc.so</code>的文本和数据到某个内存段。</p>
<p>　　● 重定位<code>libarray.so</code>的文本和数据到另一个内存段。</p>
<p>　　●
重定位<code>prog</code>中所有<code>libc.so</code>和<code>libarray.so</code>定义的符号的引用。</p>
<p>　　最后，动态链接器将控制权转移给程序，此时，共享库的位置就已固定并在程序执行时不会改变。</p>
<h3 id="从应用程序中加载和链接共享库">7.9
从应用程序中加载和链接共享库</h3>
<p>　　实际中，应用程序可能在运行时要求链接器加载和链接某个共享库而非在编译时。</p>
<p>　　动态链接的常见应用场景包括<span
style="background-color: yellow">分发软件</span>和<span
style="background-color: yellow">构建高性能Web服务器</span>。</p>
<p>　　●
Windows应用开发者经常用共享库来分发软件更新，即生成共享库的新版本，用户下载后用新共享库替代旧版本。下一次运行应用程序时，应用将自动加载新共享库。</p>
<p>　　●
很多Web服务器会生成动态内容，例如，个性化的Web页面、账户余额和广告标语。早期的Web服务器通过使用<code>fork()</code>和<code>execve()</code>创建子进程，在子进程的上下文中运行CGI程序来生成动态内容。通过使用动态链接可以更有效和完善地来生成动态内容。基本思想是将每个动态内容打包在共享库中，当Web请求到达时，服务器动态地加载和链接对应的函数并调用它们。函数会一直缓存在服务器的地址空间中，所以只需简单的函数调用就可以处理随后的请求。这样，可以在不停止服务器的情况下更新和增加函数。</p>
<p>　　Linux为动态链接提供了接口，允许应用程序在运行时加载和链接共享库。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flag)</span>; <span class="comment">/* 若成功则返回指向句柄的指针，若出错则返回空指针 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlsym</span><span class="params">(<span class="type">void</span> *handle, <span class="type">char</span> *symbol)</span>; <span class="comment">/* 若成功则返回指向符号的指针，若出错则返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dlclose</span><span class="params">(<span class="type">void</span> *handle)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">dlerror</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 若最近对函数dlopen()、dlsym()或dlerror()的调用失败则返回错误信息，若调用成功则返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>dlopen()</code>会加载和链接共享库<code>filename</code>。<code>filename</code>中的外部符号通过之前使用<code>RTLD_GLOBAL</code>选项打开的库来解析。若当前可执行文件是带<code>-rdynamic</code>选项编译，则其全局符号可用于符号解析。参数<code>flag</code>只能为<code>RTLD_NOW</code>
(指示链接器立即解析外部符号引用) 或<code>RTLD_LAZY</code>
(指示链接器将符号解析推迟到执行来自库中的代码)，两者都可以和<code>RTLD_GLOBAL</code>取或。</p>
<p>　　函数<code>dlsym()</code>的参数<code>handle</code>分别指向之前已打开的共享库的句柄，<code>symbol</code>是符号名，若该符号存在，则返回符号地址；否则，返回<code>NULL</code>。</p>
<p>　　函数<code>dlclose()</code>用于卸载共享库。</p>
<p>　　函数<code>dlerror()</code>用于返回最近对以上3个函数的调用的错误信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* dll.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> z[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *handle;</span><br><span class="line">    <span class="type">void</span> (*addarrray)(<span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 动态加载包含addarray()的共享库 */</span></span><br><span class="line">    handle = dlopen(<span class="string">&quot;./libarray.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (!handle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取指向刚加载的函数addarray()的指针 */</span></span><br><span class="line">    addarrray = dlsym(handle, <span class="string">&quot;addarray&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, error);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 现在就可以调用函数addarray() */</span></span><br><span class="line">    addarrray(x, y, z, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d\n]&quot;</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 卸载共享库 */</span></span><br><span class="line">    <span class="keyword">if</span> (dlclose(handle) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会用上述接口动态链接共享库<code>libarray.so</code>并调用其例程<code>addarray</code>。要编译该程序，需要如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -dynamic -o prog dll.c -ldl</span><br></pre></td></tr></table></figure>
<p>　　<strong>Java本地接口</strong>允许Java程序调用C/C++函数。JNI的思想就是将本地C函数
(如<code>foo()</code>) 编译到共享库 (如<code>foo.so</code>)
中。当运行的Java程序调用函数<code>foo()</code>时，Java解释器通过<code>dlopen()</code>等接口动态链接和加载<code>foo.so</code>，然后调用<code>foo()</code>。</p>
<h3 id="位置无关代码">7.10 位置无关代码</h3>
<p>　　若多个进程需要共享同一共享库，可以给每个共享库分配事先准备的专用的地址空间并要求加载器总是加载到该区域。显然，这种方法的地址使用率不高，首先，即使进程不是该共享库也会分配空间。其次，分配的空间难以管理，必须保证没有片会重叠。每当修改共享库时，必须确认分配的片的大小合适。若不合适，需要重新找新片。若创建了新共享库，必须为其分配空间。随着系统中共享库及其版本的增加，很可能导致出现很多小到无法使用的地址块。此外，每个系统的共享库的空间分配不同，这会导致更多的问题。</p>
<p>　　以上问题可以用<strong>位置无关代码</strong>避免，即可以加载而无需重定位的代码。对GCC使用<code>-fpic</code>选项可以指示GNU编译系统生成PIC代码。共享库的编译<span
style="background-color: yellow">必须</span>使用该选项。</p>
<p>　　在x86-64系统中，同一目标模块中的符号的引用无需特殊处理就能成为PIC。生成目标文件时，这种引用可以用PC相对寻址来编译，用静态链接器来重定位。</p>
<p>　　无论在内存中的何处加载目标模块，数据段与代码段的距离总是保存不变的。因此，代码段中的任何指令和数据段中的任何变量之间的<span
style="background-color: yellow">距离</span>都是运行时常量。</p>
<h4 id="pic数据引用">7.10.1 PIC数据引用</h4>
<p>　　编译器在生成全局变量PIC引用时，会在数据段起始处创建<strong>全局偏移表</strong>
(其条目是8B)，还会为每个GOT条目生成重定位记录。每个引用全局目标
(过程或全局变量)
的目标模块都有GOT，目标模块引用的每个全局目标都有对应的GOT条目。在加载时，动态链接器会重定位GOT中的每个条目，使其包含目标的绝对地址。</p>
<img src="/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/using_the_got_to_reference_a_global_variable.svg" class="" title="using_the_got_to_reference_a_global_variable">
<p>　　这是共享库<code>libarray.so</code>的GOT。例程<code>addarray</code>通过<code>GOT[3]</code>间接加载全局变量<code>addcnt</code>的地址并在内存中将<code>addcnt</code>加1。若<code>addcnt</code>是非外部符号，编译器可以利用代码段和数据段之间的固定距离直接生成<code>addcnt</code>的PC相对引用，并增加1个重定位用于链接器在生成共享库时解析；若<code>addcnt</code>是外部符号，则需要通过GOT间接访问。这里编译器采用最通用的方法，即对所有引用都使用GOT。</p>
<h4 id="pic函数调用">7.10.2 PIC函数调用</h4>
<p>　　若程序需要调用共享库定义的函数，但编译器无法预测该函数的运行时地址
(共享库在运行时可以加载到任何位置)，常规的方法是为该引用生成重定位记录，动态链接器在程序加载时再解析它。这种方法是并不是PIC，因为它需要链接器修改调用模块的代码段，GNU使用了<strong>延迟绑定</strong>来将过程地址的绑定推迟到首次调用该过程。</p>
<p>　　常规程序只会使用<code>libc.so</code>等包括成大量函数的共享库中的很少一部分函数，把函数地址的解析推迟到实际被调用的地方，能<span
style="background-color: yellow">避免动态链接器在加载时进行大量无意义的重定位</span>。这样只有首次调用过程的运行时开销很大，之后每次调用都只需单条指令和单个间接内存引用。</p>
<p>　　延迟绑定通过GOT和<strong>过程链接表</strong>来实现。若目标模块调用共享库中定义的函数，则它会有自己的GOT和PLT。GOT是数据段的一部分，PLT是代码段的一部分。</p>
<p>　　PTL是由若干个16B的条目组成的数组。<code>PTL[0]</code>是特殊条目，它会跳转到动态链接器中。每个可执行文件调用的库都有自己的PTL条目。每个条目负责调用具体函数。<code>PTL[1]</code>会调用7.7中的<span
style="background-color: yellow">系统启动函数</span>。<code>PLT[2]</code>及以后的条目会调用用户级代码调用的函数。</p>
<p>　　GOT是由若干个8B的条目组成的数组。和PTL共同使用时，<code>GOT[0]</code>和<code>GOT[1]</code>包含动态链接器在解析函数地址时会使用的信息。<code>GOT[2]</code>是动态链接器在模块<code>ld-linux.so</code>中的入口点。其余的每个条目都对应1个被调函数，其地址在运行时被解析。此外，每个GOT条目都有对应的POT条目。初始化时，每个GOT条目都指向对应PTL条目的的<span
style="background-color: yellow">第2条</span>指令。</p>
<img src="/2023/05/18/computer-systems-a-programmer's-perspective-3e-chpt-7/using_the_got_and_plt_to_call_external_functions.svg" class="" title="using_the_got_and_plt_to_call_external_functions">
<p>　　图a是在首次调用<code>addarray()</code>时，GOT和PLT协同工作来延迟解析其运行地址的流程。</p>
<p>　　1)
程序会先调用<code>addarray()</code>的PLT条目而非直接调用该函数。</p>
<p>　　2)
首条PTL指令通过<code>GOT[4]</code>间接跳转。这里<code>GOT[4]</code>指向<code>PTL[2]</code>的第2条指令，因此，这一步只是为了把控制权转移给<code>PTL[2]</code>的第2条指令。</p>
<p>　　3)
把<code>addarray()</code>的ID<code>0x1</code>压入栈后，<code>PTL[2]</code>跳转到<code>PTL[0]</code>。</p>
<p>　　4)
<code>PLT[0]</code>通过<code>GOT[1]</code>间接地把动态链接器的1个参数压入栈，再通过<code>GOT[2]</code>间接地跳转到动态链接器。动态链接器通过2个栈条目来确定的<code>addarray()</code>的运行时地址，用该地址覆写<code>GOT[4]</code>，再把控制权转移给<code>addarray()</code>。</p>
<p>　　图b是后续调用<code>addarray()</code>的控制流。</p>
<p>　　1) 和前面一样，控制权转移到<code>PTL[2]</code>。</p>
<p>　　2)
通过<code>GOT[4]</code>的间接跳转将控制权直接转移给<code>addarray()</code>。</p>
<h3 id="库打桩">7.11 库打桩</h3>
<p>　　Linux链接器的<strong>库打桩</strong>允许追踪指定的共享库函数的调用次数，验证和追踪其输入和输出值，甚至可以将其替换为其他的实现。基本思想是为目标函数创建<strong>包装函数</strong>，其原型与目标函数的原型相同。包装函数通常会执行自己的逻辑，然后调用目标函数，最后将目标函数的返回值传递给调用者。使用某些特殊的库打桩机制，可以达到欺骗操作系统调用包装函数而非目标函数。打桩可以发生在编译时、链接时和运行时。</p>
<h4 id="编译时打桩">7.11.1 编译时打桩</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* int.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 本地的malloc.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> malloc(size) mymalloc(size);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> free(ptr) myfree(ptr);</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mymalloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">myfree</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mymalloc.c中关于编译时打桩的函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILETIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc的包装函数 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mymalloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d)=%p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free的包装函数 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">myfree</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    prtinf(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>　　<code>mymalloc.h</code>中的包装函数会调用目标函数，打印追踪记录，最后返回。本地的<code>malloc.h</code>指示预处理器将目标函数的调用替换为对应的包装函数的调用。编译和链接该程序的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -DCOMPILETIME -c mymalloc.c</span><br><span class="line">gcc -I. -o intc int.c mymalloc.c</span><br></pre></td></tr></table></figure>
<p>　　命令行选项<code>-I.</code>表示执行打桩，即指示预处理器在搜索系统目录前，先在当前目录中查找<code>malloc.h</code>。这里<code>mymalloc.c</code>中的包装函数是使用标准头文件<code>malloc.h</code>编译。</p>
<h4 id="链接时打桩">7.11.2 链接时打桩</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mymalloc.c中关于链接时打桩的函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LINKTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *__real_malloc(<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">void</span> __real_free(<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc的包装函数 */</span></span><br><span class="line"><span class="type">void</span> *__wrap_malloc(<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr = __real_malloc(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d) = %p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free的包装函数 */</span></span><br><span class="line"><span class="type">void</span> __wrap_free(<span class="type">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    __real_free(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>　　Linux静态链接器支持用<code>--wrap f</code>参数进行链接时打桩。该参数指示链接器把符号<code>f</code>的引用解析为<code>__wrap_f</code>，把符号<code>__real_f</code>的引用解析为<code>f</code>。以上源文件通过以下命令编译为可重定位目标文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -DLINKTIME -c mymalloc.c</span><br><span class="line">gcc -c int.c</span><br></pre></td></tr></table></figure>
<p>　　然后，把目标文件链接为可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -W1,--warp,malloc -W1,--warp,free -o intl int.o mymalloc.o</span><br></pre></td></tr></table></figure>
<p>　　命令行选项<code>-W1,option</code>表示把<code>option</code>传递给链接器，<code>option</code>中的逗号会替换为空格，所以<code>-W1,--wrap,malloc</code>会传递<code>--wrap malloc</code>给链接器。</p>
<h4 id="运行时打桩">7.11.3 运行时打桩</h4>
<p>　　编译时打桩需要能够访问程序的源文件，链接时打桩需要能够访问程序的可重定位目标文件。基于动态链接器的<code>LD_PRELOAD</code>环境变量的运行时打桩只需要能够访问可执行文件。</p>
<p>　　若<code>LD_PRELOAD</code>环境变量设置为共享库路径名的列表
(以空格或分号分隔)，当加载和执行程序并解析未定义的引用时，动态链接器会先搜索<code>LD_PERLOAD</code>中设置的库，再搜索其他库。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mymalloc.c中关于运行时打桩的函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RUNTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc的包装函数 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *(*mallocp)(<span class="type">size_t</span> size);</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    mallocp = dlsym(RTLD_NEXT, <span class="string">&quot;malloc&quot;</span>); <span class="comment">/* 获取libc中malloc的地址 */</span></span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *ptr = mallocp(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d) = %p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free的包装函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (*freep)(<span class="type">void</span> *) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    freep = dlsym(RTLD_NEXT, <span class="string">&quot;free&quot;</span>); <span class="comment">/* 获取libc中free的地址 */</span></span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    freep(ptr); <span class="comment">/* 调用libc中的free */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>　　每个包装函数中，调用<code>dlsym()</code>会返回指向目标<code>libc</code>函数的指针，然后包装函数调用目标函数，打印追踪记录，最后返回。生成包含这些包装函数的共享库的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl</span><br></pre></td></tr></table></figure>
<p>　　编译主程序的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o intr int.c</span><br></pre></td></tr></table></figure>
<p>　　在bash shell运行该程序的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LD_PERLOAD=&quot;./mymalloc.so&quot; ./intr</span><br></pre></td></tr></table></figure>
<p>　　在<code>csh</code>或<code>tcsh</code>中运行该程序的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(setenv LD_PRELOAD &quot;./mymalloc.so&quot;; ./intr; unsetenv LD_PRELOAD)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第9章 虚拟内存</title>
    <url>/2023/08/02/computer-systems-a-programmer&#39;s-perspective-3e-chpt-9/</url>
    <content><![CDATA[<p>　　虚拟内存诞生于20世纪60年代初期，远在CPU和内存之间的差距加大导致出现SRAM缓存之前。因此，虚拟内存系统使用了和SRAM缓存不同的术语，尽管它们的许多概念是相似的。在虚拟内存的习惯说法中，块称为<strong>页</strong>。在磁盘和内存之间传输页称为<strong>交换</strong>或<strong>页面调度</strong>，页<strong>换入</strong>
(也称为<strong>页面调入</strong>) 或<strong>换出</strong>
(也称为<strong>页面调出</strong>)
到磁盘中。现代操作系统都是使用<strong>按需页面调度</strong>，即只有当发生未命中时才换入页面。</p>
<p>　　在虚拟内存中，DRAM缓存未命中称为<strong>缺页</strong>。</p>
<p>　　<strong>地址空间</strong>是非负整数地址的有序集合<span
class="math inline">\(\{0,1,2...\}\)</span>。<strong>线性地址空间</strong>中的整数是连续的。</p>
<p>　　计算机系统的内存被组织为由<span
class="math inline">\(M\)</span>个连续的单字节大小的单元组成的数组。每个字节都有唯一的<strong>物理地址</strong>。第1个字节的地址为0，第2个字节的地址为1，依此类推。CPU访问内存的最自然的方式是使用PA，这种寻址方式称为<strong>物理寻址</strong>。系统中有<strong>物理地址空间</strong>对应这<span
class="math inline">\(M\)</span>个字节。</p>
<p>　　以<span
class="math inline">\(n\)</span>位线性地址空间为例，CPU从<span
class="math inline">\(N=2^n\)</span>个地址的地址空间中生成<strong>虚拟地址</strong>，这个地址空间称为<strong>虚拟地址空间</strong><span
class="math inline">\(\{0,1,2,..,N-1\}\)</span>。现代系统通常支持32位或64位虚拟地址空间。</p>
<p>　　内存中的每个字节都有1个来自虚拟地址空间的VA和1个来自物理地址空间的PA。</p>
<p>　　DEC PDP-11/70等早期的系统支持比物理内存更小的虚拟地址空间。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/a_system_that_uses_physical_addressing.svg" class="" title="a_system_that_uses_physical_addressing">
<p>　　这个示例的背景是加载1条指令，该指令读PA4处的4B字。当CPU执行该指令时，会生成有效PA并通过内存总线传递给内存。内存取出PA4处的4B字并将它返回给CPU。CPU会将该字存放在某个寄存器中。</p>
<span id="more"></span>
<p>　　早期计算机使用物理寻址，而且数组信号处理器、嵌入式微控制器和Cray超级计算机等系统还在使用这种寻址方式。现代CPU使用<strong>虚拟寻址</strong>。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/a_system_that_uses_virtual_addressing.svg" class="" title="a_system_that_uses_virtual_addressing">
<p>　　使用虚拟寻址时，CPU通过VA来访问内存，该VA在传递给内存前会先转换为对应的PA。将VA转换为PA的过程称为<strong>地址转换</strong>。地址转换需要CPU硬件和操作系统共同来实现。CPU芯片上的<strong>内存管理单元</strong>通过存放在内存中的查询表来动态转换VA，该表的内容由操作系统管理。</p>
<p>　　Linux中的函数<code>getrusage()</code>可以监测缺页的数量以及很多其他信息。</p>
<h3 id="虚拟内存作为缓存的空间">9.1 虚拟内存作为缓存的空间</h3>
<p>　　和存储器层次结构中其他缓存一样，磁盘上的数据被划分成块，这些块作为磁盘和内存之间的传输单元。为了应对这种情况，虚拟内存系统通过将虚拟内存划分为称为<strong>虚拟页</strong>的固定大小的块。每个虚拟页的大小<span
class="math inline">\(P=2^p\)</span>字节。同样，物理内存被划分为<strong>物理页</strong>
(也称为<strong>页帧</strong>)，大小也是<span
class="math inline">\(P\)</span>字节。</p>
<p>　　虚拟页的集合分为3个不相交的子集，即<span
style="background-color: yellow">未分配</span>的页集合
(虚拟内存系统还未分配或创建的页)、<span
style="background-color: yellow">已缓存</span>的页集合
(当前已缓存在物理内存中的已分配的页) 和<span
style="background-color: yellow">未缓存</span>的页集合
(未缓存在物理内存中的已分配的页)。未分配的页没有与任何数据关联，所以不占用任何磁盘空间。</p>
<p>　　在存储器层次结构中，SRAM用于L1、L2和L3缓存，DRAM用于内存。DRAM缓存未命中的代价比SRAM缓存未命中的代价大得多。此外，读磁盘扇区的首个字节的开销比读这个扇区中连续的字节的开销大得多。因此，VP比较大，通常是4KB~2MB。</p>
<p>　　由于DRAM缓存未命中的代价很大，所以它是全相联的，即任何VP都可以放置在任何PP中。未命中的替换策略也很重要，因为替换错误的VP的代价很高。因此，与硬件对SRAM缓存使用的替换策略相比，操作系统对DRAM缓存使用的替换策略更复杂。此外，磁盘的存取时间很长，所以DRAM缓存使用回写。</p>
<p>　　虚拟内存可能看似效率很低
(因为其严重的未命中代价)，由于局部性，虚拟内存的性能并不差。</p>
<p>　　尽管在整个运行过程中程序引用的页总数可能超过物理内存，但局部性保证了程序将趋于在较小的活动页集合上进行，这个集合称为<strong>工作集</strong>或<strong>常驻集</strong>。在初始化后
(将工作集调度到内存)，之后对该工作集的引用都会命中，而不会产生额外的磁盘流量。只要程序有良好的时间局部性，虚拟内存就能有不错的性能。但实际中并非总是如此，若工作集的大小超过了物理内存，程序会出现<strong>抖动</strong>，即页面不断地调入调出。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/how_a_virtual_memory_system_uses_main_memory_as_a_cache.svg" class="" title="how_a_virtual_memory_system_uses_main_memory_as_a_cache">
<p>　　这个示例中的虚拟内存有8个VP。VP0和3还为被分配，所以在磁盘上不存在。VP1、4和6缓存在物理内存中。VP2、5和7已经被分配但未被缓存在内存中。</p>
<p>　　同缓存一样，虚拟内存系统必须判断VP是否缓存在DRAM中。若已缓存，则需要确定存放VP的PP；若未缓存，则需要判断VP在磁盘中的位置，在物理内存中选择牺牲页并将VP复制到DRAM中替换牺牲页。这些功能需要硬件和软件共同完成，包括操作系统、MMU中的地址转换硬件和存放在物理内存中的称为<strong>页表</strong>的数据结构。</p>
<p>　　页表是<strong>页表条目</strong>组成的数组。每个VP在页表中的1个固定偏移处都有对应的PTE。这里为了展示，将PTE假设为由1位<span
style="background-color: yellow">有效位</span>和<span
class="math inline">\(n\)</span>位地址字段组成。有效位指明该VP当前是否缓存在DRAM中。当设置了有效位时，表示该VP对应的PP已缓存，地址字段就是DRAM中该VP对应的PP的起始地址。当未设置有效位时，若地址字段不为空，则地址字段就是磁盘上该VP的起始地址；若地址字段为空，则表示该VP还未被分配。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/page_table.svg" class="" title="page_table">
<p>　　这个示例中展示了有8个VP和4个PP的系统的页表。VP1、2、4和7缓存在DRAM中。VP0和5还未被分配。VP3和6已经被分配但未被缓存。</p>
<p>　　若CPU需要读VP2中的某个字，而VP2缓存在DRAM中，则地址转换硬件会将该字的VA作为索引来定位PTE2并从内存中读它。因为设置了有效位，地址转移硬件会使用PTE中的地址字段来生成该字的PA。</p>
<p>　　若CPU需要读VP3中的某个字，而VP3未缓存，则地址转换硬件会从内存中读取PTE3，从有效位推断VP3未缓存并触发缺页异常。缺页异常会调用内核中的缺页异常处理程序，该程序会选择牺牲页，这里假设选择了存放在PP3中的VP4。若VP4已修改，则内核会将进行回写
(将VP4复制回磁盘)。无论如何，内核都会修改VP4的PTE来指明VP4不再缓存在内存。然后，内核从磁盘复制VP3到内存中的PP3，更新PTE3，然后返回。当从缺页异常处理程序返回时，会重启导致缺页的指令。</p>
<p>　　若调用函数<code>malloc()</code>来分配VP5，分配过程是在磁盘上创建空间并更新PTE5使之指向磁盘上新创建的页。</p>
<h3 id="虚拟内存作为内存管理的工具">9.2 虚拟内存作为内存管理的工具</h3>
<p>　　操作系统会每个进程都提供独立的页表，即独立的虚拟地址空间。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/how_virtual_memory_provides_processes_with_separate_address_spaces.svg" class="" title="how_virtual_memory_provides_processes_with_separate_address_spaces">
<p>　　在这个示例中，进程<code>i</code>的页表将VP1映射到PP2，将VP2映射到PP7。同样，进程<code>j</code>的页表将VP1映射PP7，将VP2映射PP10。多个VP可以映射到同一共享PP上。</p>
<p>　　按需页面调度和独立的虚拟地址空间的结合对系统中内存的使用和管理有深远的影响，尤其是虚拟内存简化了<span
style="background-color: yellow">链接</span>、<span
style="background-color: yellow">加载</span>、<span
style="background-color: yellow">代码和数据的共享</span>以及<span
style="background-color: yellow">程序的内存分配</span>。</p>
<p>　　●
独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放的物理内存位置。对于64位地址空间，代码段总是从虚拟地址<code>0x400000</code>开始。数据段在代码段之后
(中间有段对齐间隔)，栈在用户地址空间地址值最大的部分并向低地址增长，这样的一致性极大地简化了链接器的设计和实现，允许链接器生成完成链接的可执行文件，这些可执行文件独立于物理内存中代码和数据的最终位置。</p>
<p>　　●
虚拟内存让加载可执行文件和共享库很容易。为了把目标文件中的<code>.text</code>节和<code>.data</code>节加载到新创建进程中，Linux加载器会为代码段和数据段分配VP并将它们标记为无效
(即未被缓存)，然后将PTE指向目标文件中合适的位置。这里，加载器并不会立即从磁盘复制数据到内存。在每个页初次被引用时
(CPU取指令或正在执行的指令引用内存位置)，虚拟内存系统会按需自动调入数据页。</p>
<p>　　●
独立地址空间为操作系统提供了用于管理用户进程或操作系统自身间的共享的一致性机制。通常，每个进程都有私有的代码、数据、堆和栈区域，操作系统创建页表来将对应的VP映射到不连续的PP。在某些情况下，进程需要共享代码和数据。例如，每个进程必须调用相同的操作系统内核代码，而每个C程序都会调用C标准库中的函数，操作系统通过将不同进程中合适的VP映射到相同PP来实现多个进程共享这部分代码的副本。</p>
<p>　　●
虚拟内存为用户进程提供了简单的分配额外内存的机制。若运行在用户进程中的程序请求额外的空间
(通过调用函数<code>malloc()</code>等)，则操作系统会分配<span
class="math inline">\(k\)</span>个连续的VP并将它们映射到<span
class="math inline">\(k\)</span>个不连续的PP
(由于页表的工作方式，操作系统无需分配<span
class="math inline">\(k\)</span>个连续的PP)。</p>
<h3 id="虚拟内存作为内存保护的工具">9.3 虚拟内存作为内存保护的工具</h3>
<p>　　现代计算机系统必须为操作系统提供控制内存访问的方法。不应该允许用户进程写它的只读代码，也不应该允许它访问内核中代码和数据结构，还不应该允许它访问其他进程的私有内存和写任何与其他进程共享的VP
(除非所有的共享者通过显式的进程间通信系统调用来允许)。</p>
<p>　　独立的地址空间使得区分不同进程的私有内存很容易，但地址转换机制可以自然地扩展到提供更好的访问控制。每次CPU生成地址时，地址转换硬件都会读PTE，所以可以在PTE上添加一些额外的权限位来控制对VP的访问。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/using_virtual_memory_to_provide_page-level_memory_protection.svg" class="" title="using_virtual_memory_to_provide_page-level_memory_protection">
<p>　　在这个示例中，每个PTE中添加了3个权限位。<code>SUP</code>位表示是否只能在内核
(超级用户)
模式下访问该页。<code>READ</code>位和<code>WRITE</code>位表示该页的读和写权限。例如，若进程<code>i</code>运行在用户模式下，则它有VP0的读权限以及VP1的读和写权限。</p>
<p>　　若指令违反了这些权限，CPU会触发一般保护故障，将控制权转移给内核中的异常处理程序。</p>
<h3 id="地址转换">9.4 地址转换</h3>
<p>　　地址转换是<span
class="math inline">\(N\)</span>个元素的虚拟地址空间中的元素和<span
class="math inline">\(M\)</span>个元素的物理地址空间中的元素间的映射。
<span class="math display">\[
MAP: VAS\rightarrow PAS \cup \emptyset
\]</span> <span class="math display">\[
MAP(A) = \begin{cases} A&#39; &amp;&amp;
{若虚拟地址A处的数据在物理地址A&#39;处}\\[2px]
\emptyset &amp;&amp; {若虚拟地址A处的数据不在物理内存中}\end{cases}
\]</span></p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/address_translation_with_a_page_table.svg" class="" title="address_translation_with_a_page_table">
<p>　　CPU中的称为<strong>页表基址寄存器</strong>的控制寄存器指向当前页表。<span
class="math inline">\(n\)</span>位的VA包括<span
class="math inline">\(p\)</span>位的<strong>虚拟页偏移</strong>和<span
class="math inline">\(n-p\)</span>位的<strong>虚拟页号</strong>。MMU通过VPN来选择对应的PTE，VPN0对应PTE0，VPN1对应PTE1，依此类推。将PTE中的<strong>物理页号</strong>和VA中的VPO连接起来得到PA
(PPO和VPO相同)。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/operational_view_of_page_hits_and_page_faults.svg" class="" title="operational_view_of_page_hits_and_page_faults">
<p>　　页命中仅需硬件就可以完成，如图a所示。</p>
<p>　　1) CPU生成VA并发送给MMU。</p>
<p>　　2) MMU生成PTE地址并从缓存/内存请求对应的PTE。</p>
<p>　　3) 缓存/内存向MMU返回请求的PTE。</p>
<p>　　4) MMU生成PA并发送给缓存/内存。</p>
<p>　　5) 缓存/内存返回请求的数据给CPU。</p>
<p>　　缺页处理需要硬件和操作系统内核共同完成，如图b所示。</p>
<p>　　1~3步同页命中的1~3步相同。</p>
<p>　　4)
PTE中的有效位为0，所以MMU触发异常，将控制权转移给缺页异常处理程序。</p>
<p>　　5)
缺页异常处理程序确定物理内存中的牺牲页，若该页已被修改，则进行回写。</p>
<p>　　6) 缺页异常处理程序调入新页并更新内存中的PTE。</p>
<p>　　7)
从缺页异常处理程序返回到原来的程序并再次执行导致缺页的指令。CPU重新发送VA给MMU，此时该VA已缓存，所以会命中，内存会将请求的数据返回给CPU。</p>
<p>　　在同时使用虚拟内存和SRAM缓存的系统中，都有应使用VA还是PA来访问SRAM缓存的问题，大多数系统是选择物理寻址。物理寻址让多个进程同时在缓存中有存储块以及共享来自同一VP的块很简单。此外，缓存无需处理访问权限的问题，因为访问权限控制是地址转换的一部分。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/integrating_virtual_memory_with_a_physically_addressed_cache.svg" class="" title="integrating_virtual_memory_with_a_physically_addressed_cache">
<p>　　结合虚拟内存和物理寻址的缓存的主要思路是让地址转换在查找缓存前执行。此外，PTE可以缓存，就像数据一样。</p>
<h4 id="用tlb加速地址转换">9.4.1 用TLB加速地址转换</h4>
<p>　　每次CPU生成VA，MMU必须查阅PTE来将其转换为PA。在最差的情况下，还需要从内存中读取1次数据，开销是几十到几百个周期。若PTE刚好在L1缓存中，则开销就下降到1或2个周期。然而，很多系统通过在MMU加入称为<strong>转换后备缓存区</strong>的PTE缓存来消除这样的开销。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/components_of_a_virtual_address_that_are_used_to_access_the_tlb.svg" class="" title="components_of_a_virtual_address_that_are_used_to_access_the_tlb">
<p>　　TLB是虚拟寻址的较小的缓存，其中的每行都保存着1个由单个PTE组成的块。TLB通常有很高的相联度。用于组选择和行匹配的索引和标识字段来自VA中的VPN。若TLB有<span
class="math inline">\(T=2^t\)</span>个组，则TLBI由VPN的低<span
class="math inline">\(t\)</span>位组成，TLBT由VPN中的剩余位组成。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/operational_view_of_a_tlb_hit_and_miss.svg" class="" title="operational_view_of_a_tlb_hit_and_miss">
<p>　　所有的地址转换步骤是由CPU芯片上的MMU执行，所以很快，如图a所示。</p>
<p>　　1) CPU生成VA。</p>
<p>　　2 &amp; 3) MMU从TLB中取出相应的PTE。</p>
<p>　　4) MMU将该VA转换为PA并发送给缓存/内存。</p>
<p>　　5) 缓存/内存将请求的数据返回给CPU。</p>
<p>　　当TLB未命中时，MMU必须从L1缓存中取出对应的PTE，如图b所示。取出的PTE会存放在TLB中，可能会覆盖其中的1个条目。</p>
<h4 id="多级页表">9.4.2 多级页表</h4>
<p>　　到目前为止的情况都是假设只用1个页表来进行地址转换。对于有32位地址空间、4KB的页和4B的PTE的系统，即使程序引用的只是虚拟地址空间中很小的一部分，还是需要4MB的页表驻留在内存中。对于地址空间为64位的系统，问题将变得更复杂。</p>
<p>　　压缩页表的常用方法是使用<span
style="background-color: yellow">层次结构的页表</span>。假设32位虚拟地址空间被分为4KB的页，每个PTE都是4B。此外，还假设内存的前<span
class="math inline">\(2K\)</span>个页分配给代码和数据，接下来的<span
class="math inline">\(6K\)</span>未分配，再接下来的<span
class="math inline">\(1023\)</span>个页也未分配，最后1个页分配给用户栈。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/a_two-level_page_table_hierarchy.svg" class="" title="a_two-level_page_table_hierarchy">
<p>　　1级页表中的每个PTE负责映射虚拟地址空间中的4MB的<span
style="background-color: yellow">片</span>，这里的片都是由1024个连续的页组成。例如，PTE0映射第1片，PTE1映射到接下来的片，依此类推。若地址空间为4GB，1024个PTE足以覆盖整个空间。若片<span
class="math inline">\(i\)</span>中的每个页都未被分配，那么1级PTE<span
class="math inline">\(i\)</span>就为空。</p>
<p>　　2级页表中的每个PTE负责映射4KB的VP。1级页表和2级页表的PTE都是4B，所以1级页表、2级页表和页的大小都是相同的。</p>
<p>　　这种方法从2个方面减少了内存要求。首先，若1级页表中的某个PTE为空，则对应的2级页表就不会存在。这表示巨大的潜在节约，因为对于常规程序，4GB的虚拟地址空间中的大部分都是未被分配的。其次，只有1级页表才需要常驻内存。虚拟内存系统可以在需要时创建、调入或调出2级页表，这样减少了内存的压力。只有最常使用的2级页表才需要缓存在内存中。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/address_translation_with_k-level_page_table.svg" class="" title="address_translation_with_k-level_page_table">
<p>　　对于使用<span
class="math inline">\(k\)</span>级页表的地址转换，VA划分为<span
class="math inline">\(k\)</span>个VPN和1个VPO。VPN<span
class="math inline">\(i\)</span>是到<span
class="math inline">\(i\)</span>级页表的索引，其中<span
class="math inline">\(1\leqslant i\leqslant k\)</span>。<span
class="math inline">\(j\)</span>级页表中的每个PTE都指向<span
class="math inline">\(j+1\)</span>级中的某个页表的基址，其中<span
class="math inline">\(1\leqslant j\leqslant k-1\)</span>。<span
class="math inline">\(k\)</span>级页表中的每个PTE包含某个PP的PPN或某个磁盘块的地址。为了生成PA，在确定PPN前，MMU必须访问<span
class="math inline">\(k\)</span>个PTE。对于仅有1级的页表结构，PPO和VPO是相同的。</p>
<p>　　访问<span
class="math inline">\(k\)</span>个PTE时，看似开销很大。由于不同层级上页表的PTE已缓存，所以多级页表的地址转换并不会比单级页表的地址转换慢很多。</p>
<h4 id="端到端的地址转换">9.4.3 端到端的地址转换</h4>
<p>　　以有TLB和L1数据缓存的系统为例，为了保证可管理性，做出如下假设：</p>
<p>　　● 内存是按字节寻址的。</p>
<p>　　● 内存访问是针对<span
style="background-color: yellow">1B的字</span>。</p>
<p>　　● VA是14位。</p>
<p>　　● PA是12位。</p>
<p>　　● 页大小是64B。</p>
<p>　　● TLB是4路组相联的，共有16个条目。</p>
<p>　　● L1数据缓存是物理寻址且直接映射的，行大小是4B，共有16个组。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/tlb,page_table,and_cache_for_small_memory_system.svg" class="" title="tlb,page_table,and_cache_for_small_memory_system">
<p>　　每个页都是<span
class="math inline">\(2^6=64\)</span>B，所以VA和PA的低6位分别是VPO和PPO。VA的高8位作为VPN。PA的高6位作为PPN。</p>
<p>　　TLB通过VPN的位进行虚拟寻址。因为TLB有4个组，所以VPN的低2位作为TLBI。VPN的高6位作为TLBT，用于区分映射到同一TLB组的VPN。</p>
<p>　　页表是单级页表，共有<span
class="math inline">\(2^8=256\)</span>个PTE。这里只展示前16个PTE，为了方便，用索引它的VPN来作为标识
(实际中VPN并不存储在内存中)。<code>-</code>表示无效PTE的PPN。</p>
<p>　　直接映射的缓存通过PA中的字段来寻址。每个块都是4B，所以PA中的低2位作为缓存偏移。共有16组，所以PA中接下来的4位用于表示缓存索引，最后6位作为缓存标识。</p>
<p>　　以CPU执行读<code>0x03D4</code>处的字节的加载指令为例，MMU从虚拟地址中提取VPN<code>0x0F</code>，检查TLB来判断它是否已缓存PTE<code>0x0F</code>的副本。TLB从VPN中提取TLBI<code>0x03</code>和TLBT<code>0x3</code>。组<code>0x3</code>中的第2个条目匹配，所以命中，然后将缓存的PPN<code>0x0D</code>返回给MMU。</p>
<p>　　现在MMU能够生成PA，通过来自PTE的PPN<code>0x0D</code>和来自VA的VPO<code>0x14</code>连接起来得到PA<code>0x354</code>。然后，MMU将PA发送给缓存，缓存从PA中提取CO<code>0x0</code>、CI<code>0x5</code>和CT<code>0x0D</code>。</p>
<p>　　组<code>0x5</code>中的标识与CT匹配，所以缓存命中，读出CO处的数据字节<code>0x36</code>并返回给MMU，MMU返回给CPU。</p>
<p>　　转换过程中还有其他可能。例如，若TLB未命中，则MMU必须从页表中的PTE中提取PPN。若得到PTE是无效的，则会出现缺页，内核必须调入合适的页并重新加载这条指令。另一种可能是PTE是有效的，但是所需的内存块未缓存在缓存中。</p>
<h3 id="案例研究intel-core-i7linux内存系统">9.5 案例研究：Intel Core
i7/Linux内存系统</h3>
<p>　　以运行Linux的Intel Core
i7为例，虽然底层的Haswell微体系架构完全支持64位虚拟和物理地址空间，但Core
i7的实现仅支持48位 (256TB) 虚拟地址空间、52位 (4PB) 物理地址空间以及32位
(4GB) 虚拟和物理地址空间的兼容模式。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/the_intel_core_i7_memory_system.svg" class="" title="the_intel_core_i7_memory_system">
<p>　　Core
i7内存系统的<strong>处理器封装</strong>包括4个核以及所有核共享的L3缓存和DDR3存储控制器。每个核包括1个层次结构的TLB、1个层次结构的数据和指令缓存以及1组高速点到点链路。高速点到点链路基于QuickPath技术，可以让核与其他核以及外部I/O桥直接通信。TLB是虚拟寻址且4路组相联。L1、L2和L3缓存是物理寻址，块大小是64B。L1和L2缓存是8路组相联，L3缓存是16路组相联。页大小可以在启动时配置为4KB和4MB。Linux使用的是4KB页。</p>
<h4 id="core-i7地址转换">9.5.1 Core i7地址转换</h4>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/summary_of_core_i7_address_translation.svg" class="" title="summary_of_core_i7_address_translation">
<p>　　Core
i7采用4级页表层次结构。每个进程都有私有页表层次结构。当Linux进程运行时，虽然Core
i7体系结构允许页表调度，但与已分配的页关联的页表都会驻留在内存中。CR3控制寄存器指向1级页表的起始处。CR3的值是每个进程上下文中的一部分，每次上下文切换时，CR3的值都会恢复。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/format_of_level_1,level_2,and_level_3_pte.svg" class="" title="format_of_level_1,level_2,and_level_3_pte">
<p>　　对于1~3级PTE，当P=1时
(Linux中总是如此)，页表物理基址包含40位PPN，它指向对应页表的起始处。此外，这里还要求页表按4KB对齐。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/format_of_level_4_pte.svg" class="" title="format_of_level_4_pte">
<p>　　对于4级PTE，当P=1时，页表物理基址包括40位PPN，它指向物理内存中某页的基址。此外，这里还要求PP按4KB对齐。</p>
<p>　　PTE有3个权限位来控制页的访问。R/W位表示页的内容是只读还是可读写的。U/S位表示能否在用户模式下访问页。XD
(禁止执行)
位是64位系统中引入的，表示禁止从页中取指令，这是重要的新特性，通过限制只能执行只读代码段，使得操作系统内核降低了缓冲区溢出攻击的风险。</p>
<p>　　当MMU转换VA时，还会更新2个缺页异常处理程序会用到的位。每次访问页时，MMU会设置A位，称为<strong>引用位</strong>。内核可以用这个引用位来实现页替换算法。每次写页后，MMU会设置D位，称为<strong>修改位</strong>或<strong>脏位</strong>。修改位表示内核在复制替换页前是否需要回写牺牲页。内核可以通过调用特殊的内核指令来清除引用位。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/core_i7_page_table_translation.svg" class="" title="core_i7_page_table_translation">
<p>　　通过页表将VA转换为PA时，36位VPN会划分为4个9位的部分，每部分用作1个页表的偏移。CR3寄存器包含1级页表的PA。VPN1提供到1级PTE的偏移，该1级PTE包含2级页表的基址。VPN2提供到2级PTE的偏移，依此类推。</p>
<p>　　地址转换分为MMU将VA转换为PA和将PA发送给L1缓存。实际的硬件实现允许这2个步骤部分重叠，所以也加速了L1缓存的访问。例如，对于页大小为4KB的Core
i7，因为8路组相联且物理寻址的L1缓存有64个组和64B的块，PA有6位CI和6位CO，这12位刚好组成PPO，而PPO和VPO完全相同。因此，当MMU向TLB请求PTE时，L1缓存正在通过VPO查找对应的组并读出这个组里的8个标识和对应的数据。当MMU从TLB得到PPN时，缓存已准备好尝试把这个PPN和8个标识进行匹配。</p>
<h4 id="linux虚拟内存系统">9.5.2 Linux虚拟内存系统</h4>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/the_virtual_memory_of_a_linux_process.svg" class="" title="the_virtual_memory_of_a_linux_process">
<p>　　内核虚拟内存包含内核中的代码和数据结构。内核虚拟内存的某些区域会映射到所有进程共享的PP，例如，每个进程共享的代码和全局数据结构。Linux也会将一组连续的VP
(大小为系统中DRAM的总大小)
映射到一组连续的PP，这为内核提供了便利的方法来访问物理内存中任何特定的位置，例如，当需要访问页表或在映射到特定物理内存位置的设备上执行内存映射的I/O操作时。</p>
<p>　　内核虚拟内存中的其他区域包含每个进程都不同的数据，例如，页表、内核在进程的上下文中执行代码时使用的栈以及记录虚拟地址空间当前组织的各种数据结构。</p>
<h5 id="linux虚拟内存区域">9.5.2.1 Linux虚拟内存区域</h5>
<p>　　Linux将虚拟内存组织为<strong>区域</strong>
(也称为<strong>段</strong>) 集合。1个区域就是已存在 (已分配)
的虚拟内存的连续片，其中的页以某种方式相关联。例如，代码段、数据段、堆、共享库段以及用户栈都是不同的区域。每个存在的VP都保存在某个区域中，而不属于任何区域的VP是不存在的，并且不能被引用。区域允许虚拟地址空间有间隙。内核不用记录不存在的VP，这样的VP不占用内存、磁盘或内核本身的资源。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/how_linux_organizes_virtual_memory.svg" class="" title="how_linux_organizes_virtual_memory">
<p>　　内核为每个进程维护独立的任务结构<code>task_struct</code>。任务结构中的元素包含或指向内核运行该进程所需的所有信息，例如，PID、指向用户栈的指针、可执行文件的名称和PC。</p>
<p>　　任务结构中的1个条目指向<code>mm_struct</code>，它描述虚拟内存的当前状态。<code>pgd</code>指向1级页表
(页全局目录)
的基址。<code>mmap()</code>指向由区域结构<code>vm_area_struct</code>组成的链表，其中的每个区域结构都描述当前虚拟地址空间的某个区域。当内核运行进程时，会将该进程的<code>pgd</code>放入CR3寄存器中。</p>
<p>　　区域结构包含以下字段：</p>
<p>　　● <code>vm_start</code>指向该区域的起始处。</p>
<p>　　● <code>vm_end</code>指向该区域的结束处。</p>
<p>　　● <code>vm_prot</code>描述该区域包含的所有页的读写权限。</p>
<p>　　● <code>vm_flags</code>表示该区域的页 (还有其他信息)
是与其他进程共享还是该进程私有。</p>
<p>　　● <code>vm_next</code>指向链表中的下一个区域结构。</p>
<h5 id="linux缺页处理">9.5.2.2 Linux缺页处理</h5>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/linux_page_fault_handling.svg" class="" title="linux_page_fault_handling">
<p>　　若MMU转换VA时触发了缺页，则会导致控制权转移到缺页异常处理程序，缺页异常处理程序会执行以下步骤：</p>
<p>　　1) <span
style="background-color: yellow">判断该VA是否在某个区域结构定义的区域内</span>。因此，缺页异常处理程序会搜索区域结构链表，将该VA和每个区域结构中的<code>vm_start</code>和<code>vm_end</code>进行匹配。若没有匹配项，则触发段故障，从而终止该进程。进程可以创建任意数量的虚拟内存区域，所以顺序搜索区域结构链表的代价可能很大。在实际中，Linux会使用某些这里没有显示的字段在链表中生成树并在树上进行搜索。</p>
<p>　　2) <span
style="background-color: yellow">判断进程对该区域内的页是否有足够的访问权限</span>。若试图进行的访问不合法
(写只读的页和在用户模式下读内核虚拟内存等)，则缺页异常处理程序会触发保护故障，从而终止该进程。</p>
<p>　　3) <span
style="background-color: yellow">内核确定该缺页是对合法的VA进行合法操作导致的</span>。接下来就是常规的缺页处理，选择牺牲页，若牺牲页被修改过，则进行回写，然后进行页面调度。当从缺页异常处理程序返回时，CPU会重新执行导致缺页的指令，然后MMU正常转换VA。</p>
<h3 id="内存映射">9.6 内存映射</h3>
<p>　　Linux通过将虚拟内存区域与磁盘上的对象关联来初始化该虚拟内存区域的内容，该过程称为<strong>内存映射</strong>。Linux提供了系统调用<code>mmap()</code>来允许程序进行内存映射。虚拟内存区域可以映射到<span
style="background-color: yellow">Linux文件系统中的普通文件</span>和<span
style="background-color: yellow">匿名文件</span>的对象。</p>
<p>　　●
1个区域可以映射到1个普通磁盘文件的连续部分，例如，1个可执行文件。<strong>文件区</strong>被分为页大小的片，每个片都包含1个VP的初始内容。因为按需页面调度，只有当CPU首次引用VP时
(发送在该VP地址空间范围内的VA)，该VP才会调入物理内存。若区域比文件区大，则会用0来填充该区域剩余的部分。</p>
<p>　　●
1个区域也可以映射到1个匿名文件。匿名文件由内核创建，其内容全是二进制0。当CPU首次引用映射到匿名文件的区域内的VP时，内核会在物理内存中选择牺牲页，若牺牲页被修改过，则将牺牲页回写，用二进制0覆盖牺牲页并更新页表。这里磁盘和内存之间没有实际的数据传输。因此，映射到匿名文件的区域的页也称为<strong>请求二进制0的页</strong>。</p>
<p>　　一旦VP初始化，它就在内核维护的<strong>交换文件</strong>之间进行交换，交换文件也称为<strong>交换区域</strong>或<strong>交换空间</strong>。交换空间限制着当前运行的进程能够分配的VP总数。</p>
<h4 id="再看共享对象">9.6.1 再看共享对象</h4>
<p>　　对象可以映射到虚拟内存的某个区域，要么作为共享对象，要么作为私有对象。共享对象映射的虚拟内存区域称为<strong>共享区域</strong>，同样，也有<strong>私有区域</strong>。</p>
<p>　　若进程将共享对象映射到它的虚拟内存的某个区域，则进程对该区域的写操作对其他把该共享对象映射到其虚拟内存的进程是可见的。此外，这些变化也会反映在磁盘的原始对象上。</p>
<p>　　对于映射到私有对象的区域，进程对该区域的修改对其他进程是不可见的，而且进程对该区域的写操作不会反映在磁盘的原始对象上。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/a_shared_object.svg" class="" title="a_shared_object">
<p>　　在这个示例中，进程1将共享对象映射到它的虚拟内存的某个区域中，然后进程2也将同一共享对象映射到它的虚拟内存的某个区域中
(并不一定与进程1的VP相同)。因为每个对象有唯一的文件名，内核可以快速判断进程1已经映射该共享对象并将进程2的PTE指向合适的PP。即使共享对象映射到多个共享区域，物理内存只需存放共享对象的1个副本。这里为了方便，将PP显示为连续的，但一般情况下并非如此。</p>
<p>　　私有对象使用<strong>写时复制</strong>的技术来映射到虚拟内存中。私有对象的开始生命周期的方式基本与共享对象相同，在物理内存中只保存私有对象的1个副本。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/a_private_copy-on-write_object.svg" class="" title="a_private_copy-on-write_object">
<p>　　在这个示例中，2个进程将私有对象映射到虚拟内存的不同区域，但是共享该对象的同一物理副本。对于每个进程，对应私有区域的PTE都是只读，且区域结构为<span
style="background-color: yellow">私有写时复制</span>。当进程写私有区域的页时，写操作会触发保护故障。故障处理程序会在物理内存中创建该页的副本，更新PTE来指向该副本，然后恢复该页的写权限。当从故障处理程序返回时，CPU重新执行写操作，写操作在副本上正常执行。</p>
<p>　　通过尽可能地推迟创建私有对象的副本，写时复制充分利用了物理内存。</p>
<h4 id="再看函数fork和execve">9.6.2
再看函数<code>fork()</code>和<code>execve()</code></h4>
<p>　　当进程调用函数<code>fork()</code>时，内核会为子进程创建各种数据结构并分配唯一的PID。为了给子进程创建虚拟内存，会复制父进程的<code>mm_struct</code>、区域结构和页表。最后，将这2个进程的所有页都设置为只读并将这2个进程中的所有区域结构都设置为私有写时复制。</p>
<p>　　当函数<code>fork()</code>从子进程返回时，子进程当前的虚拟内存与调用函数<code>fork()</code>时的虚拟内存相同。然后，当这2个进程之一执行写操作时，写时复制机制会创建新页。因此，这为每个进程保留了私有地址空间。</p>
<p>　　假设当前进程执行<code>execve("a.out", NULL, NULL)</code>，函数<code>execve()</code>会在当前进程中加载并运行可执行文件<code>a.out</code>中包含的程序，然后用该程序代替当前程序。加载并运行可执行文件<code>a.out</code>需要如下步骤：</p>
<p>　　1) <span
style="background-color: yellow">删除已存在的用户区域</span>。删除当前进程VA的用户部分中的已存在的区域结构。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/how_the_loader_maps_the_areas_to_the_user_address_space.svg" class="" title="how_the_loader_maps_the_areas_to_the_user_address_space">
<p>　　2) <span
style="background-color: yellow">映射私有区域</span>。为新程序的代码、数据、<code>bss</code>和栈区域创建新区域结构，这些新区域都是私有写时复制的。代码和数据区域映射到文件<code>a.out</code>的<code>.text</code>节和<code>.data</code>节。<code>bss</code>区域是请求二进制0的，映射到匿名文件，其大小包含在文件<code>a.out</code>中。栈和堆区域也是请求二进制0的，初始长度为0。</p>
<p>　　3) <span
style="background-color: yellow">映射共享区域</span>。若程序<code>a.out</code>与<code>libc.so</code>等共享库链接，则这些共享库会动态链接到该程序，然后映射到用户虚拟地址空间中的共享区域。</p>
<p>　　4) <span
style="background-color: yellow">设置PC</span>。函数<code>execve()</code>做的最后1件事就是设置当前进程上下文中的PC，使之指向代码区域的入口点。下次调度该进程时，它将从该入口点执行。</p>
<h4 id="使用函数mmap进行用户级内存映射">9.6.3
使用函数<code>mmap()</code>进行用户级内存映射</h4>
<p>　　Linux进程可以通过函数<code>mmap()</code>来创建新虚拟内存区域并将对象映射到该区域中。函数<code>munmap()</code>可以删除虚拟内存区域。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>; <span class="comment">/* 若成功则返回指向映射区域的指针，若出错则返回MAP_FAILED(-1) */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>mmap()</code>会让内核创建新虚拟内存区域
(尽量从地址<code>start</code>开始)，然后将文件描述符<code>fd</code>指定的对象的1个连续的片映射到该区域。连续的对象片的大小为<code>length</code>字节，从文件开始处偏移为<code>offset</code>字节开始。地址<code>start</code>仅仅是1个暗示，通常定义为<code>NULL</code>。</p>
<p>　　参数<code>prot</code>包含描述新映射的虚拟内存区域的访问权限位，即对应的区域结构中的<code>vm_prot</code>。</p>
<p>　　●
<code>PROT_EXEC</code>表示该区域内的页由CPU能执行的指令组成。</p>
<p>　　● <code>PROT_READ</code>表示该区域内的页可读。</p>
<p>　　● <code>PROT_WRITE</code>表示该区域内的页可写。</p>
<p>　　● <code>PROT_NONE</code>表示该区域内的页不能被访问。</p>
<p>　　参数<code>flags</code>由描述映射对象类型的位组成。若设置为<code>MAP_ANON</code>，则映射的对象是匿名对象，而对应的VP是请求二进制0的；若设置为<code>MAP_PRIVATE</code>，则映射的对象是私有写时复制的；若设置为<code>MAP_SHARED</code>，则映射的对象是共享对象。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bufp = Mmap(<span class="literal">NULL</span>, size, PROT_READ, MAP_PRIVATE | MAP_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>　　这段代码会创建<code>size</code>字节的只读、私有和请求二进制0的虚拟内存区域。若调用成功，则<code>bufp</code>会包含新区域的地址。</p>
<p>　　函数<code>munmap()</code>会删除从地址<code>start</code>开始的<code>length</code>字节的区域。之后对已删除区域的引用会导致段故障。</p>
<h3 id="动态内存分配">9.7 动态内存分配</h3>
<p>　　虽然可以通过底层的函数<code>mmap()</code>和<code>munmap()</code>来创建和删除虚拟内存区域，但是C语言的<strong>动态内存分配器</strong>更方便且有更好的可移植性。</p>
<p>　　动态内存分配器维护着<span
style="background-color: yellow">堆</span>。各个系统之间的细节不同，但是不失通用性，这里假设堆是请求二进制0的区域，它紧接着未初始化数据区，并向高地址增长。内核为每个进程维护着指向堆顶部的变量<code>brk</code>。</p>
<p>　　分配器将堆维护为由大小不同的块组成的集合。每个块是1个连续的<span
style="background-color: yellow">虚拟内存片</span>。块要么是已分配的，要么是空闲的。已分配的块显式地保留为应用程序使用。空闲块可用来分配。空闲块会一直保持空闲，直到显式地被应用程序分配。已分配的块会一直保持已分配，直到被释放，这种释放要么由应用程序显式执行，要么由内存分配器隐式执行。</p>
<p>　　分配器有2种形式，两者都要求应用程序显式地分配块，不同之处在于由负责释放已分配的块的实体。</p>
<p>　　● <span
style="background-color: yellow">显式分配器</span>要求应用程序显式地释放所有已分配的块。C语言通过函数<code>malloc()</code>来分配块并通过函数<code>free()</code>来释放块。C++中的操作符<code>new</code>和<code>delete</code>与C中的函数<code>malloc()</code>和<code>free()</code>类似。</p>
<p>　　● <span
style="background-color: yellow">隐式分配器</span>要求分配器检测到已分配的块不再被使用时，就释放该块。隐式分配器也称为<strong>垃圾回收器</strong>，自动释放未使用的已分配的块称为<strong>垃圾回收</strong>。Lisp、ML和Java等高级语言通过垃圾回收来释放已分配的块。</p>
<p>　　程序使用动态内存分配最重要的原因是经常<span
style="background-color: yellow">到运行时才知道某些数据结构的大小</span>。</p>
<h4 id="函数malloc和free">9.7.1 函数malloc和free</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>; <span class="comment">/* 若成功则返回指向分配块的指针，若失败则返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>malloc()</code>返回指向大小至少为<code>size</code>字节的内存块，这个块会为可能包含在这个块内的任何数据对象类型进行对齐。实际上，对齐取决于代码是在32位模式还是64位模式编译。在32位模式中，函数<code>malloc()</code>返回块的地址总是8的倍数；在64位模式中，该地址总是16的倍数。</p>
<p>　　若函数<code>malloc()</code>出错
(请求的内存块比可用的虚拟内存更大等)，则会返回<code>NULL</code>并设置<code>errno</code>。函数<code>malloc()</code>不会初始化返回的块。若需要返回已初始化的块，则可以使用函数<code>calloc()</code>，该函数是基于函数<code>malloc()</code>的瘦包装函数，会将分配的块初始化为0。若需要改变之前分配的块的大小，则可以使用函数<code>realloc()</code>。</p>
<p>　　函数<code>free()</code>会释放参数<code>ptr</code>指向的块。参数<code>ptr</code>必须指向通过函数<code>malloc()</code>、<code>calloc()</code>或<code>realloc()</code>得到的已分配的块的起始处。否则，函数<code>free()</code>的行为将是未定义的。此外，函数<code>free()</code>不会返回，所以即使出错也不会有反馈。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> incr)</span>; <span class="comment">/* 若成功则返回brk的旧值，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>sbrk()</code>通过将内核的<code>brk</code>指针增加<code>incr</code>来扩展或收缩堆。若成功，则会返回<code>brk</code>的旧值；若出错，则返回-1并将<code>errno</code>置为<code>ENOMEM</code>。若<code>incr</code>为0，则返回<code>brk</code>的当前值；若<code>incr</code>小于0，则返回值指向新堆顶向上<code>incr</code>字节处。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/allocating_and_freeing_blocks_with_function_malloc_and_free.svg" class="" title="allocating_and_freeing_blocks_with_function_malloc_and_free">
<p>　　这个示例展示了通过函数<code>malloc()</code>和<code>free()</code>管理16字且双字对齐的堆
(这里的字为4B)，每个方框代表1个字。图a会请求4字的块，函数<code>malloc()</code>会从空闲块前部分配4字的块。图b会请求5字的块，函数<code>malloc()</code>会从空闲块前部分配6字的块
(为了对齐)。图c会请求6字的块，函数<code>malloc()</code>会从空闲块前部分配6字的块。图d会释放图b中分配的6字的块，但指针<code>p2</code>仍然指向释放后的块。图e会请求2字的块，函数<code>malloc()</code>会从图d释放的块的前部分配2字的块。</p>
<h4 id="分配器的要求和目标">9.7.2 分配器的要求和目标</h4>
<p>　　显式分配器必须在以下约束条件下工作：</p>
<p>　　● <span
style="background-color: yellow">处理任意请求序列</span>。程序可以有任意的分配请求和释放请求序列，只要满足约束条件
(每个释放请求必须对应1个当前已分配的块，这个块由之前的分配请求获得)。因此，分配器不可以假设分配请求和释放请求的顺序。</p>
<p>　　● <span
style="background-color: yellow">立即响应请求</span>。分配器必须立即响应分配请求。因此，不允许分配器为了提高性能重新排列或缓存请求。</p>
<p>　　● <span
style="background-color: yellow">只使用堆</span>。为了保证分配器是可扩展的，分配器使用的任何非标量数据结构必须保存在堆里。</p>
<p>　　● <span
style="background-color: yellow">块对齐</span>。分配器必须对齐块使得可以保存任何类型的数据对象。</p>
<p>　　● <span
style="background-color: yellow">不修改已分配的块</span>。分配器只能操作或修改空闲块。因此，压缩已分配的块等技术是不允许使用的。</p>
<p>　　在这些限制条件下，分配器的编写者需要试图实现<span
style="background-color: yellow">吞吐率最大化</span>和<span
style="background-color: yellow">内存利用率最大化</span>，而这2个性能目标通常是冲突的。</p>
<p>　　吞吐率定义为每个单位时间里完成的请求数，可以通过最小化分配请求和释放请求所需的时间来最大化吞吐率。然而，最差情况下分配请求所需的时间与空闲块的数量呈线性关系，释放请求所需的时间是常数。</p>
<p>　　衡量堆利用率的最有用的标准是<strong>峰值利用率</strong>。对于<span
class="math inline">\(n\)</span>个请求的序列<span
class="math inline">\(R_o,R_1,...,R_k,..,R_{n-1}\)</span>，若程序请求<span
class="math inline">\(p\)</span>字节的块，则得到的已分配的块的<strong>有效载荷</strong>是<span
class="math inline">\(p\)</span>字节。在请求<span
class="math inline">\(R_k\)</span>完成后，<strong>聚合有效载荷</strong>表示为<span
class="math inline">\(P_k\)</span>，即当前已分配的块的有效载荷总和。堆的当前大小
(单调非递减) 表示为<span class="math inline">\(H_k\)</span>。前<span
class="math inline">\(k+1\)</span>个请求的峰值利用率表示为<span
class="math inline">\(U_k\)</span>。 <span class="math display">\[
U_k=\frac{max_{i\leqslant k}P_i}{H_k}
\]</span> 　　这里可以将前<span
class="math inline">\(k+1\)</span>个请求的利用率峰值表示为<span
class="math inline">\(H_k\)</span>，则可以在<span
class="math inline">\(U_k\)</span>的定义中放宽单调非递减的条件并且允许堆扩展和收缩。</p>
<p>　　<strong>碎片</strong>是导致堆利用率低的主要原因之一。当未使用的内存不能满足分配请求时，就会出现这种情况。碎片分为<strong>外部碎片</strong>和<strong>内部碎片</strong>。</p>
<p>　　内部碎片在已分配的块比有效载荷大时出现，很多原因都能造成该问题。例如，分配器的实现可能对分配的块有最小值要求或者分配器为了保证对齐。内部碎片的量化很简单，就是所有已分配的块大小和其有效载荷之间的差的总和，所以内部碎片的数量只取决于之前请求的模式和分配器的实现。</p>
<p>　　外部碎片在空闲块总和能满足某个分配请求，但没有单独的空闲块能满足该分配请求时出现。外部碎片的量化不仅取决于之前请求的模式和分配器的实现，还取决于未来请求的模式。因此，分配器通常采用启发式策略，尽量维持少量的大空闲块而非大量的的小空闲块。</p>
<h4 id="隐式空闲链表">9.7.3 隐式空闲链表</h4>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/format_of_a_simple_heap_block.svg" class="" title="format_of_a_simple_heap_block">
<p>　　简单的堆块由<span
style="background-color: yellow">1个字的首部</span>、<span
style="background-color: yellow">有效载荷</span>和<span
style="background-color: yellow">可选的填充部分</span>组成。</p>
<p>　　首部描述该块的大小 (包括首部、有效载荷和填充部分) 和分配状态
(已分配或空闲)。若加上双字对齐的约束条件，则块大小必须8的整数倍，即块大小字段的低3位必须是0。因此，只需要首部的高29位就可以表示块大小，低3位可以表示其他信息，在这种情况下，用最低位表示该块的分配状态。首部后就是调用函数<code>malloc()</code>时请求的有效载荷。填充部分可用于分配器策略、解决外部碎片问题和保证对齐。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/organizing_the_heap_with_an_implicit_free_list.svg" class="" title="organizing_the_heap_with_an_implicit_free_list">
<p>　　若堆由简单的堆块组成，则可以将堆组织为连续的已分配的块和空闲块的序列，这种结构称为<strong>隐式空闲链表</strong>，因为空闲块通过首部中块大小字段隐式地连接。分配器可以通过遍历堆中所有的块来遍历整个空闲块的集合。此外，需要某种特殊标记的结束块，这里使用的是分配状态为已分配但块大小是0的<strong>终止首部</strong>。</p>
<p>　　隐式空闲链表的优点是简单，缺点是不低的操作成本。例如，对于搜索空闲块，搜索所需时间与堆中块的数量呈线性关系。</p>
<p>　　当程序请求<span
class="math inline">\(k\)</span>字节的块时，分配器会搜索满足请求的空闲块，搜索方式由<strong>放置策略</strong>决定。常见的策略包括<strong>首次适配</strong>、<strong>下次适配</strong>和<strong>最佳适配</strong>。首次适配会从头开始搜索空闲链表，选择首个合适的空闲块。下次适配类似首次适配，但是从上一次查询结束的地方开始搜索。最佳适配会检查每个空闲块并选择合适的最小空闲块。</p>
<p>　　●
首次适配的优点是趋向于将大的空闲块保留在链表的后面，缺点是趋向于在链表的前面留下小碎片，这增加了对较大块的搜索时间。</p>
<p>　　● 下次适配由Donald Knuth作为首次适配的替代而提出
(若上次在一些空闲块中已发现了匹配项，则下次很可能在剩余块中发现匹配项)。下次适配明显比首次适配更快，尤其是链表的前面布满很多小碎片时。但是，一些研究表明，下次适配的内存利用率比首次适配低很多。</p>
<p>　　●
最佳适配的内存利用率比首次适配和下次适配的更高。但是，对于隐式空闲链表等简单空闲链表，最佳适配需要对堆进行彻底的搜索。</p>
<p>　　在找到匹配的空闲块后，必须使用另一个策略决定从该空闲块中分配的空间。选择之一是直接使用整个空闲块，但这会导致内部碎片。若放置策略倾向于选择最佳的匹配项，则由此导致的内部碎片是可以接受的；若相反，则会导致分配器将空闲块分为2部分，第1部分作为已分配的块，第2部分作为新的空闲块。</p>
<p>　　若分配器无法为请求找到合适的块，解决方法之一就是合并内存中物理上相邻的空闲块来生成更大的空闲块，若这样仍然无法生成足够大的块或空闲块已最大程度地合并，则分配器会通过调用函数<code>sbrk()</code>来向内核请求额外的堆内存，然后将额外的内存转换为大的空闲块并插入空闲链表，最后在新的空闲块中分配请求的块。</p>
<p>　　当分配器释放已分配的块时，可能有其他空闲块与这个新释放的块相邻。这些相邻的空闲块可能导致<strong>假碎片</strong>，即有很多可用的空闲块被分割为小到无法使用的空闲块。</p>
<h4 id="合并空闲块">9.7.4 合并空闲块</h4>
<p>　　为了解决假碎片的问题，分配器必须合并相邻的空闲块，这个过程称为<strong>合并</strong>。分配器可以选择<strong>立即合并</strong>，即每次释放块时，就立即合并所有相邻的空闲块。立即合并可以在常数时间内完成，但对于某些请求模式，立即合并会导致抖动，即块会反复地合并再分割。分配器也可以选择<strong>延迟合并</strong>，即等待一段时间后再合并空闲块，例如，分配器可以将合并推迟到某些分配请求失败时，然后扫描整个堆并合并空闲块。</p>
<p>　　假设待释放的块为<span
style="background-color: yellow">当前块</span>，合并当前块的下一个块很简单，由于当前块的首部指向下一个块的首部，只需检查当前块的首部就能判断下一个块是否空闲。若下一个块为空闲块，则将它的大小直接加到当前块的大小上，这2个块会在常数时间内合并。合并当前块的前一个块更复杂，对于隐式空闲链表，需要搜索整个链表来获取前一个块的位置，所以每次调用函数<code>free()</code>需要的时间与堆的大小呈线性关系。即使使用更复杂的空闲链表组织，搜索时间也不会是常数。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/format_of_a_heap_block_with_a_boundary_tag.svg" class="" title="format_of_a_heap_block_with_a_boundary_tag">
<p>　　Donald
Knuth提出了<strong>边界标记</strong>，可以在常数时间内将当前块与前一个块合并。基本思想是在每个块的结尾添加<strong>脚部</strong>
(即边界标记)，脚部是首部的副本。分配器可以通过检查前一个块的脚部来确定其起始处和分配状态。</p>
<p>　　边界标记有1个潜在的缺点，就是要求每个块都有首部和脚部，在程序运行较长时间后，会显著增加内存开销。例如，某个图像应用通过反复调用函数<code>malloc()</code>和<code>free()</code>来动态地创建和释放图形节点且每个图像节点都是2个字，那么首部和脚部将占用每个已分配的块的一半空间。解决方法就是<span
style="background-color: yellow">已分配的块不添加脚部</span>，因为只有相邻的块都是空闲块时，才能合并
(才需要使用脚部)。</p>
<h4 id="实现简单的分配器">9.7.5 实现简单的分配器</h4>
<p>　　这里将实现基于隐式空闲链表和边界标记的简单分配器。此外，块的最大值为<span
class="math inline">\(2^{32}=4\)</span>GB。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* memlib.c (内存系统模型) */</span></span><br><span class="line"><span class="comment">/* 私有全局变量 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mem_heap;     <span class="comment">/* 指向堆的第1个字节的指针 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mem_brk;      <span class="comment">/* 指向堆的最后1个字节加1的指针 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mem_max_addr; <span class="comment">/* 堆的最大地址加1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化内存系统模型</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    mem_heap = (<span class="type">char</span> *)Malloc(MAX_HEAP);</span><br><span class="line">    mem_brk = (<span class="type">char</span> *)mem_heap;</span><br><span class="line">    mem_max_addr = (<span class="type">char</span> *)(mem_heap + MAX_HEAP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数sbrk的简单模型，将堆扩展incr字节并返回新区域的起始地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param incr 堆扩展的字节数 (不能为负)</span></span><br><span class="line"><span class="comment"> * @return void* 新区域的起始地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mem_sbrk</span><span class="params">(<span class="type">int</span> incr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *old_brk = mem_brk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((incr &lt; <span class="number">0</span>) || ((mem_brk + incr) &gt; mem_max_addr))</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ERROR: mem_sbrk failed. Ran out of memory...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mem_brk += incr;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)old_brk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　<code>memlib.c</code>提供的内存系统模型的目的是允许在不干涉系统层<code>malloc</code>包的情况下运行分配器。</p>
<p>　　函数<code>mem_init()</code>会将堆可用的虚拟内存建模为双字对齐的字节数组。<code>mem_heap</code>和<code>mem_brk</code>之间的字节表示已分配的虚拟内存。<code>mem_brk</code>后的字节表示未分配的虚拟内存。分配器通过调用函数<code>mem_sbrk()</code>来请求额外的堆内存，该函数与函数<code>sbrk()</code>的接口相同且语义也相同，唯一区别是函数<code>mem_sbrk()</code>会拒接收缩堆的请求。</p>
<p>　　分配器在源文件<code>mm.c</code>中，用户可以编译和链接该源文件到指定的程序中。分配器输出以下3个函数到程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">mm_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>mm_init()</code>会初始化分配器，若成功，则返回0；若出错，则返回-1。函数<code>mm_malloc()</code>和<code>mm_free()</code>与对应的系统级函数有相同的接口和语义。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/invariant_form_of_the_implicit_free_list.svg" class="" title="invariant_form_of_the_implicit_free_list">
<p>　　分配器使用的是带有边界标记的堆块。<span
style="background-color: yellow">块的最小值为16B</span>。空闲链表组织为隐式空闲链表。第1个字是用于双字对齐的
(未使用)
填充字。填充字后是<strong>序言块</strong>，这是8B的已分配的块，仅由首部和脚部组成。序言块在初始化时创建且永不释放。序言块后是若干个通过调用函数<code>malloc()</code>和<code>free()</code>得到的普通块。堆总是以<strong>结尾块</strong>结尾，这个块是0B的已分配的块，仅由首部组成。序言块和结尾块用于合并时消除边界条件。分配器使用私有全局变量<code>heap_listp</code>指向序言块
(作为优化，可以将其指向序言块的下一个块)。</p>
<h5 id="操作空闲链表的基本常数和宏">9.7.5.1
操作空闲链表的基本常数和宏</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mm.c */</span></span><br><span class="line"><span class="comment">/* 基本常量和宏 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4             <span class="comment">/* 字、首部和脚部的大小 (字节) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8             <span class="comment">/* 双字的大小 (字节) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12) <span class="comment">/* 堆扩展时扩展部分的大小 (字节) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x) &gt; (y) ? (x) : (y));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将大小字段和分配状态标志位打包成1个字 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读写地址p处的字 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p) (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val) (*(unsigned int *)(p) = (val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读地址p的大小字段和分配状态标志位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p) (GET(p) &amp; -0x7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取块指针bp指向的块的首部和脚部的地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp) ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取块指针bp指向的块的后继块和前驱块的地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span></span><br></pre></td></tr></table></figure>
<p>　　第3~5行是分配器会使用的基本参数和宏，即字的大小<code>WSIZE</code>、双字的大小<code>DSIZE</code>以及初始块和堆扩展时扩展部分的大小<code>CHUNKSIZE</code>。</p>
<p>　　第10行的宏<code>PACK</code>会将大小字段和分配状态标志位结合起来并返回，可以用于赋值给首部和脚部。</p>
<p>　　第13行的宏<code>GET</code>会读取并返回参数<code>p</code>指向的字，这里的强制类型转换很重要。参数<code>p</code>是<code>void *</code>类型，不能直接进行间接引用。第14行的宏<code>PUT</code>会将参数<code>val</code>存放在参数<code>p</code>指向的字中。</p>
<p>　　第16~17行的宏<code>GET_SIZE</code>和<code>GET_ALLOC</code>会从地址<code>p</code>处的首部或脚部分配返回大小字段和分配状态标志位。</p>
<p>　　其余的宏都是对<span
style="background-color: yellow">块指针</span><code>bp</code>进行操作，块指针指向有效载荷的第1个字节。对于块指针指向的块，宏<code>HDRP</code>和<code>FTRP</code>分别返回指向的该块的首部和脚部的指针，宏<code>NEXT_BLKP</code>和<code>PREV_BLKP</code>分别返回指向该块的后继块和前驱块的指针。</p>
<h5 id="创建初始空闲链表">9.7.5.2 创建初始空闲链表</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mm.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief (私有) 用新空闲块扩展堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param words	扩展的字数</span></span><br><span class="line"><span class="comment"> * @return void*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配偶数个字以保证对齐 */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化空闲块的首部、脚部以及结尾块的首部 */</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));         <span class="comment">/* 空闲块首部 */</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));         <span class="comment">/* 空闲块脚部 */</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>)); <span class="comment">/* 新结尾块首部 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若相邻的块是空闲块则合并 */</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建有1个初始空闲块的堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 创建初始空堆 */</span></span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PUT(heap_listp, <span class="number">0</span>);                          <span class="comment">/* 用于对齐的填充部分 */</span></span><br><span class="line">    PUT(heap_listp + WSIZE, PACK(DSIZE, <span class="number">1</span>));     <span class="comment">/* 序言块首部 */</span></span><br><span class="line">    PUT(heap_listp + <span class="number">2</span> * WSIZE, PACK(DSIZE, <span class="number">1</span>)); <span class="comment">/* 序言块脚部 */</span></span><br><span class="line">    PUT(heap_listp + <span class="number">3</span> * WSIZE, PACK(<span class="number">0</span>, <span class="number">1</span>));     <span class="comment">/* 结尾块首部 */</span></span><br><span class="line">    heap_listp += <span class="number">2</span> * WSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用1个CHUNKSIZE字节的空闲块扩展空堆 */</span></span><br><span class="line">    <span class="keyword">if</span> (extend_heap(CHUNKSIZE / WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在调用函数<code>mm_malloc()</code>或<code>mm_free()</code>前，应用程序必须通过调用函数<code>mm_init()</code>来初始化堆。</p>
<p>　　函数<code>mm_init()</code>会从内存系统获取4个字并初始化它们来创建空的空闲链表
(第37~45行)，然后调用函数<code>extend_heap()</code>。函数<code>extend_heap()</code>会将堆扩展<code>CHUNKSIZE</code>字节并创建初始空闲块。此时，分配器已初始化，可以接收来自应用程序的分配和释放请求。</p>
<p>　　函数<code>extend_heap()</code>会在2种不同的环境中被调用，即初始化堆和当<code>mm_malloc()</code>不能找到合适的匹配块时。为了保证对齐，函数<code>extend_heap()</code>会将请求大小向上舍入为最接近的双字的整数倍，然后向内存请求额外的堆空间
(第14~18行)。</p>
<p>　　在第21~26行中，堆开始于双字对齐的边界，每次调用函数<code>heap_extend()</code>都返回大小是双字的整数倍的块。因此，每次调用函数<code>mem_sbrk()</code>都会返回双字对齐的内存片，紧跟在结尾块首部后面。结尾块首部会变为新空闲块的首部
(第21行) 且该片的最后1个字变为新的结尾块首部
(第23行)。最后，因为可能出现相邻的块都是空闲块的情况，所以调用函数<code>coalesce()</code>来合并空闲块，该函数会返回指向合并后的块的块指针
(第26行)。</p>
<h5 id="释放和合并块">9.7.5.3 释放和合并块</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mm.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 通过边界标记将指定的空闲块和所有相邻的空闲块合并</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param bp 指向空闲块的块指针</span></span><br><span class="line"><span class="comment"> * @return void*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放块并进行合并</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param bp 块指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　应用程序可以通过调用函数<code>mm_free()</code>来释放块并合并与之相邻的空闲块。函数<code>coalesce()</code>会合并空闲块。</p>
<h5 id="分配块">9.7.5.4 分配块</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mm.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief (私有) 首次适配搜索</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param asize 块大小</span></span><br><span class="line"><span class="comment"> * @return void* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *bp;</span><br><span class="line">    <span class="keyword">for</span> (bp = heap_listp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp))))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief (私有) 放置块，当剩余部分不小于16B时进行分割</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param bp 块指针</span></span><br><span class="line"><span class="comment"> * @param asize 块大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">void</span> *bp, <span class="type">size_t</span> asize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">if</span> ((csize - asize) &gt;= (<span class="number">2</span> * DSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(bp), PACK(csize - asize, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize - asize, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从空闲链表分配块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param size 分配的块的大小</span></span><br><span class="line"><span class="comment"> * @return void*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> asize;</span><br><span class="line">    <span class="type">size_t</span> extendsize;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略空请求 */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调整块大小 */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        asize = <span class="number">2</span> * DSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        asize = DSIZE * ((size + <span class="number">2</span> * DSIZE - <span class="number">1</span>) / DSIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 寻找合适的空闲块 */</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若找不到合适的空闲块，则分配更多的空间来满足请求 */</span></span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　应用程序可以调用函数<code>mm_malloc()</code>来向内存请求<code>size</code>字节的块。在检查请求是否为空后，分配器必须调整请求块的大小来为首部和脚部保留空间并保证双字对齐。第64~67行保证块最少有16B，其中8B用于对齐，另外8B用于存放首部和脚部。对于超过8B的请求，会加上开销字节并向上舍入到最接近的8的整数倍
(第70行)。</p>
<p>　　分配器调整了块大小后，会搜索空闲链表来寻找合适的空闲块
(第74行)。若有合适的块，则分配器会为请求块分配空间并可选地分割出多余的部分
(第76行)，然后返回指向新分配的块的指针；若没有合适的块，则用新空闲块来扩展堆
(第81~85行) 并可选地分割这个块
(第86行)，然后返回指向新分配的块的指针。</p>
<h4 id="显式空闲链表">9.7.6 显式空闲链表</h4>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/format_of_heap_blocks_that_use_doubly_linked_free_lists.svg" class="" title="format_of_heap_blocks_that_use_doubly_linked_free_lists">
<p>　　对于隐式空闲链表，块分配与堆块的数量呈线性关系，所以这种结构不合适通用分配器。更好的方法是将空闲块组织为某种形式的<strong>显式空闲链表</strong>。空闲块不需要有效载荷，所以实现显式空闲链表的指针可以存放在空闲块的有效载荷中。例如，堆可以组织成双向空闲链表，每个空闲块中到包含前驱和后继指针。</p>
<p>　　使用双向链表，可以让首次适配所需的时间从块总数的线性时间减少到空闲块数量的线性时间。不过，释放块所需时间可以是线性的，也可以是常数，这取决于空闲链表中块的排序策略。</p>
<p>　　可以用<span
style="background-color: yellow">先进后出</span>顺序来维护链表，将新释放的块放在链表的开始处。使用LIFO顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放块可以在常数时间内完成，若使用边界标记，则合并也可以在常数时间内完成。也可以用<span
style="background-color: yellow">地址顺序</span>来维护链表，
其中链表的每个块的地址都小于其后继块的地址。在这种情况下，释放块需要线性时间来定位前驱块。但是，用地址顺序的首次适配比LIFO顺序的首次适配有更高的内存利用率。</p>
<p>　　显式链表的缺点是空闲块必须足够大以包含所需的指针、首部和可能的脚部，这就导致了更大的块最小值，也潜在地提高了内部碎片的比例。</p>
<h4 id="分离空闲链表">9.7.7 分离空闲链表</h4>
<p>　　使用单向空闲块链表的分配器需要与空闲块呈线性关系的时间来分配块。可以通过<strong>分离存储</strong>来减少分配时间，即维护多个空闲链表，每个链表中的块有大致相等的大小。常规思路是将所有可能的块大小分成一些等价类，称为<strong>大小类</strong>。有很多方式来定义大小类。</p>
<p>　　可以根据2的幂来划分块大小： <span class="math display">\[
\{1\},\{2\},\{3,4\},\{5\sim8\},...,\{1025\sim2048\},\{2049\sim4096\},\{4097\sim\infty\}
\]</span>
　　也可以将较小的块分配到单独的大小类中，而较大的块按照2的幂分类：
<span class="math display">\[
\{1\},\{2\},\{3\},...,\{1023\},\{1024\},\{1025\sim2048\},\{2049\sim4096\},\{4097\sim\infty\}
\]</span>
　　分配器维护着空闲链表数组，每个大小类1个数组，按照大小升序排列。当分配器需要大小为<span
class="math inline">\(n\)</span>的块时，会搜索对应的空闲链表。若不能找到合适的块，则搜索下一个链表，依此类推。</p>
<p>　　动态存储分配的相关文献描述了数十种分离存储的方法，主要区别在于它们如何定义大小类、何时进行合并、何时向操作系统请求额外的堆内存和是否允许分割等。这里仅介绍<strong>简单分离存储</strong>和<strong>分离适配</strong>。</p>
<h5 id="简单分离存储">9.7.7.1 简单分离存储</h5>
<p>　　对于简单分离存储，每个大小类的空闲链表包含大小相等的块，每个块的大小就是这个大小类中最大元素的大小。例如，某个大小类定义为<span
class="math inline">\(\{17\sim32\}\)</span>，则这个类的空闲链表全由大小为32的块组成。</p>
<p>　　为了分配指定大小的块，需要检查相应的空闲链表，若链表非空，则分配其中第1块的全部，空闲块不会分割以满足分配请求；若链表为空，则分配器向操作系统请求固定大小的额外内存片
(通常是页大小的整数倍)，将这个片分成大小相等的块并将这些块链接起来形成新的空闲链表。对于释放块，分配器只需将这个块插入到对应的空闲链表的前部。</p>
<p>　　简单分离存储的优点很多。分配和释放块都能在很快的常数时间内完成，而且每个片中的块都大小相等，不分割，不合并，这意味着每个块只有很少的内存开销。由于每个片中的块都大小相等，则已分配的块的大小能从它的地址中推断出来。因为没有合并，所以已分配的块的首部不需要分配状态标志位，即已分配的块不需要首部，而且也不需要脚部。因为分配和释放操作都是在空闲链表的起始处操作，所以链表只需要是单向的。每个空闲块都需要的字段是1个字的后继指针，所以块的最小值就是1个字。</p>
<p>　　简单分离存储的缺点是很容易产生碎片。因为不会分割空闲块，所以可能产生内部碎片。由于不会合并空闲块，某些引用模式会产生很多的外部碎片。例如，应用程序先向第1个大小类发送大量的分配和释放请求，然后向第2个大小类发送大量的分配和释放请求，然后向第3个大小类发送大量的分配和释放请求，依此类推。对于每个大小类，分配器会向操作系统请求大量永远不会回收的内存，因为不会合并空闲块，应用程序不再请求大小类的块后，该大小类的块将不再被使用。</p>
<h5 id="分离适配">9.7.7.2 分离适配</h5>
<p>　　对于分离适配，分配器维护着空闲链表的数组。每个空闲链表都与1个大小类关联且被组织为某种类型的显式或隐式链表。每个链表包含潜在的大小不同的块，这些块的大小是大小类的成员。有多种不同的分离适配器，这里只介绍比较简单的版本。</p>
<p>　　为了分配块，必须确定请求的大小类，对适当的空闲链表进行首次适配来查找合适的块。若找到合适的块，则可选地分割并将剩余部分插入到合适的空闲链表中；若找不到合适的块，则搜索下一个更大的大小类的空闲链表，依此类推，直到找到合适的块。若空闲链表中没有合适的块，则向操作系统请求额外的堆内存，从这个新的堆内存中分配块，将剩余部分插入到合适的空闲链表中。对于释放块，需要合并并将结果插入到合适的空闲链表中。</p>
<p>　　分离适配是很多分配器的常用选择，C语言中的<code>malloc</code>包就使用这种方法，因为这种方法既快速，又有较高的内存利用率。搜索时间减少了，因为搜索限定在堆的某个部分而非整个堆。内存利用率提高了，因为对分离空闲链表的首次适配搜索的内存利用率近似于对整个堆的最佳适配搜索的内存利用率。</p>
<p>　　<strong>伙伴系统</strong>就是分离适配的特例之一，其中每个大小类都是2的幂。基本思路是对于大小是<span
class="math inline">\(2^m\)</span>个字的堆，为每个块大小<span
class="math inline">\(2^k\)</span>维护1个分离空闲链表，其中<span
class="math inline">\(0\leqslant k\leqslant
m\)</span>。请求块向上舍入到最接近的2的幂。开始时，只有1个大小为<span
class="math inline">\(2^m\)</span>个字的空闲块。</p>
<p>　　对于分配大小为<span
class="math inline">\(2^k\)</span>的块，需要找到第1个可用且大小为<span
class="math inline">\(2^j\)</span>的块，其中<span
class="math inline">\(k \leqslant j \leqslant m\)</span>。若<span
class="math inline">\(j=k\)</span>，则直接完成；否则，递归地二分这个块，直到<span
class="math inline">\(j=k\)</span>。在进行分割时，每个剩余的半块
(也称为<strong>伙伴</strong>) 会插入到对应的空闲链表中。释放大小为<span
class="math inline">\(2^k\)</span>的块后，需要一直合并空闲的伙伴，直到碰到已分配的伙伴。</p>
<p>　　通过给定地址和块大小可以计算出它的伙伴的地址，因为两者的地址只有1位不同。例如，大小为32B的块的地址为<span
class="math inline">\(xxx...x00000\)</span>，其伙伴的地址为<span
class="math inline">\(xxx...x10000\)</span>。</p>
<p>　　伙伴系统的优点是快速搜索和快速合并，缺点是块大小是2的幂的要求可能产生大量内部碎片。因此，伙伴系统分配器不适合通用目的应用程序，只适合那些块大小为2的幂的应用程序。</p>
<h3 id="垃圾回收">9.8 垃圾回收</h3>
<p>　　在C语言中的<code>malloc</code>包等显式分配器中，程序调用函数<code>malloc()</code>和<code>free()</code>来分配和释放堆块。程序需要负责释放所有不再需要的已分配的块。未能释放的已分配的块是常见的编程错误之一。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">garbage</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)Malloc(<span class="number">15213</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* 数组p此时已成为垃圾 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，在函数<code>garbage()</code>返回前应该释放<code>p</code>，这个块会在程序的生命周期内一直保持已分配状态。</p>
<p>　　<strong>垃圾回收器</strong>是动态存储分配器，它自动释放程序不再需要的已分配的块，这些块称为<strong>垃圾</strong>。自动回收堆内存的过程称为<strong>垃圾回收</strong>。在支持垃圾回收的系统中，程序显式分配堆块，无需显式释放它们。</p>
<p>　　垃圾回收可以追溯到John
McCarthy于20世纪60年代早期在MIT开发的Lisp系统，它是Java、ML、Perl和Mathematica等现代语言系统中的重要部分之一，而且它仍然是重要且活跃的研究领域之一。相关文献描述了大量的垃圾回收方法，这里仅介绍John
McCarthy独创的标记-清除算法。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/garbage_collector's_view_of_memory_as_a_directed_graph.svg" class="" title="garbage_collector" alt="s_view_of_memory_as_a_directed_graph">
<p>　　如图所示，垃圾回收器将内存视为<span
style="background-color: yellow">有向可达图</span>。该图的节点分为<strong>根节点</strong>和<strong>堆节点</strong>。堆节点对应堆中已分配的块。有向边<span
class="math inline">\(p \rightarrow q\)</span>表示块<span
class="math inline">\(p\)</span>中的某个位置指向块<span
class="math inline">\(q\)</span>中的某个位置。根节点对应那些不在堆中且包含指向堆的指针的位置，这些位置可以是寄存器、栈里的变量或虚拟内存中读写数据区域中的全局变量。</p>
<p>　　当存在任意1条从根节点出发并到达<span
class="math inline">\(p\)</span>的有向路径时，则节点<span
class="math inline">\(p\)</span>是<span
style="background-color: yellow">可达</span>的。不可达的节点对应垃圾，是不能再次为程序所用。垃圾回收器负责维护可达图的某种表示，通过释放不可达的节点并将其返回给空闲链表来定期回收垃圾。</p>
<p>　　ML和Java等语言的垃圾回收器对程序如何创建和使用指针有严格的控制，可以维护可达图的精确表示，从而可以回收所有垃圾。C和C++等语言通常不能维护可达图的精确表示，这样的回收器也称为<strong>保守式垃圾回收器</strong>。保守式垃圾回收器是保守的，因为每个可达的节点都会被标记为可达，而一些不可达的节点也会被标记为可达。</p>
<p>　　回收器可以按需提供服务，也可以作为和应用程序并行的独立线程来不断地更新可达图和回收垃圾。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/integrating_a_conservative_garbage_collector_and_a_c_malloc_package.svg" class="" title="integrating_a_conservative_garbage_collector_and_a_c_malloc_package">
<p>　　将保守式垃圾回收器加入到C语言的<code>malloc</code>包后，当需要堆空间时，应用程序会用常规方式调用函数<code>malloc()</code>。若函数<code>malloc()</code>找不到合适的块，则调用垃圾回收器来回收一些垃圾到空闲链表。回收器识别垃圾块并通过调用函数<code>free()</code>来将它们返回给堆。关键思想是回收器代替应用程序去调用函数<code>free()</code>。当从回收器返回时，函数<code>malloc()</code>重新寻找合适的块。若仍然找不到，则会向操作系统请求内存。最后，函数<code>malloc()</code>返回指向请求块的指针
(若成功) 或空指针 (若失败)。</p>
<h4 id="标记-清除垃圾回收器">9.8.1 标记-清除垃圾回收器</h4>
<p>　　标记-清除垃圾回收器包括<span
style="background-color: yellow">标记阶段</span>和<span
style="background-color: yellow">清除阶段</span>。标记阶段标记出所有根节点可达且已分配的节点，随后的清除阶段释放每个未被标记且已分配的节点。块首部中空闲的低位中的1位通常用于表示这个块是否被标记。</p>
<p>　　这里对标记-清除的描述会假设使用以下函数
(其中<code>ptr</code>定义为<code>typedef void *ptr</code>) ：</p>
<p>　　●
<code>ptr isPtr(ptr p)</code>会判断<code>p</code>是否指向已分配的块的某个字。若是，则返回指向该块的起始处的指针<code>b</code>；否则，返回<code>NULL</code>。</p>
<p>　　●
<code>int blockMarked(ptr b)</code>会判断<code>b</code>是否被标记。若是，则返回<code>true</code>。</p>
<p>　　●
<code>int blockAllocated(ptr b)</code>会判断<code>b</code>是否已分配。若是，则返回<code>true</code>。</p>
<p>　　● <code>void markBlock(ptr b)</code>会标记块<code>b</code>。</p>
<p>　　● <code>int length(b)</code>会返回块<code>b</code>的长度
(不包括首部)，单位是字。</p>
<p>　　●
<code>void unmarkBlock(ptr b)</code>会取消块<code>b</code>的标记。</p>
<p>　　●
<code>ptr nextBlock(ptr b)</code>会返回堆中块<code>b</code>的后继块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 伪代码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mark</span><span class="params">(ptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((b = isPtr(p)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (blockMarked(b))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    markBlock(b);</span><br><span class="line">    len = lenght(b);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mark(b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sweep</span><span class="params">(ptr b, ptr end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (b &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (blockMarked(b))</span><br><span class="line">        &#123;</span><br><span class="line">            unmarkBlock(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (bloackAllocated(b))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        b = nextBlock(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　标记阶段会为每个根节点调用1次函数<code>mark()</code>。若<code>p</code>不指向已分配且未标记的堆块，则函数<code>mark()</code>立即返回；否则，它会标记该块并对块中的每个字递归地调用自己。每次调用函数<code>mark()</code>都会标记某个根节点的所有未标记且可达的后继节点。在标记阶段的最后，任何未标记且已分配的块被认为是不可达的
(即垃圾)，会在清除阶段被回收。</p>
<p>　　清除阶段会调用1次函数<code>sweep()</code>。函数<code>sweep()</code>会进行循环，释放遇到的所有未标记且已分配的块。</p>
<img src="/2023/08/02/computer-systems-a-programmer's-perspective-3e-chpt-9/mark&sweep_example.svg" class="" title="mark&amp;sweep_example">
<p>　　在这个示例中，块边界用粗线表示。每个方块对应内存中的1个字。每个块都有1个字的首部，要么是未标记的，要么是已标记的。开始时，堆中有6个未标记且已分配的块。块3包含指向块1的指针。块4包含指向块3和块6的指针。根节点指向块4，所以在标记阶段后，块1、块3、块4和块6会被标记
(可达)，块2和块5不会被标记
(不可达)。在清除阶段后，块2和块5会被回收到空闲链表。</p>
<h4 id="c程序的保守式标记-清除">9.8.2 C程序的保守式标记-清除</h4>
<p>　　标记-清除看似适合C程序的垃圾回收，因为它可以直接工作，而无需移动任何块。但是，C语言在实现函数<code>isPtr()</code>时会遇到一些问题。首先，C语言不会用任何信息来标记内存位置，所以无法判断函数<code>isPtr()</code>的入参<code>p</code>是否是指针。其次，即使知道<code>p</code>是指针，也无法判断<code>p</code>是否指向某个已分配的块的有效载荷中的某个位置。</p>
<p>　　对于第1个问题的解决方法是将已分配的块集合维护成平衡二叉树，该树的左子树中的所有块必须放在较小的地址处，右子树中的所有块放在较大的地址处。这需要在每个已分配的块的首部加入<code>left</code>和<code>right</code>字段，这2个字段指向某个已分配的块的首部。函数<code>isPtr(ptr p)</code>通过树来对已分配的块进行二分查找，每次通过首部的大小字段来判断<code>p</code>是否在这个块的范围内。</p>
<p>　　平衡二叉树会标记所有根节点可达的节点，这是必要的保证，因为应用程序的用户当然不会想过早地把已分配的块返回给空闲链表。然后，这种方法从某种意义上是保守的，因为它可能不正确地标记了实际不可达的块，所以它可能不会释放某些垃圾。</p>
<p>　　C程序的标记-清除必须是保守的，其根本原因在于C语言不会用任何信息来标记内存位置。因此，<code>int</code>和<code>float</code>等标量可以伪装成指针。例如，若某个可达的已分配的块的有效载荷中包含1个<code>int</code>，其值碰巧对应某个其他已分配的块<code>b</code>的有效载荷中的某个地址。对回收器而言，无法判断这个数据是<code>int</code>还是指针。因此，分配器必须保守地将块<code>b</code>标记为可达。</p>
<h3 id="c程序中常见的内存相关错误">9.9 C程序中常见的内存相关错误</h3>
<p>　　对于C程序员，管理和使用虚拟内存可能是困难且容易出错的，因为内存相关错误经常在时间和空间上与错误源有一段距离后才表现出来。</p>
<h4 id="间接使用坏指针">9.9.1 间接使用坏指针</h4>
<p>　　在进程的虚拟地址空间中有较大的空区域，没有映射到任何有意义的数据，若试图间接引用指向该区域的指针，则操作系统会以段故障中止程序。此外，虚拟内存的某些区域是只读，若试图写这些区域，则会以保护故障中止程序。</p>
<p>　　函数<code>scanf()</code>错误是间接引用坏指针的经典错误之一。若需要通过函数<code>scanf()</code>从<code>stdin</code>读整数到变量。正确的方法是将传递给函数<code>scanf()</code>格式串和<span
style="background-color: yellow">变量的地址</span>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val);</span><br></pre></td></tr></table></figure>
<p>　　但有时，很容传递<code>val</code>而非其地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, val);</span><br></pre></td></tr></table></figure>
<p>　　在这种情况下，函数<code>scanf()</code>会将<code>val</code>的值解释为地址并试图写该地址。在最好的情况下，程序会立即以异常中止。在最差的情况下，<code>val</code>的值刚好对应虚拟内存中的某个可读写区域，于是就会覆盖该区域的值，这通常会在一段时间才会造成严重后果。</p>
<h4 id="读未初始化的内存">9.9.2 读未初始化的内存</h4>
<p>　　虽然<code>bss</code>区域总是被加载器初始化为0，但是堆内存却不是这样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">matvec</span><span class="params">(<span class="type">int</span> **A, <span class="type">int</span> *x, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> *y = (<span class="type">int</span> *)Malloc(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            y[i] += A[i][j] * x[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，会错误地假设数组<code>y</code>被初始化为0。正确的实现方式是显式地将<code>y[i]</code>设置为0或使用函数<code>calloc()</code>。</p>
<h4 id="栈缓冲区溢出">9.9.3 栈缓冲区溢出</h4>
<p>　　在不检查输入字符串的长度情况下，直接将其写到栈的目标缓冲区会导致<span
style="background-color: yellow">缓冲区溢出</span>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bufoverflow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，函数<code>gets()</code>会复制任意长度的字符串到缓冲区，这会导致缓冲区溢出，应使用函数<code>fgets()</code>，该函数会限制输入字符串的长度。</p>
<h4 id="假设指针与其指向的对象大小相同">9.9.4
假设指针与其指向的对象大小相同</h4>
<p>　　假设指针与其指向的对象大小相同是常见的错误之一。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> **<span class="title function_">markArray1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> **A = (<span class="type">int</span> **)Malloc(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = (<span class="type">int</span> *)Malloc(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会创建包含<code>n</code>个指针的数组，其中的每个指针都指向包含<code>m</code>个<code>int</code>的数组。但在第4行中，实际创建的是<code>int</code>数组。</p>
<p>　　这个示例在<code>int</code>长度和指针长度相同的机器上可以正常运行，但在Core
i7等指针长度大于<code>int</code>长度的机器上运行会导致第5~8行的循环越界。因为这些字中的某个字很可能是已分配的块的脚部，所以这个错误不会立即出现，直到之后释放该块时，此时，分配器的合并会出错且没有任何明显的原因。这也是
"在远处起作用" 的示例，这类 "在远处起作用" 通常与内存相关错误有关。</p>
<h4 id="相差1错误">9.9.5 相差1错误</h4>
<p>　　<strong>相差1</strong>错误是另一种常见的导致覆盖错误的原因。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> **<span class="title function_">markArray2</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> **A = (<span class="type">int</span> **)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会创建包含<code>n</code>个指针的数组，其中的每个指针都指向包含<code>m</code>个<code>int</code>的数组。第5~8行会试图初始化该数组的<code>n + 1</code>个元素，这个过程会覆盖数组后面的某个内存位置。</p>
<h4 id="引用指针而非其指向的对象">9.9.6 引用指针而非其指向的对象</h4>
<p>　　若不太注意C操作符的优先级和结合性，可能会错误地将指针作为指针指向的内容来操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">binheapDelete</span><span class="params">(<span class="type">int</span> **binheap, <span class="type">int</span> *size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *packet = binheap[<span class="number">0</span>];</span><br><span class="line">    binheap[<span class="number">0</span>] = binheap[*size - <span class="number">1</span>];</span><br><span class="line">    *size--; <span class="comment">/* 这里应该是(*size)-- */</span></span><br><span class="line">    heapify(binheap, *size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> packet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会删除包含<code>*size</code>项的二叉堆里的第1项，然后对剩下的<code>*size - 1</code>项重新建堆。第5行是为了减少<code>size</code>指向的值，但是一元运算符<code>--</code>和<code>*</code>的优先级相同并从右到左关联，所以减少的就是指针的值。若足够幸运，程序会立即中止，但更有可能发生的是程序在运行较长时间后才会产生不正确的结果。</p>
<h4 id="误解指针运算">9.9.7 误解指针运算</h4>
<p>　　忘记了指针的算术操作是以它们指向的对象的大小作为单位来进行是常见错误之一。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">search</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (*p &amp;&amp; *p != val)</span><br><span class="line">    &#123;</span><br><span class="line">        p += <span class="keyword">sizeof</span>(<span class="type">int</span>); <span class="comment">/* 应该是p++ */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会扫描<code>int</code>数组并返回指向第1个<code>val</code>的指针。第5行中会把指针加4，就导致函数会错误地扫描数组中的每4个整数。</p>
<h4 id="引用不存在的变量">9.9.8 引用不存在的变量</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">stackref</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">return</span> &amp;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会返回指针，该指针指向随后会弹出栈帧的局部变量。尽管<code>p</code>指向合法的内存地址，但已经不再指向合法的变量。当之后程序调用其他函数时，函数<code>stackref()</code>原本的栈帧会被重用来作为其他函数的栈帧。再后来，若程序分配某个值给<code>*p</code>，则可能实际会修改另一个函数的栈帧的某个条目。</p>
<h4 id="引用空闲堆块中的数据">9.9.9 引用空闲堆块中的数据</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">heapref</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> *x, *y;</span><br><span class="line">    x = (<span class="type">int</span> *)Malloc(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">    y = (<span class="type">int</span> *)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        y[i] = x[i]++; <span class="comment">/* x[i]在空闲块中 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，第5行分配了整数数组<code>x</code>，在第7行释放了<code>x</code>，但又在第11行引用<code>x</code>，此时，<code>x</code>可能是某个已分配的块的一部分，一段时间后，<code>y</code>的值有问题才会显现出来。</p>
<h4 id="内存泄漏">9.9.10 内存泄漏</h4>
<p>　　内存泄漏是缓慢且隐性的问题，当忘记释放已分配的块时，就会出现这个问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *x = (<span class="type">int</span> *)Malloc(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　若某个程序经常调用该示例，则堆里会有很多垃圾，在最差的情况下，会占用整个虚拟地址空间。对于守护进程和服务器等程序，内存泄漏是很严重的问题，因为这类程序通常不会终止。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《剑桥国际英语语音在用》附录</title>
    <url>/2024/03/14/english-pronunciation-in-use-appx/</url>
    <content><![CDATA[<p>　　 原书及音频下载地址：<a
href="https://github.com/water-music/english-pronunciation-in-use">点击这里</a>。</p>
<h3 id="a.1-数字相关">A.1 数字相关</h3>
<p>　　100、1000和1000000分别是a hundred、a thousand和a million。</p>
<p>　　对于大于100的数，需要在百分位和十分位之间加上and，部分美国人会省略这个and。例如，350是three
hundred and fifty，27403是twenty-seven thousand, four hundred and
three。</p>
<p>　　对于年份，非100的整数倍并且小于2000的年份会分割，而大于等于2000和100的整数倍的年份与数字相同。例如，1890是eighteen
ninety，1900是nineteen hundred，1907是nineteen oh seven，2007是two
thousand and seven。</p>
<p>　　对于电话号码，数字组之间会有停顿，0发音为oh，33和77发音为double
three和double seven。例如，0609 655 400是oh six oh nine, six double
five, four double oh。</p>
<p>　　对于温度，14°是fourteen degrees，0°是zero，-12°是minus twelve
(degrees) / twelve (degrees) below zero。</p>
<p>　　对于序数，1st是first，2nd是second，3rd是third，4th是fourth，5th是fifth，13th是thirteenth，20th是twentieth，21是twenty-first，51是fifty-first。</p>
<p>　　对于日期，22 May是May the twenty-second、the twenty-second of
May或May twenty-second (美式英语)。</p>
<p>　　对于分数，<span class="math inline">\(\frac{1}{2}\)</span>是a
half，<span class="math inline">\(\frac{1}{4}\)</span>是a quarter或a
fourth (美式英语)，<span
class="math inline">\(\frac{3}{4}\)</span>是three quarters或three
fourths (美式英语)，其他分数是[数字 + 序数]的形式。例如，<span
class="math inline">\(\frac{1}{3}\)</span>是a third，<span
class="math inline">\(\frac{5}{8}\)</span>是five eighths。</p>
<p>　　对于小数，小数点发音为point。例如，1.6是one point
six，23.95是twenty-three point nine five，0.762是nought point seven six
two或zero point seven six two (美式英语)。</p>
<p>　　对于百分数，1%是one per cent，50%是fifty per
cent，67.3%是sixty-seven point three per cent。</p>
<span id="more"></span>
<h3 id="a.2-相关术语">A.2 相关术语</h3>
<blockquote>
<p><strong>adjective</strong> 形容词</p>
<p><strong>adverb</strong> 副词</p>
<p><strong>adverbial</strong> 状语</p>
<p><strong>article</strong> 冠词</p>
<p><strong>auxiliary verb</strong> 助动词</p>
<p><strong>cleft sentence</strong> 分裂句</p>
<p><strong>compound</strong> 复合词</p>
<p><strong>consonant</strong> 辅音</p>
<p><strong>consonant cluster</strong> 辅音簇</p>
<p><strong>content word</strong> 实词</p>
<p><strong>contraction</strong> 缩写</p>
<p><strong>defining relative clause</strong> 限定性定语从句</p>
<p><strong>determiner</strong> 限定词</p>
<p><strong>ellipsis</strong> 省略</p>
<p><strong>exclamation</strong> 感叹句</p>
<p><strong>function word</strong> 虚词</p>
<p><strong>glottal stop</strong> 喉塞音</p>
<p><strong>imperative</strong> 祈使句</p>
<p><strong>indefinite pronoun</strong> 不定代词</p>
<p><strong>international phonetic alphabet (IPA)</strong> 国际音标</p>
<p><strong>level tone</strong> 平调</p>
<p><strong>main/primary stress</strong> 主重音</p>
<p><strong>modal verb</strong> 情态动词</p>
<p><strong>near ellipsis</strong> 近似省略</p>
<p><strong>non-defining relative clause</strong> 非限定性定语从句</p>
<p><strong>noun</strong> 名词</p>
<p><strong>object</strong> 宾语</p>
<p><strong>reporting verb</strong> 转述动词</p>
<p><strong>participle</strong> 分词</p>
<p><strong>particle</strong> 小品词</p>
<p><strong>phrasal verb</strong> 短语动词</p>
<p><strong>plosive</strong> 塞音</p>
<p><strong>plural</strong> 复数形式</p>
<p><strong>possessive</strong> 所有格</p>
<p><strong>prefix</strong> 前缀</p>
<p><strong>preposition</strong> 介词</p>
<p><strong>prominence</strong> 强读</p>
<p><strong>pronoun</strong> 代词</p>
<p><strong>question tag</strong> 疑问尾句</p>
<p><strong>reflexive pronoun</strong> 反身代词</p>
<p><strong>root</strong> 词根</p>
<p><strong>schwa</strong> 非重读央元音</p>
<p><strong>secondary stress</strong> 次重音</p>
<p><strong>speech unit</strong> 语音单元</p>
<p><strong>statement</strong> 陈述句</p>
<p><strong>stress</strong> 重读；重音</p>
<p><strong>stress shift</strong> 重音转移</p>
<p><strong>subject</strong> 主语</p>
<p><strong>suffix</strong> 后缀</p>
<p><strong>syllabic consonant</strong> 成音节</p>
<p><strong>syllable</strong> 音节</p>
<p><strong>tense</strong> 时态</p>
<p><strong>verb</strong> 动词</p>
<p><strong>vowel</strong> 元音</p>
</blockquote>
]]></content>
      <categories>
        <category>语言学</category>
      </categories>
  </entry>
  <entry>
    <title>《剑桥国际英语语音在用》</title>
    <url>/2024/02/03/english-pronunciation-in-use/</url>
    <content><![CDATA[<h3 id="字母和发音">1 字母和发音</h3>
<p>　　音素分为元音 (V) 和辅音 (C)。在单词duck <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/dʌk/</span>中，有3个音素
(CVC)。单词的音素数通常与其字母数不同。作家经常在写作时可能会押韵，即多个单词的结尾的部分音素相同，例如，news
and views。</p>
<h4 id="元音">1.1 元音</h4>
<p>　　在有2个及以上音节的单词中，至少有1个音节是非重音音节。对于非重音音节，以英语为母语的人会经常使用弱元音<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɪ/</span>。例如，carrot中的字母o发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>，cabbage中的字母a发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɪ/</span>。</p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 23%" />
<col style="width: 24%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>大多数情况</th>
<th>有时</th>
<th>注意</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/iː/</span></td>
<td>ee (feet) ea (eat) <span>e-e</span> (scene)</td>
<td>e (me) ie (piece)</td>
<td>字母ea还能发音为其他元音，但发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/iː/</span>是最常见的情况</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/e/</span></td>
<td>e (men)</td>
<td>ea (death) ie (friend) a (many) ai (said)</td>
<td></td>
</tr>
</tbody>
</table>
<p>　　当单词以字母r结尾并且字母r前是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/iː/</span>时，很多人会给该单词加上<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>并不发音这个<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span>，很多词典在这个情况下给出的音标是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɪə/</span>，例如，near、pier和hear。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>大多数情况</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʌ/</span></td>
<td>o (come) oe (does) oo (blood) ou (young) u (cut)</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʊ/</span></td>
<td>o (wolf) oo (foot) ou (would) u (full)</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/uː/</span></td>
<td>ew (new) oe (shoe) oo (shoot) ou (soup)</td>
</tr>
</tbody>
</table>
<p>　　英格兰北部的人会用<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʊ/</span>代替<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʌ/</span>，所以luck
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/lʌk/</span>听起来像look
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/lʊk/</span>。</p>
<table>
<colgroup>
<col style="width: 37%" />
<col style="width: 24%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;"></th>
<th>e / i / o / u + r</th>
<th>其他字母</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɜː/</span></td>
<td>er (her) ir (girl)  ur (hurt)</td>
<td>ear (heard) or (word)</td>
</tr>
<tr>
<td style="text-align: left;"><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɔː/</span></td>
<td>or (form)</td>
<td>a (call) al (walk) ar (war) au (cause) augh (taught) aw (saw) ough
(thought) our (four)</td>
</tr>
</tbody>
</table>
<p>　　当发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɔː/</span>的字母中没有r时，部分美国人会用<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɑː/</span>代替<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɔː/</span>。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>大多数情况</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/eɪ/</span></td>
<td><span>a-e</span> (mate) ay (say) ey (grey) ei (eight) ai (wait) ea
(great)</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/æ/</span></td>
<td>a</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 30%" />
<col style="width: 26%" />
<col style="width: 12%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>大多数情况</th>
<th>有时</th>
<th>注意</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/aɪ/</span></td>
<td><span>i-e</span> (smile) ie (die) y (cry)</td>
<td>igh (high) uy (buy)</td>
<td>这些字母并不总是发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/aɪ/</span></td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɪ/</span></td>
<td>i (win)</td>
<td>y (gym)</td>
<td>非重音音节中能发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɪ/</span>的字母有多个</td>
</tr>
</tbody>
</table>
<p>　　当<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/aɪ/</span>后是字母r或l时，很多人会在中间加上<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>，所以hire
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈhaɪə(r)/</span>听起来就像higher。</p>
<table>
<colgroup>
<col style="width: 41%" />
<col style="width: 41%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>大多数情况</th>
<th>有时</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɑː/</span></td>
<td>ar (car) al (half)</td>
<td>ear (heart) a (ask)</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/eə/</span></td>
<td>are (care) air (fair) ear (bear) ere (where)</td>
<td></td>
</tr>
</tbody>
</table>
<p>　　在英格兰西南部，当字母a后是字母s、f、th或n时，通常发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɑː/</span>。在美国北部，字母o通常发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɑː/</span>。</p>
<table>
<colgroup>
<col style="width: 46%" />
<col style="width: 46%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>大多数情况</th>
<th>有时</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɒ/</span></td>
<td>o (dog)</td>
<td>a (wash)</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/əʊ/</span></td>
<td>o (old) <span>o-e</span> (stone) ow (show) oa (coat) oe (toe)</td>
<td></td>
</tr>
</tbody>
</table>
<p>　　在美国北部，会用<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɑː/</span>代替<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɒ/</span>，所以pot听起来就和英式口音的part差不多。</p>
<table>
<colgroup>
<col style="width: 58%" />
<col style="width: 22%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>大多数情况</th>
<th>注意</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɔɪ/</span></td>
<td>oi (coin) oy (boy)</td>
<td></td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/aʊ/</span></td>
<td>ou (loud) ow (cow)</td>
<td>字母ou和ow有多种发音</td>
</tr>
</tbody>
</table>
<p>　　当<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɔɪ/</span>后是字母l时，很多人会在中间加上<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>。同样，当<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/aʊ/</span>后是字母r或l时，很多人会在中间加上<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>。</p>
<span id="more"></span>
<h4 id="辅音">1.2 辅音</h4>
<table>
<colgroup>
<col style="width: 49%" />
<col style="width: 45%" />
<col style="width: 4%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>大多数情况</th>
<th>有时</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/f/</span></td>
<td>f (fell) ff (offer) ph (photo) gh (laugh)</td>
<td></td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/v/</span></td>
<td>v (never)</td>
<td>f (of)</td>
</tr>
</tbody>
</table>
<p>　　元音在<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/f/</span>比在<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/v/</span>前更短，例如，leaf和leave，若无法区分两者，可以延长leave中的元音。</p>
<table>
<colgroup>
<col style="width: 49%" />
<col style="width: 20%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>大多数情况</th>
<th>有时</th>
<th>极少数情况</th>
<th>注意</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span></td>
<td>d (dog) dd (address)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span></td>
<td>t (tie) tt (butter)</td>
<td>-(e)d过去式</td>
<td>th (Thomas)</td>
<td>字母t有时不发音</td>
</tr>
</tbody>
</table>
<p>　　在很多口音 (包括美式口音)
中，当字母t在元音之间时，其发音听起来像<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>，所以writer
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/raɪtə/</span>听起来像raider
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/raɪdə/</span>。</p>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 9%" />
<col style="width: 13%" />
<col style="width: 25%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>开头</th>
<th>中间</th>
<th>结尾</th>
<th>注意</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span></td>
<td>c (can) k (king)</td>
<td>cc (soccer) ck (locker)</td>
<td>k (milk) ck (black) c (comic) ch (ache)</td>
<td>有些字母k开头的单词中的字母k不发音 (know和knife)</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 42%" />
<col style="width: 16%" />
<col style="width: 18%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>大多数情况</th>
<th>有时</th>
<th>注意</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/g/</span></td>
<td>g (go) gg (bigger)</td>
<td>gh (ghost) gu (guest)</td>
<td>字母g有时不发音 (sign和foreign)</td>
</tr>
</tbody>
</table>
<p>　　元音在<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span>比在<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/g/</span>前更短，例如，back和bag。qu发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/kw/</span>
(quick)。</p>
<table>
<colgroup>
<col style="width: 53%" />
<col style="width: 21%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>大多数情况</th>
<th>注意</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/b/</span></td>
<td>b (job)</td>
<td>字母b有时不发音 (comb)</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/p/</span></td>
<td>p (open) pp (apple)</td>
<td>字母p有时不发音 (psychology)</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 46%" />
<col style="width: 32%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>大多数情况</th>
<th>有时</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span></td>
<td>s (sad) ss (class) c (place)</td>
<td>sc (science)</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/z/</span></td>
<td>z (zero) s (nose) -se结尾 (rise)</td>
<td>zz (buzz) ss (scissor)</td>
</tr>
</tbody>
</table>
<p>　　字母X能发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ks/</span> (mix)
和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/gz/</span>
(exact)。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 45%" />
<col style="width: 18%" />
<col style="width: 19%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>大多数情况</th>
<th>有时</th>
<th>注意</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span></td>
<td>l (leg) ll (call)</td>
<td></td>
<td>字母l有时不发音 (half)</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span></td>
<td>r (run) rr (carrot)</td>
<td>wr (wrong) rh (rhyme)</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 85%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>总是</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/θ/</span></td>
<td>th (three)</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ð/</span></td>
<td>th (then)</td>
</tr>
</tbody>
</table>
<p>　　很多以英语为母语的人将字母th发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/f/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/v/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/z/</span>而非<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/θ/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ð/</span>，例如，有些爱尔兰人将thick
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/θɪk/</span>发音为tick
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/tɪk/</span>。</p>
<p>　　伦敦的有些人将three <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/θriː/</span>发音为free
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/friː/</span>。尼日利亚的有些人将then
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ðen/</span>发音为den
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/den/</span>。</p>
<table>
<colgroup>
<col style="width: 39%" />
<col style="width: 31%" />
<col style="width: 8%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>大多数情况</th>
<th>极少数情况</th>
<th>注意</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/h/</span></td>
<td>h (hill)</td>
<td>wh (who)</td>
<td>字母h经常不发音 (hour和honest)</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/w/</span></td>
<td>w (will) wh (when)</td>
<td>o (one和once)</td>
<td></td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span></td>
<td>y (you) i (view) e (few) u (cute)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>　　伦敦等地的有些人不发音字母h，所以hair <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/heə/</span>听起来像air
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/eə/</span>。</p>
<p>　　美国人会省略new、student和tune等单词中的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span>，所以newspaper
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈnjuːspeipə/</span>听起来像noose
paper <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈnuːspeipə/</span>。</p>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 14%" />
<col style="width: 35%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>开头</th>
<th>中间</th>
<th>结尾</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʃ/</span></td>
<td>sh (shoe) s (suger)</td>
<td>sh (fashion) ss (Russia) ti (nation) c (ocean)</td>
<td>sh (fish)</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/dʒ/</span></td>
<td>j (jaw) g (general)</td>
<td>g (page) j (major)</td>
<td>ge (rage) dge (ledge)</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/tʃ/</span></td>
<td>ch (chair)</td>
<td>ch (teacher) t (future)</td>
<td>tch (watch)</td>
</tr>
</tbody>
</table>
<p>　　当前一单词的结尾和后一单词的开头都是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/dʒ/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/tʃ/</span>时，它们<span
style="background-color: yellow">不会</span>合并。</p>
<table>
<colgroup>
<col style="width: 41%" />
<col style="width: 16%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>大多数情况</th>
<th>注意</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/m/</span></td>
<td>m (miss)</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/m/</span>后可能有不发音的字母b或n
(comb和autumn)，<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>前可能有不发音的字母k
(knife)</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span></td>
<td>n (now)</td>
<td></td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ŋ/</span></td>
<td>ng (sing) n (sink)</td>
<td></td>
</tr>
</tbody>
</table>
<p>　　当<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>之后是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/g/</span>时，<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>会变为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ŋ/</span>。</p>
<h3 id="单词和短语的发音">2 单词和短语的发音</h3>
<p>　　很多英语单词源自其他语言，其中的部分单词甚至不再被认为是外来词，例如，bungalow
(源自印度语)、caravan (源自波斯语)、tomato
(源自西班牙语)。由于近期才引用或保持着原始语言的特点，其他单词依然是外来词。</p>
<h4 id="辅音簇">2.1 辅音簇</h4>
<p>　　<strong>辅音簇</strong>是多个辅音的组合。辅音簇能出现在单词的开头、中间和结尾，甚至跨越2个单词。</p>
<h5 id="单词开头的辅音簇">2.1.1 单词开头的辅音簇</h5>
<p>　　以下是单词开头可能出现的双辅音簇：</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>+ <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span></th>
<th>+ <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span></th>
<th>+ <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/w/</span></th>
<th>+ <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span></th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/p/</span></td>
<td>play</td>
<td>pray</td>
<td><span class="math inline">\(\times\)</span></td>
<td>pure</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span></td>
<td><span class="math inline">\(\times\)</span></td>
<td>trip</td>
<td>twins</td>
<td>tube</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span></td>
<td>class</td>
<td>crime</td>
<td>queen</td>
<td>queue</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/b/</span></td>
<td>black</td>
<td>brown</td>
<td><span class="math inline">\(\times\)</span></td>
<td>beauty</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span></td>
<td><span class="math inline">\(\times\)</span></td>
<td>drop</td>
<td>dwell</td>
<td>due</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/g/</span></td>
<td>glass</td>
<td>grow</td>
<td><span class="math inline">\(\times\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
</tr>
<tr>
<td>/<span
style="font-family:Lucida Sans Unicode,Lucida Grande">m</span>/</td>
<td><span class="math inline">\(\times\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
<td>music</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span></td>
<td><span class="math inline">\(\times\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
<td>news</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/f/</span></td>
<td>fly</td>
<td>fry</td>
<td><span class="math inline">\(\times\)</span></td>
<td>few</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/v/</span></td>
<td><span class="math inline">\(\times\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
<td>view</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/θ/</span></td>
<td><span class="math inline">\(\times\)</span></td>
<td>three</td>
<td><span class="math inline">\(\times\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʃ/</span></td>
<td><span class="math inline">\(\times\)</span></td>
<td>shrink</td>
<td><span class="math inline">\(\times\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/h/</span></td>
<td><span class="math inline">\(\times\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
<td>huge</td>
</tr>
</tbody>
</table>
<p>　　 此外，单词开头可能出现的双辅音簇中还有<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span> + <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span>
(slow)、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span> + <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/w/</span>
(swim)、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span> + <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/p/</span>
(spot)、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span> + <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>
(star)、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span> + <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span>
(sky)、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span> + <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/m/</span>
(smile)、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span> + <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>
(snow)和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span> + <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/f/</span>
(sphere)。</p>
<p>　　以下是单词开头可能出现的三辅音簇：</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>+ <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span></th>
<th>+ <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span></th>
<th>+ <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/w/</span></th>
<th>+ <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span></th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/sp/</span></td>
<td>splash</td>
<td>spray</td>
<td><span class="math inline">\(\times\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/st/</span></td>
<td><span class="math inline">\(\times\)</span></td>
<td>straw</td>
<td><span class="math inline">\(\times\)</span></td>
<td>stew</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/sk/</span></td>
<td><span class="math inline">\(\times\)</span></td>
<td>scream</td>
<td>squeak</td>
<td>skewer</td>
</tr>
</tbody>
</table>
<p>　　 以上表格中用<span
class="math inline">\(\times\)</span>表示的部分辅音簇会出现在非重读央元音和人名等不常见的单词中。</p>
<h5 id="单词结尾的辅音簇">2.1.2 单词结尾的辅音簇</h5>
<p>　　可能出现在单词结尾的辅音簇最多包括4个辅音。</p>
<p>　　即使对以英语为母语的人，部分出现在单词结尾的辅音簇也可能很难发音，所以这些辅音簇会被简化。例如，<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/kts/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/mps/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/mpt/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/nts/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ndz/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/skt/</span>中的<span
style="background-color: yellow">第2个辅音</span>几乎听不到，有时甚至被省略。此外，twelfth
→ twel<s>f</s>th <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/twelθ/</span>，fifths
→ fi<s>f</s>ths <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/fɪθs/</span>或fif<s>th</s>s
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/fɪfs/</span>。</p>
<p>　　省略单词结尾的辅音簇中的最后1个辅音可能会导致误解，尤其是复数形式和第三人称单数形式中的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/z/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span>以及动词和形容词中的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>。</p>
<h5 id="跨越单词的辅音簇">2.1.3 跨越单词的辅音簇</h5>
<p>　　说话时会将所说的内容划分为<strong>语音单元</strong>。每个语音单元都有1个主音。同一语音单元的单词之间没有停顿，语音单元之间有停顿。语音单元的边界用
// 表示。</p>
<p>　　当前一单词以辅音结尾，后一单词以辅音开头时，会形成跨越单词的辅音簇。当这种辅音簇出现在语音单元中时，通常很难发音。例如，//
it's an el<u>m tr</u>ee//。当辅音簇内有停顿时，将更容易发音。例如，// if
Tom can't take you to the fil<u>m// tr</u>y Mike//。</p>
<p>　　短语和复合词中的单词通常处于同一语音单元，所以经常会形成辅音簇。例如，civi<u>l
s</u>ervant。</p>
<h4 id="单词和短语的重音">2.2 单词和短语的重音</h4>
<p>　　大多数词典在给出单词的发音的同时也会给出<strong>重音</strong>音节。在音标中，主重音用
<span style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>
表示，次重音用 <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>
表示，例如，controversial <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˌkɒntrəˈvɜːʃl/</span>。</p>
<p>　　当强调某个单词时，该单词中的某个重音音节将会变为<strong>强读</strong>音节，这里会用大写来进行区分。对于单重音音节词，强读音节就是重音音节；对于双重音音节词，强读音节一般是<strong>主重音</strong>，例如，It
was controVERsial。</p>
<p>　　当controversial等次重音在主重音之前的单词后是强读音节开头的单词时，这类单词的强读<span
style="background-color: yellow">可能</span>会转移到次重音，这种情况称为<strong>重音转移</strong>，例如，She
gave a CONtroversial ANswer。</p>
<h5 id="后缀和单词的重音">2.2.1 后缀和单词的重音</h5>
<p>　　有些单词由词根和<strong>后缀</strong>组成。例如，对于dangerous，danger是词根，ous是后缀，其重音与词根的重音相同。对于commercial，commerce是词根，ial是后缀，后缀会改变次重音。</p>
<p>　　后缀-able、-ag、-al、-er、-ful、-less、-ness、-ous和-fy通常不会改变词根重读模式。<span
style="background-color: yellow">例外</span>包括ad<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>mire -
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>admireable、pre<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>fer -
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>preferable、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>medicine -
me<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>dicinal和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>agriculture
- agri<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>cultural。</p>
<p>　　后缀-ious、-ulous、-orous和-eous会让主重音移动到这些后缀所属音节的前一音节，例如，<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>industry -
in<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>dustrious、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>miracle -
mi<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>raculous、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>carnivore
- car<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>nivorous和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>outrage -
out<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>rageous。</p>
<p>　　后缀-ee、-eer、-ese和-ette所属音节通常是主重音。<span
style="background-color: yellow">例外</span>包括<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>omelette、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>etiquette、em<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>ployee。</p>
<p>　　带有后缀-ial、-ic、-ion、-ive或-ity的单词的主重音通常是这些后缀所属音节的前一音节。带有后缀-ative的单词的主重音通常与对应的词根的主重音是同一音节。很多带有这些后缀的单词都可能出现重音转移的情况。</p>
<p>　　当单词以字母s或t加上后缀-ion结尾时：</p>
<p>　　● 若-tion前是字母s，则-tion发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/tʃən/</span>。</p>
<p>　　● 若-tion前是除字母s外的其他字母，则-tion发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʃn/</span>。</p>
<p>　　● 若-sion前是辅音字母，则-sion发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʃn/</span>。</p>
<p>　　● 若-sion前是元音字母，则-sion发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʒn/</span>。</p>
<p>　　● -ssion发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʃn/</span>。</p>
<p>　　带有后缀-ant、-ent、-ance或-ence的名词和形容词的重音通常取决于这些后缀所属音节的前一音节：</p>
<p>　　● 若这些后缀所属音节的前一音节以1个元音字母 (V)
或1个元音字母加上1个辅音字母 (VC)
结尾，则重音音节通常是倒数第3个音节。</p>
<p>　　●
若这些后缀所属音节的前一音节以字母i结尾，词根以重音音节结尾并且最后1个字母是y，则重音音节通常是这些后缀所属音节的前一音节。</p>
<p>　　● 若为其他情况，则重音音节通常是这些后缀所属音节的前一音节。</p>
<p>　　部分带有后缀-ant、-ent、-ance或-ence的单词的重音音节不同于词根的重音音节，例如，ig<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>nore -
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>ignorant和re<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>fer -
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>reference。</p>
<p>　　后缀-ment通常不会词根的重读模式。<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>advertise
- ad<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>vertisement是常见的例外之一。</p>
<p>　　有些后缀不会改变词根的重读模式，但会改变主重音中元音字母的发音，例如，wise和wisdom。对于这种情况下的部分单词，当重音音节中的元音字母的发音改变时，该元音字母后的辅音字母
(簇) 的发音或字母 (簇) 也会改变，例如，sign - signature和repeat -
repetitive。</p>
<p>　　当后缀会改变词根的重读模式时，通常也会改变其中若干个音节的发音，例如，pre<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>fer -
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>preferable。</p>
<h5 id="前缀和单词的重音">2.2.2 前缀和单词的重音</h5>
<p>　　有些单词由<strong>前缀</strong>和词根组成。常见的前缀包括de-、dis-、il-和un-。</p>
<p>　　有些单词的前缀不会重读，例如，dis<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>like、il<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>legal、re<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>claim和un<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>easy。这类单词通常只有1个重音音节，而其他带有这些前缀的单词在该前缀上有次重音。</p>
<p>　　对于带有前缀de-和re-的单词，若前缀非重读，则通常发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/dɪ-/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/rɪ-/</span>；若前缀有次重音，则通常发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/diː-/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/riː-/</span>。例如，de<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>grade中的前缀de-发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/dɪ-/</span>，而<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>decom<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>pose中的前缀de-发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/diː-/</span>。re<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>claim中的前缀re-发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/rɪ-/</span>，而<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>recon<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>sider中的前缀re-发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/riː-/</span>。</p>
<p>　　对于少数带有前缀de-和re-的单词，当它们作为动词时，前缀的发音中通常会有<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/-ɪ-/</span>；当它们作为名词时，前缀的发音中通常会有通常会有<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/-iː-/</span>。例如，decrease作为动词时，发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/dɪˈkriːs/</span>；作为名词时，发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈdiːkriːs/</span>。</p>
<p>　　有些以re-开头的单词的发音和含义会根据re-是否表示 "再"
而改变。例如，resign <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˌriːˈsaɪn/</span>表示再次签名，而resign
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/rɪˈzaɪn/</span>表示辞职。</p>
<p>　　对于有些单词，前缀co-、counter-、hyper-、inter-、sub-、super-和under-会重读。在句子中，这些单词中的主重音通常会强读，例如，We
took the SUBway和I'm just off to the SUpermarket.</p>
<p>　　在很多带前缀的单词中，前缀是次重音，主重音在其后，例如，<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>imper<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>cise和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>hyper<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>active。在日常口语中，这些单词可能会重音转移，例如，She
gave an IMpercise ANswer。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>一般会重音转移的单词</th>
<th>很少重音转移的单词</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>decom<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>pose <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>de<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>code</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>de<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>fame</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>diso<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>bedient <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>disre<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>spectful</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>dis<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>honest</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>imma<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>ture <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>impo<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>lite</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>im<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>practical</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>mis<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>place <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>mis<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>spelt</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>mis<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>judge</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>recon<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>sider <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>repro<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>dure</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>re<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>place</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>unac<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>ceptable <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>unsuc<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>cessful</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>un<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>popular</td>
</tr>
</tbody>
</table>
<h5 id="短语动词中的重音">2.2.3 短语动词中的重音</h5>
<p>　　<strong>短语动词</strong>是与介词或/和副词结合后的动词，这个介词/副词称为<strong>小品词</strong>。</p>
<p>　　单重音短语动词中的小品词通常是介词，双重音短语动词中的小品词通常是副词。少数短语动词既可以作为单重音短语动词，又可以作为双重音短语动词，其含义也会随之改变。</p>
<p>　　在日常口语中，通常不会将单重音短语动词中的小品词强读。有时，为了强调或对比，可以强读单重音短语动词中的小品词。</p>
<p>　　很多单重音短语动词中的小品词有重音和非重音形式。在日常口语中，通常会使用这些小品词的非重音形式。当这些小品词位于句子的末尾时，通常使用其重音模式。</p>
<p>　　对于2个单词的短语动词，要么主重音在动词，小品词没有重音；要么主重音在小品词，次重音在动词。</p>
<p>　　当在日常口语中使用双重音短语动词时，动词和小品词通常都会强读。若动词和小品词之间有代词，则代词通常不会强读。</p>
<p>　　对于双重音短语动词，当<span
style="background-color: yellow">特殊强调短语动词中的动词</span>、(同一句子中)
<span style="background-color: yellow">短语动词后是名词 (即宾语)
</span>或 (同一句子中) <span
style="background-color: yellow">短语动词中的动词和小品词之间有强读的名词
(即宾语) </span>时，小品词通常不会强读。</p>
<p>　　3个单词的短语动词是双重音短语动词，主重音在第2个单词
(即第1个小品词)，次重音在第1个单词。即使 (同一句子中)
3个单词的短语动词后是名词，该短语动词的前2个单词都可以强读。</p>
<h5 id="复合词中的重音">2.2.4 复合词中的重音</h5>
<p>　　复合词是一种固定表达式，由多个单词组成。</p>
<p>　　● 复合名词的拼写形式可以是 (连词符连接的) 2个单词或1个单词。</p>
<p>　　● 复合形容词的拼写形式通常是连词符连接的2个单词
(有时是1个单词)。</p>
<p>　　● 长复合词由最多3个单词组成。</p>
<p>　　大多数主重音在第2部分的复合词能进行重音转移。</p>
<p>　　2~4个字母的缩写形式发音为单独的字母时，主重音通常在最后1个字母，次重音通常在第1个字母。这些缩写形式能进行重音转移。</p>
<h6 id="复合名词中的重音">2.2.4.1 复合名词中的重音</h6>
<p>　　[名词 + 名词]、[名词 + -ing形式]、[-ing形式 + 名词]和[动词 +
名词]的复合名词的主重音通常在第1部分。<span
style="background-color: yellow">例外</span>包括如下：</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th>[名词 + 名词]</th>
<th>[名词 + -ing形式]</th>
<th>[-ing形式 + 名词]</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>family
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>doctor</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>ball <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>bearing</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>casting
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>vote</td>
</tr>
<tr>
<td>infor<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>mation
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>technology</td>
<td>pe<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>destrian
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>crossing</td>
<td>de<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>fining
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>moment</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>town <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>hall</td>
<td>thanks<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>giving</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>managing
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>director</td>
</tr>
</tbody>
</table>
<p>　　若复合名词的第1部分表示第2部分的组成材料，则主重音通常在第2部分，例外包括大部分以-cake、-bread和-juice结尾的复合名词。</p>
<p>　　大部分[形容词 + 名词]、[形容词 + -ing形式]或[过去分词 +
名词]的复合名词的主重音在第2部分，次重音在第1部分。<span
style="background-color: yellow">例外</span>包括<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>blind
spot、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>broadband、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>dental
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>floss、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>easy <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>chair、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>greenhouse。</p>
<p>　　很多复合名词派生自双重音短语动词，这类复合名词的重音通常在第1部分，例如<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>mix-up和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>washout。</p>
<p>　　有些<span
style="background-color: yellow">不是复合名词</span>的短语的拼写形式和复合名词相同，这些短语的主重音通常在第2部分。</p>
<h6 id="复合形容词中的重音">2.2.4.2 复合形容词中的重音</h6>
<p>　　[名词 + ing形式]和[名词 +
过去分词]和拼写形式为1个单词的复合形容词的主重音通常在第1部分，<span
style="background-color: yellow">例外</span>包括如下：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>拼写形式为1个单词</th>
<th>[名词 + 过去分词]</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>hand<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>made</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>eagle-<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>eyed</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>nation<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>wide</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>home-<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>grown</td>
</tr>
</tbody>
</table>
<p>　　[名词 + 形容词]、[形容词 + 名词]、[副词/形容词 +
过去分词]、[副词/形容词 +
ing形式]和self-是第1部分的复合形容词的主重音通常在第2部分。</p>
<h6 id="长复合名词中的重音">2.2.4.3 长复合名词中的重音</h6>
<p>　　很多3部分的长复合词的主重音在第3部分，次重音在第1部分。</p>
<p>　　● 对于由1个2部分的复合词加上1个单词构成的3部分的长复合词，若<span
style="background-color: yellow">2部分的复合词的重音在第1部分</span>或<span
style="background-color: yellow">2部分的复合词 (通常使用连词符)
作为形容词来描述第3部分</span>，则长复合词的主重音通常在第3部分。</p>
<p>　　● 以数字开头的3部分的长复合词的主重音通常在第3部分。</p>
<p>　　有些3部分的长复合词的主重音在第2部分，次重音在第1部分。</p>
<p>　　●
对于由1个2部分的复合词加上1个单词构成的3部分的长复合词，若2部分的复合词的重音在第2部分，则长复合词的主重音通常在第2部分。</p>
<p>　　●
对于由1个单词加上1个2部分的复合词构成的3部分的长复合词，若2部分的复合词的重音在第1部分，则长复合词的主重音通常在第2部分。</p>
<p>　　有些3部分的长复合词的主重音在第1部分，其中的大部分单词的第3部分有次重音。</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th>主重音在第3部分，次重音在第1部分</th>
<th>主重音在第2部分，次重音在第1部分</th>
<th>主重音在第1部分</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>desktop
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>publishing</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>central
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>heating
system</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>brother-in-low</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>one-parent
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>family</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>parent-<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>teacher
association</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>on-man's
land</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>state-owned
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>industry</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>safety
de<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>posit
box</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>sell-by
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>date</td>
</tr>
</tbody>
</table>
<h4 id="重音和非重音音节">2.3 重音和非重音音节</h4>
<p>　　<strong>实词</strong>是主要用于表意的名词、动词、形容词和副词。<strong>虚词</strong>是对句子的语法而非含义很重要的单词。</p>
<p>　　单音节实词中的元音的发音不会改变。单音节虚词中的元音的发音可能会改变。</p>
<h5 id="虚词的弱读音形态">2.3.1 虚词的弱读音形态</h5>
<table>
<colgroup>
<col style="width: 68%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr>
<th>在日常口语中通常不会强读的虚词</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr>
<td>人称代词I、me、we、us、you、he、him、she、her、it、they和them</td>
<td>She SAW me.</td>
</tr>
<tr>
<td>所有格限定词my、your、his、her、its、our和their</td>
<td>He's my BROTHer.</td>
</tr>
<tr>
<td>each other和one another</td>
<td>They were HITing each other.</td>
</tr>
<tr>
<td>冠词a、an和the</td>
<td>It's an OWL.</td>
</tr>
<tr>
<td>限定词some和any</td>
<td>Do you WANT some?</td>
</tr>
<tr>
<td>作为宾语的不定代词some-/anybody、some-/anyone和some-/anything</td>
<td>I didn't SEE anyone.</td>
</tr>
<tr>
<td>there be句型中的there</td>
<td>There's some CAKE left.</td>
</tr>
<tr>
<td>助动词和情态动词的除否定形态以外的形态</td>
<td>I can HEAR it.</td>
</tr>
<tr>
<td>介词</td>
<td>They're from SPAIN.</td>
</tr>
<tr>
<td>连词</td>
<td>He's OLDer than me.</td>
</tr>
</tbody>
</table>
<p>　　有些虚词有强读音和弱读音形态。弱读音形态是常规发音。当这些单词强读、单独使用或在句末时，会使用强读音形态。</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>弱读音形态例句</th>
<th>强读音形态例句</th>
</tr>
</thead>
<tbody>
<tr>
<td>带有<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>的虚词the、a、an、and、but、that、your、them、us、at、for、from、of、to、as、there、can、could、shall、should、would、must、do、does、am、are、was、were和some</td>
<td>I can (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/kən/</span>)
SWIM.</td>
<td>I CAN (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/kæn/</span>) come
after ALL.</td>
</tr>
<tr>
<td>she、he、we和you以弱元音发音为弱读音形态<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʃi/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/hi/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/wi/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/jə/</span></td>
<td>Are you (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/jə/</span>)
TIRED?</td>
<td>YOU (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/juː/</span>)!</td>
</tr>
<tr>
<td>his、her、he、him、has和had在弱读音形态中经常省略<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/h/</span>
(除非在句首)</td>
<td>Was he (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/hi/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/i/</span>)
THERE?</td>
<td>HE (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/hiː/</span>) was
THERE, but SHE (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʃiː/</span>)
wasn't.</td>
</tr>
</tbody>
</table>
<p>　　在快速口语中，弱读音形态可能导致语句难以理解。因此，有时为了区分，不使用弱读音形态。</p>
<h5 id="虚词强读">2.3.2 虚词强读</h5>
<img src="/2024/02/03/english-pronunciation-in-use/when_it_is_prominent.png" class="" title="when_it_is_prominent">
<p>　　it很少强读，只有出现在带有this和that的某些特定句子的句末时，才会强读。</p>
<p>　　some在以下情况通常会强读：</p>
<p>　　● 表示 "有些人"，例如，SOME consider him to be the best golfer in
the world.</p>
<p>　　● 表示数量很多，例如，I didn't see her again for SOME YEARS.</p>
<p>　　● 表示未指明的特定的人或物，例如，There must be SOME time we're
all free for a meeting.</p>
<p>　　any在以下情况通常会强读：</p>
<p>　　● 表示 "任意1个"，例如，ANY of the camera shops in town will sell
them.</p>
<p>　　● 用于强调并且位于否定动词后，例如，Haven't you done ANY of your
homework yet?</p>
<p>　　somebody和anybody等词作为句子的主语时，通常会强读，例如，SOMEBODY
must have seen it.</p>
<p>　　当the表示事物最好或最重要等含义时，会强读 (发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ðiː/</span>)，例如，You
should go to the Maldives. It's THE place to see coral.</p>
<p>　　助动词和情态动词为否定形态/特殊强调、表示反驳和进行时间对比时，通常会强读。</p>
<p>　　do、does和did用于现在/过去时态的强调时，通常会强读，例如，Wo DID
warn you.</p>
<p>　　在新信息或仅由虚词组成的问题中，最后1个虚词通常强读，例如，There
was nothing I could DO和What was it aBOUT?</p>
<h5 id="实词的非重音音节中的元音">2.3.3 实词的非重音音节中的元音</h5>
<p>　　对于实词，重音音节中的元音的发音通常不会随着其是否强读而改变，但是非重音音节的元音的发音可以变化很大。</p>
<p>　　● 在正式场合的口语中，非重音音节的元音发音为完全形态。</p>
<p>　　● 在日常口语中，非重音音节的元音经常发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>
(有时也发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɪ/</span>)，例如，calendar可以发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈkælɪndə(r)/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈkæləndə(r)/</span>。</p>
<p>　　当实词中以元音结尾的非重音音节后是以元音开头的非重音音节时，这2个音节可能会合并为1个音节，这仅发生在日常口语中，正式场合的口语中不会出现这种情况。例如，casual在日常口语中可以发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/kæʒ.əl/</span>，类似的词还有virtual、actual、adverbial、colonial、studious、obedient、ingredient和gradient。</p>
<h5 id="成音节">2.3.4 成音节</h5>
<p>　　大多数音节都包含1个元音。但是，有些音节仅由辅音组成，这种音节称为<strong>成音节</strong>。<span
style="background-color: yellow">可以</span>在成音节中加入元音<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>来将其发音为常规音节。因此，在部分词典中，会在成音节的前面使用符号
<sup>ə</sup>，例如，listen <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈlɪs.<sup>ə</sup>n/</span>。</p>
<p>　　当<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span>在<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/p/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/b/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/z/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>后时，经常作为非重音成音节，在这种情况下，其拼写形式通常为-le
(有时是-al、-el和-ol)，例如，pistol、saddle、principal、able、hassle、hazel、knuckle和communal。</p>
<p>　　当<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>在<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/p/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/z/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/f/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/v/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/θ/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʃ/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʒ/</span>后时，经常作为非重音成音节，在这种情况下，其拼写形式通常为-en、-an、-ion和-ian，例如，button、sadden、happen、person、cousin、often、seven、marathon、musician和illusion。</p>
<p>　　以后缀-sm结尾的单词用会有成音节<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/m/</span>，例如，criticism和enthusiasm。</p>
<p>　　didn't、haven't、shouldn't、wouldn't等形式的单词会有成音节<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/nt/</span>，例如，haven't
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈhævnt/</span>。</p>
<p>　　部分单词有2个连续的成音节，例如，conditional、diagonal、general、literal、national和veteran。</p>
<p>　　当以成音节结尾的单词后加上后缀-ing时，成音节通常会和-ing发音为1个音节，成音节会作为合并后的音节的第1个辅音。</p>
<h3 id="口语中的发音">3 口语中的发音</h3>
<h4 id="流利口语">3.1 流利口语</h4>
<p>　　在之前提到过，同一语音单元的单词之间通常没有停顿。前一单词末尾的音会与后一单词开头的音连在一起，从而达到平滑过渡的效果。</p>
<p>　　● 前一单词末尾的辅音会与后一单词开头的元音连在一起。</p>
<p>　　● 若前一单词末尾的辅音和后一单词开头的辅音<span
style="background-color: yellow">不同</span>，则前一单词末尾的辅音可能会变为更像后一单词开头的辅音的音。在这种情况下，若前一单词末尾的辅音是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/p/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/b/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/g/</span>并且后一单词开头的辅音是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/p/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/b/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/g/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/m/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>，则前一单词末尾的辅音不会释放气流，并且会平滑地变为后一单词开头的辅音。</p>
<p>　　●
若前一单词末尾的辅音和后一单词开头的辅音相同，则两者会合并为1个更长的辅音。</p>
<p>　　●
若前一单词末尾的音和后一单词开头的音都是元音，则会在两者之间加上<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/w/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span>。在这种情况下，若前一单词末尾的元音是通过将舌头的最高端靠近口腔的<span
style="background-color: yellow">前部</span>而发出 (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/iː/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/eɪ/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/aɪ/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɔɪ/</span>)，则新增的音是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span>；若前一单词末尾的元音是通过将舌头的最高端靠近口腔的<span
style="background-color: yellow">后部</span>而发出 (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/uː/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/aʊ/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/əʊ/</span>)，则新增的音是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/w/</span>。</p>
<p>　　●
若前一单词以字母-r或-re结尾但发音以元音结尾，后一单词以元音开头，则会在两者之间加上<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span>。在这种情况下，某些词典为前者给出的发音中会加上符号
<span style="font-family:Lucida Sans Unicode,Lucida Grande">(r)</span>
或 <span
style="font-family:Lucida Sans Unicode,Lucida Grande"><sup>r</sup></span>，例如，car
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/kɑː(r)/</span>和more
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/mɔː<sup>r</sup>/</span>。除英式口音外的很多其他口音中
(例如，苏格兰口音、爱尔兰口音和大部分北美口音)，前一单词结尾的-r或-re会一直发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span>，例如，car
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/kɑːr/</span>和more
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/mɔːr/</span>。</p>
<p>　　● 在极少数情况下，若前一单词以<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɑː/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɔː/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɜː/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɪə/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/eə/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʊə/</span>结尾但拼写形式不以字母-r或-re结尾，后一单词以元音开头，也会在两者之间加上<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span>。但是，部分以英式英语为母语的人不认可这种发音。</p>
<h5 id="缩写形式">3.1.1 缩写形式</h5>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 12%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr>
<th>缩写形式</th>
<th>对应的虚词</th>
<th>发音</th>
</tr>
</thead>
<tbody>
<tr>
<td>'d</td>
<td>had和would</td>
<td>在元音后发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>，在辅音后发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/əd/</span></td>
</tr>
<tr>
<td>'s</td>
<td>is和has</td>
<td>在<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/p/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/f/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/θ/</span>后发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span>，其他情况下发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/z/</span></td>
</tr>
<tr>
<td>'ll</td>
<td>will</td>
<td>发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span></td>
</tr>
<tr>
<td>'ve</td>
<td>have</td>
<td>在元音后发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/v/</span>，在辅音后发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/əv/</span></td>
</tr>
<tr>
<td>'re</td>
<td>are</td>
<td>在元音后发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ər/</span>，在辅音后发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span></td>
</tr>
<tr>
<td>n't</td>
<td>not</td>
<td>发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/nt/</span></td>
</tr>
</tbody>
</table>
<p>　　有些虚词有缩写形式，这些缩写形式中通常包含符号
'。除了n't，其他缩写形式都不能出现在句末。在口语中，这些缩写形式常用于wh-词、名词、this/that/these/those以及there后。有时，did在wh-词后可以缩写为'd，例如，why
did you do that可以缩写为why'd you do
that。这些缩写形式在书写中的使用频率不高。</p>
<p>　　I am可以缩写为I'm，let us可以缩写为let's。</p>
<p>　　在口语中，有时会将[would/will + have]和[not +
have]都进行缩写，例如，I'll've finished it by tomorrow和I'wouldn't've
minded doing it。这种形式的缩写在书写中极少使用。</p>
<p>　　在日常口语中，句子中有had better和have got to时，缩写词'd (had)
和've (have) 有时可以省略，例如，You ('d) better apologise to her和You
('ve) gotta (=go to) be joking。</p>
<h5 id="省略">3.1.2 省略</h5>
<p>　　在口语中，可以省略部分根据语境可以得出的单词，该过程称为<strong>省略</strong>，例如，Not
sure (I'm not
sure)。但是，经常出现的情况是省略的部分留下了其中部分单词的发音，例如，'m
not sure (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/mnɒt.../</span>)，这里称之为<strong>近似省略</strong>。</p>
<p>　　省略和近似省略经常出现句首，省略的部分包括如下：</p>
<p>　　● [人称主语 + be/have]，例如，He's gone home. / Gone home. / 's
gone home.</p>
<p>　　● [it + is/has]，例如，It's really hot. / Really hot. / 'ts
really hot.</p>
<p>　　● be，例如，Is that Ken? / That Ken? / 's that Ken?</p>
<p>　　● [助动词/be + 主语]，例如，Do you want another drink? / Want
another drink? / d'y (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/dʒ/</span>) want
another drink?、Have you seen my keys? / Seen my keys? / v'y (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/vj/</span>) seen
my keys?和Are you leaving already? / Leaving already? / r'y (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/əj/</span>)
leaving already? / 'y (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span>)
leaving already?</p>
<p>　　wh-疑问句中疑问词和主语之间的be和have经常可以省略，例如，What are
you doing? / What you doing? / What're you doing?</p>
<p>　　dose在wh-词后时，只能近似省略 (发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/z/</span>)，例如，When
dose it start? / When's it start?</p>
<h5 id="省略辅音">3.1.3 省略辅音</h5>
<p>　　当前一单词以辅音簇结尾并且最后1个辅音是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>，后一单词以除<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/h/</span>之外的其他辅音开头时，经常会省略前一单词结尾的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>，例如，las<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">t</span>
night和I collec<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">t</span>
coins。</p>
<p>　　当前一单词以辅音簇<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/skt/</span>结尾时，若后一单词以元音或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/h/</span>开头，则经常会省略前一单词结尾辅音簇中的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span>；若后一单词以除<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/h/</span>之外的其他辅音开头，则经常会省略前一单词结尾辅音簇中的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>。例如，He
ris<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">k</span>ed
his life (...<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/rɪstɪz/</span>...)
和He ris<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">ked</span>
losing (...<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/rɪsluː/</span>...)。</p>
<p>　　在日常口语中，当<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>在音节末并且之前的音是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/m/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/或元音</span>时，若<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>之后的音节以辅音开头或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>所属音节位于句末，部分人则会将<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>替换为<span
style="background-color: yellow">喉塞音</span>，即声门关闭引起的气流瞬时中断而成的塞音，其国际音标符号为
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ʔ</span>。例如，football
(<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈfʊʔbɔːl/</span>)、pointless
(<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈpɔɪnʔləs/</span>)和It
cost a lot (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/lɒʔ/</span>)。</p>
<p>　　若前一单词以<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>结尾，后一单词以<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span>开头，则<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span>通常会合并为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/tʃ/</span>，只要满足条件，这种情况下也可以将<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>替换为喉塞音。例如，las<u>t
y</u>ear (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/tʃ/</span>) 和I
can't let you (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/letʃuː/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/leʔjuː/</span>)
do it。</p>
<p>　　当前一单词以辅音簇结尾并且最后1个辅音是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>，后一单词以除<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/h/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/m/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span>之外的其他辅音开头时，经常会省略前一单词结尾的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>，例如，a
ol<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">d</span>
car和I chang<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">ed</span>
clothes。</p>
<p>　　若前一单词以<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>结尾，后一单词以<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span>开头，则<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span>通常会合并为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/dʒ/</span>，例如，I'll
len<u>d y</u>ou (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/dʒ/</span>)
one。</p>
<p>　　代词he/her/his/him、助动词have/has/had和疑问词who中开头的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/h/</span>经常会省略，除非这些词重读或位于句首，例如，ask
<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">h</span>im和<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">wh</span>o
did it。</p>
<p>　　同一单词中，很多人会省略<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɔː/</span>后的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span>，例如，a<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">l</span>most和a<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">l</span>so。</p>
<p>　　and通常发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ən/</span>，例如，red
an<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">d</span>
blue和pen an<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">d</span>
ink。</p>
<p>　　若of后的单词以辅音开头时，则of通常发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>；若of后的单词以元音开头时，则of通常发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/əv/</span>。例如，a
waste o<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">f</span>
time和a can of oil。</p>
<h5 id="省略音节">3.1.4 省略音节</h5>
<p>　　在日常口语中，有些单词的元音可以省略，在这种情况下，这些单词会省略1个非重音音节，例如，av<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">e</span>rage和happ<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">e</span>ning。有些词典会将用符号
<span
style="font-family:Lucida Sans Unicode,Lucida Grande"><sup>ə</sup></span>
代表可以省略的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>，例如，<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈæv<sup>ə</sup>rɪdʒ/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈhæp<sup>ə</sup>nɪŋ/</span>。</p>
<p>　　当元音在<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>前时，通常都可以省略，在这种情况下，单词可能会省略1个非重音音节。例如，accident<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">a</span>lly、batt<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">e</span>ry、conf<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">e</span>rence、consid<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">e</span>rable、deaf<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">e</span>ning、nati<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">o</span>nal、second<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">a</span>ry。</p>
<p>　　少数单词中除<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>外的其他辅音前的元音可以省略，例如，gov<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">ern</span>ment、med<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">i</span>cine和veg<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">e</span>table。</p>
<p>　　在快速口语中，少数重音在第2个音节的双音节词中的第1个元音经常会省略，从而导致单词变为单音节词，例如，I
don't b<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">e</span>lieve
(<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/bliːv/</span>) in
you和I s<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">u</span>ppose
(<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/spəʊz/</span>)
so。少数单词可以省略第1个音节，例如，<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">a</span>bout
five o'clock、I brought it <span
style="text-decoration: line-through; text-decoration-thickness: 2px;">be</span>cause
it was cheap和I've invited everyone <span
style="text-decoration: line-through; text-decoration-thickness: 2px;">ex</span>cept
Jack，在这种情况下，这些单词的拼写形式中会变为'bout、'cause和'cept。</p>
<h4 id="在对话中组织信息">3.2 在对话中组织信息</h4>
<p>　　在说话时，通常会根据含义和强调来将划分语音单元。尽管如何划分语音单元没有确切的规则，但是为了让语句更通顺，有些词更容易组合成语音单元。例如，通常是//
we stuck a picture// of an elephant//，而非// we stuck a// picture of an
elephant//或// we stuck a picture of// an elephant//。</p>
<p>　　有时，语句的含义会根据语音单元的划分不同而不同。例如，对于// we
were rather than naughty// once// we stuck a picture// of an
elephant//和// we were rather than naughty once// we stuck a picture//
of an elephant//，前者表示多次并举例其中1次，而后者表示仅有1次。</p>
<h5 id="语音单元中的强读词">3.2.1 语音单元中的强读词</h5>
<p>　　在同一语音单元中，部分单词会强读
(提供重要/有趣的信息、对比、强调或纠正)，其他则不会 (旧信息)。</p>
<img src="/2024/02/03/english-pronunciation-in-use/the_last_prominent_word_in_a_speech_unit.png" class="" title="the_last_prominent_word_in_a_speech_unit">
<p>　　对于包含多个强读词的语音单元，其中的最后1个强读词是该语音单元的主要的升/降调的起点。</p>
<h5 id="语音单元中的固定短语和习语">3.2.2
语音单元中的固定短语和习语</h5>
<p>　　固定短语和习语通常处于同一语音单元，不会跨域多个语音单元。但是，较长的习语通常会划分为多个语音单元。例如，//
a race against time//、// I could barely hear myself think//和// I could
count// on the fingers of one hand// the number of times I've seen her
this year。</p>
<p>　　很多固定短语和习语有2个强读音节，其中的部分固定短语和习语的最后1个单词中有1个强读音节，其他则不然。例如，a
RACE against TIME、to CALL it a DAY、THROW your WEIGHT around和a WHOLE
new BALL name。</p>
<h5 id="无实义实词的非强读">3.2.3 无实义实词的非强读</h5>
<p>　　部分语音单元末尾的单词不会强读，因为这些单词<span
style="background-color: yellow">无实义</span> (不包含新信息)。</p>
<p>　　●
部分单词引用已提及的内容或内容与之前已提及的内容重复，所以它们无实义。例如，Gail
talked to me about Oscar as if I knew him well, although I've never MET
her brother中，her brother表示Oscar，所以不会强读。</p>
<p>　　●
部分单词的意义可以根据前文和特殊场景预测出来，所以它们无实义。例如，I
must get my HAIR cut中，cut可以根据语境预测出来，所以不会强读。</p>
<p>　　● 部分惯用短语的末尾会有若干个无实义的单词。例如，It was her
fourth novel that she really MADE a NAME for herself和Being a builder is
a hard job, even at the BEST of times。</p>
<h5 id="模糊表达的非强读">3.2.4 模糊表达的非强读</h5>
<p>　　当无需具体描述时，通常会使用模糊表达。大部分模糊表达位于语音单元的末尾。它们通常不会强读，并且紧跟着强读单词。</p>
<p>　　当引用已提及的事物或地点时，可以使用the stuff、the place(s)和the
thing(s)。可以用sort of加上这些词来进行举例，sort of前可以加上 (all)
this/that/these/those。例如，My car's always breaking down. I HATE the
thing和Before we could use the laboratory, we had to learn about safety
and all THAT sort of stuff。</p>
<p>　　可以用and stuff、and thins和and
places等方式来粗略引用事物和地点，例如，We went through Berlin, BONN and
places。</p>
<p>　　and that表示涉及其他事情 (不给出详情)，例如，Kate is gone
upstairs to do her HAIR and that。</p>
<p>　　可以用or something/anything
(etc.)来让刚才所说的内容更模糊或间接。or something/anything (etc.) like
that与之类似。例如，Let me know if you want any HELP or anything。</p>
<p>　　短语or/and +
whatever/whenever/wherever/whoever会使句子更非正式或间接，例如，When we
move into the flat, we can change the carpets and LIGHTS and
whatever。</p>
<p>　　短语or
so与表示次数或时间的句子一起使用时，可以使次数或时间更不准确，例如，About
a WEEK or so。</p>
<h5 id="反身代词和人称代词的强读">3.2.5 反身代词和人称代词的强读</h5>
<p>　　当反身代词引用主语或紧跟动词/介词时，通常不会强读。为了强调，反身代词也可以强读。</p>
<p>　　● 反身代词在名称和代词后，用于强调该名称/代词，例如，I'm flying
to Rome, but the AIRport itSELF is miles from the city。</p>
<p>　　● 反身代词在句末，用于强调主语，例如，They drew the posters
themSELVES。</p>
<p>　　● 反身代词强调某人将/已经独立进行某事，例如，We had the beach all
to ourSELVES。</p>
<p>　　人称代词通常不会强读。为了将某个/群人与其他人进行对比，人称代词也可以强读，例如，Throw
it to ME, not to HIM。</p>
<h4 id="语调">3.3 语调</h4>
<p>　　在每个语音单元中，声音有1个主要的变化
(降调或升调)，始于语音单元的最后1个强读词。升调和降调的范围可以是语音单元末尾的1个单词，也可以是语音单元末尾的多个非强读音节。</p>
<img src="/2024/02/03/english-pronunciation-in-use/falling_and_rising_tones.png" class="" title="falling_and_rising_tones">
<p>　　降调表示语音单元中的信息是<span
style="background-color: yellow">新信息</span>，升调表示语音单元中的信息是<span
style="background-color: yellow">旧信息</span>。</p>
<h5 id="尾句">3.3.1 尾句</h5>
<p>　　在日常口语中，为了强调刚才所说的内容，会使用<strong>尾句</strong>。尾句是1个名称
(短语)，通常是升调，因为它是对之前所说内容的引用或扩展。例如，在She's a
JUDGE, my AUNT中，my aunt就是升调的尾句。</p>
<p>　　●
有些尾句包含this、that、these、those或以这些单词开头的短语。</p>
<p>　　● 其他尾句则是对之前所说内容的引用。</p>
<p>　　在日常口语中，另一种类型的尾句也是升调，这种尾句是重复之前说过的[主语
+ 动词]。</p>
<p>　　部分其他尾句是降调，例如，在wh-疑问句后加上尾句来使问题更明确。在What
time's it ON, this THOW?中，this show是降调的尾句。</p>
<h5 id="疑问尾句">3.3.2 疑问尾句</h5>
<p>　　<strong>疑问尾句</strong>是添加在陈述句后的疑问句。</p>
<p>　　● 向对方确定自己所说的内容是否正确时
(给出自己的意见等)，疑问尾句通常是降调，例如，GREAT FILEM, WASn't
it?中，WASn't it就是降调的疑问尾句。</p>
<p>　　● 询问对是否赞成自己所说的内容时
(不太确定自己所说的内容是否正确等)，疑问句通常是升调，例如，NOT on a
DIET again, ARE you?中，are you是升调的疑问尾句。</p>
<p>　　当疑问尾句之前的句子显然是正确时，疑问尾句通常是降调。</p>
<p>　　为了让对方同意对方之前可能不同意的某事时
(实际上是正确的)，疑问尾句会使用降调。</p>
<p>　　疑问尾句也可以添加在感叹句后，此时，疑问尾句是降调。</p>
<p>　　当疑问尾句和之前的句子都是肯定句时，疑问尾句通常是升调，例如，Came
by CAR, DID you?中，did
you是升调。这种模式有时会用于批评和讽刺，此时，通常以So和Oh开头。</p>
<p>　　疑问尾句还可以添加在祈使句后 (通常是will you、can't you、would
you和shall we)，此时，疑问尾句通常是升调，作用是让祈使句更温和。</p>
<h5 id="分裂句">3.3.3 分裂句</h5>
<p>　　<strong>分裂句</strong>分为2部分，有助于将重点放在其中的1部分。分裂句在口语中很常见，例如，在What
I lost was gold necklace中，my gold necklace是重点。</p>
<p>　　what-分裂句的第1部分是[what + 主语 + 动词]，第2部分是[be +
重点]。第1部分通常是先降调再升调，第2部分通常是降调。有时，what-分裂句的第1部分和第2部分的顺序是相反的，此时，它们的语调与正常情况下相同。为了强调只有1件事，可以用all代替what。</p>
<p>　　it-分裂句的第1部分是[it + be + 重点]，第2部分是相关句子
(that或who)。第1部分通常是降调，第2部分的语调取决于其内容，若其内容是新信息，则是先降调再升调；若其内容是旧信息，则是降调。</p>
<h5 id="疑问句">3.3.4 疑问句</h5>
<p>　　当提问时，可能是为了了解不知道的事情，也可能是为了确定所了解的情况是否正确。前者通常以降调结尾，后者通常升调或先降调再升调结尾。</p>
<p>　　当为了确定所了解的情况是否正确而提问时，先降调再升调比升调<span
style="background-color: yellow">更礼貌</span>。例如，Are you SURE you
can MANage that?就是先降调再升调。</p>
<p>　　wh-疑问句经常是为了了解不知道的事情，yes-no疑问句经常是为了确定所了解的情况是否正确。有时，wh-疑问句也可以用于确定所了解的情况是否正确，yes-no疑问句也可以用于了解不知道的事情。</p>
<p>　　带有would you mind、perhaps和I
wonder的疑问句用于请求帮助时，通常是降调。wh-疑问句和yes-no疑问句用于提供帮助时，通常是降调
(表示真诚)。例如，Can I HELP you?和WHAT can I DO for you?都是降调。</p>
<p>　　为了获得对方答复的陈述句通常是升调，因为是为了了解不知道的事情。例如，You
HAVEen't even STARted?是升调。</p>
<p>　　疑问句也经常用于发表评论和感叹，此时，回答不是必要的。</p>
<p>　　● 否定yes-no疑问句用于表示惊讶和高兴时
(尤其是希望对方同意自己)，通常是降调，例如，WASn't it
TERrible?是降调。在日常口语中，肯定yes-no疑问句可用于批评，此时，通常是升调，例如，Are
you CRAzy?是升调。</p>
<p>　　● wh-疑问句用于发表评论时
(尤其是与情态动词一起使用)，通常是降调，例如，HOW was I supposed to
know?是降调。</p>
<p>　　有时，会在疑问句后加上1个自己的回答
(确定自己所想的内容是否正确)，此时，通常是先降调在升调，例如，Where are
you off to? The SUpermarket?就是先降调再升调。</p>
<p>　　疑问句还可以用于给出指示或建议
(经常会包含情态动词)，此时，通常是降调，例如，WHY don't you go by
TRAIN?是降调。</p>
<p>　　有时，为了让对方重复刚才所说的全部或部分内容，会提问，此时，疑问句是为了确定所了解的情况是否正确，所以经常是升调。</p>
<p>　　●
部分重复问题的组成结构可以是1个wh-词，也可以是以wh-词开头的短语/疑问句，还可以是常规单词/短语。</p>
<p>　　●
重复问题可以是对方刚才所说的内容或将对方刚才所说的内容中的部分词替换为[do
+ what]/wh-词，例如，You're staying with WHO?和You did WHAT?是升调。</p>
<p>　　用于重复问题时，相比SORRy?和PARdon?等，WHAT?和You
WHAT?相对更不礼貌，有些人会避免使用。</p>
<h5 id="比较和对比">3.3.5 比较和对比</h5>
<img src="/2024/02/03/english-pronunciation-in-use/comparisons_and_contrasts.png" class="" title="comparisons_and_contrasts">
<p>　　当对比2个单词/短语时，会将对比部分强读来强调。同样，新信息是降调，旧信息是升调。</p>
<p>　　比较和对比的常用模式如下：</p>
<p>　　● 使用形容词的比较级，例如，在I think it's more important to have
COMfortable clothes than STYlish ones中，comfortable
clothes是降调，stylish ones是升调。</p>
<p>　　● 使用either...or，例如，在I've either left my wallet at HOME or
I've LOST it中，home是先降调再升调，lost it是降调。</p>
<p>　　● 使用..., not...或...not ..., ...，例如，He's got bronCHItis,
not just a COUGH中，bronchitis是降调，cough是先降调再升调。</p>
<p>　　● 使用其他比较短语，例如，Rather than catch the BUS, maybe we
could WALK home中，bus是先降调再升调，walk home是降调。</p>
<h5 id="反驳请求和保留意见">3.3.6 反驳、请求和保留意见</h5>
<p>　　当反驳某件事时，会强调侧重双方观点差异的单词，该单词通常是降调并且音高会升高。</p>
<p>　　●
在反驳肯定形态动词时，可以使用not和包含n't的缩写形式，此时，not和缩写形式会强读。</p>
<p>　　●
在反驳否定形态动词时，会使用助动词和情态动词的肯定形式，此时，助动词和情态动词会强读。</p>
<p>　　● 进行其他类型的反驳时，会强调用于纠正对方的单词。</p>
<img src="/2024/02/03/english-pronunciation-in-use/contradictions.png" class="" title="contradictions">
<p>　　有时，用于反驳的强调候选词可能有多个。</p>
<p>　　当提出请求、表达对某事的保留意见和谈论已经被取消的安排时，通常先降调再升调。</p>
<img src="/2024/02/03/english-pronunciation-in-use/the_meaning_of_a_negative_sentence_may_change_according_the_sentence's_tone.png" class="" title="the_meaning_of_a_negative_sentence_may_change_according_the_sentence" alt="s_tone">
<p>　　有时，否定句的含义会随着降调或先降调再升调而改变。</p>
<h5 id="态度词和短语">3.3.7 态度词和短语</h5>
<img src="/2024/02/03/english-pronunciation-in-use/attitude_words_and_phrases_1.png" class="" title="attitude_words_and_phrases_1">
<p>　　很多单词和短语可用于表示态度，这些单词和短语通常位于句首或句末，经常是1个单独的语音单元，并且其语调通常是固定的。</p>
<p>　　有些态度词和短语用于强调自己所说的内容是真实的，例如，believe
'me、'surely、to put it 'mildly和to say the
'least。当它们位于句首或句末时，通常是降调。</p>
<p>　　有些单词用于表明所说的内容的视角，即确定讨论的内容的特征，例如，physically、logically、economically、outwardly、politically、statistically、superficially和technically。这些单词通常是升调或先降调再升调。</p>
<p>　　短语mind you通常位于句首，并且是降调，用于强调后面的信息。</p>
<p>　　短语the (only) thing is
...通常位于句首，并且是升调或先降调再升调，用于突出问题与刚才所说的内容有关。</p>
<p>　　短语the fact/point is ...用于指明将要说的内容很重要，短语the
question/problem is
...用于指明将要说的内容是重要的问题或难题，它们都通常是升调或先降调后升调。</p>
<img src="/2024/02/03/english-pronunciation-in-use/attitude_words_and_phrases_2.png" class="" title="attitude_words_and_phrases_2">
<p>　　以下态度词和短语在句首 (或and和but后)
时，通常是先降调再升调；在句末时，通常是升调：</p>
<p>　　●
很多副词可用于表示对自己所说的内容的看法，例如，unfortunately、amazingly、astonishingly、curiously、fortunately、funnily、interestingly、luckily、oddly、regrettably、remarkably、sadly、strangely、surprisingly和unbelievably。部分列举的单词
(尤其是curiously、funnily、interestingly、luckily、oddly、strangely和surprisingly)
可以与enough组成短语来表达看法。</p>
<p>　　●
actually位于句首或句末时，可以让其后的内容更礼貌，尤其是纠正他人所说的内容、给出不同的看法以及拒绝请求或提议。</p>
<p>　　●
apparently、presumably和supposedly表示并不能很确定自己所说的内容是正确的。</p>
<p>　　●
有些态度词和短语表示所说的内容只是大致情况，例如，'basically、es'sentially、'generally、as
a 'rule、by and 'large、in 'general和on the 'whole。</p>
<h5 id="感叹句">3.3.8 感叹句</h5>
<img src="/2024/02/03/english-pronunciation-in-use/exclamations.png" class="" title="exclamations">
<p>　　感叹句可以是1个形容词，此时，通常是向升调再降调。部分积极的形容词独立成句并使用降调时，通常表示讥讽。</p>
<p>　　当感叹句是1个完整的句子并且强调的是形容词时
(经常与absolutely、completely和totally一起使用)，该形容词通常是先升调再降调。</p>
<p>　　部分感叹句的结构是[how + 形容词]，形容词通常是先升调再降调。</p>
<p>　　名词和不包含形容词的短语也能作为感叹句，通常是先升调再降调。</p>
<p>　　really作为感叹句时，通常是先升调再降调。</p>
<h5 id="保持对话的进行">3.3.9 保持对话的进行</h5>
<img src="/2024/02/03/english-pronunciation-in-use/keeping_conversation_going_1.png" class="" title="keeping_conversation_going_1">
<p>　　在对话中，经常会使用单词或短语来让对方继续
(通常是升调)，例如，mm、uhuh、mhm、okay、right、yeah和I
see。当这些单词或短语是降调时，经常表示自己认为对方已经说完或想要改变话题。</p>
<img src="/2024/02/03/english-pronunciation-in-use/keeping_conversation_going_2.png" class="" title="keeping_conversation_going_2">
<p>　　有些单词和短语可以添加到肯定句后，以确认对方是否理解或接受所说的内容，此时，通常是升调，例如，alright、you
know、okay、you
see和right。对应的回答经常是mm、uhuh、mhm、okay、right、yeah和I
see等单词或短语 (通常是降调)，表示自己已经理解或接受。</p>
<p>　　为了表示对对方所说的内容感兴趣或希望对方继续，可以使用较短的疑问句，例如，really、did
you、were they、haven't we，这些疑问句通常先降调再升调。</p>
<h5 id="增加信息和改变话题">3.3.10 增加信息和改变话题</h5>
<img src="/2024/02/03/english-pronunciation-in-use/adding_information_and_changing_topic_1.png" class="" title="adding_information_and_changing_topic_1">
<p>　　很多单词和短语可以用于引入与之前所说内容相关的信息。部分这样的单词通常是1个单独的语音单元并且是升调或先升调再降调，例如，also、otherwise、similarly、at
the same time、better still、by the some token、even better、in that
case、in the same way、in other words、on top of that和worse still。</p>
<img src="/2024/02/03/english-pronunciation-in-use/adding_information_and_changing_topic_2.png" class="" title="adding_information_and_changing_topic_2">
<p>　　当需要改变话题或讨论当前话题的其他方面时，经常会使用anyhow、anyway、incidentally
(将要说的内容不如之前说的内容重要)、now (then)、okay、right、well和by
the way等单词或短语，它们通常是降调并且是1个单独的语音单元。</p>
<img src="/2024/02/03/english-pronunciation-in-use/adding_information_and_changing_topic_3.png" class="" title="adding_information_and_changing_topic_3">
<p>　　部分人会使用look来引入希望对方注意的当前话题的其他方面
(降调)，但是，其他人只通过这种方式来表达生气。</p>
<p>　　besides可以用于提供某事的其他理由或论据 (降调)。</p>
<h3 id="正式场合的发音">4 正式场合的发音</h3>
<img src="/2024/02/03/english-pronunciation-in-use/dividing_prepared_speech_into_units_1.png" class="" title="dividing_prepared_speech_into_units_1">
<p>　　在演讲中，倾向于按照句子的边界 (标点符号等)
来划分语音单元的边界。</p>
<p>　　● 根据连接2个句子的and和but划分语音单元。</p>
<p>　　● 根据状语从句划分语音单元。</p>
<p>　　● 根据主语从句划分。</p>
<p>　　● 根据非限定性定语从句划分语音单元。</p>
<p>　　限定性定语从句很少与其引用的名词处于不同的语音单元，例如，在Thu
number of people who are emigrating// is increasing
steadily中，people与who are emigrating处于同一语言单元。</p>
<p>　　由多个较短的句子组成的句子可能不会划分语音单元，例如，We'll leave
when we can只有1个语音单元。</p>
<img src="/2024/02/03/english-pronunciation-in-use/dividing_prepared_speech_into_units_2.png" class="" title="dividing_prepared_speech_into_units_2">
<p>　　对于演讲，除了按照句子的边界划分语音单元，还会按照特定的语法单元来划分语音单元。</p>
<p>　　● 根据引用整个句子的状语划分语音单元。</p>
<p>　　● 当主语是较长的短语时，主语会作为单独的语音单元。</p>
<p>　　● 根据包含连词或形容词的缩略句划分语音单元。</p>
<p>　　● 根据句首的非主语的单词或短语划分，包括<span
style="background-color: yellow">提供时间或地点相关信息的状语短语</span>、<span
style="background-color: yellow">表示所说内容的联系的连接副词或短语</span>
(furthermore和in the meantime等)、<span
style="background-color: yellow">表示所说内容的所处阶段的单词和短语</span>
(firstly和in summary等) 和<span
style="background-color: yellow">位于动词之前的宾语</span>。</p>
<p>　　此外，也可以将希望听者重点关注的单词或短语放在1个单独的语音单元中，例如，在the
name of the process is//
electrolysis中，electrolysis是1个单独的语音单元。</p>
<h4 id="插入语">4.1 插入语</h4>
<img src="/2024/02/03/english-pronunciation-in-use/inserts.png" class="" title="inserts">
<p>　　在写作时，有时会在某些单词前后加上破折号或括号，这些单词会为句子增加可以忽略的信息，这些单词称为<strong>插入语</strong>。</p>
<p>　　● 插入语可以表示内容是如何组织的。</p>
<p>　　● 插入语可用于举例。</p>
<p>　　● 插入语可用于限制所说的内容。</p>
<p>　　● 插入语可用于给出更多细节。</p>
<p>　　● 插入语可用于表达个人看法。</p>
<p>　　在演讲中，插入语通常是1个单独的语音单元，前后都会有停顿，通常是先降调再升调。但是，对于较长的插入语，其发音可能包括更多升调和降调。</p>
<h4 id="升高和降低音高">4.2 升高和降低音高</h4>
<img src="/2024/02/03/english-pronunciation-in-use/contrasts_and_new_topics.png" class="" title="contrasts_and_new_topics">
<p>　　在演讲中，为了进行对比或开始新话题，通常会让对应的语音单元的第1个强读词的音高升高。</p>
<img src="/2024/02/03/english-pronunciation-in-use/adding_information_and_ending_topics.png" class="" title="adding_information_and_ending_topics">
<p>　　当用名词短语来为之前的提到的名词短语增加相关信息时
(或这2个名词短语都是引用同一人或物)，通常会让该名词短语的音高相对其所属的语音单元更低。若名词短语是新信息，则使用降调；反之，则使用升调或先降调再升调。这种方式也同样适用于句子。此外，在演讲中，为了结束话题，也会使用这种方式。</p>
<h4 id="一系列相似项中的语调">4.3 一系列相似项中的语调</h4>
<img src="/2024/02/03/english-pronunciation-in-use/tones_in_a_series_of_similar_items.png" class="" title="tones_in_a_series_of_similar_items">
<p>　　在演讲中，当列举2个以上的相似项时，每个项通常都是1个单独的语音单元。在大多数情况下，只有最后1个项是降调
(表示结束)，其他项都是升调或先降调再升调
(表示它们在某种程度上相似)。但是，在日常口语中，情况并非完全如此，例如，1个语音单元可以包含多个项或不完整的一系列项。</p>
<p>　　● 若项中的单词不提供新信息，则通常不会强读。</p>
<p>　　●
对于作为例程一部分或重复的一系列项，除了最后1个项是降调，其他项都是平调
(有时是升调)。</p>
<p>　　● 若需要强调每个项都是独立和重要的，则每个项都会使用降调。</p>
<h4 id="引用和建立悬念时的平调">4.4 引用和建立悬念时的平调</h4>
<img src="/2024/02/03/english-pronunciation-in-use/level_tone_in_quoting_and_building_suspense.png" class="" title="level_tone_in_quoting_and_building_suspense">
<p>　　当引用别人所说的话时，经常会使用平调并在最后1个语音单元使用降调，以表示只是简单引用别人所说的话而非解析其含义。</p>
<p>　　引用别人所说的话时所用<strong>转述动词</strong>通常是平调，其音高通常相对较高。转述动词后会有停顿，然后是引用的话，引用的话的第1个单词的音高也会相对较高。</p>
<p>　　可以通过升高音高、平调和停顿来建立悬念。</p>
]]></content>
      <categories>
        <category>语言学</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第1章 历史和标准</title>
    <url>/2024/07/03/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-1/</url>
    <content><![CDATA[<p>　　贝尔实验室的Ken Thompson于1969年用汇编语言开发了第1个UNIX实现
(同年Linus
Torvalds出生)，用于数字PDP-7微型计算机。贝尔实验室是电话公司AT&amp;T的部门之一。UNIX是<span
style="background-color: yellow">多路复用信息与计算服务</span>
(AT&amp;T与麻省理工学院和通用电气公司合作的早期操作系统项目的名称)
的双关语。此时，AT&amp;T已经退出MULTICS，因为该项目最初未能开发出有经济收益的系统。Thompson根据MULTICS为他的新操作系统拟定了一些想法，包括树状结构的文件系统、用于解释命令的独立程序
(即shell) 和将文件视为非结构化的字节流的概念。</p>
<p>　　在1970年，UNIX用汇编语言重写，用于新收购的数字PDP-11微型计算机和之后的功能更强大的新型计算机。大部分UNIX实现
(包括Linux) 中使用的多个名称中仍然有PDP-11遗产的痕迹。</p>
<p>　　不久之后，Dennis
Ritchie设计并实现了C语言，他是Thompson在贝尔实验室的同事，也是UNIX的早期合作者。这是革命性的进程，C语言遵循更早的解释型语言B。B最早由Thompson实现，从更早的编程语言BCPL中吸收了很多思想。到1973年，C语言已经很成熟，UNIX内核几乎可以完全用C语言重写。因此，UNIX成为了用高级语言编写的最早的操作系统之一，这使得后续将UNIX移植到其他硬件架构成为可能。</p>
<p>　　C语言的起源解释了为何如今C和C++被广泛使用。之前广泛使用的语言在设计时都考虑了其他用途。例如，FORTRAN可用于工程师和科学家执行的数学任务，而COBOL可用于处理面向记录的数据流的商业系统。C语言的设计源于少数人的想法和需求，他们朝着同一目标努力：开发1种用于实现UNIX内核和相关软件的高级语言。就像UNIX操作系统本身，C语言由专业程序员为自己使用而设计。</p>
<span id="more"></span>
<h3 id="unix简介">1.1 UNIX简介</h3>
<p>　　从1969年到1979年，UNIX进行多次版本发布。从本质上说，这些版本是AT&amp;T不断发展的开发版本的快照。</p>
<p>　　●
第1版发布于1971年11月。该版本可以运行在PDP-11上，并且包含1个FORTRAN编译器和多个现在依旧在使用的程序的早期版本
(包括<code>ar</code>、<code>cat</code>、<code>chmod</code>、<code>chown</code>、<code>cp</code>、<code>dc</code>、<code>ed</code>、<code>find</code>、<code>ln</code>、<code>ls</code>、<code>mail</code>、<code>mkdir</code>、<code>mv</code>、<code>rm</code>、<code>sh</code>、<code>su</code>和<code>who</code>)。</p>
<p>　　●
第2版发布于1972年1月。此时，UNIX已经安装在AT&amp;T内部的10台机器上。</p>
<p>　　●
第3版发布于1973年2月。该版本包含1个C编译器和第1个管道的实现。</p>
<p>　　●
第4版发布于1973年11月。该版本是第1个几乎完全用C语言开发的版本。</p>
<p>　　● 第5版发布于1974年1月。此时，UNIX已经安装在50多个系统中。</p>
<p>　　●
第6版发布于1975年5月。该版本是第1个在AT&amp;T之外被广泛使用的版本。</p>
<p>　　在这段时间内，AT&amp;T对美国电话系统拥有政府批准的垄断权。AT&amp;T与美国政府的协议中的条目让AT&amp;T无法出售软件，所以UNIX也不能作为商品出售。从1974年的第5版开始，尤其是第6版，AT&amp;T以象征性的发行费来授权在大学中使用UNIX。大学发行版包括文档和内核代码
(大约1万行)。</p>
<p>　　AT&amp;T将UNIX发布到大学的行为极大地促进了操作系统的使用和普及。在1977年，UNIX运行在大约500个站点上，其中包括美国和其他国家的125所大学。UNIX为大学提供了1个便宜且功能强大的交互式多用户操作系统，当时，商业操作系统十分昂贵。这也为大学的计算机科学系提供了真实操作系统的源码，这些源码可以被修改以及提供给学生来学习和实验。有些掌握了UNIX的学生成为了UNIX的布道者，其他学生则后来成立或加入初创公司，销售运行UNIX的廉价计算机工作站。</p>
<p>　　1977年到1978年，UNIX系统首次移植到PDP-11之外的硬件。Dennis
Ritchie和Steve Johnson将UNIX移植到Interdata
8/32，同时，澳大利亚伍伦贡大学的Richard Miller将UNIX移植到Interdata
7/32。伯克利数字VAX移植版基于John Reiser和Tom London的早期 (1978年)
移植版，也称为32V，该版本与PDP-11的第7版大致相同，除了更大的地址空间和数据类型。</p>
<p>　　1979年1月，UNIX第7版发布，该版本提升了系统的稳定性并提供了1个增强型文件系统。该版本还包含<code>awk</code>、<code>make</code>、<code>sed</code>、<code>tar</code>、<code>uucp</code>、Bourne
shell和FORTRAN
77编译器等大量新工具。该版本意义重大，因为自此开始，UNIX分化出了2个重要变体——<span
style="background-color: yellow">伯克利软件套件</span>和<span
style="background-color: yellow">System V</span>。</p>
<p>　　Thompson于1975/1976学年担任其母校加州大学伯克利分校的客座教授。在这里，他与几位研究生一起为UNIX添加了很多新功能
(其中的学生Bill Joy参与了Sun
Microsystem的创立)。随着时间的流逝，加州大学伯克利分校开发了很多新功能和工具，包括C
shell、<code>vi</code>编辑器、改良型文件系统
(伯克利快速文件系统)、<code>sendmail</code>、Pascal编译器和新型数字VAX架构的虚拟内存管理。</p>
<p>　　在BSD的名义下，这个版本的UNIX (包含源码)
被广泛分发。1979年12月，3BSD全面发布。加州大学伯克利分校早期的发行版BSD和2BSD是该校开发的新工具集，而非完整的UNIX发行版。</p>
<p>　　在1983年，加州大学伯克利分校的计算机系统研究组发布了4.2BSD，该版本有完整的TCP/IP实现，包含套接字应用程序编程接口和大量网络工具。4.2BSD及其前身4.1BSD在世界各地的大学广泛传播，它们也构成了Sun
OS (首次发布于1983年)
的基础，SunOS是Sun公司销售的UNIX变体。其他重要的BSD发行版是1986年的4.3BSD和1993年的4.4BSD
(最终发行版)。</p>
<p>　　与此同时，美国反垄断法迫使AT&amp;T分立
(该事件始于20世纪70年代中期，AT&amp;T分立生效于1982年)。其结果是AT&amp;T不再垄断电话系统，但被允许销售UNIX。因此，AT&amp;T发布了System
III，System
III由AT&amp;T的UNIX支持组开发，UNIX支持组雇佣了数百名开发者来优化UNIX和开发UNIX应用程序。System
V首次发布于1983年，并在1989年进行多次版本发现，最终推出了System V第4版
(SVR4)。此时，System V已经集成了BSD的很多功能，包括网络工具。System
V被授权给多个商业提供商，这些提供商将其作为UNIX实现的基础。</p>
<p>　　最后，除了BSD在学术界的传播，在20世纪80年代晚期，UNIX在很多硬件上都有大量商业化实现，包括Sun的Sun
OS和后来的Solaris、Digtial的Ultrix和OSF/1
(经过了一系列的改名和收购后，成为了如今的HP True 64
UNIX)、IBM的AIX、HP的HP-UX、NeXT的NeXTStep、苹果为麦金塔开发的A/UX、微软和SCO为Intel
x86-32架构共同开发的XENIX。当时，更常见的情况是每个供应商生产1种或最多几种专有计算机芯片架构，并在其架构上销售自己的专有操作系统。大多数供应商系统的专有性质使得采购商只能选择1个供应商。若需要切换到其他专有系统和硬件平台，则需要移植现有应用程序和重新培训员工，其成本十分高昂。这一因素再加上各种供应商的廉价单用户UNIX工作站的出现，使得UNIX系统更具有商业吸引力。</p>
<p>　　在20世纪90年代早期，支持x86-32的免费UNIX已经出现。Bill
Jolitz和其妻子Lynne
Jolitz为x86-32开发了成熟的BSD移植版，称为386/BSD。386/BSD基于4.3BSD源码的版本BSD
Net/2 (1991年1月)，并从中移除或替换了AT&amp;T的专有代码部分
(其中6个源文件已经琐碎到无法重写，只能移除)。Jolitz夫妇将Net/2代码移植到x86-32，重写了缺失的源文件，并在1992年2月发布了386/BSD的第1版0.0。</p>
<p>　　在最初的成功和流行后，由于各种原因，386/BSD的开发停滞。随着越来越多的补丁挤压，2个代替开发组很快出现，它们基于386/BSD分别开发自己的版本——NetBSD和FreeBSD，前者侧重于各种硬件平台的可移植性，后者侧重于性能
(也是如今最传播最广的现代BSD)。NetBSD的第1版0.7发布于1993年4月。FreeBSD
CD-ROM (版本1.0) 出现于1993年12月。另一种BSD OpenBSD出现于1996年
(初始版本号2.0)，它是NetBSD项目的分支，侧重于安全性。2003年年中出现了新BSD
DragonFly BSD，它从FreeBSD 4.x中分裂出来。DragonFly
BSD在对称多处理架构方面使用了与FreeBSD 5.x不同的方法。</p>
<p>　　在20世纪90年代早期，UNIX系统实验室
(AT&amp;T用于开发和销售UNIX的子公司)
与加州大学伯克利分校出现了法律纠纷。1992年年初，伯克利软件设计公司
(如今已成为WInd River的一部分) 开始分发商业支持的BSD BSD/OS
(基于Net/2发行版和Jolitz夫妇的386/BSD附件)，分发二进制文件和源码的费用995美元，该公司还支持潜在的客户拨打它们的电话号码1-800-ITS-UNIX。</p>
<p>　　在1992年4月，UNIX系统实验室起诉了伯克利软件设计公司，以阻止其销售包含UNIX系统实验室的专有代码和商业机密的产品。UNIX系统实验室还要求伯克利软件设计公司停止使用欺骗性的电话号码。该诉讼最终扩大到包括对加州大学伯克利分校的索赔。法院最终驳回了UNIX系统实验室的2项索赔外的其他索赔。随后，加州大学反诉UNIX系统实验室，声称System
V在未经许可的情况下中使用了BSD的代码。</p>
<p>　　在这些诉讼悬而未决期间，UNIX系统实验室被Novell收购。Novell的CEO
Ray Noorda (目前已故)
公开表示更愿意在市场上竞争，而非在法庭上竞争。最终在1994年1月达成和解，加州大学被要求删除出Net/2发行版的18000个文件中的3个，对其他小部分文件进行小幅修改，并在大约70个其他文件中添加UNIX系统实验室版权声明，但该大学仍然可以继续分发这些文件。修改后的系统以4.4BSD-Lite发布于1994年6月
(该大学的最后1个发行版本4.4BSD-Lite版本2发布于1995年6月)。法律条款还要求伯克利软件设计公司、FreeBSD和NetsBSD用修改后的4.4BSD-Lite源码替换基于Net/2的代码部分。这场法律纠纷导致BSD衍生系统的开发出现了一些滞后，但也有积极意义，即这些系统与加州大学的计算机系统研究组自Net/2发布以来所做的3年开发工作再次同步。</p>
<h3 id="linux简介">1.2 Linux简介</h3>
<p>　　通俗意义上的Linux (即整个Linux系统)
的源码中的相当大一部分来自GNU项目，GNU的创建者Richard
Stallman倾向于用GNU/Linux来表示整个Linux系统。命名问题在自由软件社区的引起了一些争论。因为之后的内容主要与Linux内核的API相关，所以这里使用术语LInux来表示整个系统。</p>
<p>　　对于早期Linux，
用户需要装配软件、创建文件系统并在文件系统上正确地放置和配置所有软件，这需要大量的时间和专业知识。Linux发行商便应运而生，负责创建用于自动化大部分安装过程、创建文件系统和安装内核以及必需软件的包
(发行版)。</p>
<p>　　最早的一批Linux发行商出现在1992年，包括MCC Interim
Linux、TAMU和SoftLanding Linux系统
(SLS)。目前仍然存在的历史最悠久的Linux发行商Slackware出现在1993年。非商业的Debian发行版大约出现在这一时间，随后是SUSE和Red
Hat。Ubuntu发行版最早出现在2004年。现在，很多Linux发行公司都会雇佣积极为自由软件项目做出贡献和启动新项目的程序员。</p>
<h4 id="gnu项目">1.2.1 GNU项目</h4>
<p>　　在1984年，受雇于MIT的天赋异禀的程序员Stallman着手于创建1个"free"的UNIX实现。在他的观点中，这里的free是法律意义上的自由，而非经济意义上的免费。然而，Stallman所描述的法律上的自由有1个隐含的后果，即操作系统等软件将以非常低的价格甚至免费提供。</p>
<p>　　Stallman反对计算机供应商对专有操作系统的法律限制。这些限制使得计算机软件的购买者通常无法看见所购软件的源码，他们当然不能复制、修改或分发。他指出，这种情况会鼓励程序员与其他程序员竞争并隐藏其成果，而非协作和分享。作为相应，Stallman发起了GNU
(GNU's not UNIX)
项目来开发1个自由获取的完整的类UNIX系统，包含内核及相关软件包，并且他还鼓励其他来加入他。在1985年，Stallman创建非营利性组织——自由软件基金会，用于支持GNU项目和自由软件的开发。</p>
<p>　　当GNU项目成立时，BSD并非Stallman所指的自由，BSD的使用需要AT&amp;T的许可证，用户不能自由地修改和分发BSD中AT&amp;T的专有代码部分。</p>
<p>　　<strong>GNU通用公共许可证</strong>是GNU项目的重要成果之一，这是Stallman自由软件理论的法律体现。Linux发行版中的大部分软件
(包括内核)
都是使用GPL或类似的许可证授权。使用GPL的软件必须以源码的形式提供，并且必须可以根据GPL条款再分发。此外，可以自由地对GPL授权的软件进行修改，修改后的软件也必须符合GPL条款。若修改后的软件以可执行文件的形式分发，则开发者必须允许接收者以不高于分发成本的价格获取修改后的源码。GPL第1版发布于1989年。GPL第3版
(即最新版)
发布于2007年。GPL第2版发布于1991年，该版本如今仍然被广泛使用，Linux内核的许可证就是该版本。</p>
<p>　　GNU项目最初并没有开发出可以运行的UNIX内核，但是开发了大量的其他程序。因为这些程序设计为可以运行在类UNIX操作系统上，所以它们可以运行在UNIX实现上，甚至可以移植到其他操作系统。GNU开发的软件中，比较知名的软件包括Emacs文本编辑器、GCC
(原为GNU
C编译器，现已更名为GNU编译器合集，包括C、C++和其他语言的编译器)、bash
shell和glibc (GNU C语言库)。</p>
<p>　　在20世纪90年代早期，GNU项目开发出了近乎完整的操作系统，除了可以运行的UNIX内核。GNU项目开始开发基于Mach微内核的内核——GNU/HURD，但是HURD的完成度很低
(在本书的撰写过程中，HURD的开发工作仍在继续，此时，HURD还是只能运行在x86-32架构上)。</p>
<h4 id="linux内核">1.2.2 Linux内核</h4>
<p>　　在1991年，芬兰赫尔辛基大学的学生Linus Torvalds萌生了为他的Intel
80386计算机开发操作系统的想法。在他的学习过程中，Torvalds曾接触过Minix
(20世纪80年代中期阿姆斯特丹自由大学的教授Andrew
Tanenbaum开发的类UNIX操作系统内核)。Tanenbaum提供了Minix的源码，作为在大学中教授操作系统设计的工具。Minix内核可以在386系统上构建和运行。但是，由于Minix主要作为教学工具，其设计很大程度上独立于硬件架构，并且没有完全发挥386
CPU的性能。</p>
<p>　　因此，Torvalds成立了1个项目来开发了可运行在386上的高效且功能完整的UNIX内核。数月后，Torvalds开发了1个能编译和运行各种GNU程序的基础内核。在1991年10月，Torvalds请求其他程序员的帮助：</p>
<blockquote>
<p>Do you pine for the nice days of Minix-1.1, when men were men and
wrote their own device drivers? Are you without a nice project and just
dying to cut your teeth on a OS you can try to modify for your needs?
Are you finding it frustrating when everything works on Minix? No more
all-nighters to get a nifty program working? Then this post might be
just for you. As I mentioned a month ago, I'm working on a free version
of a Minix-look-alike for AT-386 computers. It has finally reached the
stage where it's even usable (though may not be depending on what you
want), and I am willing to put out the sources for wider distribution.
It is just version 0.02 . . . but I've successfully run bash, gcc,
gnu-make, gnu-sed, compress, etc. under it.</p>
</blockquote>
<p>　　遵循类UNIX系统以字母X结尾的悠久传统，该内核最终命名为Linux。最初，Linux使用的许可证更严格。不久，Torvalds就将其许可证变为GPL。</p>
<p>　　事实证明，呼吁支持很有效。其他开发者加入了Torvalds，共同开发LInux和增加新功能
(例如，更高级的文件系统、网络支持、设备驱动和多处理器支持)。Linux
1.0发布于1994年3月。Linux 1.2发布于1995年3月。Linux
2.0发布于1996年6月。Linux 2.2发布于1999年1月。Linux
2.4发布于2001年1月。Linux 2.5的开发始于2001年11月，这使得Linux
2.6能在2003年12月发布。</p>
<p>　　在Linux的早期开发中，主要目标是Intel
80386上的高效实现，而非移植到其他硬件架构。随着Linux用户的增加，Linux移植版开始出现。开始只有Digital
Alpha芯片的移植版，后来移植到了x86-64、Motorola/IBM
PowerPC和PowerPC64、Sun SPARC和SPARC64 (UltraSPARC)、MIPS、ARM
(Acorn)、IBM z系列 (以前称为System/390)、Intel IA-64、Hitachi SuperH、HP
PA-RISC和Motorola 68000。</p>
<h4 id="linux内核版本号">1.2.3 Linux内核版本号</h4>
<p>　　与大多数自由软件项目一样，LInux使用 "早发布、常发布"
的模型，所以内核版本的发布频率很高
(有时甚至每天都发布)。随着LInux用户基数的增加，发布模型也进行了调整，以减少对现有用户的影响。从Linux
1.0开始，内核开发者采用了x.y.z的版本命名方案，x表示主要版本，y表示主要版本的次要版本，z表示次要版本的修订版本
(次要版本改进和漏洞修复)。</p>
<p>　　在此模型下，有2个内核版本同时开发——稳定分支
(用于生产系统，其次要版本号是偶数) 和开发分支
(其次要版本号是奇数，表示稳定分支的下1个更大的次要版本号)。实际中并非严格如此，所有新功能都应该添加到当前开发分支，而稳定分支中的修订版本仅包含次要版本改进和漏洞修复。当当前开发分支适合发布时，会作为新的稳定分支并分配偶数次要版本号。例如，开发分支2.3.z可以发布时，会发布为稳定分支2.4。</p>
<p>　　随着内核版本2.6的发布，开发模型发生了改变，主要因为稳定分支间隔过长而导致的问题和挫折
(Linux
2.4.0和2.6.0的间隔时间接近3年)。开发模型的细节会不定期地修改，但基本细节不变：</p>
<p>　　●
开发分支和稳定分支不再分离。每个新的2.6.z版都可以包括新功能，其生命周期从添加新功能开始，然后通过多个候选版本稳定下来。当候选版本足够稳定时，会发布为2.6.z稳定版。发布周期通常是3个月。</p>
<p>　　●
有时，2.6.z稳定版可能需要小补丁来修复漏洞和安全问题。若这些修复优先级较高且补丁简单到看似明显正确，则会发布为版本2.6.z.r，r是2.6.z的当前次要版本的序列号。</p>
<p>　　● 确定发行版内核稳定的责任转移给了发行版提供商。</p>
<h3 id="标准化">1.3 标准化</h3>
<p>　　在20世纪90年代晚期，各种可用的UNIX实现都有自己的缺点。有些UNIX实现基于BSD，其他UNIX实现基于System
V，部分UNIX实现从BSD和System
V中都吸收了功能。此外，每个商业提供商都为自己的UNIX实现添加了额外功能。结果是当人员和软件从某个UNIX实现转移到其他UNIX实现时，情况变得越来越困难。这种情况为C语言和UNIX系统的标准化造成了很大的压力，应用程序的移植也因此变得更简单。</p>
<p>　　除了参考由独立或多方团体制定的标准，有时还会参考BSD最终版
(即4.4BSD) 和AT&amp;T的System V第4版 (即SVR4)
制定的实现标准。SVR4实现标准是通过AT&amp;T发布的System V接口定义 (SVID)
正式确定的。在1989年，AT&amp;T发布了SVID第3期，该版本定义了SVR4必须提供的接口。</p>
<p>　　由于SVR4和BSD的部分系统调用和库函数的行为之间的差距，很多UNIX实现提供了兼容性库和条件编译工具来模拟该实现未使用的基础UNIX风格
(SVR4或BSD) 的行为，这减少了移植应用程序时遇到的阻力。</p>
<h4 id="c语言">1.3.1 C语言</h4>
<p>　　在20世纪90年代早期，C语言已经存在10年了，并实现在各种UNIX实现和其他操作系统上。各个实现之间的小差异越来越多，部分原因是Kernighan和Ritchie于1978年出版的书《The
C Programming
Language》中没有详细说明C语言运作的某些方面。因此，1985年出现的C++强调在不破坏现有程序的情况下，对C语言进行改进并增加新功能，尤其是函数原型、结构体赋值、类型限定符
(<code>const</code>和<code>volatile</code>)、枚举类型和关键字<code>void</code>。</p>
<p>　　这些因素推动着C语言的标准化。1989年美国国家标准学会批准了C标准，该标准随后在1990年被国际标准化组织采用
(ISO/IEC
9899:1990)。除了定义C语言的语法和语义外，该标准还描述了标准C库，其中包括标准I/O函数、字符串处理函数、数学函数和各种头文件。该标准称为<span
style="background-color: yellow">C89</span>或<span
style="background-color: yellow">ISO
C90</span>，Kernighan和Ritchie于1988年出版的《The C Programming
Language》第2版全面地描述了该版本。</p>
<p>　　在1999年，ISO发布了C标准第2版 (ISO/IEC
9899:1999)。该标准称为<span
style="background-color: yellow">C99</span>，包括对于大量C语言和标准库的修改，这些修改包括添加<code>long long</code>和布尔数据类型、C++风格注释<code>//</code>、受限指针以及长度可变的数组。在2011年，ISO发布了C标准第3版
(ISO/IEC 9899:2011)。该标准称为<span
style="background-color: yellow">C11</span>或<span
style="background-color: yellow">C1X</span>。</p>
<p>　　从历史角度，C89过去经常被称为<span
style="background-color: yellow">ANSI
C</span>，即使如今的有些情况下也是如此。例如，gcc就使用了这一含义，限定符<code>-ansi</code>表示支持所有ISO
C90程序。但是，随着ANSI采用了C99，ANSI应该表示C99。这里为了避免歧义，之后的内容不会使用该术语。</p>
<p>　　C语言标准独立于操作系统，这表示仅使用标准库的C程序可以移植到任何带有C语言实现的电脑和操作系统上。</p>
<h4 id="posix.1">1.3.2 POSIX.1</h4>
<p>　　在<span
style="background-color: yellow">电气与电子工程师协会</span>的<span
style="background-color: yellow">可移植应用程序标准委员会</span>主持下制定的一系列标准称为<strong>可移植操作系统接口</strong>。PASC标准的目标是在源码级别上提高应用程序的可移植性。</p>
<p>　　POSIX.1在1988年成为IEEE标准，其修订版在1990年成为了ISO标准
(ISO/IEC 9945-1:1990)。POSIX.1最初基于早期的非官方标准
(1984年)，该标准由名为/usr/group的UNIX提供商协会制定。</p>
<p>　　POSIX.1记录了一组服务共有的1个API，这些服务应该由符合标准的操作系统提供给应用程序。符和标准的操作系统可以认证为<span
style="background-color: yellow">符合POSIX.1</span>。</p>
<p>　　POSIX.1基于UNIX系统调用和C库函数API，但它不需要任何特定的实现与该接口关联，即所有操作系统都可以实现该接口，而非特定UNIX操作系统。实际上，有些提供商会为它们的专有UNIX操作系统添加接口来保证其符合POSIX.1，同时保持底层操作系统基本不变。</p>
<p>　　很多对原始POSIX.1的扩展也很重要。IEEE POSIX 1003.1b (也称为<span
style="background-color: yellow">POSIX.1b</span>，以前称为POSIX.4或POSIX
1003.4) 于1993年获批，包含大量基于POSIX基础标准的实时扩展。IEEE POSIX
1003.1c (也称为<span style="background-color: yellow">POSIX1.c</span>)
于1995年获批，定义了POSIX线程。1996年，POSIX.1的修订版发布 (ISO/IEC
9945-1:1996)，其核心内容不变，但加入了实时和线程扩展。IEEE POSIX 1003.1g
(也称为<span style="background-color: yellow">POSIX.1g</span>)
定义了套接字等网络接口。IEEE POSIX 1003.1d (也称为<span
style="background-color: yellow">POSIX.1d</span>) 于1999年获批。<span
style="background-color: yellow">POSIX.1j</span>于2000年获批，定义了POSIX基础标准的额外实时扩展。</p>
<p>　　POSIX.1b的实时扩展包含文件同步、异步I/O、进程调度、高精度时钟和定时器以及使用信号量、共享内存和消息队列的进程间通信。前缀POSIX经常用于3种进程间通信方式，以区分相似但更早的System
V信号量、共享内存和消息队列。</p>
<p>　　POSIX.2发布于1992年 (ISO/IEC
9945-2:1993)，它标准化了shell和各种UNIX工具
(包括C编译器的命令行界面)。</p>
<p>　　美国政府采购计算机系统时所用的一系列标准称为<span
style="background-color: yellow">美国联邦信息处理标准</span>。FIPS
151-1发布于1989年，该标准基于1988年的POSIX.1和ANSI C标准草案。FIPS
151-1和POSIX.1的主要区别是POSIX.1中的部分可选功能在FIPS
151-1中是必需的。由于美国政府是计算机系统的主要购买者之一，大部分计算机提供商都会保证它们的UNIX系统符合POSIX.1的FIPS
151-1版本。FIPS 151-2与1990年的ISO版POSIX.1完全相同。现已过时的FIPS
151-2于2000年2月被撤销。</p>
<h4 id="xopen-company和the-open-group">1.3.3 X/Open Company和The Open
Group</h4>
<p>　　<span style="background-color: yellow">X/Open
Company</span>是1个由国际计算机供应商集团组成的联盟，旨在采用和调整现有标准，以制定1套全面且一致的开放系统标准。该联盟推出了1套基于POSIX的可移植性指南——<strong>X/Open可移植性指南</strong>，该指南的第1个重要版本是1989年发布的第3期
(XPG3)，然后是1992年发布的XPG4。XGP4在1994年进行了修订，得到了XPG4第2版，该标准还成为了AT&amp;T的System
V接口定义第3期的一部分。XPG4第2版也称为<span
style="background-color: yellow">Spec
1170</span>，其中1170表示标准定义的接口 (包括函数、头文件和命令)
的数量。</p>
<p>　　在1993年年初，Novell收购了AT&amp;T的UNIX系统业务，然后剥离了该业务并将UNIX商标转让给了X/Open
(转让计划于1993年宣布，但法律要求该转让延迟到1994年年初执行)。XPG4第2版之后重新打包成了<strong>单一UNIX规范</strong>
(也称为<span style="background-color: yellow">UNIX
95</span>)。此次重打包包括XPG第2版、X/Open Curses第2期第4版规范、X/Open
Networking Services (XNS) 第4期规范。SUS第2版 (即SUSv2，有时也称为XPG5)
出现于1997年，通过SUSv2认证的UNIX实现可以称为<span
style="background-color: yellow">UNIX 98</span>。</p>
<p>　　<span
style="background-color: yellow">开放软件基金会是</span>是20世纪80年代晚期UNIX之战期间形成的2个供应商联盟之一。OSF包括Digtial、IBM、HP、Apollo、Bull、Nixdorf和Siemens。OSF的成立主要是为了应对AT&amp;T
(UNIX的开发公司) 和Sun (UNIX工作站市场中最强大的公司)
之间的商业联盟所构成的威胁。因此，AT&amp;T、Sun和其他公司组成了OSF的对手UNIX国际联盟。</p>
<p>　　在1996年，X/Open与OSF合并为<span
style="background-color: yellow">The Open
Group</span>。如今，几乎每个与UNIX相关的组织和公司都是The Open
Group的成员，而The Open Group还在继续制定API标准。</p>
<h4 id="susv3和posix.1-2001">1.3.4 SUSv3和POSIX.1-2001</h4>
<p>　　在1999年年初，IEEE、The Open Group和ISO/IEC联合技术委员会1在<span
style="background-color: yellow">奥斯汀通用标准修订小组</span>
(名称源于其成立会议于1998年9月在德州奥斯汀举行)
中合作，以修订和整合POSIX和SUS。结果是POSIX 1003.1-2001 (也称为<span
style="background-color: yellow">POSIX.1-2001</span>)
获批，并在2001年12月成为了ISO标准 (ISO/IEC
9945:2002)。POSIX.1-2001替代了SUSv2、POSIX.1、POSIX.2和大量早期POSIX，该标准也称为SUS第3版
(即SUSv3)。通过SUSv3认证的UNIX实现可以称为<span
style="background-color: yellow">UNIX 03</span>。</p>
<p>　　SUSv3基础规范包含3700页，分为以下4部分：</p>
<p>　　● <strong>基础定义</strong> (XBD)
包含头文件内容的定义、术语、概念和规范，共提供了84个头文件规范。</p>
<p>　　● <strong>系统接口</strong> (XSH)
从各种有用的背景信息开始，主体包含各种函数的规范
(这些函数在特定UNIX实现上实现为系统调用或库函数)。该部分共包含1123个系统接口。</p>
<p>　　● <strong>shell和工具</strong> (XCU)
详细说明了shell操作和各种UNIX命令，共详细说明了160个工具。</p>
<p>　　● <strong>基本原理</strong> (XRAT)
包括前3部分的相关信息文本和原由。</p>
<p>　　此外，SUSv3还包括X/Open CURSES第2期第2版规范
(详细说明了curses屏幕处理API的372个函数和3个头文件)。</p>
<p>　　SUSv3共详细说明了1742个接口。相比之下，POSIX.1-1990 (包括FIPS
151-2) 仅详细说明了199个接口，POSIX.2-1992仅详细说明了130个工具。</p>
<p>　　SUSv3获批后，经过了数次小幅的修复和改进，这导致了技术勘误表1号和2号的出现，它们分别被纳入了SUSv3的2003年修订版和2004年修订版。</p>
<p>　　从历史角度，SUS和XPG符合对应的POSIX并构建为POSIX的功能性超集。除了详细说明额外的接口外，SUS还让很多在POSIX中可选的接口和行为成为了标准的一部分。</p>
<p>　　这种区别在POSIX 1003.1-2003中表现得很微妙。POSIX
1003.1-2003是早期POSIX和SUS的结合体，它既是IEEE标准，又是Open
Group技术标准。该标准定义了2种符合级别：</p>
<p>　　● <span
style="background-color: yellow">POSIX符合级别</span>定义了符合标准的实现必须提供的接口基准。它还允许这些实现提供可选的功能性接口。</p>
<p>　　● <span style="background-color: yellow">X/Open系统接口 (XSI)
符合级别</span>要求符合标准的实现除了符合POSIX，还必须提供大量在POSIX中可选的接口和行为，这些接口和行为统称为<span
style="background-color: yellow">XSI扩展</span>。要获取The Open
Group的UNIX
03品牌标识，实现必须达到该符合级别。在之后的内容中，会用符合SUSv3来表示符合XSI。</p>
<p>　　XSI扩展包括对线程、<code>mmap()</code>和<code>munmap()</code>、<code>dlopen()</code>
API、资源限制、伪终端、System V
IPC、<code>syslog</code>接口、<code>poll()</code>和登录账号的支持。</p>
<p>　　有时，会用 "未说明" 或 "简要说明"
来描述SUSv3中的某个接口。前者表示标准中完全未定义的接口，在极少数情况下，它们在背景或原由说明中会提及。后者表示标准中重要细节未定义的接口，通常因为现有实现之间的差距而导致委员会成员之间没有达成共识。当接口为未说明或简要说明时，无法完全保证应用程序可以移植到其他UNIX实现上，尽管如此，少数情况下，这种接口在各个实现之间相当一致。</p>
<p>　　SUSv3会将部分特定的功能标为LEGACY，表示为兼容旧应用程序而保留的功能，但是其限制意味着在新应用程序中应该避免使用。在很多情况下，会存在一些等效API。</p>
<h4 id="susv4和posix.1-2008">1.3.5 SUSv4和POSIX.1-2008</h4>
<p>　　在2008年，奥斯汀小组完成了对合并后的POSIX.1和SUS的修订。与之前的版本一样，该版本由1个标准规范和1个XSI扩展组成。这里将该版本称为<span
style="background-color: yellow">SUSv4</span>。</p>
<p>　　SUSv4的修改幅度不如SUSv3的修改幅度。重要修改包括以下内容：</p>
<p>　　● SUSv4为一系列功能增加了新规范。</p>
<p>　　●
部分在SUSv3中可选的函数成为了SUSv4的一部分，包括<code>dlopen()</code>
API、实时信号API、POSIX信号量API和POSIX定时器API。</p>
<p>　　●
部分SUSv3中的函数在SUSv4中被标记为已过时，包括<code>asctime()</code>、<code>ctime()</code>、<code>ftw()</code>、<code>gettimeofday()</code>、<code>getitimer()</code>、<code>setitimer()</code>和<code>siginterrupt()</code>。</p>
<p>　　●
部分SUSv3中标记为已过时的函数规范在SUSv4中被移除，包括<code>gethostbyname()</code>、<code>gethostbyaddr()</code>和<code>vfork()</code>。</p>
<p>　　● SUSv3中已存在的大量规范细节在SUSv4中被修改。</p>
<h4 id="unix标准时间线">1.3.6 UNIX标准时间线</h4>
<img src="/2024/07/03/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-1/relationships_between_various_unix_and_c_standards.svg" class="" title="relationships_between_various_unix_and_c_standards">
<p>　　如图所示，这里总结了之前内容介绍的各个标准间的关系并根据时间对它们进行了排序。实线表示2个标准直接相关。虚线箭头表示2个标准间接相关，即某个标准符合其他标准或其他标准的一部分纳入到该标准。</p>
<p>　　网络标准的情况有些复杂。该领域的工作始于20世纪80年代晚期，当时成立了POSIX
1003.12委员会来标准化套接字API、X/Open传输接口 (XTI)
API和大量相关API。XTI是基于System
V传输层接口的备选网络编程API。该标准的酝酿经过数年，在此期间，POSIX
1003.12更名为POSIX 1003.1g并于2000年获批。</p>
<p>　　在POSIX 1003.1g制定的同时，X/Open也在制定自己的X/Open网络规范
(XNS)。该规范的第1版XNS第4期成为了SUSv1的一部分。其后的XNS第5期成为了SUSv2的一部分，该版本与当时的POSIX.1g草案基本相同。再往后的XNS第5.2期与XNS第5期和获批的POSIX.1g都不同，该版本将XTI标记为已过时并包含了20世纪90年代中期设计的IPv6。XNS第5.2期构成了SUSv3中的网络规范的基础
(如今已被取代)。因此，POSIX1.g在获批不久后就被撤销。</p>
<h4 id="linux标准和linux标准基础">1.3.7 Linux、标准和Linux标准基础</h4>
<p>　　作为总体目标，LInix (包括内核、glibc和工具)
的开发旨在符合各种UNIX标准，尤其是POSIX和SUS。但是，在本书的撰写过程中，The
Open
Group没有为任何Linux发行版授予UNIX品牌标识，主要是因为时间和费用。每个供应商的发行版都需要通过标准符合测试才能获得UNIX品牌标识，并且发行版的每个新版本都需要通过测试。尽管如此，正是Linux对各种标准的基本符合才使得其在UNIX市场如此成功。</p>
<p>　　对于大多数商业UNIX实现，同一家公司既开发操作系统，也分发操作系统。对于LInux，情况则不同，因为实现与分发是分开的，并且存在多个组织
(包括商业组织和非商业组织) 负责分发Linux。</p>
<p>　　Linus
Torvalds并不参与或支持某个特定的Linux分发版。但是，对于其他负责Linux开发的开发者，情况则更复杂。很多从事Linux内核和其他自由软件项目开发的开发者受雇于Linux分发公司或IBM和HP等对Linux有浓厚兴趣的公司。虽然这些公司可以通过将开发者分配到某个项目来影响改变Linux的发展方向，但是无法控制Linux。当然，其他很多为Linux内核和GNU做过贡献的人都是出于自愿。</p>
<p>　　在本书的撰写过程中，Linus Torvalds受雇于Linux基金会
(前身为开源开发实验室)
——由商业组织和非商业组织组成的非营利性联盟，旨在促进LInux的发展。</p>
<p>　　因为Linux内核实现不控制分发版的内容并且存在多个Linux分发商，所以并不存在
"标准的" 商业版Linux。每个Linux分发商的内核都是基于主线 (即Torvalds)
Linux的某个时间点的快照，并使用了一些补丁。这些补丁提供的功能被认为具有商业吸引力，以在商业竞争中获得优势。有时，这些补丁之后会加入到主线内核。事实上，主线内核的部分新功能本来是发行公司开发的，最初出现在其发行版中，然后才合并到主线中。例如，Reiserfs日志文件系统第3版最初是部分Linux发行版的一部分，然后才合并到了主线2.4内核。</p>
<p>　　以上几点得到的结果是各个Linux发行公司提供的系统存在差异
(大部分差异都是细微的)。从更微观的角度，这让人想起了UNIX早期出现的实现分裂。<span
style="background-color: yellow">Linux标准基础</span>便应运而生，旨在保证各个Linux发行版之间的可移植性。为此，LSB为Linux系统制定一系列标准并对它们进行了推广，以确保二进制应用程序可以运行在任何符合LSB的系统上。</p>
<p>　　LSB推广的二进制可移植性有别于POSIX推广的源码可移植性。前者表示在符合LSB的系统上编译的C程序可以运行在其他任何符合LSB的系统上，这在不同的硬件平台上通常不可行。后者表示C程序代码可以在任何符合POSIX的系统上编译并运行。二进制可移植性是独立软件供应商的Linux应用程序的商业可行性的基本要求。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第2章 基本概念</title>
    <url>/2024/08/12/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-2/</url>
    <content><![CDATA[<p>　　术语<strong>操作系统</strong>通常有2种不同的含义：</p>
<p>　　● 操作系统是由管理计算机资源 (即CPU、RAM和设备)
的核心软件和所有随附的标准软件工具
(例如，命令行解释器、图形用户界面、文件工具和编辑器) 组成的软件包。</p>
<p>　　● 从更狭义的角度，操作系统是管理和分配计算机资源的核心软件。</p>
<p>　　术语<strong>内核</strong>通常是第2种含义的同义词，本书关注的正是此含义。</p>
<p>　　尽管在没有内核的计算机上运行是程序是可能的，但是内核的存在可以大幅度简化程序的开发和使用，并且可以增加程序员可用的功能和灵活度。内核通过提供管理计算机资源的软件层来实现这一点。</p>
<p>　　Linux内核程序通常位于路径<code>/boot/vmlinuz</code>或相似路径下。对于早期UNIX实现，内核程序名是<code>unix</code>。对于之后实现了虚拟内存的UNIX实现，内核程序改名为<code>vmunix</code>。对于Linux，内核程序名与系统名相似，但是用z替换了末尾的x，以表示内核是压缩的可执行文件。</p>
<p>　　现代处理器架构通常会允许CPU在2种模式下工作，即<strong>用户模式</strong>和<strong>内核模式</strong>
(有时也称为<strong>超级用户模式</strong>)。硬件指令允许从当前模式切换到其他模式。相应地，虚拟内存的区域可以被标记为<strong>用户空间</strong>或<strong>内核空间</strong>的一部分。当运行在用户模式下时，CPU只能访问标记为用户空间的内存区域，若试图访问标记为内核空间的内存区域，则会导致硬件异常。当运行在内核模式下时，CPU能访问用户空间和内核空间的内存区域。</p>
<p>　　只有当CPU在内核模式下时，特定操作才能执行，例如，执行<code>halt</code>指令
(停止系统)、访问内存管理硬件和初始化I/O操作。通过这种硬件设计来将操作系统置于内核空间，操作系统实现者能确保用户进程无法访问内核的指令和数据结构或者执行不利于系统运行的操作。</p>
<p>　　<strong>程序</strong>通常以2种形式存在。第1种形式是<span
style="background-color: yellow">源代码</span>，即由一系列C语言等编程语言编写的语句组成的人类可读的文本。源代码必须转换成计算机可以理解的<span
style="background-color: yellow">二进制机器语言指令</span>才能执行，也就是第2种形式。这2种形式通常被认为是等同的，因为编译和链接步骤能将源代码转换为语义相同的二进制机器代码。</p>
<p>　　<strong>过滤器</strong>指从标准输入中读输入并对其进行一些转换，然后将转换后的内容写到标准输出的程序，例如，<code>cat</code>、<code>grep</code>、<code>tr</code>、<code>sort</code>、<code>wc</code>、<code>sed</code>和<code>awk</code>。</p>
<span id="more"></span>
<p>　　C程序可以访问<strong>命令行参数</strong>，即执行程序时命令行中提供的参数。为了访问命令行参数，程序的主函数必须声明为<code>int main(int argc, char *argv[])</code>。参数<code>argc</code>表示命令行参数的数量。参数<code>argv</code>的第1个成员<code>argv[0]</code>指向的字符串是程序名，其他成员指向的字符串就是各个命令行参数。</p>
<p>　　<strong>shell</strong>是专用程序，用于读用户输入的命令并执行合适的程序来响应，这种程序也称为<strong>命令解释程序</strong>。<span
style="background-color: yellow">登录shell</span>是用户第1次登录时为运行shell而创建的进程。</p>
<p>　　shell除了用于交互，还可以用于解释<span
style="background-color: yellow">shell脚本</span>
(即包含shell命令的文本文件)。出于该目的，shell会提供部分通常与编程语言相关的功能，包括变量、循环、条件语句、I/O命令和函数。</p>
<p>　　对于大多数Linux文件系统，文件名最长为255个字符。文件名可以包含除了斜杠<code>/</code>和空字符<code>\0</code>之外的所有字符。在实际中，文件名建议使用字母、数字、英文句号<code>.</code>、下划线<code>_</code>和连字符<code>-</code>的组合，这65个字符组成的集合<code>[-._a-zA-Z0-9]</code>在SUSv3中被称为<strong>可移植文件名字符集</strong>。</p>
<p>　　应该避免在文件名中使用除了可移植文件名字符集之外的字符，因为这些字符在shell、正则表达式或其他上下文中可能有特殊含义。若需要在这些上下文中的文件名使用包含特殊含义的字符，则必须对这些字符进行<strong>转义</strong>，即在每个待转义的字符前面都加上反斜杠<code>\</code>来表示它们不需要解释为特殊含义。在不支持转义的上下文中，包含特殊含义的字符的文件名将不可用。此外，应该避免文件名以连字符<code>-</code>开头，因为这种文件名可能会被shell命令解释为参数。</p>
<p>　　为了执行文件I/O，C程序通常会调用标准库<code>stdio</code>中的函数，包括<code>fopen()</code>、<code>fclose()</code>、<code>scanf()</code>、<code>printf()</code>、<code>fgets()</code>、<code>fputs()</code>。库<code>stdio</code>中的函数是<code>open()</code>、<code>close()</code>、<code>read()</code>、<code>write()</code>等I/O系统调用的包装函数。</p>
<p>　　<strong>进程</strong>是运行中的程序的1个实例。执行程序时，内核会将程序的代码加载到虚拟内存，为程序变量分配空间并设置内核记录数据结构来记录该进程的各种信息
(例如，进程ID、终止状态、用户ID和组ID)。从内核角度，进程是内核必须与之共享各种计算机资源的实体。对于内存等有限资源，内核会先分配部分资源给进程，然后在进程的生命周期中根据进程的请求和整个系统对该资源的需求来调节资源分配。当进程终止时，为该进程分配的所有有限的资源会释放。对于CPU和网络带宽等可再生资源，所有进程必须平等地共享它们。</p>
<p>　　运行中的Linux系统包含大量进程，其中的很多进程都独立于彼此运行。但是，有些进程需要合作才能达到目的，为此，需要保证<strong>进程间通信</strong>和同步操作。</p>
<p>　　从逻辑角度，进程分为4个称为<strong>段</strong>的部分。</p>
<p>　　● <span
style="background-color: yellow">文本</span>段包含程序的指令。</p>
<p>　　● <span
style="background-color: yellow">数据</span>段包含程序所用的静态变量。</p>
<p>　　● <span
style="background-color: yellow">栈</span>段是会随着函数调用和返回而伸缩的区域，用于为局部变量和函数调用链信息分配空间。</p>
<p>　　● <span
style="background-color: yellow">堆</span>段是用于程序动态分配额外空间的区域。</p>
<p>　　进程中有2种重要的时间，即<span
style="background-color: yellow">实际时间</span>和<span
style="background-color: yellow">进程时间</span>。</p>
<p>　　● 实际时间基于某个标准点 (日历时间) 或固定点
(通常是进程生命周期的起点)
测量。在UNXI系统中，日历时间以秒为单位，自1970年1月1日凌晨开始计时
(即<span
style="background-color: yellow">协调世界时</span>)，并且以英国格林威治的经线定义的时区为基准进行协调。这个日期接近UNIX系统的诞生，也称为<strong>纪元</strong>。</p>
<p>　　● 进程时间也称为<span
style="background-color: yellow">CPU时间</span>，是自进程启动以来所有的CPU时间总和。CPU时间可以进一步划分为<span
style="background-color: yellow">系统CPU时间</span>和<span
style="background-color: yellow">用户CPU时间</span>，前者是在内核模式下执行代码所用的时间
(系统调用和其他代表进程执行的内核服务)，后者是在用户模式下执行代码所用的时间
(常规程序代码)。</p>
<p>　　命令<code>time</code>会显示执行管道中的进程所用的实际时间、系统CPU时间和用户CPU时间。</p>
<p>　　在现代UNIX实现中，每个进程可以有多个执行<strong>线程</strong>，线程可以类比为多个共享虚拟内存和大量其他属性的进程。每个线程都会执行相同的程序代码、数据和堆。但是，每个线程都有自己的栈，用于存储局部变量和函数调用链信息。线程可以通过共享的全局变量通信。线程API提供了<strong>互斥锁</strong>和<strong>条件变量</strong>，用于同一进程的线程的通信和同步操作。线程还能通过IPC和同步机制通信。</p>
<p>　　线程的主要优势是易于共享数据，并且某些算法更容易用多线程实现。此外，多线程程序可以透明地利用多处理器硬件上的并行处理的可能性。</p>
<p>　　<strong>伪终端</strong>是1对连接的虚拟设备，即<span
style="background-color: yellow">主设备</span>和<span
style="background-color: yellow">从设备</span>。这对设备提供了IPC通道，以允许双向传输数据。</p>
<p>　　伪终端的关键点在于从设备提供了行为与终端相似的接口，这使得可以将从设备连接到面向终端的程序，然后用另一个连接到主设备的程序来驱动面向终端的程序。驱动程序的输出通过终端驱动程序执行的常规输入处理
(例如，在默认模式下，回车符会映射为换行符)，然后作为输入传递给连接到从设备的面向终端的程序。面向终端的程序写到从设备的所有内容都会
(在经过所有终端输出处理后)
作为输入传递给驱动程序，即驱动程序会执行用户在常规终端上通常执行的功能。</p>
<p>　　伪终端用于各种应用程序，其中最著名的是X
Window系统登录时提供的终端窗口的实现以及<code>telnet</code>和<code>ssh</code>等提供网络登录服务的程序。</p>
<p>　　<span
style="background-color: yellow">实时应用程序</span>是需要及时响应输入的应用程序。通常，这些输入来自于外部传感器或专用设备，而输出则采用控制某些外部硬件的形式。尽管很多实时应用程序需要对输入做出快速响应，但决定性因素是保证触发事件后的特定时间内做出响应。</p>
<p>　　实时响应 (尤其是短时间内)
需要底层操作系统的支持。大多数操作系统没有实时响应的原生支持，因为实时响应的要求于与多用户分时操作系统的要求相冲突。传统UNIX实现并不是实时操作系统，尽管实时变体已经出现。Linux的实时变体也已经出现，而且Linux内核也在向完全支持实时应用程序的方向发展。</p>
<p>　　POSIX.1b定义了大量支持实时应用程序的POSIX.1扩展，包括异步I/O、共享内存、内存映射文件、内存上锁、实时锁、实时定时器、备选调度策略、实时信号、信息队列和信号量。尽管它们并不严格地符号实时，但是大部分UNIX实现都支持部分或全部扩展。</p>
<p>　　类似于其他几个UNIX实现，Linux提供了<code>/proc</code>文件系统，它由挂载在目录<code>/proc</code>的1组目录和文件组成。该文件系统是虚拟文件系统，以文件系统中的文件和目录的形式提供内核数据结构的接口。这为查看和修改各种系统属性提供了1种简单的机制。此外，有1组名称为<code>/proc/PID</code>的目录
(PID即进程ID)，允许查看系统中正在运行的所有进程的信息。</p>
<p>　　<code>/proc</code>文件的内容通常是人类可读的文本形式，并且能被shell脚本解析。程序可以简单地对<code>/proc</code>文件进行打开、读和写操作。在大多数情况下，进程需要拥有权限才能修改<code>/proc</code>目录下的文件的内容。</p>
<h3 id="内核">2.1 内核</h3>
<p>　　内核负责<span
style="background-color: yellow">进程调度</span>、<span
style="background-color: yellow">内存管理</span>、<span
style="background-color: yellow">提供文件系统</span>、<span
style="background-color: yellow">创建和终止进程</span>、<span
style="background-color: yellow">访问设备</span>、<span
style="background-color: yellow">网络</span>和<span
style="background-color: yellow">提供系统调用API</span>。</p>
<p>　　●
计算机有1个或多个用于执行程序指令的中央处理单元。与其他UNIX系统一样，Linux是<strong>抢占式多任务</strong>操作系统。多任务表示多个进程可以同时驻留于内存中，并且都可以使用CPU。抢占式表示内核进程调度程序决定哪些进程使用CPU以及使用时间。</p>
<p>　　●
虽然以10年前的标准，计算机内存是巨大的，但是软件的大小也相应地变大，所以物理内存仍然是内核必须以公平且有效的方式进行共享的有限资源。与大多数现代操作系统一样，Linux使用了虚拟内存。虚拟内存主要有2个优点。首先，进程间以及进程与内核间是隔离的，所以进程无法读取或修改其他进程或内核的虚拟内存。其次，只有进程的一部分需要常驻在内存中，这降低了进程的内存占用
(允许更多进程同时驻留在内存中)，进而提高了CPU利用率。</p>
<p>　　●
内核在磁盘上提供了文件系统，允许对文件进行创建、检索、更新和删除等操作。</p>
<p>　　●
内核可以将新程序加载到内存并提供该程序运行所需的资源。一旦进程运行完成，内核必须确保该进程使用的资源得到释放，以供其他程序使用。</p>
<p>　　● 连接到计算机的设备 (例如，鼠标、键盘、显示器、硬盘和磁带驱动器)
允许计算机与外界进行信息通信以及输入或/和输出。内核为计算机提供了1个接口，该接口标准化和简化了设备的访问，同时也会协调多个进程对同一设备的访问。</p>
<p>　　●
内核会代表用户进程发送和接收网络分组，该过程包括将网络分组路由到目标系统。</p>
<p>　　●
进程通过称为<strong>系统调用</strong>的内核入口点来请求内核执行某些任务。</p>
<p>　　除了以上功能，Linux等多用户操作系统通常会为用户提供<strong>虚拟私有计算机</strong>的抽象，即每个用户都能登录系统，并且使用时很大程度上独立于其他用户。例如，每个用户都用自己的磁盘存储空间
(即<span
style="background-color: yellow">主目录</span>)。此外，用户能执行多个程序，这些程序会共享CPU，每个程序会在自己的虚拟地址空间中执行操作，并且这些程序能独立访问设备和通过网络传输信息。内核会解决访问硬件资源时潜在的冲突，所以用户和进程通常不知道这些冲突。</p>
<p>　　运行中的系统通常会有大量进程。对于单个进程，很多事情异步发生。运行中的进程不知道它何时被挂起以及之后运行的进程，或者它运行完成后接着运行的进程。信号的传递和IPC事件的发生由内核协调，对进程而言，这可能随时发生。很多事情对进程是不可见的。进程并不知道它在RAM中的位置，或者其内存空间的特定部分是在内存中还是在交换空间
(用于补充RAM的磁盘空间保留区域)
中。同样，进程也不知道它访问的文件所处的磁盘驱动位置，进程仅通过文件名来访问文件。进程是独立运行的，进程间无法直接通信。进程无法创建新进程或终止自己。最后，进程无法直接与连接到电脑的I/O设备通信。</p>
<p>　　相比之下，运行中的系统仅有1个内核，内核知道并控制所有事情。内核推动着系统中所有进程的运行。内核决定进程调度以及维护包含所有运行中的进程的信息的数据结构和可以将文件名转换为磁盘上的物理位置的底层数据结构。此外，内核还维护将每个进程的虚拟内存转换为物理内存和交换空间的数据结构。进程间的所有通信通过内核提供的机制完成。为了响应进程的请求，内核会创建新进程和终止已有进程。最后，内核
(尤其是设备驱动程序)
执行所有与I/O设备的通信，根据用户进程的请求传输信息。</p>
<h3 id="shell">2.2 shell</h3>
<p>　　尽管在某些操作系统中，命令解释程序是内核的组成部分，而在UNIX系统中，shell是用户进程。存在多个不同的shell，并且同一计算机上的不同用户可以同时使用不同的shell。随着时间的推移，出现了几个重要的shell：</p>
<p>　　● <span style="background-color: yellow">Bourne shell</span>
(即<code>sh</code>) 是最古老的广泛使用的shell，由Steve
Bourne开发。<code>sh</code>是第7版UNIX的标准shell。<code>sh</code>中包含在很多所有shell中都熟悉的功能，包括I/O重定向、管道、文件名生成
(通配符)、变量、环境变量控制、命令替换、后台命令执行和函数。所有后续的UNIX实现除了包含它们可能提供的任何其他shell，还包含<code>sh</code>。</p>
<p>　　● <span style="background-color: yellow">C shell</span>
(即<code>csh</code>) 由加州大学伯克利分校的Bill
Joy开发。其名称源于该shell的很多流控制结构与C语言中对应的流控制结构相似。<code>csh</code>提供了几个<code>sh</code>所没有的有用的交互功能，包含命令历史、命令行编辑、作业控制和别名。<code>csh</code>与<code>sh</code>不向后兼容。尽管BSD中的标准交互式shell是<code>csh</code>，但是shell脚本通常是为<code>sh</code>编写，以保证可移植到任何UNIX实现。</p>
<p>　　● <span style="background-color: yellow">Korn shell</span>
(即<code>ksh</code>) 由AT&amp;T贝尔实验室的David
Korn开发，作为<code>sh</code>的后继者。除了保证与<code>sh</code>的兼容，<code>ksh</code>还包含与<code>csh</code>类似的交互功能。</p>
<p>　　● <span style="background-color: yellow">Bourne again
shell</span> (即<code>bash</code>)
是GNU项目对<code>sh</code>的重实现。它提供了<code>ksh</code>和<code>csh</code>中类似的交互功能。<code>bash</code>的主要开发者是Brain
Fox和Chet Ramey。<code>bash</code>可能是Linux中使用最广泛的shell
(在Linux中，<code>sh</code>实际是通过<code>bash</code>模拟)。</p>
<p>　　POSIX.2-1992详细说明了shell标准，该标准基于<code>ksh</code>当时的版本。如今，<code>ksh</code>和<code>bash</code>都通过了POSIX认证，两者都提供了很多对标准的扩展，其中的很多扩展存在差异。</p>
<h3 id="用户和组">2.3 用户和组</h3>
<p>　　每个用户都有唯一的<span
style="background-color: yellow">登录名</span> (即用户名)
和对应的数字<span style="background-color: yellow">用户ID</span>
(即UID)。每个用户的用户名和UID都由系统<span
style="background-color: yellow">密码文件</span><code>/etc/passwd</code>中的某行定义，该行包括组ID
(即GID)
字段、主目录字段和登录shell字段。GID字段是用户所属的第1个组的数字GID。主目录字段是用户登录后所在的初始目录。登录shell字段是为解释用户命令而执行的程序的名称。</p>
<p>　　密码文件可能会包含加密后的用户密码。出于安全，密码通常存储在单独的<span
style="background-color: yellow">影子密码文件</span>，只有特权用户才能读。</p>
<p>　　出于管理目的
(特别是控制文件和其他系统资源的访问)，将用户组织成<span
style="background-color: yellow">组</span>很有用。在早期的UNIX实现中，1个用户只能属于1个组。BSD允许1个用户同时属于多个组，这个想法之后被其他UNIX实现和POSIX.1-1990吸收。</p>
<p>　　每个组都由系统<span
style="background-color: yellow">组文件</span><code>/etc/group</code>中的某行定义，该行包括组名称字段、GID字段和用户列表字段。组名称字段是组的唯一名称。GID字段是组ID。用户列表字段是以逗号分隔的组成员的用户名
(组成员的判断基于该字段，而非密码文件中的GID字段)。</p>
<p>　　唯一拥有特权的用户是<span
style="background-color: yellow">超级用户</span>。超级用户的UID是0，用户名通常是root。对于常规UNIX系统，超级用户会绕过系统中的所有权限检测。因此，超级用户可以无视文件的访问权限而直接访问任何文件，也可以给任何用户进程发送信号。</p>
<h3 id="单目录层次结构目录链接和文件">2.4
单目录层次结构、目录、链接和文件</h3>
<p>　　内核维护了单目录层次结构来组织系统中的所有文件
(Windows等操作系统的每个磁盘设备都有自己的目录层次结构)。该层次结构的根基是<strong>根目录</strong>
(即<code>\</code>)。所有文件和目录都是根目录的后代。</p>
<img src="/2024/08/12/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-2/subset_of_the_linux_single_directory_hierarchy.svg" class="" title="subset_of_the_linux_single_directory_hierarchy">
<p>　　在文件系统中，每个文件都有<strong>类型</strong>。表示原始数据文件的类型称为<strong>常规文件</strong>或<strong>纯文本文件</strong>，以区分其他文件类型。这些其他文件类型包括设备、管道、套接字、目录和符号链接。</p>
<p>　　<strong>目录</strong>是特殊文件，其内容形式是文件名表与对应文件的引用。这种
"文件名+指针"
的关联称为<strong>链接</strong>。1个文件可以有多个链接，所以也可以有多个文件名
(在不同或相同目录下)。</p>
<p>　　目录可以同时包含文件和其他目录。目录间的链接构成了如图所示的目录层次结构。</p>
<p>　　每个目录至少包括<code>.</code>和<code>..</code>这2个条目，前者表示到目录自己的链接，后者表示到父目录
(即目录层次结构中该目录的上一级目录)
的链接。除了根目录之外的所有目录都有父目录。对于根目录，条目<code>/..</code>等同于<code>/</code>。</p>
<p>　　类似于普通链接，<strong>符号链接</strong>提供文件的别名。普通链接是目录列表中的
"文件名+指针" 条目，而符号链接是特殊标记文件，包含另一个文件的名称
(符号链接也是目录列表中的 "文件名+指针"
条目，其中指针指向的文件包含另一个文件的名称)。符号链接中的 "另一个文件"
通常称为符号链接的<strong>目标</strong>，通常会说符号链接引用或指向目标文件。当系统调用使用路径名时，大多数情况下，内核会自动<strong>解引用</strong>路径名中的每个符号链接，用它指向的文件名来替换它。若符号链接的目标也是符号链接，则解引用会递归
(内核对解引用的次数进行了限制)。目标文件不存在的符号链接称为<strong>死链接</strong>。此外，普通链接也称为<strong>硬链接</strong>，符号链接也称为<strong>软连接</strong>。</p>
<p>　　<strong>路径名</strong>是以可选的斜杠<code>/</code>开头加上以斜杠分隔的一系列文件名组成的字符串。路径名中的除了最后1个文件名之外的所有文件名都会被识别为目录或指向目录的符号链接。路径名中的最后1个文件名可能会被识别为任何类型的文件
(包括目录)。最后1个斜杠前的所有文件名也称为路径名的<span
style="background-color: yellow">目录</span>部分，最后1个斜杠后的文件名也称为路径名的<span
style="background-color: yellow">文件</span>或<span
style="background-color: yellow">基础</span>部分。</p>
<p>　　路径名的读取顺序是从左到右，每个文件名位于路径名中的前一文件名指定的目录下。字符<code>..</code>可以在路径名中的任何位置使用，表示路径名当前指定位置的父目录。</p>
<p>　　每个进程都有<strong>当前工作目录</strong>，简称为<strong>工作目录</strong>或<strong>当前目录</strong>，即进程在单目录层次结构中的位置。子进程会继承其父进程的工作目录。登录shell的初始当前工作目录为密码文件中对应的主目录字段。shell的工作目录可以用命令<code>cd</code>来修改。</p>
<p>　　可以用<strong>绝对路径</strong>或<strong>相对路径</strong>来描述文件在单目录层次结构中的位置。</p>
<p>　　●
绝对路径以表示根目录的斜杠<code>/</code>开头，例如，<code>/home/mtk/.bashrc</code>、<code>/usr/include</code>和<code>/</code>。</p>
<p>　　●
相对路径表示文件相对进程的工作目录的路径。为了与绝对路径区分，相对路径不以斜杠<code>/</code>开头。对于目录<code>usr</code>，文件<code>types.h</code>的相对路径是<code>include/sys/types.h</code>。对于目录<code>avr</code>，文件<code>.bashrc</code>的相对路径是<code>../mtk/bashrc</code>。</p>
<p>　　每个文件都有1个关联的用户ID和1个关联的组ID，用户ID定义了该文件的所有者，组ID定义了该文件的所属组。文件的所有权用于决定用户对该文件的访问权限。</p>
<p>　　为了控制文件的访问，系统将用户分为3类。第1类用户是文件的所有者，第2类用户的组ID与文件所属组的组ID相同，第3类用户是其他用户。可以为3类用户分别设置3个权限位，读权限位允许读文件，写权限位允许写文件，执行权限位允许执行文件。目录也可以设置这些权限位，其含义略有不同，读权限位允许列出目录的内容
(例如，文件名)，写权限位允许修改目录的内容 (例如，修改文件名)，执行
(也称为搜索) 权限位允许访问目录下的文件 (受限于文件的访问权限)。</p>
<h3 id="文件io模型">2.5 文件I/O模型</h3>
<p>　　UNIX系统的I/O模型的显著特征之一就是I/O<strong>通用性</strong>的概念，即同一系统调用
(例如，<code>open()</code>、<code>read()</code>、<code>write()</code>和<code>close()</code>)可用于执行对所有类型
(包括设备)
的文件的I/O。内核会将应用程序的I/O请求转换为对目标文件或设备执行I/O的文件系统操作或事件驱动程序操作。</p>
<p>　　内核本质上提供了<span
style="background-color: yellow">字节流序列</span>这种文件类型。对于磁盘文件、磁盘和磁带设备，可以通过系统调用<code>lseek()</code>来进行随机访问。</p>
<p>　　很多应用程序和库会将换行符 (ASCII字符的十进制的10)
解释为终止当前行并开始下一行。UNIX系统没有文件结束符，文件的结束通过不返回数据的读来检测。</p>
<p>　　<strong>I/O系统调用</strong>指用文件描述符 (较小的非负整数)
打开文件。文件描述符一般通过调用函数<code>open()</code>获取，该函通过路径名来指定执行I/O操作的文件。</p>
<p>　　通常，当进程被shell启动时，会继承3个已打开的文件描述符
(即描述符0~2)。描述符0是标准输入，进程从其读输入。描述符1是标准输出，进程向其写输出。描述符2是标准错误，进程向其写异常情况的错误信息和通知。对于交互式shell或程序，这3个描述符通常会连接到终端。在库<code>stdio</code>中，这3个描述符分别对应文件流<code>stdin</code>、<code>stdout</code>和<code>stderr</code>。</p>
<h3 id="进程">2.6 进程</h3>
<p>　　每个进程都有唯一的整数<strong>进程标识符</strong>
(即PID)。此外，每个进程还有<strong>父进程标识符</strong>
(即PPID)，表示请求内核创建该进程的进程。</p>
<p>　　进程可以通过系统调用<code>fork()</code>来创建新进程，前者称为<strong>父进程</strong>，后者称为<strong>子进程</strong>。内核通过创建父进程的副本来创建子进程。子进程会继承父进程的数据段、栈段和堆段，子进程之后可以独立地修改这些段。程序在内存中的文本段会被标记为只读，由这2个进程共享。</p>
<p>　　子进程要么执行与父进程相同的代码中的不同函数，要么调用系统调用<code>execve()</code>来加载和执行新程序。系统调用<code>execve()</code>会用基于新程序的代码的文本段、数据段、栈段和堆段来替换已存在的这4个段。</p>
<p>　　C标准库中有几个系统调用<code>execve()</code>的包装函数，这些函数大同小异，并且都以字符串<code>exec</code>开头。之后的内容会将这些函数统称为函数<code>exec()</code>。</p>
<p>　　<strong>守护进程</strong>是特殊进程，其创建方式与普通进程相同，但具有以下特点：</p>
<p>　　●
守护进程的生命周期很长。守护进程通常在系统引导时就会启动，并且会持续到关机。</p>
<p>　　● 守护进程运行在后台，并且没有用于读输入或写输出的控制终端。</p>
<p>　　<code>syslogd</code>和<code>httpd</code>就是守护进程，前者记录系统日志中的信息，后者通过超文本传输协议来提供网页。</p>
<p>　　每个进程都有1个<strong>环境列表</strong>，即<strong>环境变量</strong>的集合。环境变量维护在进程的用户空间内存中。环境变量包含1个名称和1个关联的值。子进程会继承父进程的环境列表，所以环境列表可用于父进程传递信息给子进程。当进程通过函数<code>exec()</code>替换当前正在运行的程序时，新程序要么继承旧程序的环境列表，要么接收作为<code>exec()</code>调用的一部分的新环境列表。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export MYVAR=&#x27;Hello world&#x27;</span><br></pre></td></tr></table></figure>
<p>　　对于大多数shell，环境变量通过命令<code>export</code>来创建。对于<code>csh</code>，环境变量通过命令<code>setenv</code>来创建。</p>
<p>　　C程序可以通过外部变量<code>char **environ</code>来访问环境变量，并且有大量库函数可以用于检索和修改其环境变量的值。</p>
<p>　　环境变量的用途很广。例如，shell定义和使用了大量可以通过脚本或由shell执行的程序访问的环境变量。其中包括环境变量<code>HOME</code>和<code>PATH</code>，前者指定了用户的登录目录的路径，后者指定了shell在查找与用户输入的命令相对应的程序时应搜索的一系列目录。</p>
<p>　　进程可以以2种方法终止。第1种方法是调用系统调用<code>_exit()</code>及其包装函数来请求终止自己。第2种方法是收到信号而终止。进程终止时会生成<strong>终止状态</strong>
(较小的非负整数)，父进程可以调用系统调用<code>wait()</code>来查看子进程的终止状态。当调用系统调用<code>_exit()</code>及其包装函数时，进程会显式地指明自己的终止状态。当收到信号而终止时，进程的终止状态会根据该信号的类型来设置。</p>
<p>　　按照惯例，终止状态为0时表示进程正常终止，终止状态非0时表示出现错误。大部分shell可以通过shell变量<code>$?</code>来获取最后执行的程序的终止状态。</p>
<p>　　每个进程都有多个关联的用户ID和组ID，包括<span
style="background-color: yellow">实际用户ID</span>、<span
style="background-color: yellow">实际组ID</span>、<span
style="background-color: yellow">有效用户ID</span>、<span
style="background-color: yellow">有效组ID</span>和<span
style="background-color: yellow">辅助组ID</span>。</p>
<p>　　●
实际用户ID和实际组ID是进程所属的用户和组的ID。子进程会继承父进程的实际用户ID和实际组ID。登录shell的实际用户ID和实际组ID取自系统密码文件中对应的字段。</p>
<p>　　● 有效用户ID和有效组ID (与辅助组ID一起使用)
用于确定进程对文件和IPC对象等受保护资源的访问权限。进程的有效用户ID和有效组ID通常与其实际用户ID和实际组ID相同。可以通过修改有效用户ID和有效组ID来允许进程获取其他用户或组的特权。</p>
<p>　　●
辅助组ID可能有多个。辅助组ID是进程所属的辅助组的ID。子进程会继承父进程的辅助组ID。登录shell的辅助组ID取自系统组文件。</p>
<p>　　依据传统，在UNIX系统中，有效用户ID为0 (超级用户)
的进程是<strong>特权进程</strong>，此类进程可以绕过内核通常使用的权限限制。相比之下，有效用户ID非0的进程是<strong>非特权进程</strong>，此类进程必须遵守内核的权限限制。特权进程创建的子进程也是特权进程。修改非特权进程的有效用户ID可以将其变为特权进程。</p>
<p>　　从内核2.2开始，Linux将传统上授予超级用户的特权划分为了多个不同的称为<strong>能力</strong>的单元。每个特权操作都与特定的能力关联，进程执行特权操作需要拥有对应的能力。传统的超级用户进程
(有效用户ID为0) 拥有全部能力。</p>
<p>　　在引导系统时，内核会创建特殊进程<code>init</code>，该进程源自文件<code>/sbin/init</code>。系统中的所有进程都是进程<code>init</code>的后代。进程<code>init</code>的进程ID是1，并且拥有超级用户特权。进程<code>init</code>无法被杀死
(超级用户也不能)，只会在关机时终止。进程<code>init</code>的主要任务是创建和监视系统运行所需的一系列进程。</p>
<p>　　通过系统调用<code>strlimit()</code>，进程可以设置其对各种资源的消耗上限。每个这样的<strong>资源限制</strong>都有2个关联的值——软限制和硬限制，前者限制进程可以消耗的资源，后者是前者可以调整的值的上限。非特权进程可以调整某个特定资源的软限制，其值必须在0到对应的硬限制之间
(小于硬限制)。当通过系统调用<code>fork()</code>创建子进程时，子进程会继承父进程的资源限制设置。</p>
<p>　　shell的资源限制可以通过命令<code>ulimit</code>
(<code>csh</code>中的命令<code>limit</code>)
来调整，shell创建的用于执行命令的子进程会继承这些资源限制设置。</p>
<h3 id="内存映射">2.7 内存映射</h3>
<p>　　系统调用<code>mmap()</code>会在调用进程的虚拟地址空间中创建1个新的<strong>内存映射</strong>。内存映射有2种类型——<strong>文件映射</strong>和<strong>匿名映射</strong>。</p>
<p>　　●
文件映射会将1个文件在磁盘上的区域映射到调用进程的虚拟内存。一旦映射，该文件的内容就可以通过对相应的内存区域中的字节的操作来访问。映射的页会按需自动从文件中加载。</p>
<p>　　● 匿名映射没有对应的文件。相反，映射的页会初始化为0。</p>
<p>　　某个进程的映射中的内存可能与其他进程的映射共享。当多个进程映射同一文件的同一区域或子进程继承了父进程的映射时，就会出现这种情况。</p>
<p>　　当多个进程共享同一页时，若映射是私有的，则进程对映射内容的修改对其他进程<span
style="background-color: yellow">不可见</span>，并且这些修改<span
style="background-color: yellow">不会</span>应用到对应的文件；若映射是共享的，则进程对映射内容的修改对其他进程<span
style="background-color: yellow">可见</span>，并且这些修改会应用到对应的文件。</p>
<p>　　内存映射用途广泛，包括通过可执行文件的文本段来初始化进程的文本段、分配新内存
(填充为0)、文件I/O (内存映射I/O) 和IPC (通过共享映射)。</p>
<h3 id="静态库和共享库">2.8 静态库和共享库</h3>
<p>　　<strong>对象库</strong>是包含一系列函数 (通常存在逻辑关联)
编译后的目标代码的文件。将一系列函数放在单个对象库可以简化程序的创建和维护。在现代UNIX系统中，对象库有2种类型——<strong>静态库</strong>
(也称为<strong>归档文件</strong>)
和<strong>共享库</strong>。早期UNIX系统中只有静态库。</p>
<p>　　静态库本质上是已编译的目标模块的结构化包。当需要使用静态库中的某个函数时，会在构建程序的链接命令中指明对应的静态库。在解析完主程序对静态库模块的函数的引用后，链接器会从静态库中提取所需模块的副本，并且将这些副本复制到作为结果的可执行文件。这个过程称为<strong>静态链接</strong>。</p>
<p>　　静态链接有多个缺点。第1个缺点是不同的可执行文件可能都包含同一模块的副本，这会浪费磁盘空间。第2个缺点是多个包含同一模块的程序同时运行时，会产生内存浪费，因为每个程序都需要自己的模块副本驻留在内存中。第3个缺点是修改静态库中的函数后，需要重新编译并更新静态库，所有用到该函数的应用程序都需要再次进行静态链接。</p>
<p>　　共享库正是为了解决静态库的问题而设计。当程序链接了1个共享库后，链接器只会在可执行文件中写1条记录，以指示可执行文件在运行时所需的共享库。在可执行文件的运行过程中，当它加载到内存时，<strong>动态链接器</strong>会保证可执行文件所需的共享库会被找到并加载到内存中，然后执行运行时链接来将可执行文件中的函数调用解析为共享库中对应的声明。在运行时，只需要1份共享库的代码驻留在内存中，所有运行中的程序都能使用该副本。</p>
<p>　　共享库不像静态库那样需要每个程序都包含所需模块的副本，这节省了磁盘空间。此外，在修改共享库中的函数并更新共享库后，现有程序会在下次运行时会自动使用修改后的函数。</p>
<h3 id="ipc和同步">2.9 IPC和同步</h3>
<p>　　可以通过读写磁盘文件的信息来实现IPC。但是，对于很多应用程序，这种方法效率很低而且不灵活。</p>
<p>　　就像所有现代UNIX实现一样，Linux提供了大量IPC机制，包括<span
style="background-color: yellow">信号</span>、<span
style="background-color: yellow">管道</span>、<span
style="background-color: yellow">套接字</span>、<span
style="background-color: yellow">文件上锁</span>、<span
style="background-color: yellow">消息队列</span>、<span
style="background-color: yellow">信号量</span>和<span
style="background-color: yellow">共享内存</span>。</p>
<p>　　● 信号用于指示事件已经发生。</p>
<p>　　● 无名管道 (类似于shell中的操作符<code>|</code>)
和有名管道用于在进程之间传输数据。</p>
<p>　　●
套接字用于在进程之间传输数据，无论这些进程在同一计算机上，还是在通过网络连接的不同计算机上。</p>
<p>　　●
文件上锁允许进程给文件在磁盘上的区域上锁，以防止其他进程读或更新文件内容。</p>
<p>　　● 消息队列用于在进程之间交换消息 (即数据包)。</p>
<p>　　● 信号量用于同步进程的操作。</p>
<p>　　●
共享内存允许多个进程共享同一片内存区域。当进程修改了共享内存的内容后，其他的所有进程都可以立即看到变化。</p>
<p>　　UNIX系统中的IPC机制繁多，并且有些机制在功能上重复，部分原因是受到了各种标准和UNIX系统的不同变体的影响。例如，有名管道和套接字都可以实现同一系统上的不相关进程之间的信息交换。两者共存于现代UNIX系统是因为有名管道来自于System
V，而套接字来自于BSD。</p>
<h3 id="信号">2.10 信号</h3>
<p>　　除了用于IPC，信号通常在其他情况下也会使用。信号经常被描述为
"软件中断"。信号的到达表示某些事件或异常情况已经发生。信号有多种类型，每种类型对应1种事件或情况。每种信号类型唯一的整数标识符，由形如<code>SIGxxxx</code>的符号名定义。</p>
<p>　　信号的来源可以是内核、其他进程 (需要合适的权限)
或进程自己。当<span
style="background-color: yellow">用户在键盘上输入中断字符</span>
(通常是Control-C)、<span
style="background-color: yellow">进程的子进程终止</span>、<span
style="background-color: yellow">进程设置的定时器过期</span>或<span
style="background-color: yellow">进程试图访问非法内存地址</span>时，内核可能会发送信号给进程。</p>
<p>　　在shell中，命令<code>kill</code>可以用于发送信号给进程。系统调用<code>kill()</code>也提供同样的功能。</p>
<p>　　当进程收到信号时，可以<span
style="background-color: yellow">忽略信号</span>、<span
style="background-color: yellow">被信号终止</span>或<span
style="background-color: yellow">被挂起直到收到特殊用途的信号</span>。</p>
<p>　　对于大部分信号类型，程序都可以忽略信号或触发<strong>信号处理程序</strong>，而非执行接收信号的默认操作。信号处理程序是程序员定义的函数，它会在程序收到对应的信号时自动调用。</p>
<p>　　在信号生成到信号接收的这段时间内，该信号对程序来说是<span
style="background-color: yellow">待处理</span>的。通常情况下，若接收程序已经在运行，则会立即收到待处理信号；否则，接收程序在下次运行时会尽快收到待处理信号。但是，可以通过将信号添加到<strong>信号掩码</strong>来阻塞信号。若信号在阻塞期间生成，则该信号会保持待处理状态，直到解除阻塞
(即从信号掩码中移除该信号)。</p>
<h3 id="进程组和shell作业控制">2.11 进程组和shell作业控制</h3>
<p>　　shell执行的程序都会在新进程中启动。例如，shell会创建3个进程来执行以下管道命令
(列出当前工作目录下的文件并按文件大小排序)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l | sort -k5n | less</span><br></pre></td></tr></table></figure>
<p>　　除了<code>sh</code>之外的所有主要shell都提供了称为<strong>作业控制</strong>的交互功能，该功能允许用户同时执行和控制多个命令或管道。在作业控制shell中，管道中的所有进程都放置在1个新的<strong>进程组</strong>或<strong>作业</strong>。对于仅包含1个命令的shell命令行，新进程组仅包含1个新创建的进程。同一进程组中的进程都有相同的整数<strong>进程组标识符</strong>——进程组的<strong>进程组组长</strong>的进程ID。</p>
<p>　　内核允许进程组中的所有成员执行各种操作，尤其是传递信号。作业控制shell使用此功能来允许用户挂起或恢复管道中的所有进程。</p>
<p>　　<strong>会话</strong>是进程组 (或作业)
集合。同一会话中的所有进程都有相同的<strong>会话标识符</strong>。<strong>会话领导</strong>是创建会话的进程，会话ID也就是会话领导的进程ID。会话主要用于作业控制shell。作业控制shell创建的所有进程组都属于同一会话，其会话领导也就是shell。</p>
<p>　　会话通常有1个关联的<strong>控制终端</strong>。当会话领导第1次打开终端设备时，会创建控制终端。对于交互式shell创建的会话，控制终端就是用户登录的终端。1个终端最多只能作为1个会话的控制终端。</p>
<p>　　打开控制终端后，会话领导会成为控制终端的<strong>控制进程</strong>。当控制进程的终端断开连接时
(例如，终端窗口关闭)，控制终端会收到信号<code>SIGHUP</code>。</p>
<p>　　会话总是有1个<strong>前台进程组</strong>
(或<strong>前台作业</strong>)，用于从终端读输入和写输出到终端。当用户在控制终端输入<span
style="background-color: yellow">中断</span> (通常是Control-C) 或<span
style="background-color: yellow">挂起</span> (通常是Control-Z)
字符后，终端驱动程序会发送信号来杀死或挂起前台进程组。会话可以有任意个<strong>后台进程组</strong>
(或<strong>后台作业</strong>)，它们通过与号字符<code>&amp;</code>创建。</p>
<p>　　作业控制shell提供了列出所有作业、发送信号给作业以及将前台作业改为后台作业或将后台作业改为前台作业的命令。</p>
<h3 id="客户端-服务器架构">2.12 客户端-服务器架构</h3>
<p>　　<span
style="background-color: yellow">客户端-服务器应用程序</span>由2个进程组成，即客户端进程和服务器进程。客户端通过发送请求信息给服务器来请求服务器执行某些服务。服务器解释客户端的请求，执行合适的操作，然后发送响应信息给客户端。</p>
<p>　　客户端和服务器可以位于同一计算机，也可以位于通过网络连接的不同计算机。客户端和服务器通过IPC机制通信。</p>
<p>　　有时，客户端和服务器可能会进行请求和响应的扩展对话。</p>
<p>　　通常，客户端应用程序与用户交互，而服务器应用程序提供对某些共享资源的访问。此外，可能出现多个客户端进程的实例与1个或少数几个服务器进程的实例通信的情况。</p>
<p>　　服务器可能会实现多个服务，例如：</p>
<p>　　● 提供对数据库或其他共享信息资源的访问。</p>
<p>　　● 通过网络提供对远程文件的访问。</p>
<p>　　● 封装部分业务逻辑。</p>
<p>　　● 提供对共享硬件资源 (例如，打印机) 的访问。</p>
<p>　　● 提供网页。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第3章 系统编程概念</title>
    <url>/2024/08/30/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-3/</url>
    <content><![CDATA[<p>　　<strong>系统调用</strong>是内核中的受控入口点，允许进程请求内核代表自己执行某些操作
(命令<code>strace</code>可用于追踪程序中的系统调用)。</p>
<p>　　●
系统调用会将处理器状态从用户模式切换到内核模式，以便CPU访问受保护的内核内存。</p>
<p>　　● 系统调用集是固定的，每个系统调用都有唯一的数字标识符
(这些标识符通常对程序不可见，因为程序通过名称来标识系统调用)。</p>
<p>　　● 每个系统调用都可能有参数，指定要从用户空间 (进程的虚拟地址空间)
传输到内核空间的信息，反之亦然。</p>
<p>　　在Linux中，系统调用服务例程的名称通常是<code>sys_xyz()</code>，其中<code>xyz()</code>是对应的系统调用名。</p>
<p>　　<strong>库函数</strong>是构成标准C库的众多函数之一。很多库函数都不会使用系统调用。相反，有些库函数就是系统调用的包装函数，这些库函数提供的接口通常比对应的系统调用提供的接口更易于使用。</p>
<p>　　从C程序角度，调用C库中的包装函数等同于调用对应的系统调用服务例程。在之后的内容，会用诸如
"调用系统调用<code>xyz()</code>" 的措辞表示
"调用系统调用<code>xyz()</code>的包装函数"。</p>
<p>　　各种UNIX实现上有很多标准C库的实现。Linux上最广泛使用的实现是GNU
C库 (即<code>glibc</code>)。GNU C库的主要开发者和维护者最初是Roland
McGrath。如今，这项工作由Ulrich
Drepper接班。Linux上还有其他可用的C库，包括用于嵌入式设备应用程序的内存要求较小的库
(例如，<code>uClibc</code>和<code>diet libc</code>)。</p>
<p>　　在C语言中，术语<strong>左值</strong>指引用存储区域的表达式。最常见的示例就是变量标识符。部分运算符也会生成左值。例如，若<code>p</code>是指向存储区域的指针，则<code>*p</code>就是左值。</p>
<p>　　对于POSIX.1-1990说明的很多函数，POSIX.1-1990要求头文件<code>sys/types.h</code>的引入先于其他与这些函数有关联的头文件。但是，这个要求是多余的，因为当时的大部分UNIX实现都不要求应用程序为这些函数引入此头文件。因此，SUSv1移除了该要求。尽管如此，在开发可移植程序时，尽量将该头文件作为第1批引入的头文件。</p>
<span id="more"></span>
<h3 id="系统调用">3.1 系统调用</h3>
<p>　　从编程角度，调用系统调用与调用C函数极其相似。但是，系统调用的执行包含很多步骤。以x86-32为例，其流程如下：</p>
<p>　　1) 应用程序调用C库中的系统调用包装函数。</p>
<p>　　2)
包装函数必须保证系统调用的所有参数都可用于系统调用陷阱处理例程。这些参数通过栈传递给包装函数，但内核希望这些参数位于特定的寄存器中。包装函数会将这些参数复制到内核指定的寄存器。</p>
<p>　　3)
因为所有系统调用都以相同的方式进入内核，所以内核需要识别系统调用的方法。为了实现这一点，包装函数将系统调用号复制到CPU寄存器<code>%eax</code>。</p>
<p>　　4)
包装函数执行陷阱指令<code>int 0x80</code>，该指令会将处理器从用户模式切换到内核模式并执行系统陷阱向量的位置<code>0x80</code>指向的代码。</p>
<p>　　5) 内核调用例程<code>system_call()</code>
(位于汇编文件<code>arch/i386/entry.S</code>)
来处理陷阱，该处理程序会执行5个步骤。第1步，<span
style="background-color: yellow">将寄存器值保存到内核栈</span>。第2步，<span
style="background-color: yellow">检查系统调用号的有效性</span>。第3步，<span
style="background-color: yellow">调用合适的系统调用服务例程</span>，通过系统调用号索引包含所有系统调用服务例程的表
(对应内核变量<code>sys_call_table</code>)
来查找例程。若系统调用服务例程有参数，则会先验证其有效性。然后，服务例程执行请求的任务
(这些任务可能会涉及根据参数指定的地址修改值或在用户内存和内核内存中传输数据)，最后，服务例程返回结果状态给例程<code>system_call()</code>。第4步，<span
style="background-color: yellow">从内核栈中恢复寄存器值并将系统调用返回值压入栈</span>。第5步，<span
style="background-color: yellow">返回到包装函数，同时处理器切换到用户模式</span>。</p>
<p>　　6)
若系统调用服务例程的返回值表示出错，则包装函数会根据该返回值设置全局变量<code>errno</code>。然后，包装函数返回到调用函数，提供1个整数返回值来指示系统调用是否成功。</p>
<p>　　在Linux中，系统调用服务例程遵循非负返回值表示成功的约定。当出错时，例程会返回负值，该值是<code>errno</code>的某个值的相反数。当返回值为负时，C库中的包装函数会取它的相反数，将结果复制到<code>errno</code>，然后返回-1作为结果，表示出错。</p>
<p>　　非负返回值表示成功的约定基于假设：系统调用服务例程正常运行时不会返回负值。对于少数系统调用服务例程，此假设不成立。一般情况下，这不是问题，因为<code>errno</code>的负值范围不与有效的负返回值重叠。但是，对于系统调用<code>fcntl()</code>的操作<code>F_GETOWN</code>，这个约定会导致问题。</p>
<p>　　较新的x86-32架构实现了指令<code>sysenter</code>，该指令提供了比传统的陷阱指令<code>int 0x80</code>更快速地切换到内核模式的方法。内核2.6和<code>glibc</code>
2.3.2及更高的版本支持该指令。</p>
<img src="/2024/08/30/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-3/steps_in_the_execution_of_a_system_call.svg" class="" title="steps_in_the_execution_of_a_system_call">
<p>　　上图是系统调用<code>execve()</code>的执行步骤。对于运行在x86-32上的Linux，<code>execve()</code>的系统调用号是11
(<code>__NR_execve</code>)。因此，在向量<code>sys_call_table</code>中，条目11包含系统调用服务例程<code>sys_execve()</code>的地址。</p>
<p>　　以系统调用<code>getppid()</code>为例，该系统调用会返回调用进程的父进程的进程ID，对于运行在x86-32上的Linux
2.6.25，1千万次调用大约耗时2.2s。在同样的系统上，1千万次调用简单地返回1个整数的C函数大约耗时0.11s。此外，大多数系统调用的耗时都远高于<code>getppid()</code>的耗时。</p>
<h3 id="gnu-c库">3.2 GNU C库</h3>
<p>　　当需要确定系统上的GNU
C库的版本时，可以在shell中以运行程序的方式运行<code>glibc</code>共享库文件，这会显示大量文本
(包括版本号) ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/lib/libc.so.6</span><br></pre></td></tr></table></figure>
<p>　　在某些Linux分发版中，GNU
C库的路径并非<code>/lib/libc.so.6</code>，可以对动态链接<code>glibc</code>的可执行文件运行程序<code>ldd</code>
(列出动态依赖) 来确定库的位置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldd myprog | grep libc</span><br></pre></td></tr></table></figure>
<p>　　应用程序可以通过2种方法来确定系统中已有的GNU
C库的版本，即判断常量和调用库函数。从2.0版本开始，<code>glibc</code>定义了2个常量
(<code>__GLIBC__</code>和<code>__GLIBC_MINOR__</code>)，可以在编译时进行判断
(<code>#ifdef</code>语句)。例如，对于<code>glibc</code>版本是2.12的系统，这2个常量的值分别是2和12。但是，这种方法不适用于程序运行时的系统和编译时的系统不同的情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gnu/libc-version.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">gnu_get_libc_version</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回null结尾的静态分配的字符串，其中包含GNU C库的版本号 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>gnu_get_libc_version()</code>可以在运行时确定<code>glibc</code>的版本，该函数会返回形如<code>2.12</code>的字符串。</p>
<p>　　此外，函数<code>confstr()</code>也可用于确定<code>glibc</code>的版本，通过该函数检索配置变量<code>_CS_GNU_LIBC_VERSION</code>
(仅限<code>glibc</code>) 的值，会返回形如<code>2.12</code>的字符串。</p>
<h3 id="处理系统调用和库函数中的错误">3.3
处理系统调用和库函数中的错误</h3>
<p>　　几乎所有系统调用和库函数都会返回某种类型的状态值，表示调用是否成功。应<span
style="background-color: yellow">始终</span>检查状态值以确定调用是否成功。若失败，则采取合适的行动
(至少应该显示错误信息，警告发生了意外情况)。</p>
<p>　　少部分系统调用不会失败。例如，<code>getpid()</code>总是会返回进程的进程ID，<code>_exit()</code>总是会终止进程。对于这些系统调用，检查返回值并不是必需的。</p>
<h4 id="处理系统调用错误">3.3.1 处理系统调用错误</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cnt = read(fd, buf, numbytes);</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read was interrupted by a signal\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Some other error occurred */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　每个系统调用的说明都给出了返回值，并且指出了那些值表示出错。返回值-1通常表示出错。当系统调用失败时，会将全局整数变量<code>errno</code>设置为正值，以标识特定的错误。头文件<code>errno.h</code>提供了<code>errno</code>的声明和相关错误号的常量，这些常量名都以<code>E</code>开头。错误相关说明提供了每个系统调用可能的<code>errno</code>值。</p>
<p>　　成功的系统调用和库函数不会将<code>errno</code>置0。但是，SUSv3允许成功的函数调用将<code>errno</code>设置为非0值
(尽管只有少数函数如此)。因此，在检查错误时，应先检查函数返回值是否表示出错，只有返回值表示出错时，才继续检查<code>errno</code>以确定导致错误的原因。</p>
<p>　　<code>getpriority()</code>等少数系统调用在正常运行时也会返回-1。对于这些函数，在调用之前应该先把<code>errno</code>置0，在调用后再进行判断。若调用返回-1并且<code>errno</code>非0，则表示出错。少数相似的库函数也是同理。</p>
<p>　　在调用出错后通常采取的行动是根据<code>errno</code>值打印错误信息。库函数<code>perror()</code>和<code>strerror()</code>正是用于此目的。这2个函数返回的错误信息的语言是系统设置的语言。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>perror()</code>会打印参数<code>msg</code>指向的字符串加上当前<code>errno</code>值对应的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>; <span class="comment">/* 返回errnum对应的字符串 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>strerror()</code>会返回参数<code>errnum</code>中的错误号对应的错误信息。该函数返回的字符串是静态分配的，所以它能被后续的<code>strerror()</code>调用覆盖。</p>
<p>　　若<code>errnum</code>指定的错误号不存在，则函数<code>strerror()</code>返回<code>Unknown error nnn</code>形式的字符串。对于某些实现，函数<code>strerror()</code>在这种情况下会返回<code>NULL</code>。</p>
<h4 id="处理库函数错误">3.3.2 处理库函数错误</h4>
<p>　　各种库函数会返回不同的数据类型和不同的值来表示出错。这里将库函数分为3类：</p>
<p>　　●
第1类库函数返回错误信息的方式与系统调用相同，即返回值为-1并设置<code>errno</code>来表示特定的错误。函数<code>remove()</code>便是其中之一，该函数会删除文件
(使用系统调用<code>unlink()</code>) 或目录
(使用系统调用<code>rmdir()</code>)。这类函数的错误处理与系统调用的错误处理相同。</p>
<p>　　●
第2类函数的错误返回值不是-1，但仍然会设置<code>errno</code>来表示特定的错误情况。函数<code>fopen()</code>便是其中之一，该函数出错时会返回空指针，并且会根据出错的底层系统调用设置<code>errno</code>。函数<code>perror()</code>和<code>strerror()</code>可用于处理此类函数出错。</p>
<p>　　●
第3类函数不使用<code>errno</code>。确定此类函数是否出错及其原因需要基于函数说明。</p>
<h3 id="关于本书中示例程序的说明">3.4 关于本书中示例程序的说明</h3>
<p>　　本书中的大量示例程序依赖命令行选项和参数来决定其行为。</p>
<p>　　传统的UNIX命令行选项由1个连字符<code>-</code>加上1个标识选项的字母和1个可选的参数组成。GNU工具提供的扩展选项语法由2个连字符<code>-</code>加上1个标识选项的字母和1个可选的参数组成。可以通过标准<code>getopt()</code>库函数来解析这些选项。</p>
<p>　　本书中的每个示例程序都提供了简单的帮助工具。如果使用选项<code>--help</code>调用程序，程序会给出命令行选项和参数的语法的相关信息。</p>
<h4 id="常用函数头文件">3.4.1 常用函数头文件</h4>
<p>　　大部分示例程序都引入了包含常用定义的头文件，并且这些程序也会使用1组常用函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* tlpi_hdr.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TLPI_HDR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TLPI_HDR_H           <span class="comment">/* 防止意外的多重引用 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>       <span class="comment">/* 很多程序使用的类型定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>           <span class="comment">/* 标准I/O函数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>          <span class="comment">/* 常用库函数的原型以及常量EXIT_SUCCESS和EXIT_FAILURE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>          <span class="comment">/* 很多系统调用的原型 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>           <span class="comment">/* errno声明和errno常量 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>          <span class="comment">/* 常用字符串处理函数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;get_num.h&quot;</span>         <span class="comment">/* 用于处理数字参数的自定义函数getInt()和getLong()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;error_functions.h&quot;</span> <span class="comment">/* 用于处理错误的自定义函数的声明 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FALSE,</span><br><span class="line">    TRUE</span><br><span class="line">&#125; Boolean;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(m, n) ((m) &lt; (n) ? (m) : (n))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(m, n) ((m) &gt; (n) ? (m) : (n))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>　　几乎本书中的所有示例程序都会使用头文件<code>tlpi_hdr.h</code>。该头文件引入了各种头文件，并且定义了数据类型<code>Boolean</code>和用于计算2个数字的最大值和最小值的宏。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* error_functions.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ERROR_FUNCTIONS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_FUNCTIONS_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errMsg</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="comment">/* 该宏可以保证使用以下函数来终止主函数或其他一些有返回值的函数时，</span></span><br><span class="line"><span class="comment">    gcc -Wall不会提示&quot;control reaches end of non-void function&quot; */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NORETURN __attribute__((__noreturn__))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NORETURN</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span> NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span> NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExitEN</span><span class="params">(<span class="type">int</span> errnum, <span class="type">const</span> <span class="type">char</span> *format, ...)</span> NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span> NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usageErr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span> NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cmdLineErr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span> NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>　　为了简化示例程序中的错误处理，会使用这段代码所示的错误诊断函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errMsg</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExitEN</span><span class="params">(<span class="type">int</span> errnum, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<p>　　这里会使用函数<code>errMsg()</code>、<code>errExit()</code>、<code>err_exit()</code>和<code>errExitEN()</code>诊断系统调用和库函数中的错误。</p>
<p>　　函数<code>errMsg()</code>会在标准错误中打印1条信息
(自动在末尾加上换行符)，其参数列表与函数<code>prtinf()</code>的相同。该函数打印的的字符串是<code>errno</code>当前值对应的错误信息
(其中包含错误名，例如，EPERM)
加上函数<code>strerror()</code>返回的错误描述加上参数指定格式的输出。</p>
<p>　　函数<code>errExit()</code>的用法与函数<code>errMsg()</code>相似，但会终止程序。若环境变量<code>EF_DUMPCORE</code>定义为非空字符串，则该函数会通过<code>abort()</code>终止程序，同时生成内存快照
(与调试程序一起使用)；否则，该函数会通过<code>exit()</code>终止程序。</p>
<p>　　函数<code>err_exit()</code>在功能上与函数<code>errExit()</code>相似，但在2个方面有所不同。首先，函数<code>err_exit()</code>在打印错误信息前不会刷新标准输出。其次，函数<code>err_exit()</code>通过<code>_exit()</code>终止进程，这导致进程终止时不会刷新<code>stdio</code>缓存或调用退出处理程序。</p>
<p>　　函数<code>errExitEN()</code>会打印参数<code>errnum</code>指定的错误号对应的信息
(所以函数以后缀<code>EN</code>结尾)。除此之外，其他方面与函数<code>errExit()</code>相同。</p>
<p>　　不同于传统的UNIX系统调用，POSIX线程函数会返回错误号
(正常运行时返回0)。因此，通常会在使用POSIX线程函数的程序中使用函数<code>errExitEN()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s;</span><br><span class="line">s = pthread_create(&amp;thread, <span class="literal">NULL</span>, func, &amp;arg);</span><br><span class="line"><span class="keyword">if</span> (s)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　可以通过这段代码来确定POSIX线程函数是否出错。不直接使用<code>errno</code>的原因是POSIX线程函数中的<code>errno</code>被重定义为宏，该宏会扩展为返回可修改左值的函数调用，所以每次使用<code>errno</code>都会调用1次函数。</p>
<p>　　对于其他类型错误的诊断，可以使用函数<code>fatal()</code>、<code>usageErr()</code>和<code>cmdLineErr()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usageErr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cmdLineErr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>fatal()</code>用于通用错误的诊断，包括那些不设置<code>errno</code>的库函数，其参数列表与函数<code>prtinf()</code>的相同。该函数会在标准错误中输出格式化的字符串
(自动在末尾加上换行符)，然后像函数<code>errExit()</code>一样终止程序。</p>
<p>　　函数<code>usageErr()</code>用于命令行参数错误的诊断，其参数列表与函数<code>prtinf()</code>的相同。该函数会在标准错误中输出字符串<code>Usage:</code>加上格式化的输出，然后调用<code>exit()</code>来终止程序。</p>
<p>　　函数<code>cmdLineErr()</code>与函数<code>usageErr()</code>相似，但主要用于程序的命令行参数错误的诊断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* error_functions.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;error_functions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ename.c.inc&quot;</span> <span class="comment">/* ename和MAX_ENAME的定义 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line">__attribute__((__noreturn__))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">terminate</span><span class="params">(Boolean useExit3)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *s;</span><br><span class="line">    <span class="comment">/* 若环境变量EF_DUMPCORE定义为非空字符串，则生成内存快照；</span></span><br><span class="line"><span class="comment">    否则，根据useExit3的值调用exit(3)或_exit(2) */</span></span><br><span class="line">    s = getenv(<span class="string">&quot;EF_DUMPCORE&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">NULL</span> &amp;&amp; *s != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (useExit3)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">outputError</span><span class="params">(Boolean useErr, <span class="type">int</span> err, Boolean flushStdout,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 500</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE], userMsg[BUF_SIZE], errText[BUF_SIZE];</span><br><span class="line">    vsnprintf(userMsg, BUF_SIZE, format, ap);</span><br><span class="line">    <span class="keyword">if</span> (useErr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(errText, BUF_SIZE, <span class="string">&quot; [%s %s]&quot;</span>,</span><br><span class="line">                 (err &gt; <span class="number">0</span> &amp;&amp; err &lt;= MAX_ENAME) ? ename[err] : <span class="string">&quot;?UNKNOWN?&quot;</span>, strerror(err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(errText, BUF_SIZE, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;ERROR%s %s\n&quot;</span>, errText, userMsg);</span><br><span class="line">    <span class="keyword">if</span> (flushStdout)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>); <span class="comment">/* 刷新所有待处理的标准输出 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fputs</span>(buf, <span class="built_in">stderr</span>);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>); <span class="comment">/* 防止标准错误是行缓存 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errMsg</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    <span class="type">int</span> savedErrno;</span><br><span class="line">    savedErrno = errno; <span class="comment">/* 防止errno被修改 */</span></span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    outputError(TRUE, errno, TRUE, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    errno = savedErrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    outputError(TRUE, errno, TRUE, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    <span class="built_in">terminate</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    outputError(TRUE, errno, FALSE, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    <span class="built_in">terminate</span>(FALSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExitEN</span><span class="params">(<span class="type">int</span> errnum, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    outputError(TRUE, errnum, TRUE, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    <span class="built_in">terminate</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    outputError(FALSE, <span class="number">0</span>, TRUE, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    <span class="built_in">terminate</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usageErr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>); <span class="comment">/* 刷新所有待处理的标准输出 */</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: &quot;</span>);</span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>); <span class="comment">/* 防止标准错误是行缓存 */</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cmdLineErr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>); <span class="comment">/* 刷新所有待处理的标准输出 */</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Command-line usage error: &quot;</span>);</span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>); <span class="comment">/* 防止标准错误是行缓存 */</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这段代码是之前介绍的错误诊断函数的实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ename.c.inc */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *ename[] = &#123;</span><br><span class="line">    <span class="comment">/* 0 */</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">/* 1 */</span> <span class="string">&quot;EPERM&quot;</span>, <span class="string">&quot;ENOENT&quot;</span>, <span class="string">&quot;ESRCH&quot;</span>, <span class="string">&quot;EINTR&quot;</span>, <span class="string">&quot;EIO&quot;</span>, <span class="string">&quot;ENXIO&quot;</span>, <span class="string">&quot;E2BIG&quot;</span>,</span><br><span class="line">    <span class="comment">/* 8 */</span> <span class="string">&quot;ENOEXEC&quot;</span>, <span class="string">&quot;EBADF&quot;</span>, <span class="string">&quot;ECHILD&quot;</span>, <span class="string">&quot;EAGAIN/EWOULDBLOCK&quot;</span>, <span class="string">&quot;ENOMEM&quot;</span>,</span><br><span class="line">    <span class="comment">/* 13 */</span> <span class="string">&quot;EACCES&quot;</span>, <span class="string">&quot;EFAULT&quot;</span>, <span class="string">&quot;ENOTBLK&quot;</span>, <span class="string">&quot;EBUSY&quot;</span>, <span class="string">&quot;EEXIST&quot;</span>, <span class="string">&quot;EXDEV&quot;</span>,</span><br><span class="line">    <span class="comment">/* 19 */</span> <span class="string">&quot;ENODEV&quot;</span>, <span class="string">&quot;ENOTDIR&quot;</span>, <span class="string">&quot;EISDIR&quot;</span>, <span class="string">&quot;EINVAL&quot;</span>, <span class="string">&quot;ENFILE&quot;</span>, <span class="string">&quot;EMFILE&quot;</span>,</span><br><span class="line">    <span class="comment">/* 25 */</span> <span class="string">&quot;ENOTTY&quot;</span>, <span class="string">&quot;ETXTBSY&quot;</span>, <span class="string">&quot;EFBIG&quot;</span>, <span class="string">&quot;ENOSPC&quot;</span>, <span class="string">&quot;ESPIPE&quot;</span>, <span class="string">&quot;EROFS&quot;</span>,</span><br><span class="line">    <span class="comment">/* 31 */</span> <span class="string">&quot;EMLINK&quot;</span>, <span class="string">&quot;EPIPE&quot;</span>, <span class="string">&quot;EDOM&quot;</span>, <span class="string">&quot;ERANGE&quot;</span>, <span class="string">&quot;EDEADLK/EDEADLOCK&quot;</span>,</span><br><span class="line">    <span class="comment">/* 36 */</span> <span class="string">&quot;ENAMETOOLONG&quot;</span>, <span class="string">&quot;ENOLCK&quot;</span>, <span class="string">&quot;ENOSYS&quot;</span>, <span class="string">&quot;ENOTEMPTY&quot;</span>, <span class="string">&quot;ELOOP&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">/* 42 */</span> <span class="string">&quot;ENOMSG&quot;</span>, <span class="string">&quot;EIDRM&quot;</span>, <span class="string">&quot;ECHRNG&quot;</span>, <span class="string">&quot;EL2NSYNC&quot;</span>, <span class="string">&quot;EL3HLT&quot;</span>, <span class="string">&quot;EL3RST&quot;</span>,</span><br><span class="line">    <span class="comment">/* 48 */</span> <span class="string">&quot;ELNRNG&quot;</span>, <span class="string">&quot;EUNATCH&quot;</span>, <span class="string">&quot;ENOCSI&quot;</span>, <span class="string">&quot;EL2HLT&quot;</span>, <span class="string">&quot;EBADE&quot;</span>, <span class="string">&quot;EBADR&quot;</span>,</span><br><span class="line">    <span class="comment">/* 54 */</span> <span class="string">&quot;EXFULL&quot;</span>, <span class="string">&quot;ENOANO&quot;</span>, <span class="string">&quot;EBADRQC&quot;</span>, <span class="string">&quot;EBADSLT&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;EBFONT&quot;</span>, <span class="string">&quot;ENOSTR&quot;</span>,</span><br><span class="line">    <span class="comment">/* 61 */</span> <span class="string">&quot;ENODATA&quot;</span>, <span class="string">&quot;ETIME&quot;</span>, <span class="string">&quot;ENOSR&quot;</span>, <span class="string">&quot;ENONET&quot;</span>, <span class="string">&quot;ENOPKG&quot;</span>, <span class="string">&quot;EREMOTE&quot;</span>,</span><br><span class="line">    <span class="comment">/* 67 */</span> <span class="string">&quot;ENOLINK&quot;</span>, <span class="string">&quot;EADV&quot;</span>, <span class="string">&quot;ESRMNT&quot;</span>, <span class="string">&quot;ECOMM&quot;</span>, <span class="string">&quot;EPROTO&quot;</span>, <span class="string">&quot;EMULTIHOP&quot;</span>,</span><br><span class="line">    <span class="comment">/* 73 */</span> <span class="string">&quot;EDOTDOT&quot;</span>, <span class="string">&quot;EBADMSG&quot;</span>, <span class="string">&quot;EOVERFLOW&quot;</span>, <span class="string">&quot;ENOTUNIQ&quot;</span>, <span class="string">&quot;EBADFD&quot;</span>,</span><br><span class="line">    <span class="comment">/* 78 */</span> <span class="string">&quot;EREMCHG&quot;</span>, <span class="string">&quot;ELIBACC&quot;</span>, <span class="string">&quot;ELIBBAD&quot;</span>, <span class="string">&quot;ELIBSCN&quot;</span>, <span class="string">&quot;ELIBMAX&quot;</span>,</span><br><span class="line">    <span class="comment">/* 83 */</span> <span class="string">&quot;ELIBEXEC&quot;</span>, <span class="string">&quot;EILSEQ&quot;</span>, <span class="string">&quot;ERESTART&quot;</span>, <span class="string">&quot;ESTRPIPE&quot;</span>, <span class="string">&quot;EUSERS&quot;</span>,</span><br><span class="line">    <span class="comment">/* 88 */</span> <span class="string">&quot;ENOTSOCK&quot;</span>, <span class="string">&quot;EDESTADDRREQ&quot;</span>, <span class="string">&quot;EMSGSIZE&quot;</span>, <span class="string">&quot;EPROTOTYPE&quot;</span>,</span><br><span class="line">    <span class="comment">/* 92 */</span> <span class="string">&quot;ENOPROTOOPT&quot;</span>, <span class="string">&quot;EPROTONOSUPPORT&quot;</span>, <span class="string">&quot;ESOCKTNOSUPPORT&quot;</span>,</span><br><span class="line">    <span class="comment">/* 95 */</span> <span class="string">&quot;EOPNOTSUPP/ENOTSUP&quot;</span>, <span class="string">&quot;EPFNOSUPPORT&quot;</span>, <span class="string">&quot;EAFNOSUPPORT&quot;</span>,</span><br><span class="line">    <span class="comment">/* 98 */</span> <span class="string">&quot;EADDRINUSE&quot;</span>, <span class="string">&quot;EADDRNOTAVAIL&quot;</span>, <span class="string">&quot;ENETDOWN&quot;</span>, <span class="string">&quot;ENETUNREACH&quot;</span>,</span><br><span class="line">    <span class="comment">/* 102 */</span> <span class="string">&quot;ENETRESET&quot;</span>, <span class="string">&quot;ECONNABORTED&quot;</span>, <span class="string">&quot;ECONNRESET&quot;</span>, <span class="string">&quot;ENOBUFS&quot;</span>, <span class="string">&quot;EISCONN&quot;</span>,</span><br><span class="line">    <span class="comment">/* 107 */</span> <span class="string">&quot;ENOTCONN&quot;</span>, <span class="string">&quot;ESHUTDOWN&quot;</span>, <span class="string">&quot;ETOOMANYREFS&quot;</span>, <span class="string">&quot;ETIMEDOUT&quot;</span>,</span><br><span class="line">    <span class="comment">/* 111 */</span> <span class="string">&quot;ECONNREFUSED&quot;</span>, <span class="string">&quot;EHOSTDOWN&quot;</span>, <span class="string">&quot;EHOSTUNREACH&quot;</span>, <span class="string">&quot;EALREADY&quot;</span>,</span><br><span class="line">    <span class="comment">/* 115 */</span> <span class="string">&quot;EINPROGRESS&quot;</span>, <span class="string">&quot;ESTALE&quot;</span>, <span class="string">&quot;EUCLEAN&quot;</span>, <span class="string">&quot;ENOTNAM&quot;</span>, <span class="string">&quot;ENAVAIL&quot;</span>,</span><br><span class="line">    <span class="comment">/* 120 */</span> <span class="string">&quot;EISNAM&quot;</span>, <span class="string">&quot;EREMOTEIO&quot;</span>, <span class="string">&quot;EDQUOT&quot;</span>, <span class="string">&quot;ENOMEDIUM&quot;</span>, <span class="string">&quot;EMEDIUMTYPE&quot;</span>,</span><br><span class="line">    <span class="comment">/* 125 */</span> <span class="string">&quot;ECANCELED&quot;</span>, <span class="string">&quot;ENOKEY&quot;</span>, <span class="string">&quot;EKEYEXPIRED&quot;</span>, <span class="string">&quot;EKEYREVOKED&quot;</span>,</span><br><span class="line">    <span class="comment">/* 129 */</span> <span class="string">&quot;EKEYREJECTED&quot;</span>, <span class="string">&quot;EOWNERDEAD&quot;</span>, <span class="string">&quot;ENOTRECOVERABLE&quot;</span>, <span class="string">&quot;ERFKILL&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ENAME 132</span></span><br></pre></td></tr></table></figure>
<p>　　这段代码是文件<code>error_functions.c</code>中引入的文件<code>ename.c.inc</code>，其中定义了字符串数组<code>ename</code>，该数组中的字符串就是对应的<code>errno</code>值的名称。该文件中的内容仅限于运行在x86-32的Linux
2.6 ，因为不同架构的<code>errno</code>值不同。</p>
<p>　　函数<code>stderror()</code>返回的字符串并未给出错误信息对应的名称，但参考手册中给出的都是错误名。通过数组<code>ename</code>，错误处理函数就可以获取错误号对应的名称。</p>
<p>　　数组<code>ename</code>中有部分空字符串，因为这些字符串对应的错误号未被使用。此外，数组<code>ename</code>中有部分字符串是斜杠<code>/</code>分隔的2个错误名，因为这2个错误名对应的值相同。</p>
<p>　　在数组<code>ename</code>中，<code>EAGAIN</code>和<code>EWOULDBLOCK</code>对应同一值
(SUSv3明确允许这样做，大部分UNIX系统也都是如此)。这2个错误通常由系统调用返回，在这种情况下，系统调用通常被阻塞
(即在完成前必须等待)，但调用函数要求系统调用返回错误，而非阻塞。<code>EAGAIN</code>源自System
V，它是执行I/O、信号量操作、消息队列操作和文件上锁
(<code>fcntl()</code>)
的系统调用返回的错误。<code>EWOULDBLOCK</code>源自BSD，它是文件上锁
(<code>flock()</code>) 和套接字相关的系统调用返回的错误。</p>
<p>　　在SUSv3中，<code>EWOULDBLOCK</code>仅在套接字相关接口中提及。对于这些接口，SUSv3允许非阻塞的系统调用返回<code>EAGAIN</code>和<code>EWOULDBLOCK</code>。对于其他所有非阻塞的系统调用，SUSv3仅指定了<code>EAGAIN</code>。</p>
<h4 id="用于解析数值命令行参数的函数">3.4.2
用于解析数值命令行参数的函数</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* get_num.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GET_NUM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_NUM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GN_NONNEG 01 <span class="comment">/* 值必须大于等于0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GN_GT_0 02   <span class="comment">/* 值必须大于0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 整数默认十进制 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GN_ANY_BASE 0100 <span class="comment">/* 可用于任何情况 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GN_BASE_8 0200   <span class="comment">/* 值以八进制表示 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GN_BASE_16 0400  <span class="comment">/* 值以十六进制表示 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getInt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 将字符串转换为int类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">getLong</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 将字符串转换为long类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>　　头文件<code>get_num.h</code>给出了用于解析数值命令行参数的函数<code>getInt()</code>和<code>getLong()</code>的声明。相比函数<code>atoi()</code>、<code>atol()</code>和<code>strtol()</code>，这2个函数提供了一些基本的数值参数的有效性检查。</p>
<p>　　若参数<code>arg</code>不是有效的整数字符串，则这2个函数会打印错误信息并终止程序。</p>
<p>　　若参数<code>name</code>非空，则它应该包含参数<code>arg</code>的标识字符串，该字符串会作为这2个函数打印的错误信息的一部分。</p>
<p>　　参数<code>flags</code>提供了一些对这2个函数的控制。默认情况下，这2个函数会假定字符串为有符号的十进制整数。通过对任意个<code>GN_</code>开头的常量进行与操作并赋值给参数<code>flags</code>，就能选择转换模式，并且限制范围和正负。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* get_num.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;get_num.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gnFail</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fname, <span class="type">const</span> <span class="type">char</span> *msg, <span class="type">const</span> <span class="type">char</span> *arg, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s error&quot;</span>, fname);</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot; (in %s)&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;: %s\n&quot;</span>, msg);</span><br><span class="line">    <span class="keyword">if</span> (arg != <span class="literal">NULL</span> &amp;&amp; *arg != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot; offending text: %s\n&quot;</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">getNum</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fname, <span class="type">const</span> <span class="type">char</span> *arg, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> res;</span><br><span class="line">    <span class="type">char</span> *endptr;</span><br><span class="line">    <span class="type">int</span> base;</span><br><span class="line">    <span class="keyword">if</span> (arg == <span class="literal">NULL</span> || *arg == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gnFail(fname, <span class="string">&quot;null or empty string&quot;</span>, arg, name);</span><br><span class="line">    &#125;</span><br><span class="line">    base = (flags &amp; GN_ANY_BASE) ? <span class="number">0</span> : (flags &amp; GN_BASE_8) ? <span class="number">8</span></span><br><span class="line">                                   : (flags &amp; GN_BASE_16)  ? <span class="number">16</span></span><br><span class="line">                                                           : <span class="number">10</span>;</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    res = strtol(arg, &amp;endptr, base);</span><br><span class="line">    <span class="keyword">if</span> (errno != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gnFail(fname, <span class="string">&quot;strtol() failed&quot;</span>, arg, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*endptr != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gnFail(fname, <span class="string">&quot;nonnumeric characters&quot;</span>, arg, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; GN_NONNEG) &amp;&amp; res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gnFail(fname, <span class="string">&quot;negative value not allowed&quot;</span>, arg, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; GN_GT_0) &amp;&amp; res &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gnFail(fname, <span class="string">&quot;value must be &gt; 0&quot;</span>, arg, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getInt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> res;</span><br><span class="line">    res = getNum(<span class="string">&quot;getInt&quot;</span>, arg, flags, name);</span><br><span class="line">    <span class="keyword">if</span> (res &gt; INT_MAX || res &lt; INT_MIN)</span><br><span class="line">    &#123;</span><br><span class="line">        gnFail(<span class="string">&quot;getInt&quot;</span>, <span class="string">&quot;integer out of range&quot;</span>, arg, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">getLong</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getNum(<span class="string">&quot;getLong&quot;</span>, arg, flags, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这段代码是函数<code>getInt()</code>和<code>getLong()</code>的实现。</p>
<h3 id="可移植性问题">3.5 可移植性问题</h3>
<p>　　各种标准控制着系统调用和库函数API的行为。部分标准由The Open
Group等标准机构定义，其他标准有历史上2个重要的UNIX实现定义，即BSD和System
V第4版 (和相关的System V接口定义)。</p>
<p>　　在开发可移植应用程序时，可能需要在头文件中仅公开符合特定标准的定义
(例如，常量、函数原型)。为此，在编译时需要定义<strong>功能测试宏</strong>。从实现角度，可以通过判断
(通过<code>#if</code>)
应用程序为这些宏定义的值来决定头文件中的哪些功能可用。</p>
<p>　　第1种定义功能测试宏的方法是在引入头文件前定义宏。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE 1</span></span><br></pre></td></tr></table></figure>
<p>　　第2种定义功能测试宏的方法是对于C编译器使用命令行参数<code>-D</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cc -D_BSD_SOURCE prog.c</span><br></pre></td></tr></table></figure>
<h4 id="功能测试宏">3.5.1 功能测试宏</h4>
<p>　　相关标准详细说明了功能测试宏<code>_POSIX_SOURCE</code>、<code>_POSIX_C_SOURCE</code>和<code>_XOPEN_SOURCE</code>，所以这些宏的使用可以移植到所有支持这些标准的系统。</p>
<p>　　● 若定义了宏<code>_POSIX_SOURCE</code>
(无论什么值)，则符合POSIX.1-1990和ISO C (1990)
的定义会公开。该宏现已被宏<code>_POSIX_C_SOURCE</code>取代。</p>
<p>　　●
若宏<code>_POSIX_C_SOURCE</code>定义为值1，则其功能与<code>_POSIX_SOURCE</code>相同；若定义的值大于等于199309，则还会公开符合POSIX.1b
(实时) 的定义；若定义的值大于等于199506，则还会公开符合POSIX.1c (线程)
的定义；若定义的值大于等于200112，则还会公开符合POSIX.1-2001基础规范
(不包含XSI扩展) 的定义
(在版本2.3.3前，<code>glibc</code>的头文件会无视这种情况)；若定义的值大于等于200809，则还会公开符合POSIX.1-2008基础规范的定义
(在版本2.10前，<code>glibc</code>的头文件会无视这种情况)。</p>
<p>　　● 若定义了宏<code>_XOPEN_SOURCE</code>
(无论什么值)，则会公开符合POSIX.1、POSIX.2和X/Open (XPG4)
的定义；若定义的值大于等于500，则还会公开符合SUSv2 (UNIX 98和XPG5)
扩展的定义；若定义的值大于等于600，则还会公开符合SUSv3 XSI (UNIX 03)
扩展和C99扩展的定义
(在版本2.2前，<code>glibc</code>的头文件会无视这种情况)；若定义的值大于等于700，则还会公开符合SUSv4扩展的定义
(在版本2.10前，<code>glibc</code>的头文件会无视这种情况)。值500、600和700源于SUSv2、SUSv3和SUSv4分别是X/Open规范的第5~7期。</p>
<p>　　功能测试宏<code>_BSD_SOURCE</code>、<code>_SVID_SOURCE</code>和<code>_GNU_SOURCE</code>仅适用于<code>glibc</code>。</p>
<p>　　● 若定义了宏<code>_BSD_SOURCE</code>
(无论什么值)，则会公开BSD定义，而且也会将宏<code>_POSIX_C_SOURCE</code>定义为值199506。</p>
<p>　　● 若定义了宏<code>_SVID_SOURCE</code>
(无论什么值)，则会公开System V接口定义中的定义。</p>
<p>　　● 若定义了宏<code>_GNU_SOURCE</code>
(无论什么值)，则会公开通过设置所有上述宏而提供的定义和各种GNU扩展的定义。</p>
<p>　　当调用GNU
C编译器时，若没有使用特殊选项，则会自动设宏<code>_POSIX_SOURCE</code>、<code>_POSIX_C_SOURCE</code>
(若<code>glibc</code>的版本小于2.4，则设置为值199506；若<code>glibc</code>的版本在2.5到2.9之间，则设置为值200112；否则，设置为值200809)、<code>_BSD_SOURCE</code>和<code>_SVID_SOURCE</code>。</p>
<p>　　若定义上述宏之一或以标准模式之一调用编译器
(例如，<code>cc -ansi</code>或<code>cc -std=c99</code>)，则只有定义的宏会生效。但是，存在1个例外，若未定义宏<code>_POSIX_C_SOURCE</code>，并且编译器未以其标准模式之一调用，则该宏会自动定义
(若<code>glibc</code>的版本小于2.4，则设置为值199506；若<code>glibc</code>的版本在2.5到2.9之间，则设置为值200112；否则，设置为值200809)。头文件<code>features.h</code>提供了上述宏的更多信息。</p>
<p>　　可以定义多个功能测试宏。例如，使用如下命令来显式设置默认宏：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cc -D_POSIX_SOURCE -D_POSIX_C_SOURCE=199506 \ -D_BSD_SOURCE -D_SVID_SOURCE prog.c</span><br></pre></td></tr></table></figure>
<p>　　POSIX.1-2001详细说明了宏<code>_POSIX_C_SOURCE</code>
，并且要求定义为值200112。SUSv3详细说明了宏<code>_XOPEN_SOURCE</code>，并且要求定义为值600。POSIX.1-2008和SUSv4与之类似，要求将这2个宏分别定义为值200809和700。</p>
<p>　　SUSv3要求将宏<code>_XOPEN_SOURCE</code>定义为值600时，应该提供将宏<code>_POSIX_C_SOURCE</code>定义为值200112时提供的所有功能。SUSv4与之类似。</p>
<h4 id="系统数据类型">3.5.2 系统数据类型</h4>
<p>　　为了避免可移植性问题，SUSv3详细说明了各种标准系统数据类型，并且要求UNIX实现合适地定义和使用这些类型。</p>
<p>　　标准系统数据类型都通过功能<code>typedef</code>定义，并且其名称几乎都以<code>_t</code>结尾。大部分标准系统数据类型都声明在头<code>sys/types.h</code>中，少部分声明在其他头文件中。</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 28%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr>
<th>数据类型</th>
<th>SUSv3类型要求</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>blkcnt_t</code></td>
<td>有符号整数</td>
<td>文件块计数</td>
</tr>
<tr>
<td><code>blksize_t</code></td>
<td>有符号整数</td>
<td>文件块大小</td>
</tr>
<tr>
<td><code>cc_t</code></td>
<td>无符号整数</td>
<td>终端特殊字符</td>
</tr>
<tr>
<td><code>clock_t</code></td>
<td>整数或实浮点数</td>
<td>时钟节拍的系统时间</td>
</tr>
<tr>
<td><code>clockid_t</code></td>
<td>算术类型</td>
<td>POSIX.1b时钟和定时器函数的时钟标识符</td>
</tr>
<tr>
<td><code>comp_t</code></td>
<td>未提及</td>
<td>压缩时钟节拍</td>
</tr>
<tr>
<td><code>dev_t</code></td>
<td>算术类型</td>
<td>设备号 (包括主编号和次编号)</td>
</tr>
<tr>
<td><code>DIR</code></td>
<td>无要求</td>
<td>目录流</td>
</tr>
<tr>
<td><code>fd_set</code></td>
<td>结构体</td>
<td>函数<code>select()</code>的文件描述符集</td>
</tr>
<tr>
<td><code>fsblkcnt_t</code></td>
<td>无符号整数</td>
<td>文件系统块计数</td>
</tr>
<tr>
<td><code>fsfilcnt_t</code></td>
<td>无符号整数</td>
<td>文件计数</td>
</tr>
<tr>
<td><code>gid_t</code></td>
<td>整数</td>
<td>数字组标识符</td>
</tr>
<tr>
<td><code>id_t</code></td>
<td>整数</td>
<td>存放标识符的通用类型，足以容纳<code>pid_t</code>、<code>uid_t</code>和<code>gid_t</code></td>
</tr>
<tr>
<td><code>in_addr_t</code></td>
<td>32位无符号整数</td>
<td>IPv4地址</td>
</tr>
<tr>
<td><code>in_port_t</code></td>
<td>16位无符号整数</td>
<td>IP端口号</td>
</tr>
<tr>
<td><code>ino_t</code></td>
<td>无符号整数</td>
<td>文件i-node号</td>
</tr>
<tr>
<td><code>key_t</code></td>
<td>算术类型</td>
<td>System V IPC密钥</td>
</tr>
<tr>
<td><code>mode_t</code></td>
<td>整数</td>
<td>文件权限和类型</td>
</tr>
<tr>
<td><code>mqd_t</code></td>
<td>除了数组之外的类型</td>
<td>POSIX消息队列描述符</td>
</tr>
<tr>
<td><code>msglen_t</code></td>
<td>无符号整数</td>
<td>System V消息队列允许的字节数</td>
</tr>
<tr>
<td><code>msgqnum_t</code></td>
<td>无符号整数</td>
<td>System V消息队列中的消息数</td>
</tr>
<tr>
<td><code>nfds_t</code></td>
<td>无符号整数</td>
<td>函数<code>poll()</code>的文件描述符数</td>
</tr>
<tr>
<td><code>nlink_t</code></td>
<td>整数</td>
<td>文件的硬链接数</td>
</tr>
<tr>
<td><code>off_t</code></td>
<td>有符号整数</td>
<td>文件偏移或大小</td>
</tr>
<tr>
<td><code>pid_t</code></td>
<td>有符号整数</td>
<td>进程ID、进程组ID和会话ID</td>
</tr>
<tr>
<td><code>ptrdiff_t</code></td>
<td>有符号整数</td>
<td>2个指针值之间的差值</td>
</tr>
<tr>
<td><code>rlim_t</code></td>
<td>无符号整数</td>
<td>资源限制</td>
</tr>
<tr>
<td><code>sa_family_t</code></td>
<td>无符号整数</td>
<td>套接字地址族</td>
</tr>
<tr>
<td><code>shmatt_t</code></td>
<td>无符号整数</td>
<td>System V共享内存段的相关进程计数</td>
</tr>
<tr>
<td><code>sig_atomic_t</code></td>
<td>整数</td>
<td>可原子访问的数据类型</td>
</tr>
<tr>
<td><code>siginfo_t</code></td>
<td>结构体</td>
<td>信号源的信息</td>
</tr>
<tr>
<td><code>sigset_t</code></td>
<td>整数或结构体</td>
<td>信号集</td>
</tr>
<tr>
<td><code>size_t</code></td>
<td>无符号整数</td>
<td>对象的大小 (以字节为单位)</td>
</tr>
<tr>
<td><code>socklen_t</code></td>
<td>至少32位的整数</td>
<td>套接字地址结构体的大小 (以字节为单位)</td>
</tr>
<tr>
<td><code>speed_t</code></td>
<td>无符号整数</td>
<td>终端行速度</td>
</tr>
<tr>
<td><code>ssize_t</code></td>
<td>有符号整数</td>
<td>字节计数或错误指示 (负值)</td>
</tr>
<tr>
<td><code>stack_t</code></td>
<td>结构体</td>
<td>备用信号栈的描述</td>
</tr>
<tr>
<td><code>suseconds_t</code></td>
<td>[-1, 1000000] 内的有符号整数</td>
<td>微秒时间间隔</td>
</tr>
<tr>
<td><code>tcflag_t</code></td>
<td>无符号整数</td>
<td>终止模式标志位掩码</td>
</tr>
<tr>
<td><code>time_t</code></td>
<td>整数或实浮点数</td>
<td>自纪元以来的日历时间 (以秒为单位)</td>
</tr>
<tr>
<td><code>timer_t</code></td>
<td>算术类型</td>
<td>POSIX.1b间隔计时器函数的计时器标识符</td>
</tr>
<tr>
<td><code>uid_t</code></td>
<td>整数</td>
<td>数字用户标识符</td>
</tr>
</tbody>
</table>
<p>　　SUSv3要求某些系统数据类型为算术类型，即整数或浮点数。</p>
<p>　　当打印数值系统数据类型时，必须保证在调用函数<code>printf()</code>时不要出现<span
style="background-color: yellow">表示依赖</span>
(C的参数提升规则会将<code>short</code>转换为<code>int</code>
，而<code>int</code>和<code>long</code>不变)。函数<code>printf()</code>无法在运行时确定参数的类型，所以调用时必须显式地提供<code>%d</code>或<code>%ld</code>等格式化字符串。常用的解决方法是将系统数据类型转换为<code>long</code>并在调用<code>printf()</code>时使用格式化字符串<code>%ld</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> mypid;</span><br><span class="line">mypid = getpid();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My PID is %ld\n&quot;</span>, (<span class="type">long</span>)mypid);</span><br></pre></td></tr></table></figure>
<p>　　这种解决方法有1个例外。数据类型<code>off_t</code>在某些编译环境中的长度与<code>long long</code>相同，所以需要将它转换为<code>long long</code>并使用格式化字符串<code>%lld</code>。</p>
<p>　　C99标准为函数<code>printf()</code>定义了格式化字符串<code>%zd</code>和<code>%jd</code>，前者对应类型<code>size_t</code>和<code>sszie_t</code>，后者对应足以表示任何类型的整数的类型<code>intmax_t</code>
(或<code>uintmax_t</code>)。但是，并非所有UNIX实现都使用<code>glibc</code>，所以应该避免使用这些格式化字符串。</p>
<h4 id="其他可移植性问题">3.5.3 其他可移植性问题</h4>
<p>　　每个UNIX实现都给出了用于系统调用和库函数的大量标准结构体。这里以结构体<code>sembuf</code>
(用于表示系统调用<code>semop()</code>执行的信号量操作) 为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> sem_num; <span class="comment">/* 信号量号 */</span></span><br><span class="line">    <span class="type">short</span> sem_op;           <span class="comment">/* 执行的操作 */</span></span><br><span class="line">    <span class="type">short</span> sem_flg;          <span class="comment">/* 操作标志 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　尽管SUSv3详细说明了<code>sembuf</code>等结构体，但通常不会指定这些结构体中的字段定义顺序。在某些情况下，这些结构体可能会包含额外的特定于某些UNIX实现的字段。</p>
<p>　　因此，为了保证可移植性，应使用如下方法初始化结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">s</span>;</span></span><br><span class="line">s.sem_num = <span class="number">3</span>;</span><br><span class="line">s.sem_op = <span class="number">-1</span>;</span><br><span class="line">s.sem_flg = SEM_UNDO;</span><br></pre></td></tr></table></figure>
<p>　　若使用了C99，则可以使用C99的新语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">s</span> =</span> &#123;.sem_num = <span class="number">3</span>, .sem_op = <span class="number">-1</span>, .sem_flg = SEM_UNDO&#125;;</span><br></pre></td></tr></table></figure>
<p>　　有时，并非所有UNIX实现都定义了某个宏。例如，用于检查子进程是否生成了内存快照的宏<code>WCOREDUMP</code>在大部分UNIX实现中都可用，但SUSv3并未说明该宏。因此，该宏并不适用于所有UNIX实现。为了保证可移植性，可以使用<code>#ifdef</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WCOREDUMP</span></span><br><span class="line"><span class="comment">/* 使用宏WCOREDUMP */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>　　此外，为系统调用和库文件提供原型的头文件可能因UNIX实现而异。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第4章 文件I/O：通用I/O模型</title>
    <url>/2024/09/16/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-4/</url>
    <content><![CDATA[<p>　　所有执行I/O的系统调用都通过<strong>文件描述符</strong>
(通常是较小的非负整数)
打开文件。文件描述符用于引用所有类型的打开的文件，包括无名管道、有名管道、套接字、终端、设备和常规文件。每个进程都有自己的文件描述符集。</p>
<table>
<thead>
<tr>
<th>文件描述符</th>
<th>目的</th>
<th>POSIX名称</th>
<th><code>stdio</code>流</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>标准输入</td>
<td><code>STDIN_FILENO</code></td>
<td><code>stdin</code></td>
</tr>
<tr>
<td>1</td>
<td>标准输出</td>
<td><code>STDOUT_FILENO</code></td>
<td><code>stdout</code></td>
</tr>
<tr>
<td>2</td>
<td>标准错误</td>
<td><code>STDERR_FILENO</code></td>
<td><code>stderr</code></td>
</tr>
</tbody>
</table>
<p>　　按照惯例，大多数程序都期望能够使用3个标准文件描述符
(即文件描述符0~2)。程序会继承打开它的shell的文件描述符，而shell通常在这3个文件描述符打开的情况下运行。对于交互性shell，这3个文件描述符通常指运行shell的终端。若在命令行中指定了I/O重定向，则shell会保证在启动程序前就适当地修改文件描述符。</p>
<p>　　当在程序中引用标准文件描述符时，可以直接使用数字0~2，更好的方法是使用头文件<code>unistd.h</code>中定义的POSIX标准名。</p>
<p>　　变量<code>stdin</code>、<code>stdout</code>和<code>stderr</code>初始时引用进程的标准输入、标准输出和标准错误，但可以使用库函数<code>freopen()</code>来让它们引用其他文件。作为其操作的一部分，<code>freopen()</code>可能改变重新打开的流的底层描述符。例如，对<code>stdout</code>使用<code>freopen()</code>后，无法保证其底层描述符一定是1。</p>
<p>　　以下是4个重要的执行文件I/O的系统调用：</p>
<p>　　●
<code>fd = open(pathname, flags, mode)</code>会打开参数<code>pathname</code>对应的文件，然后返回打开的文件描述符。若文件不存在，则<code>open()</code>可能会创建
(根据参数<code>flags</code>的值)。参数<code>flags</code>还指定打开文件是为了读或/和写。参数<code>mode</code>指定<code>open()</code>创建的文件的访问权限，若此次调用<code>open()</code>不会创建文件，则该参数会被忽略。</p>
<p>　　●
<code>numread = read(fd, buffer, count)</code>会从参数<code>fd</code>引用的打开的文件中读最多<code>count</code>字节，然后将这些字节存储在<code>buffer</code>中。<code>read()</code>会返回实际读取的字节数。若文件中没有可读的字节
(即遇到了文件结尾)，则<code>read()</code>会返回0。</p>
<p>　　●
<code>numwritten = write(fd, buffer, count)</code>会从<code>buffer</code>中写最多<code>count</code>字节到参数<code>fd</code>引用的打开的文件。<code>write()</code>会返回实际写入的字节数
(不会大于<code>count</code>)。</p>
<p>　　●
<code>status = close(fd)</code>会释放参数<code>fd</code>及其相关内核资源。</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* copy.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUF_SIZE <span class="comment">/* 允许用命令行参数cc -D覆盖定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> inputFd, outputFd, openFlags;</span><br><span class="line">    <span class="type">mode_t</span> filePerms;</span><br><span class="line">    <span class="type">ssize_t</span> numRead;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s old-file new-file\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开输入和输出文件 */</span></span><br><span class="line">    inputFd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (inputFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;opening file %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    openFlags = O_CREAT | O_WRONLY | O_TRUNC;</span><br><span class="line">    filePerms = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP |</span><br><span class="line">                S_IROTH | S_IWOTH; <span class="comment">/* rw-rw-rw- */</span></span><br><span class="line">    outputFd = open(argv[<span class="number">2</span>], openFlags, filePerms);</span><br><span class="line">    <span class="keyword">if</span> (outputFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;opening file %s&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 传输数据，直到遇到输入结束或出错 */</span></span><br><span class="line">    <span class="keyword">while</span> ((numRead = read(inputFd, buf, BUF_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (write(outputFd, buf, numRead) != numRead)</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;couldn&#x27;t write whole buffer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (close(inputFd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close input&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (close(outputFd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close output&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是包含上述4个系统调用的用法的示例代码，其功能与命令<code>cp</code>的相同，会复制第1个命令行参数指定的文件中的内容到第2个命令行参数指定的文件。用法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./copy oldfile newfile</span><br></pre></td></tr></table></figure>
<p>　　由于I/O通用性，上述4个系统调用可以对所有类型的文件执行I/O。因此，仅使用这些系统调用的程序也能作用于所有类型的文件。</p>
<p>　　为了实现I/O通用性，必须保证所有文件系统和设备驱动程序都实现了相同的I/O系统调用集。因为特定于文件系统或设备的细节都是在内核中处理，所以在开发应用程序时通常可以忽略特定于设备的因素。若需要访问特定于文件系统或设备的功能，可以使用通用系统调用<code>ioctl()</code>，该系统调用会提供I/O通用模型之外的功能的接口。</p>
<h3 id="打开文件">4.1 打开文件</h3>
<p>　　系统调用<code>open()</code>会打开已存在的文件或创建新文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, ... <span class="comment">/* mode_t mode */</span>)</span>; <span class="comment">/* 成功则返回文件描述符，出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　参数<code>pathname</code>标识打开的文件
(若它是符号链接，则会解引用)。若<code>open()</code>正常运行，则返回文件描述符；若出错，则返回-1并设置<code>errno</code>。</p>
<table>
<thead>
<tr>
<th>访问模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O_RDONLY</code></td>
<td>以只读模式打开文件</td>
</tr>
<tr>
<td><code>O_WRONLY</code></td>
<td>以只写模式打开文件</td>
</tr>
<tr>
<td><code>O_RDWR</code></td>
<td>以读写模式打开文件</td>
</tr>
</tbody>
</table>
<p>　　参数<code>flags</code>是位掩码，可用于指定文件访问模式。早期UNIX实现直接使用数字0~2表示访问模式。大多数现代UNIX实现都会将这些访问模式定义为这些值。因此，<code>O_RDWR</code>并不等价于<code>O_RDONLY | O_WRONLY</code>，后者会被认为是逻辑错误。</p>
<p>　　当<code>open()</code>用于创建新文件时，位掩码参数<code>mode</code>会指定新创建的文件的访问权限。若调用<code>open()</code>时不将参数<code>flags</code>指定为<code>O_CREAT</code>，则<code>mode</code>会被忽略。</p>
<p>　　实际上，<code>open()</code>创建的新文件的权限并非仅取决于参数<code>mode</code>，还取决于父目录的进程umask和
(可选的) 默认访问控制列表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 以只读模式打开文件 */</span></span><br><span class="line">fd = open(<span class="string">&quot;startup&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以读写模式打开已存在文件或创建新文件，截断为0字节；</span></span><br><span class="line"><span class="comment">拥有者对文件有读写权限，其他用户没有任何访问权限 */</span></span><br><span class="line">fd = open(<span class="string">&quot;myfile&quot;</span>, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以只写模式打开已存在文件或创建新文件；</span></span><br><span class="line"><span class="comment">写入的数据位于文件结尾 */</span></span><br><span class="line">fd = open(<span class="string">&quot;w.log&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC | O_APPEND,</span><br><span class="line">          S_IRUSR | S_IWUSR);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这段代码是<code>open()</code>的用法示例，这里使用了参数<code>flags</code>。</p>
<p>　　SUSv3要求<code>open()</code>正常运行时返回的文件描述符是进程未使用的编号最小的描述符，该功能可用于通过特定的文件描述符打开文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (close(STDIN_FILENO) == <span class="number">-1</span>) <span class="comment">/* 关闭文件描述符0 */</span></span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fd = open(pathname, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这段代码中，因为文件描述符0未被使用，所以<code>open()</code>用该描述符打开文件。</p>
<h4 id="参数flags">4.1.1 参数<code>flags</code></h4>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 74%" />
<col style="width: 8%" />
</colgroup>
<thead>
<tr>
<th>标志</th>
<th>目的</th>
<th>SUS版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O_RDONLY</code></td>
<td>以只读模式打开</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_WRONLY</code></td>
<td>以只写模式打开</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_RDWR</code></td>
<td>以读写模式打开</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_CLOEXEC</code></td>
<td>设置close-on-exec标志 (Linux 2.6.23及以上)</td>
<td>SUSv4</td>
</tr>
<tr>
<td><code>O_CREAT</code></td>
<td>若文件不存在，则创建文件</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_DIRECT</code></td>
<td>文件I/O绕过缓冲区</td>
<td></td>
</tr>
<tr>
<td><code>O_DIRECTORY</code></td>
<td>若<code>pathname</code>不是目录，则失败</td>
<td>SUSv4</td>
</tr>
<tr>
<td><code>O_EXCL</code></td>
<td>与<code>O_CREAT</code>一起使用时会显式地创建文件</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_LARGEFILE</code></td>
<td>用于在32位系统中打开大文件</td>
<td></td>
</tr>
<tr>
<td><code>O_NOATIME</code></td>
<td>调用<code>read()</code>时不更新文件的最后访问时间 (Linux
2.6.8及以上)</td>
<td></td>
</tr>
<tr>
<td><code>O_NOCTTY</code></td>
<td>不会将<code>pathname</code>解释为终端</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_NOFOLLOW</code></td>
<td>不会对符号链接进行解引用</td>
<td>SUSv4</td>
</tr>
<tr>
<td><code>O_TRUNC</code></td>
<td>将现有文件截断为0字节</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_APPEND</code></td>
<td>总是在文件结尾写数据</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_ASYNC</code></td>
<td>当I/O可能时，生成信号</td>
<td></td>
</tr>
<tr>
<td><code>O_DSYNC</code></td>
<td>提供同步的I/O数据完整性</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_NONBLOCK</code></td>
<td>以非阻塞模式打开</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_SYNC</code></td>
<td>使文件写同步</td>
<td>SUSv3</td>
</tr>
</tbody>
</table>
<p>　　这是参数<code>flags</code>支持的所有标志常量。这些标志常量可以分为3类，即<span
style="background-color: yellow">文件访问模式标志</span>、<span
style="background-color: yellow">文件创建标志</span>和<span
style="background-color: yellow">打开文件状态标志</span> (也称为<span
style="background-color: yellow">文件状态标志</span>)。</p>
<p>　　●
文件访问模式标志是表中的第1~3行。这些标志可以通过系统调用<code>fcntl()</code>的操作<code>F_GETFL</code>来检索。</p>
<p>　　●
文件创建标志是表中的第4~13行，控制着<code>open()</code>的行为以及后续的I/O操作。这些标志无法检索或修改。</p>
<p>　　●
打开文件状态标志是第14~18行。这些标志可以通过<code>fcntl()</code>的操作<code>F_GETFL</code>和<code>F_SETFL</code>来检索和修改。</p>
<p>　　以下是这18个标志常量的详细信息：</p>
<p>　　● <code>O_APPEND</code>表示写入的数据总是在文件结尾。</p>
<p>　　●
<code>O_ASYNC</code>表示可以对<code>open()</code>返回的文件描述符进行I/O时，生成信号，这个功能称为<strong>信号驱动I/O</strong>。该功能仅适用于特定的文件类型，例如，终端、有名管道和套接字。SUSv3并未说明该标志，但在大多数UNIX实现中都可以找到该标志
(或更早的类似的标志<code>FASYNC</code>)。对于Linux，在调用<code>open()</code>时指定<code>O_ASYNC</code>无效。为了启用信号驱动I/O，必须通过<code>fcntl()</code>的操作<code>F_SETFL</code>来设置该标志
(部分UNIX实现也是如此)。</p>
<p>　　● <code>O_CLOEXEC</code>表示启用新文件描述符的close-on-exec标志
(即<code>FD_CLOEXEC</code>)，而无需通过<code>fcntl()</code>的操作<code>F_GETFL</code>。此外，这样也避免了多线程程序中的竞争。</p>
<p>　　●
<code>O_CREAT</code>表示若文件不存在，则创建新的空文件。若指定了该标志，则必须设置参数<code>mode</code>；否则，新文件的访问权限会被设置为随机权限。</p>
<p>　　●
<code>O_DIRECT</code>表示允许文件I/O绕过缓冲区。若需使用此标志，则需要定义功能测试宏<code>_GNU_SOURCE</code>，该标志的定义会出现在头文件<code>fcntl.h</code>中。</p>
<p>　　●
<code>O_DIRECTORY</code>表示参数<code>pathname</code>不是目录时，返回错误
(将<code>errno</code>设置为<code>ENOTDIR</code>)。该标志是专为实现<code>opendir()</code>而设计的扩展。若需使用此标志，则需要定义功能测试宏<code>_GNU_SOURCE</code>，该标志的定义会出现在头文件<code>fcntl.h</code>中。</p>
<p>　　●
<code>O_DSYNC</code>表示根据同步I/O数据完整性的完成条件来写文件。</p>
<p>　　●
<code>O_EXCL</code>与<code>O_CREAT</code>一起使用时，表示若文件已存在，则不会打开文件。同时，<code>open()</code>会失败，并将<code>errno</code>设置<code>EEXIST</code>。换句话说，该标志会保证调用进程是创建文件的进程。文件存在的检测和创建会自动执行。SUSv3要求，当<code>O_EXCL</code>与<code>O_CREAT</code>一起出现在<code>flags</code>中时，若参数<code>pathname</code>是符号链接，则<code>open()</code>会失败，并将<code>errno</code>设置<code>EEXIST</code>。这样是为了让特权应用程序可以在已知位置创建文件，而不会出现符号链接导致在不同位置
(例如，系统目录) 创建文件的可能性。</p>
<p>　　●
<code>O_LARGEFILE</code>表示支持打开大文件，主要用于32位系统。SUSv3并未说明该标志，但在数个UNIX实现中都可以找到该标志。对于Alpha和IA-64等64位Linux实现，该标志无效。</p>
<p>　　● <code>O_NOATIME</code>表示读文件时不更新文件的最后访问时间
(字段<code>st_atime</code>)，该标志并非标准Linux扩展。若需要使用该标志，则调用进程必须是特权进程
(<code>CAP_FOWNER</code>)
或其有效用户ID匹配文件的所有者；否则，<code>open()</code>会失败，并会将<code>errno</code>设置为<code>EPERM</code>。在实际中，在使用该标志的情况下，对于非特权进程，需要和文件的所有者匹配的是进程的文件系统用户ID，而非有效用户ID。该标志旨在供索引和备份系统使用。该标志能显著减少磁盘活动，因为无需重复进行磁盘查找来读文件的内容和更新文件的i-node中的最后访问时间。可以使用<code>mount()</code>的标志<code>MS_NOATIME</code>和<code>FS_NOATIME_FL</code>来达到类似的功能。若需使用此标志，则需要定义功能测试宏<code>_GNU_SOURCE</code>，该标志的定义会出现在头文件<code>fcntl.h</code>中。</p>
<p>　　●
<code>O_NOCTTY</code>表示当打开的文件是终端设备时，它不会成为控制终端。若打开的文件不是终端，则该标志无效。</p>
<p>　　●
<code>O_NOFOLLOW</code>表示当<code>pathname</code>是符号链接时，<code>open()</code>会失败，并将<code>errno</code>设置为<code>ELOOP</code>。若需使用此标志，则需要定义功能测试宏<code>_GNU_SOURCE</code>，该标志的定义会出现在头文件<code>fcntl.h</code>中。</p>
<p>　　● <code>O_NONBLOCK</code>表示以非阻塞模式打开文件。</p>
<p>　　● <code>O_SYNC</code>表示打开同步I/O的文件。</p>
<p>　　●
<code>O_TRUNC</code>表示当文件已存在并且是常规文件时，将其截断为长度0，以破坏文件内容。对于Linux，无论文件以只读或只写模式打开，都可以截断
(需要写权限)。SUSv3并没有说明<code>O_RDONLY</code>和<code>O_TRUNC</code>的组合，但大多数UNIX实现都有类似于Linux的行为。</p>
<p>　　从内核2.6.22开始，可以读目录<code>/proc/PID/fdinfo</code>下的特定于Linux的文件来获取系统中的所有进程的文件描述符的信息。对于进程的每个打开的文件描述符，该目录下都有1个对应的文件。该文件的字段<code>pos</code>表示当前文件偏移量，字段<code>flags</code>
(八进制数) 表示文件访问模式标志和打开文件状态标志。</p>
<h4 id="来自open的错误">4.1.2 来自<code>open()</code>的错误</h4>
<p>　　当打开文件出错时，<code>open()</code>会返回-1并将<code>errno</code>设置为对应的值：</p>
<p>　　●
<code>EACCES</code>表示文件权限不允许调用进程以<code>flags</code>指定的模式打开文件。此外，由于目录权限，文件可能无法访问，或文件不存在并且无法被创建。</p>
<p>　　●
<code>EISDIR</code>表示调用进程试图以只写模式打开类型为目录的文件。</p>
<p>　　●
<code>EMFILE</code>表示进程的打开的文件描述符数的资源限制达到上限
(<code>RLIMIT_NOFILE</code>)。</p>
<p>　　●
<code>ENFILE</code>表示系统的打开的文件描述符数的资源限制达到上限。</p>
<p>　　●
<code>ENOENT</code>表示出现2种情况之一。第1种情况是指定的文件不存在，但<code>flags</code>未指定<code>O_CREAT</code>。第2种情况是<code>flags</code>指定了<code>O_CREAT</code>，但<code>pathname</code>是死链接或其中的某个目录不存在。</p>
<p>　　●
<code>EROFS</code>表示指定的文件位于只读文件系统，并且试图写该文件。</p>
<p>　　●
<code>ETXTBSY</code>表示指定的文件是正在运行的可执行文件，对此类文件的修改是禁止的。</p>
<h4 id="系统调用creat">4.1.3 系统调用<code>creat()</code></h4>
<p>　　在早期UNIX实现中，<code>open()</code>仅有2个参数，并且不能用于创建文件。相反，系统调用<code>creat()</code>用于创建并打开新文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>; <span class="comment">/* 若成功则返回文件描述符，若失败则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>creat()</code>会创建并打开参数<code>pathname</code>指定的文件，若文件已存在，则将其截断为长度0。该系统调用会返回文件描述符。调用<code>creat()</code>等价于以以下方式调用<code>open()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);</span><br></pre></td></tr></table></figure>
<p>　　因为<code>open()</code>的参数<code>flags</code>提供了对文件打开方式的更多控制，所以<code>creat()</code>现已过时。</p>
<h3 id="读写文件">4.2 读写文件</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buffer, <span class="type">size_t</span> count)</span>; <span class="comment">/* 若成功则返回读取的字节数；若遇到EOF则返回0；若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buffer, <span class="type">size_t</span> count)</span>; <span class="comment">/* 若成功则返回写入的字节数；若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>read()</code>会从参数<code>fd</code>引用的打开的文件中读数据。参数<code>count</code>表示读取的字节数。参数<code>buffer</code>表示用于存放读取的数据的内存缓冲区
(长度至少是<code>count</code>字节) 的地址，因为<span
style="background-color: yellow">系统调用不会为用于存放返回信息的缓冲区分配内存</span>。若<code>read()</code>正常运行，则返回实际读取的字节数；若遇到EOF，则返回0；若出错，则返回-1。</p>
<p>　　系统调用<code>write()</code>会向参数<code>fd</code>引用的打开的文件中写数据，其参数与<code>read()</code>相似。参数<code>buffer</code>表示待写入数据的地址。参数<code>count</code>表示写入的字节数。若<code>write()</code>正常运行，则返回实际写入的字节数；若出错，则返回-1。</p>
<p>　　对于每个打开的文件，内核都记录了<strong>文件偏移量</strong>
(也称为<strong>读写偏移</strong>或<strong>读写指针</strong>)，即下次<code>read()</code>或<code>write()</code>开始的位置。它是相对文件开头的序号字节位。文件的第1个字节的偏移量是0。当打开文件时，文件偏移量会设置为0。文件偏移量会在调用<code>read()</code>或<code>write()</code>后自动调整。因此，连续调用<code>read()</code>和<code>write()</code>会按序进行。</p>
<p>　　<code>read()</code>实际读取的字节数可能会少于要求的字节数。对于常规文件，这可能是因为文件偏移量靠近EOF。对于无名管道、有名管道、套接字和终端等其他类型的文件，可能导致该情况的因素较多。例如，<code>read()</code>读终端时，默认遇到换行符<code>\n</code>就会结束读取。同样，<code>write()</code>实际写入的字节数也可能会少于要求的字节数。对于磁盘文件，这可能是因为磁盘已满或进程的文件大小的资源限制达到上限
(<code>RLIMIT_FSIZE</code>)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_READ 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[MAX_READ + <span class="number">1</span>];</span><br><span class="line"><span class="type">ssize_t</span> numRead;</span><br><span class="line"></span><br><span class="line">numRead = read(STDIN_FILENO, buffer, MAX_READ);</span><br><span class="line"><span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buffer[numRead] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The input data was: %s\n&quot;</span>, buffer);</span><br></pre></td></tr></table></figure>
<p>　　当通过<code>read()</code>读字符串时，<span
style="background-color: yellow">不会</span>将字符串结束符<code>\0</code>读取到缓冲区。若需要打印缓冲区中的字符串，则需要加上结束符。</p>
<p>　　当对磁盘文件执行I/O时，<code>write()</code>的非-1返回值并不保证数据已经传输到磁盘，因为内核会缓存磁盘I/O来减少磁盘活动和加快<code>write()</code>调用。</p>
<h3 id="关闭文件">4.3 关闭文件</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>close()</code>会关闭参数<code>fd</code>引用的打开的文件。当进程终止时，它的所有打开的文件描述符都会自动关闭。</p>
<p>　　通常，最好显式关闭不再使用的文件描述符，因为这会使得代码在后续修改时有更好的可读性和健壮性。此外，文件描述符是有限资源，所以未关闭的文件描述符可能会导致进程耗尽描述符。对于处理多文件的生命周期长的程序，这会导致严重的问题。</p>
<p>　　就像其他系统调用一样，对<code>close()</code>的调用应该用错误处理代码包围起来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (close(fd) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这种错误处理代码会捕捉关闭未打开的文件描述符和重复关闭同一描述符等错误，并且也能用于捕获特定文件系统在执行关闭操作时可能诊断的错误情况。NFS提供了特定于文件系统的错误的示例，若NFS提交失败
(数据无法到达远程磁盘)，则将该错误作为调用<code>close()</code>失败反馈给应用程序。</p>
<h3 id="修改文件偏移量">4.4 修改文件偏移量</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>; <span class="comment">/* 若成功则返回新文件偏移量，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>lseek()</code>会根据参数<code>offset</code>和<code>whence</code>调整参数<code>fd</code>引用的打开的文件的文件偏移量。参数<code>offset</code>是以字节为单位的值。参数<code>whence</code>是参数<code>offset</code>的基点，其值如下：</p>
<p>　　●
<code>SEEK_SET</code>表示文件偏移量设置为距文件开头<code>offset</code>个字节处的位置。</p>
<p>　　●
<code>SEEK_CUR</code>表示文件偏移量设置为距当前文件偏移量<code>offset</code>个字节处的位置。</p>
<p>　　●
<code>SEEK_END</code>表示文件偏移量设置为距文件最后1个字节的后1个字节<code>offset</code>个字节处的位置。</p>
<img src="/2024/09/16/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-4/interpreting_the_whence_argument_of_lseek.svg" class="" title="interpreting_the_whence_argument_of_lseek()">
<p>　　若<code>lseek()</code>正常运行，则返回新文件偏移量。</p>
<p>　　当参数<code>whence</code>是<code>SEEK_CUR</code>或<code>SEEK_END</code>时，参数<code>offset</code>可以是正值或负值；当参数<code>whence</code>是<code>SEEK_SET</code>时，参数<code>offset</code>只能是非负值。</p>
<p>　　在早期UNIX实现中，使用的是整数0~2，而非<code>SEEK_SET</code>、<code>SEEK_CUR</code>和<code>SEEK_END</code>。在旧版本的BSD中，使用的是<code>L_SET</code>、<code>L_INCR</code>和<code>L_XTND</code>。</p>
<p>　　某些UNIX实现 (不包括Linux)
中有非标准函数<code>tell(fd)</code>，其功能与<code>lseek()</code>相同。</p>
<p>　　以下是<code>lseek()</code>的用法示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lseek(fd, <span class="number">0</span>, SEEK_SET);     <span class="comment">/* 文件开头处 */</span></span><br><span class="line">lseek(fd, <span class="number">0</span>, SEEK_END);     <span class="comment">/* 当前文件结尾的后1个字节处 */</span></span><br><span class="line">lseek(fd, <span class="number">-1</span>, SEEK_END);    <span class="comment">/* 当前文件结尾处 */</span></span><br><span class="line">lseek(fd, <span class="number">-10</span>, SEEK_CUR);   <span class="comment">/* 当前文件偏移量的前10个字节处 */</span></span><br><span class="line">lseek(fd, <span class="number">10000</span>, SEEK_END); <span class="comment">/* 当前文件结尾后的第10001个字节处 */</span></span><br></pre></td></tr></table></figure>
<p>　　<code>lseek()</code>仅会修改文件描述符关联的内核文件记录，不涉及物理设备访问。<code>lseek()</code>不适用于所有类型的文件，不能对无名管道、有名管道、套接字和终端使用。若必要时，可以对设备使用<code>lseek()</code>，例如，查询磁盘或磁带上的特定位置。</p>
<p>　　<code>lseek()</code>名称中的<code>l</code>源于事实：参数<code>offset</code>和返回值的类型本质上是<code>long</code>。早期UNIX实现提供了系统调用<code>seek()</code>，并将这些值定义为<code>int</code>。</p>
<h4 id="文件空洞">4.4.1 文件空洞</h4>
<p>　　前一文件结尾和新写入的字节之间的空间称为<strong>文件空洞</strong>。从编程角度，空洞里的字节是存在的，读空洞会返回只包含空字节
(即0) 的缓冲区。</p>
<p>　　文件空洞占用的磁盘空间很少。在大多数文件系统中，文件空间以块为单位分配。块的大小取决于文件系统，通常是1024字节的整数倍。若空洞的边界在块中，而非在块的边界，则会分配整个块来存储数据
(空洞对应的部分用0填充)。除了这种情况之外，文件系统不会为空洞分配磁盘空间，直到有数据写入空洞时。文件空洞可以节省磁盘空间，尤其是那些稀疏填充的文件。内存快照文件就是包含大量空洞的常见示例。</p>
<p>　　大多数UNIX原生文件系统都支持文件空洞，但很多非原生的文件系统
(例如，Microsoft的VFAT) 不支持文件空洞。</p>
<p>　　文件空洞的存在表示文件的常规大小可能大于实际占用的磁盘空间。<span
style="background-color: yellow">在文件空洞的中间写数据会减少可用磁盘空间</span>
(尽管文件大小并没有增加)，因为内核会分配块来填充空洞。</p>
<p>　　SUSv3详细说明了函数<code>posix_fallocate(fd, offset, len)</code>，该函数会在磁盘上由<code>offset</code>和<code>len</code>指定的字节范围内为<code>fd</code>引用的磁盘文件分配空间。这可用于确保应用程序在随后对文件调用<code>write()</code>时不会因磁盘空间耗尽
(向文件中的空洞写数据或者其他应用程序使用了磁盘空间)
而失败。从历史角度，<code>glibc</code>通过向指定范围内的所有块写入1个字节0来实现该函数。从版本2.6.23开始，Linux提供了系统调用<code>fallocate()</code>，该系统调用提供了更高效的方式来保证必要的空间会被分配，并且<code>glibc</code>的<code>posix_fallocate()</code>实现在会在该系统调用可用时使用它。</p>
<p>　　系统调用<code>stat()</code>可用于获取当前文件的大小和实际分配给该文件的块的数量。</p>
<h4 id="示例程序">4.4.2 示例程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* seek_io.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="type">off_t</span> offset;</span><br><span class="line">    <span class="type">int</span> fd, ap, j;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">ssize_t</span> numRead, numWritten;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s file &#123;r&lt;length&gt;|R&lt;length&gt;|w&lt;string&gt;|s&lt;offset&gt;&#125;...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR | O_CREAT,</span><br><span class="line">              S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH); <span class="comment">/* rw-rw-rw- */</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ap = <span class="number">2</span>; ap &lt; argc; ap++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (argv[ap][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>: <span class="comment">/* 以文本显示当前偏移量 */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>: <span class="comment">/* 以十六进制显示当前偏移量 */</span></span><br><span class="line">            len = getLong(&amp;argv[ap][<span class="number">1</span>], GN_ANY_BASE, argv[ap]);</span><br><span class="line">            buf = <span class="built_in">malloc</span>(len);</span><br><span class="line">            <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            numRead = read(fd, buf, len);</span><br><span class="line">            <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (numRead == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: end-of-file\n&quot;</span>, argv[ap]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: &quot;</span>, argv[ap]);</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numRead; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (argv[ap][<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>((<span class="type">unsigned</span> <span class="type">char</span>)buf[j]) ? buf[j] : <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)buf[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(buf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>: <span class="comment">/* 在当前偏移量处写入字符串 */</span></span><br><span class="line">            numWritten = write(fd, &amp;argv[ap][<span class="number">1</span>], <span class="built_in">strlen</span>(&amp;argv[ap][<span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">if</span> (numWritten == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: wrote %ld bytes\n&quot;</span>, argv[ap], (<span class="type">long</span>)numWritten);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: <span class="comment">/* 修改文件偏移量 */</span></span><br><span class="line">            offset = getLong(&amp;argv[ap][<span class="number">1</span>], GN_ANY_BASE, argv[ap]);</span><br><span class="line">            <span class="keyword">if</span> (lseek(fd, offset, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: seek succeeded\n&quot;</span>, argv[ap]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cmdLineErr(<span class="string">&quot;Argument must start with [rRws]: %s\n&quot;</span>, argv[ap]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>lseek()</code>与<code>read()</code>和<code>write()</code>一起使用时的情况。该程序的第1个命令行参数是待打开文件的名称。其余参数指定对文件执行的I/O操作，这些I/O操作由1个字母和1个值组成
(没有进行分隔)：</p>
<p>　　●
<code>soffset</code>表示将文件偏移量设置为距文件开头的<code>offset</code>个字节处的位置。</p>
<p>　　●
<code>rlength</code>表示从当前文件偏移量处读<code>length</code>个字节，并以文本显示。</p>
<p>　　●
<code>Rlength</code>表示从当前文件偏移量处读<code>length</code>个字节，并以十六进制显示。</p>
<p>　　●
<code>wstr</code>表示向当文件偏移量写<code>str</code>指定的字符串。</p>
<p>　　以下shell命令展示了该程序的用法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch tfile</span><br><span class="line">./seek_io tfile s100000 wabc</span><br><span class="line">ls -l tfile</span><br><span class="line">./seek_io tfile s10000 R5 </span><br></pre></td></tr></table></figure>
<p>　　第1条命令会创建文件<code>tfile</code>。第2条命令会将文件偏移量设置为距文件开头100000个字节处的位置，并向该位置写入字符串<code>abc</code>。第3条命令会展示文件的信息。第4条命令会将文件偏移量设置为距文件开头10000个字节处的位置
(也就是空洞)，并且从该位置读5个字节。</p>
<h3 id="通用io模型之外的操作">4.5 通用I/O模型之外的操作</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> request, ... <span class="comment">/* argp */</span>)</span>; <span class="comment">/* 若成功则返回request对应的值，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>ioctl()</code>可用于执行通用I/O模型外的文件和驱动操作。参数<code>fd</code>是文件或设备的打开的文件描述符，参数<code>request</code>指定在该描述符上执行的控制操作。特定于设备的头文件中定义了可通过参数<code>request</code>传递的常量。</p>
<p>　　由C省略号<code>...</code>表示的第3个参数
(这里用<code>argp</code>表示)
可以是任何类型。参数<code>request</code>的值使得<code>ioctl()</code>能够决定<code>argp</code>预期的类型。<code>argp</code>通常是指向整数或结构体的指针，有时也不会使用。</p>
<p>　　SUSv3对<code>ioctl()</code>的唯一要求是用于控制STREAMS设备。STREAMS是System
V的功能，但主线Linux内核并不支持该功能
(尽管已经开发了一些附加组件实现)。SUSv3并没有说明本书中描述的<code>ioctl()</code>的其他操作。但是，从UNIX系统的早期版本开始，<code>ioctl()</code>就一直作为UNIX系统的一部分，因此，很多UNIX实现都提供了本书描述的<code>ioctl()</code>的部分操作。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第5章 文件I/O：更多细节</title>
    <url>/2024/10/05/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-5/</url>
    <content><![CDATA[<p>　　所有系统调用都是<strong>原子</strong>执行的，即内核会保证系统调用在执行时不会被中断，这避免了<strong>竞争</strong>。竞争是2个进程或线程产生的操作共享资源的结果取决于无法预期的情况
(进程或线程访问CPU的相对顺序)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span>; <span class="comment">/* 若成功则返回cmd对应的值；若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>fcntl()</code>能够对打开的文件描述符执行多种控制操作。参数<code>cmd</code>用于指定操作。由省略号表示的第3个参数可以是任何类型，或者被忽略，内核根据参数<code>cmd</code>来确定该参数的期望类型
(若存在)。</p>
<p>　　内核维护了<strong>打开文件表</strong>
(系统范围)，其中的条目称为<strong>打开的文件句柄</strong>，包括<span
style="background-color: yellow">当前文件偏移量</span>、<span
style="background-color: yellow">打开文件时指定的状态标志</span>、<span
style="background-color: yellow">文件访问模式</span>、<span
style="background-color: yellow">信号驱动I/O的相关设置</span>和<span
style="background-color: yellow">指向i-node表条目的指针</span>。</p>
<p>　　对于每个进程，内核都为其维护了<strong>打开的文件描述符表</strong>，简称<strong>文件描述符表</strong>。该表中的每个条目都记录了1个文件描述符的信息，包括<span
style="background-color: yellow">1组用于控制对应文件描述符的操作的标志位</span>和<span
style="background-color: yellow">1个指向打开的文件句柄的指针</span>。</p>
<p>　　每个文件系统都有i-node表，为该文件系统中驻留的所有文件所用，其条目包括<span
style="background-color: yellow">文件类型和权限</span>、<span
style="background-color: yellow">指向该文件持有的锁列表的指针</span>和<span
style="background-color: yellow">文件的各种属性</span>
(例如，文件大小和不同类型的文件操作的相关时间戳)。</p>
<p>　　i-node在磁盘上的表示和内存中的表示不同。磁盘上的i-node记录了文件的永久属性
(例如，文件类型、权限和时间戳)。当访问文件时，会创建内存中的i-node副本，该版本的i-node记录了引用i-node的打开的文件句柄的数量以及从中复制i-node的设备的主要ID和次要ID。此外，内存中的i-node还记录了文件打开时与文件关联的临时属性
(例如，文件锁)。</p>
<img src="/2024/10/05/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-5/relationship_between_file_descriptors,open_file_handles_and_i-nodes.svg" class="" title="relationship_between_file_descriptors,open_file_handles_and_i-nodes">
<p>　　如图所示，进程A和B有大量的打开的文件描述符。进程A的描述符1和20引用的打开的文件句柄相同，这种情况可能是因为调用了<code>dup()</code>、<code>dup2()</code>或<code>fcntl()</code>。进程A的描述符2和进程B的描述符2引用的打开的文件句柄相同，这种情况是因为调用了<code>fork()</code>或进程通过UNIX域名套接字传递文件描述符给其他进程。</p>
<p>　　进程A的描述符0和进程B的描述符3引用的打开的文件句柄不同，但这2个句柄引用的是同一i-node表条目
(即同一文件)。这种情况是因为2个进程都对该文件调用了<code>open()</code>。当同一进程多次打开同一文件时，会出现类似的情况。</p>
<p>　　综上所述，引用同一打开的文件句柄的不同文件描述符共享文件偏移量，类似的规则也适用于打开文件状态标志。相反，文件描述符标志仅限于进程和文件描述符，对这些标志的修改不会影响同一进程的其他描述符或其他进程。</p>
<span id="more"></span>
<h3 id="原子和竞争">5.1 原子和竞争</h3>
<p>　　在4.1.1中提到过，标志<code>O_EXCL</code>与<code>O_CREAT</code>一起使用时，若文件已存在，则返回-1，并设置<code>errno</code>。其中对文件存在的检测和文件的创建都是原子执行的。为了体现这一点的重要性，考虑以下代码
(未使用标志<code>O_EXCL</code>)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(argv[<span class="number">1</span>], O_WRONLY);</span><br><span class="line"><span class="keyword">if</span> (fd != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[PID %ld] File \&quot;%s\&quot; already exists\n&quot;</span>, (<span class="type">long</span>)getpid(), argv[<span class="number">1</span>]);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (errno != ENOENT)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        fd = open(argv[<span class="number">1</span>], O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[PID %ld] Created file \&quot;%s\&quot; exclusively\n&quot;</span>, (<span class="type">long</span>)getpid(), argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这段代码会打印系统调用<code>getpid()</code>返回的进程ID。假设有多个运行这段代码的进程，当内核调度程序决定某个进程的时间片已经结束，并将控制权交给其他进程时，可能会出现情况：该进程第1次调用<code>open()</code>时，文件不存在；第2次调用<code>open()</code>时，其他进程创建了文件。</p>
<img src="/2024/10/05/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-5/failing_to_exclusively_create_a_file.svg" class="" title="failing_to_exclusively_create_a_file">
<p>　　进程A错误地认为它创建了文件，因为第2次调用<code>open()</code>成功。这种竞争情况是否出现完全取决于进程的调度顺序。</p>
<p>　　第2个关于原子性的示例就是多个进程都向同一文件的末尾写数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lseek(fd, <span class="number">0</span>, SEEK_END) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (write(fd, buf, len) != len)</span><br><span class="line">&#123;</span><br><span class="line">    fatal(<span class="string">&quot;Partial/failed write&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这段代码的问题和前一示例的相同。若执行这段代码的进程在调用<code>lseek()</code>和调用<code>write()</code>之间被执行相同操作的其他进程中断，则会导致2个进程都向同一偏移量处写数据。标志<code>O_APPEND</code>可以解决这个问题
(NFS等文件系统不支持该标志)。</p>
<h3 id="打开文件状态标志">5.2 打开文件状态标志</h3>
<p>　　系统调用<code>fcntl()</code>的用途之一是<span
style="background-color: yellow">检索或修改文件访问模式和打开文件状态标志</span>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flags, accessMode;</span><br><span class="line"></span><br><span class="line">flags = fcntl(fd, F_GETFL); <span class="comment">/* 第3个参数不是必需的 */</span></span><br><span class="line"><span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; O_SYNC)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;writes are synchronized\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">accessMode = flags &amp; O_ACCMODE;</span><br><span class="line"><span class="keyword">if</span> (accessMode == O_WRONLY || accessMode == O_RDWR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;file is writable\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　为了检索这些设置，需要将<code>fcntl()</code>的参数<code>cmd</code>指定为<code>F_GETFL</code>。在这段代码中，第8~11行会判断打开的文件是否写同步。访问模式的判断稍微复杂一些，因为打开文件状态标志<code>O_RDONLY</code>
(0)、<code>O_WRONLY</code> (1) 和 <code>O_RDWR</code> (2)
并不对应单个位，所以需要对<code>flags</code>进行掩码操作
(使用<code>O_ACCMODE</code>)，如第13~17行所示。</p>
<p>　　可以通过<code>fcntl()</code>的操作<code>F_SETFL</code>修改部分打开文件状态标志，包括<code>O_APPEND</code>、<code>O_NONBLOCK</code>、<code>O_NOATIME</code>、<code>O_ASYNC</code>和<code>O_DIRECT</code>
(有些UNIX实现允许修改的标志更多)，对其他标志的修改将会被忽略
。这在以下场景很有用：</p>
<p>　　● 当前进程并非调用<code>open()</code>打开文件的进程
(即文件可能是3个标准描述符之一，在程序启动前就已被打开)，所以无法控制调用<code>open()</code>时使用的标志。</p>
<p>　　●
文件描述符是通过除<code>open()</code>之外的其他系统调用获取。例如，系统调用<code>pipe()</code>会创建管道，并返回分别引用管道两端的2个文件描述符。系统调用<code>socket()</code>会创建套接字，并返回引用该套接字的文件描述符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">flags = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flags |= O_APPEND;</span><br><span class="line"><span class="keyword">if</span> (fcntl(fd, F_SETFL, flags) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这段代码会启用标志<code>O_APPEND</code>。为了修改打开文件状态标志，需要先调用<code>fcntl()</code>来获取当前标志的副本，然后进行修改，最后再次调用<code>fcntl()</code>来更新标志。</p>
<p>　　SUSv3要求通过调用<code>open()</code>或之后的<code>fcntl()</code>的操作<code>F_SETFL</code>设置的状态标志仅适用于打开的文件。但是，Linux在偏离了这一点：若应用程序的编译方式是5.8中描述的用于打开文件的技术之一，则<code>fcntl()</code>的操作<code>F_GETFL</code>检索的标志中将总是包含<code>O_LARGEFILE</code>。</p>
<h3 id="复制文件描述符">5.3 复制文件描述符</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>; <span class="comment">/* 若成功则返回新文件描述符，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>; <span class="comment">/* 若成功则返回新文件描述符，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>dup()</code>返回的新文件描述符
(未使用的编号最小的描述符)
引用的打开的文件句柄与参数<code>oldfd</code>的相同。</p>
<p>　　系统调用<code>dup2()</code>与<code>dup()</code>类似，但返回的文件描述符由参数<code>newfd</code>指定
(即两者相同)。当参数<code>newfd</code>已经打开时，该系统调用会先关闭它，并且关闭时出现的错误会被忽略。因此，应该在调用<code>dup2()</code>前显式地关闭参数<code>newfd</code>指定的文件描述符。若<code>oldfd</code>是无效的文件描述符，则<code>dup2()</code>会失败
(将<code>errno</code>设置为<code>EBADF</code>)，并且不会关闭<code>newfd</code>。若<code>oldfd</code>是有效的文件描述符，并且<code>oldfd</code>和<code>newfd</code>相同，则<code>dup2()</code>什么也不会做
(不会关闭<code>newfd</code>)。</p>
<p>　　对于复制文件描述符，系统调用<code>fcntl()</code>的操作<code>F_DUPFD</code>可以提供更多的灵活性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">newfd = fcntl(oldfd, F_DUPFD, startfd);</span><br></pre></td></tr></table></figure>
<p>　　这种调用方式会使用编号不小于<code>startfd</code>的未使用的文件描述符来复制<code>oldfd</code>。对<code>dup()</code>和<code>dup2()</code>的调用都可以替换为对<code>close()</code>和<code>fcntl()</code>的调用
(有时，<code>dup2()</code>设置<code>errno</code>的错误码和<code>fcntl()</code>的不同)。</p>
<p>　　在5.3中提到过，复制文件描述符后，新文件描述符与原文件描述符共享文件偏移量和打开文件状态标志。但是，新文件描述符有自己的文件描述符标识
(集)，并且close-on-exec标志是关闭的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup3</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd, <span class="type">int</span> flags)</span>; <span class="comment">/* 若成功则返回新文件描述符，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>dup3()</code>与<code>dup2()</code>执行的任务相同，但添加了参数<code>flags</code>。参数<code>flags</code>是位掩码，用于修改该系统调用的行为。此外，<code>dup3()</code>还支持标志<code>O_CLOEXEC</code>。<code>dup3()</code>是Linux
2.6.27新增的系统调用，并且仅限于Linux。</p>
<p>　　从Linux
2.6.24开始，Linux还支持符系统调用<code>fcntl()</code>的操作<code>F_DUPFD_CLOEXEC</code>。该操作与<code>F_DUPFD</code>的功能相同
(复制文件描述符)，但该操作会为新文件描述符设置close-on-exec标志。SUSv4详细说明了该操作，但SUSv3没有说明该操作。</p>
<h3 id="指定偏移量处的文件io">5.4 指定偏移量处的文件I/O</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">pread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span>; <span class="comment">/* 若成功则返回实际读取的字节数；若遇到EOF则返回0；若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">pwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span>; <span class="comment">/* 若成功则返回实际写入的字节数；若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　除了能够指定执行文件I/O的位置之外，系统调用<code>pread()</code>和<code>pwrite()</code>与<code>read()</code>和<code>write()</code>的功能相同。此外，<code>pread()</code>和<code>pwrite()</code>不会修改文件偏移量。</p>
<p>　　系统调用<code>pread()</code>和<code>pwrite()</code>在多线程应用程序中很有用，因为进程的所有线程共享文件描述符表
(所以它们也共享文件偏移量)。</p>
<h3 id="分散-聚集io">5.5 分散-聚集I/O</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>; <span class="comment">/* 若成功则返回实际读取的字节数；若遇到EOF则返回0；若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>; <span class="comment">/* 若成功则返回实际写入的字节数；若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>readv()</code>和<code>writev()</code>会执行<strong>分散-聚集I/O</strong>，即每次传输多个缓冲区的数据，这些缓冲区由参数<code>iov</code>指定。参数<code>iovcnt</code>表示<code>iov</code>中的元素数。<code>iov</code>中的元素是结构体，其形式如下：</p>
<img src="/2024/10/05/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-5/example_of_an_iovec_array_and_associated_buffers.svg" class="" title="example_of_an_iovec_array_and_associated_buffers">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> *iov_base; <span class="comment">/* 缓冲区起始地址 */</span></span><br><span class="line">    <span class="type">size_t</span> iov_len; <span class="comment">/* 缓冲区中写入/读取的字节数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　SUSv3允许实现对<code>iov</code>中的元素数设置限制，这些限制可以通过头文件<code>limits.h</code>中的<code>IOV_MAX</code>或在运行时调用<code>sysconf(_SC_IOV_MAX)</code>的返回值查看
(如果有)。SUSv3要求这些限制的最小值是16。Linux的<code>IOV_MAX</code>定义为1024，对应内核对该向量的大小限制
(由内核常量<code>UIO_MAXIOV</code>定义)。</p>
<p>　　但是，系统调用<code>readv()</code>和<code>writev()</code>的<code>glibc</code>包装函数会隐式地执行了一些额外的任务。若这些系统调用因<code>iovcnt</code>过大而失败，则包装函数会临时分配1个足以存储<code>iov</code>所有元素的缓冲区，并调用<code>read()</code>或<code>write()</code>。</p>
<h4 id="分散输入和聚集输出">5.5.1 分散输入和聚集输出</h4>
<p>　　系统调用<code>readv()</code>会执行分散输入，即从参数<code>fd</code>引用的文件中读连续的字节序列，然后将这些字节存放到参数<code>iov</code>指定的缓冲区中。<code>iov</code>指定的缓冲区以<code>iov[0]</code>开头。</p>
<p>　　<code>readv()</code>的重要属性之一是<span
style="background-color: yellow">以原子方式完成</span>。从调用进程的角度，内核只会在<code>fd</code>引用的文件和用户内存之间进行1次数据传输。因此，当<code>readv()</code>读文件时，读取的字节必定是连续的，即使共享同一文件偏移量的其他进程
(或线程) 试图在此过程中修改偏移量。</p>
<p>　　若<code>readv()</code>正常运行时，则返回实际读取的字节数；若遇到EOF，则返回0。调用者需要根据返回值来确定是否读取了所有请求的数据。若有效数据不足以填充所有缓冲区，则仅会填充部分缓冲区，并且最后1个缓冲区可能只会被填充一部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_readv.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[3];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">myStruct</span>;</span> <span class="comment">/* 第1个缓冲区 */</span></span><br><span class="line">    <span class="type">int</span> x;                <span class="comment">/* 第2个缓冲区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR_SIZE 100</span></span><br><span class="line">    <span class="type">char</span> str[STR_SIZE]; <span class="comment">/* 第3个缓冲区 */</span></span><br><span class="line">    <span class="type">ssize_t</span> numRead, totRequired;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s file\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    totRequired = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = &amp;myStruct;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> stat);</span><br><span class="line">    totRequired += iov[<span class="number">0</span>].iov_len;</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">1</span>].iov_base = &amp;x;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span>(x);</span><br><span class="line">    totRequired += iov[<span class="number">1</span>].iov_len;</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">2</span>].iov_base = str;</span><br><span class="line">    iov[<span class="number">2</span>].iov_len = STR_SIZE;</span><br><span class="line">    totRequired += iov[<span class="number">2</span>].iov_len;</span><br><span class="line"></span><br><span class="line">    numRead = readv(fd, iov, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;readv&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numRead &lt; totRequired)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read fewer bytes than requested\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;total bytes requested: %ld; bytes read: %ld\n&quot;</span>, (<span class="type">long</span>)totRequired, (<span class="type">long</span>)numRead);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是<code>readv()</code>的用法示例。对于这种主要展示1个系统调用或库函数的用法的示例程序，这里会使用前缀<code>t_</code>加上函数名来作为名称。</p>
<p>　　系统调用<code>writev()</code>会执行聚集输出，即将参数<code>iov</code>指定的缓冲区中所有数据连接起来
(按数组顺序)，然后将它们作为连续的字节序列写入参数<code>fd</code>引用的文件描述符中。同样，<code>iov</code>指定的缓冲区也以<code>iov[0]</code>开始。</p>
<p>　　与<code>readv()</code>一样，<code>writev()</code>也是<span
style="background-color: yellow">以原子方式完成</span>。在用户内存和<code>fd</code>引用的文件描述符之间的数据传输仅会作为1个操作执行，因此，当<code>writev()</code>写数据时，所有请求的数据都会连续写入到文件，不会被其他进程
(或线程) 中断。</p>
<p>　　<code>writev()</code>可能出现不完全写的情况，所以需要检查返回值来确定所有请求的数据是否已写入。</p>
<h4 id="在指定偏移量处执行分散-聚集io">5.5.2
在指定偏移量处执行分散-聚集I/O</h4>
<p>　　Linux
2.6.30新增了系统调用<code>preadv()</code>和<code>pwritev()</code>，用于在指定偏移量处执行分散-聚集I/O。这2个系统调用并非标准，但现代BSD中都包含它们。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">preadv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt, <span class="type">off_t</span> offset)</span>; <span class="comment">/* 若成功则返回实际读取的字节数；若遇到EOF则返回0；若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">pwritev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt, <span class="type">off_t</span> offset)</span>; <span class="comment">/* 若成功则返回实际写入的字节数；若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>preadv()</code>和<code>pwritev()</code>执行的任务与<code>readv()</code>和<code>writev()</code>相同，但会在参数<code>offset</code>指定的位置处。</p>
<h3 id="截断文件">5.6 截断文件</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">off_t</span> length)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>truncate()</code>和<code>ftruncate()</code>会将文件截断到参数<code>length</code>指定的值。若文件大小大于<code>length</code>，则丢弃多余的数据；若文件大小小于<code>lenght</code>，则补上空字节序列或空洞。</p>
<p>　　这2个系统调用的区别在于指定文件的方式。对于<code>truncate()</code>，参数<code>pathname</code>指定的文件必须是可访问和可写的
(若是符号链接，则会解引用)。对于<code>ftruncate()</code>，参数<code>fd</code>是
(至少以只读模式) 打开的文件描述符，该系统调用不会改变文件偏移量。</p>
<p>　　当<code>length</code>大于文件大小时，SUSv3给出了2个选择，即扩展文件
(对于Linux)
或返回错误。对于<code>truncate()</code>，SUSv3要求扩展文件。此外，XSI也要求扩展文件。</p>
<p>　　系统调用<code>truncate()</code>是<span
style="background-color: yellow">仅有的可以直接修改文件内容</span>
(无需先通过<code>open()</code>或其他方法来获取文件描述符)
的系统调用。</p>
<h3 id="非阻塞io">5.7 非阻塞I/O</h3>
<p>　　在打开文件时指定标志<code>O_NONBLOCK</code>有2个目的：</p>
<p>　　● 若文件不能立即打开，则<code>open()</code>会返回错误
(而非阻塞中)。与有名管道一起使用时，<code>open()</code>可以阻塞。</p>
<p>　　●
当成功调用<code>open()</code>后，后续的I/O操作也是非阻塞的。若系统调用不能立即完成，则只会传输部分数据，或者失败，并将<code>errno</code>设置为<code>EAGAIN</code>或<code>EWOULDBLOCK</code>。系统调用出错时设置的<code>errno</code>值取决于系统调用本身。对于Linux和很多UNIX实现，这2个错误常量是同义词。</p>
<p>　　非阻塞模式可以用于设备
(即终端和伪终端)、无名管道、有名管道和套接字。因为无名管道和套接字的文件描述符不是通过<code>open()</code>获得，所以必须通过<code>fcntl()</code>的操作<code>F_SETFL</code>来启用该标志。</p>
<p>　　常规文件会忽略标志<code>O_NONBLOCK</code>，因为内核缓冲区会确保对常规文件的I/O不会阻塞。但是，当使用强制文件锁定时，该标志也会对常规文件生效。</p>
<p>　　从历史角度，System
V衍生的实现提供了与标志<code>O_NONBLOCK</code>相似的标志<code>O_NDELAY</code>。主要区别在于，若<code>write()</code>无法完成或没有足够的输入来满足<code>read()</code>时，非阻塞的<code>write()</code>会返回0。这种情况不适用于<code>read()</code>，因为无法区分这种情况与EOF情况。因此，POSIX.1新增了标志<code>O_NONBLOCK</code>。有些UNIX实现仍然提供具有旧语义的标志<code>O_NDELAY</code>。Linux定义了标志<code>O_NDELAY</code>，但它与标志<code>O_NONBLOCK</code>是同义词。</p>
<h3 id="大文件的io">5.8 大文件的I/O</h3>
<p>　　用于表示文件偏移量的数据类型<code>off_t</code>通常实现为有符号长整型数
(实现为有符号数是因为值-1表示错误情况)。对于32位架构，这会将文件大小限制为2<sup>31</sup>-1字节
(即2GB)。但是，磁盘驱动程序的容量早就超过了该限制，所以需要32位UNIX实现来处理大于该限制的文件。由于这个问题在很多实现中都很常见，UNIX供应商联盟在<span
style="background-color: yellow">大型文件峰会</span>中进行了合作，来让SUSv2支持大文件的访问
(完整的LFS规范于1996年定稿)。</p>
<p>　　从内核2.4开始 (还需要<code>glic</code>
2.2及以上)，Linux提供了32位系统的LFS支持。此外，对应的文件系统也必须支持大文件。大多数Linux原生文件系统都支持大文件，有些非原生文件系统不支持大文件
(Microsoft的VFAT和NSFv2严格限制文件大小为2G，无论是否使用了LFS扩展)。</p>
<p>　　64位架构的长整型数实现为64位，文件大小的理论上限是2<sup>63</sup>-1字节，在大多数情况下，该大小远大于磁盘大小。因此，64位架构通常不需要对文件大小进行限制。</p>
<p>　　可以通过以下2种方式之一来开发需要LFS功能的应用程序：</p>
<p>　　● 使用支持大文件的替代API。LFS将该API设计为SUS的
"过渡扩展"。因此，符合SUSv2或SUSv3的系统并不需要提供此API，但很多符合SUSv2或SUSv3的系统还是提供了此API。这种方法现已过时。</p>
<p>　　●
编译程序时将宏<code>_FILE_OFFSET_BITS</code>定义为值64。这是首选方法，因为它允许符合规范的应用程序在不修改源码的情况下获取LFS功能。</p>
<p>　　若通过32位函数来访问大文件
(不使用LFS功能)，则可能会遇到错误<code>EOVERFLOW</code>。例如，当使用函数<code>stat()</code>的32位版本来获取大于2GB的文件的信息时，就会出现该错误。</p>
<h4 id="过渡lfs-api">5.8.1 过渡LFS API</h4>
<p>　　为了使用过渡LFS
API，需要定义功能测试宏<code>_LARGEFILE64_SOURCE</code>。该API提供的函数足以处理64位的文件大小和偏移量，其名称与对应的32位函数类似
(使用了后缀<code>64</code>)，包括<code>fopen64()</code>、<code>open64()</code>、<code>lseek64()</code>、<code>truncate64()</code>、<code>stat64()</code>、<code>mmap64()</code>、<code>setrlimit64()</code>。</p>
<p>　　为了打开大文件，可以直接使用这些函数的64位版本。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open64(name, O_CREAT | O_RDWR, mode);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　调用<code>open64()</code>等同于调用<code>open()</code>时指定标志<code>O_LARGEFILE</code>。若通过<code>open()</code>打开大于2GB的文件时不指定标志<code>O_LARGEFILE</code>，则会出错。</p>
<p>　　除了上述函数，过渡LFS
API还提供了一些新数据类型，包括<code>struct stat64</code>和<code>off64_t</code>。前者类似于结构体<code>stat</code>，但支持大文件。后者是表示偏移量的64位数据类型，用于函数<code>lseek64()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* large_file.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LARGEFILE64_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">off64_t</span> off;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s pathname offset\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open64(argv[<span class="number">1</span>], O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open64&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    off = atoll(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (lseek64(fd, off, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;lseek64&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write(fd, <span class="string">&quot;test&quot;</span>, <span class="number">4</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例程序的命令行参数有2个，即待打开文件的名称和表示文件偏移量的整数值。该程序会打开指定的文件，并在指定文件偏移量处写字符串。以下命令是通过该程序来在大文件的指定文件偏移量处写数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./large_file x 10111222333</span><br><span class="line">ls -l x</span><br></pre></td></tr></table></figure>
<h4 id="宏_file_offset_bits">5.8.2 宏<code>_FILE_OFFSET_BITS</code></h4>
<p>　　定义宏<code>_FILE_OFFSET_BITS</code>的方式有2种，即在C源码中定义<code>#define _FILE_OFFSET_BITS 64</code>
(引入头文件之前)
或对C编译器使用命令行选项<code>-D_FILE_OFFSET_BITS=64</code>。</p>
<p>　　宏<code>_FILE_OFFSET_BITS</code>会将所有相关的32位函数和数据类型转换为对应的64位版本。例如，对<code>open()</code>的调用会转换为对<code>open64()</code>的调用，数据类型<code>off_t</code>会定义为64位。因此，若程序<span
style="background-color: yellow">仅使用</span>数据类型为<code>off_t</code>的变量来表示文件偏移量，则只需要重新编译程序就可以支持大文件。</p>
<p>　　宏<code>_FILE_OFFSET_BITS</code>并不是LFS规范的要求
(仅提及该宏可作为指定数据类型<code>off_t</code>的长度的备选方法)。有些UNIX实现通过其他功能测试宏来获取同样的功能。</p>
<h4 id="打印off_t值">5.8.3 打印<code>off_t</code>值</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _LARGEFILE64_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> offset;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;offset=%lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>) offset);</span><br></pre></td></tr></table></figure>
<p>　　数据类型<code>off_t</code>有时会定义为<code>long long</code>。因此，为了保证可移植性，在打印<code>off_t</code>值时，需要将其转换为<code>long long</code>，并使用格式化字符串<code>%lld</code>。当需要在不同的编译模块之间传递<code>off_t</code>值时，需要确保编译模块的设置统一，即都
(不) 使用宏<code>_FILE_OFFSET_BITS</code>。</p>
<p>　　同样的情况也适用于结构体<code>stat</code>中使用的数据类型<code>blcnt_t</code>。</p>
<h3 id="目录devfd">5.9 目录<code>/dev/fd</code></h3>
<p>　　对于每个进程，内核都提供了特殊的虚拟目录<code>/dev/fd</code>。该目录下包含名称形如<code>/dev/fd/n</code>的文件，其中<code>n</code>是数字，对应进程的打开的文件描述符之一。例如，<code>/dev/fd/0</code>是进程的标准输入。</p>
<p>　　<code>/dev/stdin</code>、<code>/dev/stdout</code>和<code>/dev/stderr</code>分别是指向<code>/dev/fd/0</code>、<code>/dev/fd/1</code>和<code>/dev/fd/2</code>的符号链接。</p>
<p>　　<code>/dev/fd</code>实际上是指向特定于Linux的目录<code>/proc/self/fd</code>的符号链接。目录<code>/proc/self/fd</code>是特定于Linux的目录<code>/proc/PID/fd</code>的特例
(每个目录都包含与进程打开的所有文件相对应的符号链接)。</p>
<p>　　SUSv3并未说明目录<code>/dev/fd</code>，但多个UNIX实现都提供了该功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/dev/fd/1&quot;</span>, O_WRONLY);</span><br><span class="line">fd = dup(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>　　打开目录<code>/dev/fd</code>下的文件等同于复制对应的文件描述符，所以这2行代码是等效的。当用<code>open()</code>打开目录<code>/dev/fd</code>下的文件时，参数<code>flags</code>也会生效，需要保证复制的文件描述符的访问模式与原文件描述符的相同
(<code>O_CREAT</code>等标志将会被忽略)。</p>
<p>　　目录<code>/dev/fd</code>下的文件通常不会在程序中使用，最常见的使用场景是shell。很多用户级命令都会使用文件名参数，有时会将这些命令用在管道中，并且其中1个参数是标志输入或输出。出于这个目的，部分程序
(例如，<code>diff</code>、<code>ed</code>、<code>tar</code>和<code>comm</code>)
已经开始使用仅包含1个连字符<code>-</code>的参数，以表示该参数是标准输入或输出
(如果适用)。因此，可以通过如下命令来对<code>ls</code>返回的文件列表和之前的构建的文件列表对比：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls | diff - oldfilelist</span><br></pre></td></tr></table></figure>
<p>　　这种方法会产生很多问题。首先，需要所有相关程序都支持连字符的解析，但很多程序并不支持。其次，有些程序会将单个连字符解析为命令行选项结尾的标识符。解决方法之一是使用<code>/dev/fd</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls | diff /dev/fd/0 oldfilelist</span><br></pre></td></tr></table></figure>
<h3 id="创建临时文件">5.10 创建临时文件</h3>
<p>　　在某些情况下，程序可能需要创建一些仅在程序运行时才会使用的临时文件，并且这些临时文件会在程序终止时删除。通常，临时文件在打开不久后就会取消链接/删除
(通过系统调用<code>unlink()</code>)。</p>
<p>　　GNU
C库提供了大量用于此目的的函数，这里仅介绍函数<code>mkstemp()</code>和<code>tmpfile()</code>。函数<code>tmpnam()</code>、<code>tempnam()</code>和<code>mktemp()</code>也能用于创建临时文件，但这些函数会<span
style="background-color: yellow">产生安全漏洞</span>，所以应该避免使用它们。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkstemp</span><span class="params">(<span class="type">char</span> *template)</span>; <span class="comment">/* 若成功则返回文件描述符；若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>mkstemp()</code>会根据参数<code>template</code>指定的模板生成唯一的文件名，并打开文件
(使用标志<code>O_EXCL</code>)。然后，返回文件描述符。对于生成的文件，所有者有读写权限，其他用户没有任何权限。</p>
<p>　　参数<code>template</code>的形式是路径名，并且最后6个字符必须是<code>XXXXXX</code>。这6个字符会被替换为唯一的文件名，并且修改后的字符串会存放在参数<code>template</code>中。因此，<code>template</code>必须是字符数组，而非字符串常量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">char</span> template[] = <span class="string">&quot;/tmp/somestringXXXXXX&quot;</span>;</span><br><span class="line"></span><br><span class="line">fd = mkstemp(template);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;mkstemp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Generated filename was: %s\n&quot;</span>, template);</span><br><span class="line">unlink(template); <span class="comment">/* 文件名会立即消失，但文件只会在调用close()后删除 */</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">if</span> (close(fd) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是函数<code>mkstemp()</code>的用法示例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">tmpfile</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 若成功则返回文件指针，若出错则返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>tempfile()</code>会创建名称唯一的临时文件。临时文件使用标志<code>O_EXCL</code>打开，以防止其他进程已经创建了名称相同的文件。函数<code>tempfile()</code>的内部<span
style="background-color: yellow">已经调用</span>了<code>unlink()</code>。</p>
<p>　　当函数<code>tempfile()</code>正常运行时，会返回可与<code>stdio</code>库函数一起使用的文件流。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第6章 进程</title>
    <url>/2024/10/21/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-6/</url>
    <content><![CDATA[<p>　　<strong>程序</strong>是1个文件，其中包含一系列描述如何在运行时构建进程的信息，包括<span
style="background-color: yellow">二进制格式ID</span>、<span
style="background-color: yellow">机器语言指令</span>、<span
style="background-color: yellow">程序入口点地址</span>、<span
style="background-color: yellow">数据</span>、<span
style="background-color: yellow">符号表和重定位表</span>、<span
style="background-color: yellow">共享库和动态链接信息</span>以及<span
style="background-color: yellow">其他信息</span>。</p>
<p>　　● 每个程序文件都包含描述可执行文件格式的元信息
(即二进制格式ID)，这使内核能够解析文件的剩余信息。从历史角度，有2个广泛使用的UNIX可执行文件格式，即原始的<code>a.out</code>
(汇编器输出)
和之后出现的更复杂的<strong>通用对象文件格式</strong>。如今，Linux等大部分UNIX实现使用的都是更具优势的<strong>可执行链接格式</strong>。</p>
<p>　　● 机器语言指令对程序的算法进行编码。</p>
<p>　　● 程序入口点地址是程序执行时的第1条指令的地址。</p>
<p>　　● 程序文件包含用于初始化变量和字符串的值 (即数据)。</p>
<p>　　●
符号表和重定位表描述程序中的函数和变量的名称和位置。这些表用途广泛，包含调试和运行时符号解析
(即动态链接)。</p>
<p>　　●
程序文件包含的字段列出了程序在运行时所需的共享库和加载这些库的动态链接器的路径名。</p>
<p>　　● 程序文件还包含描述如何构建进程的各种其他信息。</p>
<p>　　1个程序可能会构建多个进程，多个进程可能运行相同的程序。</p>
<p>　　<strong>进程</strong>是由内核定义的抽象实体，系统会分配资源给进程来执行程序。</p>
<p>　　从内核角度，进程由用户空间内存 (包含程序代码和代码使用的变量)
和各种内核数据结构 (维护程序状态信息)
组成。内核数据结构中记录的信息包含与进程关联的各种ID、虚拟内存表、打开的文件描述符表、与信号传递和处理相关的信息、进程资源使用情况和限制、当前工作目录和主机的其他信息。</p>
<p>　　每个进程都有正整数的<strong>进程ID</strong>
(即PID)，用于标识系统中的进程。很多系统调用会使用或返回进程ID。除了<code>init</code>
(进程ID为1)
等少数系统进程，程序和为运行程序创建的进程的进程ID之间没有固定关系。</p>
<p>　　每个进程都有<strong>父进程</strong>，即创建该进程的进程。每个进程的父进程ID属性表示系统中的所有进程的树状关系。进程的父进程也有父进程，依此类推，一直追溯到进程<code>init</code>，它是所有进程的祖先。这个
"族谱" 可以通过命令<code>pstree</code>查看。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的进程ID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的父进程的进程ID */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>getpid()</code>会返回调用进程的进程ID。系统调用<code>getppid()</code>会返回调用进程的父进程ID。</p>
<p>　　若进程因为父进程终止而成为了<strong>孤儿进程</strong>，则它会被进程<code>init</code>收养
(系统调用<code>getppid()</code>会返回1)。任何进程的父进程都可以通过特定于Linux的文件<code>/proc/PID/status</code>中的字段<code>Ppid</code>查看。</p>
<p>　　Linux内核为进程ID设置的最大值是<span
style="background-color: yellow">32767</span>。当新进程创建时，会为其分配下1个按序可用的进程ID。当达到上限32767时，进程会将进程ID计数器重置为<span
style="background-color: yellow">300</span>，因为数值较小的进程ID会永远分配给系统进程和守护进程。</p>
<p>　　对于Linux
2.4及以下版本，进程ID的最大值32767由内核常量<code>PID_MAX</code>定义。这在Linux
2.6发生了变化，进程ID的默认最大值还是32767，不过该上限可通过特定于Linux的文件<code>/proc/sys/kernel/pid_max</code>修改
(32位平台的最大值是2<sup>15</sup>，64位平台的最大值是2<sup>22</sup>)。</p>
<span id="more"></span>
<p>　　每个C程序都有函数<code>main()</code> (即<span
style="background-color: yellow">主函数</span>)，该函数是程序执行的起点。</p>
<p>　　每个进程都有关联的称为<strong>环境列表</strong>
(简称<strong>环境</strong>)
的字符串数组，其中的元素都定义为<code>name=value</code>的形式。因此，环境变量表示一组用于存放任意信息的名称-值对，其中的名称称为<strong>环境变量</strong>。</p>
<p>　　当进程被创建时，进程会继承父进程的环境列表
(这是一种原始但经常使用的进程间通信方式)。随后，进程可以修改自己的环境列表，这些修改对其他进程不可见。</p>
<p>　　环境变量的常见使用场景之一是shell。通过设置环境变量，shell可以保证对应的值会传递给它创建的用于执行用户命令行的进程。</p>
<p>　　有些库函数允许通过设置环境变量来修改其行为，这允许用户无需修改源码或重新链接对应的库，就能通过这些函数控制应用程序的行为。例如，库函数<code>getopt()</code>的行为会根据环境变量<code>POSIXLY_CORRECT</code>来改变。</p>
<p>　　有时，修改环境列表会很有用。第1个原因是对环境列表的修改对后续创建的子进程都是可见的。第2个原因是环境列表的修改对加载到该进程的内存的新程序是可见的。因此，除了用于进程间通信，环境列表还能用于程序间通信。</p>
<h3 id="进程的内存布局">6.1 进程的内存布局</h3>
<p>　　系统分配给进程的内存包含多个部分，通常称为<strong>段</strong>或<strong>节</strong>，包含<span
style="background-color: yellow">文本段</span>、<span
style="background-color: yellow">初始化数据段</span>、<span
style="background-color: yellow">未初始化数据段</span>、<span
style="background-color: yellow">栈</span>和<span
style="background-color: yellow">堆</span>。</p>
<p>　　●
文本段包含进程运行的程序的机器语言指令。文本段是只读的，所以进程无法通过指针来修改其中的指令。多个进程可能运行相同的程序，所以文本段是共享的
(程序代码的单个副本可以映射到多个进程的虚拟地址空间)。</p>
<p>　　●
初始化数据段包含显式初始化的全局变量和静态变量。当程序加载到内存时，会从可执行文件中读这些变量的值。此外，该段也称为<span
style="background-color: yellow">用户初始化数据段</span>。</p>
<p>　　●
未初始化数据段包含隐式初始化的全局变量和静态变量。在程序启动前，系统会将该段初始化为0。由于历史原因，该段也称为<code>bss</code>段，源自早期汇编器助记符
"block started by
symbol"。当程序存储在磁盘时，没必要为未初始化的数据分配空间。相反，可执行文件只需要记录未初始化数据段的位置和大小，并且这些空间由程序加载器在运行时分配。因此，才会用未初始化数据段来单独存储未初始化的全局变量和静态变量。此外，该段也称为<span
style="background-color: yellow">0初始化数据段</span>。</p>
<p>　　●
栈是包含栈帧的动态伸缩的段。系统会为所有当前被调用的函数分配栈帧，包含函数局部变量、参数和返回值。在C中，函数参数和局部变量称为<strong>自动变量</strong>，因为当函数创建时会自动创建这些变量。当函数返回时，自动变量会自动释放
(因为对应的栈帧已经被释放)。</p>
<p>　　●
堆是运行时为变量动态分配空间的区域。堆的顶端称为<strong>程序分段点</strong>。</p>
<p>　　可以通过命令<code>size</code>来展示二进制可执行文件的文本段、初始化数据段和未初始化数据段的大小。</p>
<p>　　<strong>应用程序二进制接口</strong>是用于指定二进制可执行文件在运行时如何与某些服务
(例如，内核或库)
交换信息的一组规则。ABI还指定了哪些寄存器或栈位置用于交换信息和交换的值的含义。一旦编译器使用了特定ABI，生成的二进制可执行文件可以运行在所有提供了该ABI的系统。这与仅保证应用程序源码的可移植性的标准化API
(例如，SUSv3) 形成对比。</p>
<p>　　在之后的内容中，有些库函数会返回指向静态分配的内存的指针，也就是初始化数据段和未初始化数据段。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mem_segments.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> globBuf[<span class="number">65536</span>];         <span class="comment">/* 未初始化数据段 */</span></span><br><span class="line"><span class="type">int</span> primes[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;; <span class="comment">/* 初始化数据段 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">/* 在square()的栈帧中分配空间 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result; <span class="comment">/* 在square()的栈帧中分配空间 */</span></span><br><span class="line">    result = x * x;</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">/* 返回值通过寄存器传递 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">doCalc</span><span class="params">(<span class="type">int</span> val)</span> <span class="comment">/* doCalc()的栈帧中分配空间 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The square of %d is %d\n&quot;</span>, val, square(val));</span><br><span class="line">    <span class="keyword">if</span> (val &lt; <span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t; <span class="comment">/* doCalc()的栈帧中分配空间 */</span></span><br><span class="line">        t = val * val * val;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The cube of %d is %d\n&quot;</span>, val, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> <span class="comment">/* 在main()的栈帧中分配空间 */</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> key = <span class="number">9973</span>;      <span class="comment">/* 初始化数据段 */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> mbuf[<span class="number">10240000</span>]; <span class="comment">/* 未初始化数据段 */</span></span><br><span class="line">    <span class="type">char</span> *p;                    <span class="comment">/* 在主函数的栈帧中分配空间 */</span></span><br><span class="line">    p = <span class="built_in">malloc</span>(<span class="number">1024</span>);           <span class="comment">/* 指向堆的指针 */</span></span><br><span class="line">    doCalc(key);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了各种C变量所在的段。这里展示的情况是基于编译器不执行优化和程序仅通过栈传递参数。当使用编译器优化后，可能会将频繁使用的变量存储在寄存器中，甚至直接优化到不存在。此外，有些ABI要求函数参数和结果通过寄存器传递。</p>
<p>　　Linux等大多数UNIX实现都提供了全局符号<code>etext</code>、<code>edata</code>和<code>end</code>
(SUSv3并未说明这些符号)。这些符号可以在程序中用于获取文本段的下1个字节的起始地址
(对应<code>etext</code>)、未初始化数据段的下1个字节的起始地址
(对应<code>edata</code>) 和初始化数据段的下1个字节的起始地址
(对应<code>end</code>)。为了使用这些符号，需要显式声明它们：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> etext, edata, end;</span><br></pre></td></tr></table></figure>
<p>　　然后，可以通过<code>&amp;etext</code>来获取文本段的结束地址/初始化数据段的起始地址。</p>
<img src="/2024/10/21/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-6/typical_memory_layout_of_a_process_on_linux.svg" class="" title="typical_memory_layout_of_a_process_on_linux">
<p>　　如图所示，这是x86-32架构的各种内存段的布局。程序的命令行参数存储在<code>argv</code>和<code>environ</code>
(可以通过主函数的参数<code>argv</code>访问)。图中所示的十六进制地址可能因内核配置和程序链接选项而异。灰色部分表示程序虚拟地址空间中的无效区域，即这些区域的页表还未创建。</p>
<h3 id="虚拟内存管理">6.2 虚拟内存管理</h3>
<p>　　与大多数现代内核相同，Linux使用<strong>虚拟内存管理</strong>。虚拟内存管理通过充分利用<span
style="background-color: yellow">引用局部性</span>来提升CPU和RAM
(物理内存)
的效率。大多数程序都有2种局部性，即<strong>空间局部性</strong>和<strong>时间局部性</strong>。空间局部性是程序<span
style="background-color: yellow">访问最近访问过的内存地址附近的内存地址</span>的趋势
(由于指令和数据结构的顺序处理)。时间局部性是程序<span
style="background-color: yellow">访问最近访问过的内存地址</span>的趋势
(由于循环)。</p>
<p>　　引用局部性使得在程序运行时仅在RAM中维护其部分地址空间成为可能。</p>
<img src="/2024/10/21/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-6/overview_of_virtual_memory.svg" class="" title="overview_of_virtual_memory">
<p>　　程序使用的内存划分为称为<strong>页</strong>的大小固定的单元。相应地，RAM也划分为相同大小的<strong>页帧</strong>。在任何时刻，仅需要程序的部分页驻留在页帧中，这些页称为<strong>驻留集</strong>。程序未使用的页的副本维护在<strong>交换空间</strong>中
(交换空间是磁盘空间中的预留区域，用于补充RAM)，仅在有需要时才会加载到物理内存。当程序引用的页未驻留在物理内存中时，会出现<strong>缺页</strong>，缺页处理程序会将对应的页加载到内存
(在此过程中，内核会挂起程序)。</p>
<p>　　对于x86-32，页大小是4096字节。部分其他Linux实现使用的页更大。例如，Alpha的页大小是8192字节，IA-64的页大小是可变的
(默认是16384字节)。程序可以通过调用<code>sysconf(_SC_PAGESIZE)</code>来得到页大小。</p>
<p>　　为了支持虚拟内存，内核会为每个进程都维护<strong>页表</strong>。页表描述了进程的每个页在<strong>虚拟地址空间</strong>
(进程可用的虚拟内存页的集合)
中的位置。页表中的每个条目都表示虚拟页在RAM中的位置，或者虚拟页当前在磁盘上。通常，虚拟地址空间中的很多虚拟页都是<span
style="background-color: yellow">未使用</span>的，所以无需为它们维护页表条目。当进程试图访问没有对应页表条目的地址时，会收到信号<code>SIGSEGV</code>。</p>
<p>　　在进程的生命周期内，其有效虚拟地址集不是固定的，因为内核会给进程分配和取消分配页
(和页表条目)。当<span
style="background-color: yellow">栈向下增长到临界值</span>，<span
style="background-color: yellow">在堆上分配和释放空间</span>
(通过<code>brk()</code>、<code>sbrk()</code>和<code>malloc()</code>等函数)，<span
style="background-color: yellow">连接和分离System V共享内存区域</span>
(通过函数<code>shmat()</code>和<code>shmdt()</code>) 以及<span
style="background-color: yellow">创建内存映射和取消内存映射</span>时，就会出现这种情况。</p>
<p>　　虚拟内存的实现需要<strong>分页式内存管理单元</strong>形式的硬件支持。PMMU会将虚拟内存地址引用转换为对应的物理内存地址，并且会在虚拟内存地址对应的页没有驻留在RAM中时通知内核出现了缺页。</p>
<p>　　虚拟内存管理将进程的虚拟地址空间与RAM的物理地址空间分开，这有如下优势：</p>
<p>　　●
进程彼此隔离，并且也与内核隔离，所以进程无法读或修改其他进程或内核的内存
(使每个进程的页表条目都指向RAM或交换空间中的不同物理页)。</p>
<p>　　● 当有需要时，多个进程可以共享内存
(使不同进程的页表条目指向RAM中的相同物理页)。通常，有2种情况会需要内存共享。第1种情况是多个运行相同程序的进程会共享相同的程序代码副本，这种共享是隐式的。第2种情况是进程通过系统调用<code>shmget()</code>和<code>mmap()</code>来显式地请求共享其他进程的内存区域
(为了进程间通信)。</p>
<p>　　● 有助于实现进程保护
(可以通过标记页表条目来指示对应内容的访问权限)。当多个进程共享RAM中的物理页时，可以为每个进程指定不同的访问权限。</p>
<p>　　● 程序员和工具 (例如，编译程序和链接程序)
无需关注程序在RAM中物理布局。</p>
<p>　　●
因为仅需要程序的一部分驻留在内存中，所以程序的加载速度和运行速度更快。此外，这使得进程的虚拟内存容量大于RAM容量成为可能。</p>
<p>　　●
因为每个进程使用了更少的RAM，所以RAM中可以驻留更多的进程。同样，因为增加了CPU在任何时刻至少执行1个进程的可能，所以提高了CPU利用率。</p>
<h3 id="栈和栈帧">6.3 栈和栈帧</h3>
<p>　　栈会随着函数调用和返回而伸缩。对于Linux/x86-32
(和大多数其他Linux和UNIX实现)，栈位于高地址处，并且向下增长
(栈的实际方向是硬件实现细节。Linux实现HP
PA-RISC使用的就是向下增长的栈)。特殊寄存器<strong>栈指针</strong>总是指向栈顶。当调用函数时，会在栈中分配1个栈帧；当函数返回时，会释放对应的栈帧。</p>
<p>　　从虚拟内存角度，栈的大小会随着栈帧的分配而增加。在大多数实现中，其大小不会随着栈帧的释放而减少，对应的内存会直接在分配栈帧时重新使用。之前所说的栈会随着栈帧的分配和释放而伸缩是从逻辑角度。</p>
<p>　　<span
style="background-color: yellow">内核栈</span>是系统为每个进程在内核内存中维护对应的内存区域，用于系统调用执行期间内部函数调用的栈。</p>
<p>　　除了之前介绍的栈和内核栈，还有<span
style="background-color: yellow">用户栈</span>。用户栈包含自动变量和调用链信息。每个函数都会使用特定的CPU寄存器
(例如，指向下1条待执行的机器语言指令的程序计数器)。当调用函数时，这些寄存器的副本会保存在被调函数的栈帧中，以便于在函数返回时恢复调用函数的寄存器值。</p>
<p>　　因为函数可以调用函数，所以栈中可以有多个栈帧
(若函数递归调用自己，则栈中会出现多个该函数的栈帧)。</p>
<img src="/2024/10/21/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-6/example_of_a_process_stack.svg" class="" title="example_of_a_process_stack">
<p>　　如图所示，这是6.1中的<code>mem_segments.c</code>的函数<code>square</code>执行期间栈的情况。</p>
<h3 id="命令行参数">6.4 命令行参数</h3>
<p>　　当执行程序时，命令行参数 (shell解析的单个词语)
可以通过主函数的参数访问。第1个参数是<code>int argc</code>，该参数是命令行参数的数量。第2个参数是<code>char *argv[]</code>，该参数是数组，除了最后1个元素是空指针之外，其他元素都是以<code>null</code>字符结尾的字符串。<code>argv[0]</code>通常是函数名。</p>
<p>　　<code>argv[0]</code>可以用于到相同程序的多个链接
(即名称)，并且根据调用的链接来执行不同的操作。例如，命令<code>gzip</code>、<code>gunzip</code>和<code>zcat</code>链接的可执行文件相同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* necho.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, j, argv[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2024/10/21/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-6/values_of_argc_and_argv_for_the_command_necho_hello_world.svg" class="" title="values_of_argc_and_argv_for_the_command_necho_hello_world">
<p>　　这个示例会以每行1个参数的形式回显命令行参数。</p>
<p>　　因为<code>argv</code>以<code>NULL</code>结尾，所以可以通过如下方式来迭代命令行参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> **p;</span><br><span class="line"><span class="keyword">for</span> (p = argv; *p; p++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(*p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　参数<code>argc</code>和<code>argv</code>仅限于主函数。若需要在其他函数中使用命令行参数，则需要将<code>argv</code>作为参数传递或使用指向<code>argv</code>的全局指针。</p>
<p>　　任何进程的命令行参数都可以通过特定于Linux的文件<code>/proc/PID/cmdline</code>来获取，其中的参数以<code>null</code>字节结尾
(进程可以通过文件<code>/proc/self/cmdline</code>来访问自己的命令行参数)。</p>
<p>　　GNU C标准库提供了2个全局变量来获取用于执行程序的名称
(即<code>argv[0]</code>)，即<code>program_invocation_name</code>和<code>program_invocation_short_name</code>。前者提供用于执行程序的完整路径名，而后者则去除了目录前缀。若需要使用这2个全局变量，则需要定义宏<code>_GNU_SOURCE</code>，这2个全局变量就可以通过头文件<code>error.h</code>获取。</p>
<p>　　如6.1中的图所示，数组<code>argv</code>和<code>environ</code>以及它们最初指向的字符串占据单独的内存区域。该区域的容量上限可以存储在该区域。对于SUSv3，该上限通过常量<code>ARG_MAX</code>或调用<code>sysconf(_SC_ARG_MAX)</code>来获取。SUSv3还要求<code>ARG_MAX</code>的最小值是<code>_POSIX_ARG_MAX</code>
(即4096)。大部分UNIX实现允许更高的上限。SUSv3并未说明实现在计算<code>ARG_MAX</code>时否需要包含开销字节
(即结尾的<code>null</code>字节、对齐字节以及<code>argv</code>和<code>environ</code>数组的指针)。</p>
<p>　　从历史角度，Linux的<code>ARG_MAX</code>固定为32页
(即Linux/x86-32上的131072字节)，并且包括开销字节。从内核2.6.23开始，数组<code>argv</code>和<code>environ</code>所处内存区域的限制可以通过资源限制<code>RLIMIT_STACK</code>来控制，并且允许更大的限制，该限制计算为调用<code>execve()</code>时资源限制<code>RLIMIT_STACK</code>的软限制的<span
class="math inline">\(\frac{1}{4}\)</span>。</p>
<p>　　很多程序都是通过库函数<code>getopt()</code>来解析命令行选项
(即以连字符<code>-</code>开头的参数)。</p>
<h3 id="环境列表">6.5 环境列表</h3>
<p>　　对于大多数shell，可以通过命令<code>export</code>来为添加环境变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL=/bin/bash</span><br><span class="line">export SHELL</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，第1行命令会创建变量<code>SHELL</code>，第2行命令会将该变量添加到shell进程的环境列表中。对于<code>bash</code>和<code>ksh</code>，这2行命令可以缩写为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export SHELL=/bin/bash</span><br></pre></td></tr></table></figure>
<p>　　对于<code>csh</code>，可以通过命令<code>setenv</code>来设置环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setenv SHELL /bin/bash</span><br></pre></td></tr></table></figure>
<p>　　环境变量可以通过命令<code>unset</code>移除
(<code>csh</code>中的命令<code>unsetenv</code>)。</p>
<p>　　对于<code>sh</code>及其继承者
(例如，<code>bash</code>和<code>ksh</code>)，以下语法可用于在执行程序时为执行程序的进程创建环境变量
(不会影响shell)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME=value program1 program2</span><br></pre></td></tr></table></figure>
<p>　　命令<code>printenv</code>可用于获取当前环境列表。</p>
<p>　　任何进程的环境列表都可以通过特定于Linux的文件<code>/proc/PID/environ</code>来获取
(形如<code>NAME=value</code>，并且以<code>null</code>字节结尾)。</p>
<h4 id="在程序中访问环境列表">6.5.1 在程序中访问环境列表</h4>
<p>　　在C程序中，环境列表可以通过全局变量<code>char **environ</code>
(C运行时启动代码会定义该变量，并且会将环境列表的地址赋值给它)。与<code>argv</code>类似，<code>environ</code>是数组，除了最后1个元素是空指针之外，其他元素都是以<code>null</code>字符结尾的字符串。</p>
<img src="/2024/10/21/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-6/example_of_process_environment_list_data_structures.svg" class="" title="example_of_process_environment_list_data_structures">
<p>　　如图所示，这是命令<code>printenv</code>展示的环境列表对应的数据结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* display_env.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> **ep;</span><br><span class="line">    <span class="keyword">for</span> (ep = environ; *ep; ep++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(*ep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会通过访问<code>environ</code>来列出进程的所有环境变量，其输出与命令<code>printenv</code>的相同。</p>
<p>　　还可以通过声明主函数的第3个参数来访问环境列表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *envp[])</span></span><br></pre></td></tr></table></figure>
<p>　　参数<code>envp</code>的用法与<code>environ</code>的相同，但仅限于主函数。尽管该功能广泛实现于UNIX系统，但还是应该避免使用，因为SUSv3并未说明该功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 若环境变量存在则返回对应值；若不存在则返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　对于给定名称的环境变量，<code>getenv()</code>会返回对应值
(字符串)。若环境变量不存在，则返回<code>NULL</code>。</p>
<p>　　● SUSv3明确指出，应用程序<span
style="background-color: yellow">不应该</span>修改<code>getenv()</code>返回的字符串，因为该字符串实际上就是环境列表的一部分
(对于大部分实现)。</p>
<p>　　●
SUSv3允许<code>getenv()</code>实现返回的字符串使用静态分配的缓冲区，但静态缓冲区可能被后续的<code>getenv()</code>、<code>setenv()</code>、<code>putenv()</code>或<code>unsetenv()</code>调用覆盖。尽管<code>glibc</code>的<code>getenv()</code>实现不以这种方式使用静态缓冲区，为了例保证可移植性，还是应该在后续调用这些函数前将<code>getenv()</code>返回的字符串复制到其他位置。</p>
<h4 id="修改环境列表">6.5.2 修改环境列表</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span>; <span class="comment">/* 若成功则返回0，若出错则返回非0值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> overwrite)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>putenv()</code>会创建环境变量，或者修改已有的环境变量
(若存在)。参数<code>string</code>是形如<code>name=value</code>的字符串。在调用<code>putenv()</code>后，<code>string</code>会成环境变量的一部分
(并非复制<code>string</code>，而是直接将其赋值给环境列表中的元素)，即后续对<code>string</code>的修改会直接应用到环境变量。因此，<code>string</code>不能是自动变量
(当定义该变量的函数返回后，存储自动变量的内存区域可能会被覆盖)。若<code>putenv()</code>出错，则返回<span
style="background-color: yellow">非0值</span>。</p>
<p>　　<code>glibc</code>的<code>putenv()</code>实现提供了非标准扩展。若<code>string</code>不包含等号<code>=</code>，则会从环境列表中移除名称为<code>string</code>的环境变量。</p>
<p>　　函数<code>setenv()</code>会通过为形如<code>name=value</code>的字符串分配内存缓冲区来创建环境变量，然后将参数<code>name</code>和<code>value</code>复制到该缓冲区
(不同于<code>putenv()</code>，后续对<code>name</code>和<code>value</code>的修改不会应用到环境变量，所以这2个参数可以是自动变量)。只有当参数<code>overwrite</code>非0时，才会覆盖已有的环境变量。</p>
<p>　　函数<code>unsetenv()</code>会移除名为参数<code>name</code>的环境变量。与<code>setenv()</code>相同，<code>name</code>不应该包含等号。</p>
<p>　　<code>setenv()</code>和<code>unsetenv</code>源于BSD，它们的使用率不如<code>putenv()</code>。POSIX.1和SUSv2没有说明这2个函数，但SUSv3详细说明了它们。对于<code>glibc</code>
2.2.2之前的版本，<code>unsetenv()</code>的返回值类型是<code>void</code>，这也是该函数在BSD中的返回值类型，并且部分UNIX实现依然如此。</p>
<p>　　有时，可能需要清空环境列表，可以直接将<code>NULL</code>赋值给<code>environ</code>，这也是库函数<code>clearenv()</code>执行的步骤。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE <span class="comment">/* 或#define _SVID_SOURCE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">clearenv</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 若成功则返回0，若出错则返回非0值 */</span></span><br></pre></td></tr></table></figure>
<p>　　在部分情况下，<code>setenv()</code>和<code>clearenv()</code>一起使用会导致内存泄漏。<code>setenv()</code>会分配内存缓冲区，并会将其作为环境变量的一部分。调用<code>clearenv()</code>时，不会释放缓冲区。在实际中，通常不会这样使用，因为一般仅会在开始时调用<code>clearenv()</code>，或者用于清空继承的环境列表。</p>
<p>　　SUSv3并未说明<code>clearenv()</code>，但很多UNIX实现都提供了该函数。SUSv3指出，若应用程序直接修改<code>environ</code>
(正如<code>clearenv()</code>所作)，则<code>setenv()</code>、<code>unsetenv()</code>和<code>getenv()</code>的行为将会是未定义的
(防止符合规范的应用程序通过修改环境列表来完全控制实现环境变量的数据结构)。SUSv3要求应用程序只能通过先获取所有环境变量，再对其逐个调用<code>unsetenv()</code>的方式来清空环境列表。</p>
<h4 id="示例程序">6.5.3 示例程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">char</span> **ep;</span><br><span class="line"></span><br><span class="line">    clearenv();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (putenv(argv[j]) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;putenv: %s&quot;</span>, argv[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setenv(<span class="string">&quot;GREET&quot;</span>, <span class="string">&quot;Hello world&quot;</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;setenv&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsetenv(<span class="string">&quot;BYE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ep = environ; *ep; ep++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(*ep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是之前介绍的函数的用法示例。在第1次清空环境列表后，该程序会创建命令行参数中定义的环境变量。然后，创建环境变量<code>GTEET</code>
(若不存在)，并且移除环境变量<code>BYE</code>。最后，打印当前环境列表。</p>
<h3 id="非本地跳转">6.6 非本地跳转</h3>
<p>　　库函数<code>setjmp()</code>和<code>longjmp()</code>用于执行<strong>非本地跳转</strong>
(非本地表示跳转目标在当前执行的函数之外)。</p>
<p>　　与其他编程语言相同，C提供了跳转语句。跳转语句更容易使程序难以阅读和维护，但有时也会使程序更高效和/或简洁。</p>
<p>　　无法从当前执行的函数跳转到其他函数是C跳转的限制之一。但是，该功能有时可能很有用。考虑如下错误处理场景：在多层嵌套的函数执行期间遇到了错误，处理方法是放弃当前执行的任务，经过多个函数返回，然后继续执行更高层的函数
(甚至高于主函数)。为了完成这些，需要让每个函数都返回合适的返回值。这是完全合理的，在很多情况下，这是理想的处理方法。但是，在有些情况下，直接从嵌套函数的中间跳转到调用它的函数
(调用函数、调用函数的调用函数，依此类推)
会让代码更简洁，这正是<code>setjmp()</code>和<code>longjmp()</code>提供的功能。</p>
<p>　　对于C，无法在函数之间跳转的原因是所有的C函数都在相同的作用域
(标准C中没有函数声明的嵌套，尽管<code>gcc</code>支持这种方式)。因此，对于函数X和Y，编译器无法得知在调用函数Y时函数X的栈帧是否在栈中
(即无法得知能否从函数Y跳转到函数X)。对于Pascal等编程语言，允许函数声明嵌套和从嵌套函数跳转到包含它的函数，并且函数的静态作用域允许编译器确定一些动态作用域的信息。若函数Y在词法上嵌套在函数X中，则编译器会知道当调用函数Y时函数X的栈帧必定在栈中，并且能生成从函数Y跳转函数X的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>; <span class="comment">/* 若第1次调用则返回0；若通过longjmp()则返回非0值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure>
<p>　　调用<code>setjmp()</code>会为后续的<code>longjmp()</code>执行的跳转设置目标
(即调用<code>setjmp()</code>的位置)。第1次调用<code>setjmp()</code>会返回0。在调用<code>longjmp()</code>后，<code>setjmp()</code>会像第2次调用它一样返回，返回值是<code>longjmp()</code>的参数<code>val</code>。通过为参数<code>val</code>指定不同的值，就可以区分不同跳转点。将参数<code>val</code>指定为0时，为了区分第1次调用<code>setjmp()</code>的返回值，<code>longjmp()</code>会将其替换为<span
style="background-color: yellow">1</span>。</p>
<p>　　<code>setjmp()</code>可以将当前进程的环境列表的各种信息存储在参数<code>env</code>中，<code>longjmp()</code>必须将参数<code>env</code>指定为相同的值。因为<code>setjmp()</code>的调用和<code>longjmp()</code>的调用在不同的函数，参数<code>env</code>需要声明为全局变量，或者作为函数参数。</p>
<p>　　参数<code>env</code>还存储着调用<code>setjmp()</code>时<span
style="background-color: yellow">程序计数器</span>和<span
style="background-color: yellow">栈指针</span>的副本。这些信息允许后续的<code>longjmp()</code>调用执完成2个关键的步骤：</p>
<p>　　●
去除栈上的<code>longjmp()</code>调用之间和<code>setjmp()</code>调用之前的无关函数的栈帧。该过程有时称为<span
style="background-color: yellow">展开栈</span>，通过将栈指针重置为<code>env</code>中保存的值来完成。</p>
<p>　　●
通过重置程序计数器来让程序从第1次调用<code>setjmp()</code>的位置执行。同样，这也是通过<code>env</code>中保存的值来完成。</p>
<p>　　若跳转语句会让程序变得难以阅读，则非本地跳转会严重加剧这一点，因为非本地跳转能够在任意2个函数之间进行控制转移。因此，应该尽量不使用非本地跳转。</p>
<h4 id="示例程序-1">6.6.1 示例程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* longjmp.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> jmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    longjmp(env, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> argc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        longjmp(env, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    f2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (setjmp(env))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Calling f1() after initial setjmp()\n&quot;</span>);</span><br><span class="line">        f1(argc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;We jumped back from f1()\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;We jumped back from f2()\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是<code>setjmp()</code>和<code>longjmp()</code>的用法示例。该程序会在第1次调用<code>setjmp()</code>来设置跳转目标。后续的<code>switch</code>语句会根据<code>setjmp()</code>返回值来执行不同的操作。若返回值是0
(表示第1次调用<code>setjmp()</code>)，则会调用<code>f1()</code>，而<code>f1()</code>会根据<code>argc</code>来调用<code>longjmp()</code>或<code>f2()</code>。若执行到<code>f2()</code>，则会调用<code>longjmp()</code>。<code>longjmp()</code>会执行非本地跳转。</p>
<h4 id="setjmp的限制">6.6.2 <code>setjmp()</code>的限制</h4>
<p>　　SUSv3和C99指出，只能在以下上下文中调用<code>setjmp()</code>：</p>
<p>　　● 作为选择或迭代语句
(例如，<code>if</code>、<code>switch</code>和<code>while</code>)
的完整控制表达式。</p>
<p>　　●
作为一元运算符<code>!</code>的操作数，其结果表达式是选择或迭代语句的完整控制表达式。</p>
<p>　　● 作为比较操作
(例如，<code>==</code>、<code>!=</code>和<code>&lt;</code>)
的一部分，其他操作数是整数常量表达式，并且结果表达式是选择或迭代语句的完整控制表达式。</p>
<p>　　● 作为未嵌入到较大表达式中的独立函数调用。</p>
<p>　　显然，赋值语句并不在以上范围，<code>s = setjmp(env)</code>不符合规范。</p>
<p>　　若将<code>setjmp()</code>作为常规函数来实现，则无法保证有足够的信息来保存封闭表达式所使用的所有寄存器和临时栈位置的值
(用于后续调用<code>longjmp()</code>时恢复)。因此，仅允许在不需要临时存储的表达式中调用<code>setjmp()</code>。</p>
<h4 id="longjmp滥用">6.6.3 <code>longjmp()</code>滥用</h4>
<p>　　若将缓存区<code>env</code>声明为全局变量，则可能会按以下步骤执行：</p>
<p>　　1)
调用函数<code>x()</code>，<code>x()</code>会通过<code>setjmp()</code>来在全局变量<code>env</code>中设置跳转目标。</p>
<p>　　2) 从<code>x()</code>返回。</p>
<p>　　3)
调用函数<code>y()</code>，<code>y()</code>会通过<code>env</code>来调用<code>longjmp()</code>。</p>
<p>　　这是很严重的错误，因为无法将已经返回的函数作为跳转目标。在这种情况下，<code>longjmp()</code>会试图展开栈来回到已经不存在的栈帧。若足够幸运，则程序会崩溃。但是，根据栈的状态，其他可能的结果包括无限调用-返回循环和程序的行为如同其真的从已经结束的函数返回
(对于多线程程序，类似的滥用行为是<code>setjmp()</code>的调用和<code>longjmp()</code>的调用在不同的线程)。</p>
<p>　　SUSv3指出，若在嵌套的信号处理程序中调用<code>longjmp()</code>
(即在信号处理程序中调用其他信号处理程序)，则程序的行为将会是未定义的。</p>
<h4 id="编译器优化问题">6.6.4 编译器优化问题</h4>
<p>　　若使用编译器优化，则可能会改变程序的指令执行顺序和将不使用编译器优化时存储在RAM的变量存储在寄存器中。这些优化通常依赖于反映程序词法结构的运行时控制流。因为通过<code>setjmp()</code>和<code>longjmp()</code>执行的跳转操作在运行时生成和执行，并且不会反映在程序词法结构上，执行编译器优化时不会考虑它们。此外，部分ABI实现的语义要求<code>longjmp()</code>恢复调用<code>setjmp()</code>时保存的寄存器副本。这表示<code>longjmp()</code>可能会让优化后的变量最终取得错误的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* setjmp_vars.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> jmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">doJump</span><span class="params">(<span class="type">int</span> nvar, <span class="type">int</span> rvar, <span class="type">int</span> vvar)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Inside doJump(): nvar=%d rvar=%d vvar=%d\n&quot;</span>, nvar, rvar, vvar);</span><br><span class="line">    longjmp(env, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nvar;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> rvar; <span class="comment">/* 在可能的情况下分配在寄存器中 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> vvar;</span><br><span class="line"></span><br><span class="line">    nvar = <span class="number">111</span>;</span><br><span class="line">    rvar = <span class="number">222</span>;</span><br><span class="line">    vvar = <span class="number">333</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setjmp(env) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* setjmp()后执行 */</span></span><br><span class="line">        nvar = <span class="number">777</span>;</span><br><span class="line">        rvar = <span class="number">888</span>;</span><br><span class="line">        vvar = <span class="number">999</span>;</span><br><span class="line">        doJump(nvar, rvar, vvar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* longjmp()后执行 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After longjmp(): nvar=%d rvar=%d vvar=%d\n&quot;</span>, nvar, rvar, vvar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　当正常编译这个程序时，会得到预期的输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cc -o setjmp_vars setjmp_vars.c</span><br><span class="line">./setjmp_vars</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inside doJump(): nvar=777 rvar=888 vvar=999</span><br><span class="line">After longjmp(): nvar=777 rvar=888 vvar=999</span><br></pre></td></tr></table></figure>
<p>　　但是，在使用编译器优化后，会得到意料之外的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cc -O -o setjmp_vars setjmp_vars.c</span><br><span class="line">./setjmp_vars</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inside doJump(): nvar=777 rvar=888 vvar=999</span><br><span class="line">After longjmp(): nvar=111 rvar=222 vvar=999</span><br></pre></td></tr></table></figure>
<p>　　在<code>longjmp()</code>执行完成后，<code>nvar</code>和<code>rvar</code>的值重置为调用<code>setjmp()</code>之前的值。这是因为编译器执行的代码重组由于<code>longjmp()</code>而混乱。所有可能作为优化对象的局部变量
(通常指指针、<code>char</code>、<code>int</code>、<code>float</code>和<code>long</code>)
都可能会遇到这个问题。</p>
<p>　　可以通过将变量声明为<code>volatile</code>
(告诉编译器不对该变量使用优化)
来解决这个问题。在示例程序中，<code>vvar</code>就声明为<code>volatile</code>，所以它的值是正确的。</p>
<p>　　因为不同编译器使用的优化类型不同，为了保证可移植性，应该将调用<code>setjmp()</code>的函数中的可能成为优化对象的局部变量都声明为<code>volatile</code>。</p>
<p>　　若对GNU C编译器使用选项<code>-Wextra</code>
(额外的警告)，则会生成如下警告：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cc -Wall -Wextra -O -o setjmp_vars setjmp_vars.c</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setjmp_vars.c: In function &#x27;main&#x27;:</span><br><span class="line">setjmp_vars.c:16: warning: variable &#x27;nvar&#x27; might be clobbered by &#x27;longjmp&#x27; or &#x27;vfork&#x27;</span><br><span class="line">setjmp_vars.c:17: warning: variable &#x27;rvar&#x27; might be clobbered by &#x27;longjmp&#x27; or &#x27;vfork&#x27;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第7章 内存分配</title>
    <url>/2024/10/29/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-7/</url>
    <content><![CDATA[<p>　　程序分段点最初位于未初始化数据段的末尾
(即<code>&amp;end</code>)。当程序分段点增加后，程序能访问新分配区域的所有地址，但对应的物理内存页并非在此时分配。当程序<span
style="background-color: yellow">第1次访问该区域内的地址</span>时，内核才会分配对应的物理页。</p>
<p>　　程序分段点的上限由多个因素决定，包括<span
style="background-color: yellow">进程的数据段大小的资源限制</span>
(即<code>RLIMIT_DATA</code>) 以及<span
style="background-color: yellow">内存映射、共享内存段和共享库的位置</span>。</p>
<p>　　UNIX系统历来提供了2个用于控制程序分段点的系统调用，即<code>brk()</code>和<code>sbrk()</code>。Linux也提供了这2个系统调用。但是，这2个系统调用很少直接调用。</p>
<p>　　当程序分配的堆内存由于某种原因未释放或无法释放时，堆会持续增长，直到达到可用虚拟内存的上限，此时，后续的堆内存分配请求会失败。这种情况称为<strong>内存泄漏</strong>。</p>
<h3 id="在堆上分配内存">7.1 在堆上分配内存</h3>
<p>　　进程可以通过扩大堆来分配内存
(见6.1)，这通常使用<code>malloc</code>系列函数来完成，而<code>malloc</code>系统函数基于系统调用<code>brk()</code>和<code>sbrk()</code>。</p>
<h4 id="调整程序分段点">7.1.1 调整程序分段点</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">brk</span><span class="params">(<span class="type">void</span> *end_data_segment)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> increment)</span>; <span class="comment">/* 若成功则返回程序分段点的旧值，若出错则返回(void *)-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>brk()</code>会将程序分段点设置为参数<code>end_data_segment</code>指定的位置。由于虚拟内存以页为单位，所以<code>end_data_segment</code>会向上取整为下一页的起始地址。</p>
<p>　　若<code>end_data_segment</code>小于程序分段点的初始值，则可能会导致无法预测的行为。例如，当访问不属于初始化数据段或未初始化数据段的数据时，会出现段错误
(信号<code>SIGSEGV</code>)。</p>
<p>　　系统调用<code>sbrk()</code>会将程序分段点增加<code>increment</code>。<code>increment</code>的类型<code>intptr_t</code>是整型数据类型。若<code>sbrk()</code>正常运行，则返回程序分段点的旧值，即新分配的内存块的起始位置。对于Linux，<code>sbrk()</code>是基于<code>brk()</code>的库函数。</p>
<p>　　<code>sbrk(0)</code>会返回程序分段点的当前值。当需要获取堆的大小时，这会很有用
(也许是为了监视内存分配包的行为)。</p>
<p>　　SUSv2详细说明了<code>brk()</code>和<code>sbrk()</code>
(将它们标记为LEGACY)，但SUSv3没有说明它们。</p>
<span id="more"></span>
<h4 id="malloc和free">7.1.2
<code>malloc()</code>和<code>free()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>; <span class="comment">/* 若成功则返回指向新内存块的指针，若出错则返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>malloc()</code>会从堆中分配<code>size</code>字节的内存块
(不会初始化)，返回值是指向新内存块的指针。</p>
<p>　　<code>malloc()</code>的返回值类型是<code>void *</code>，所以可以将其赋值给所有类型的指针。此外，<code>malloc()</code>分配的内存块会自动对齐，通常按8B或16B对齐。</p>
<p>　　SUSv3指出，<code>malloc(0)</code>会返回<code>NULL</code>，或者指向较小的内存块的指针。对于Linux，<code>malloc(0)</code>的行为遵从后者。</p>
<p>　　若<code>malloc()</code>的请求的内存块无法分配，则会返回<code>NULL</code>，并且将<code>errno</code>设置为对应的值。尽管出现这种情况的可能性很小，但还是应该检查<code>malloc()</code>的返回值。</p>
<p>　　函数<code>free()</code>会释放参数<code>ptr</code>指向的在堆上分配的内存块。通常，<code>free()</code>不会减少程序分段点，而是将<code>ptr</code>指向的内存块添加到用于后续<code>malloc()</code>调用的
(双向) 空闲内存块链表。这样做有如下原因：</p>
<p>　　●
待释放的内存块通常位于堆的中间，所以减少程序分段点是不可能的。</p>
<p>　　● 这可以最小化必须的<code>sbrk()</code>的调用次数
(在3.1中提到过，大多数系统调用的耗时都很长)。</p>
<p>　　●
在很多情况下，减少程序分段点对需要分配大量内存的程序没有帮助，因为这些程序通常会长时间占用内存或重复分配和释放内存
(而非一次释放所有内存，然后运行较长时间)。</p>
<p>　　当<code>ptr</code>是<code>NULL</code>时，<code>free()</code>不会执行任何操作，即<span
style="background-color: yellow">不会反馈错误</span>。调用<code>free()</code>后，再次使用<code>ptr</code>会导致错误，产生无法预测的结果。</p>
<p>　　当进程终止时，它的所有内存都会被系统释放，包括通过<code>malloc</code>包分配的堆内存。对于那些在分配堆内存后一直使用的程序，通常不会调用<code>free()</code>，进程终止时的内存自动释放机制足以处理。进程终止时的内存自动释放机制对很多程序都是可以接受的，但显式释放堆内存仍然是值得考虑的，理由如下：</p>
<p>　　●
显式调用<code>free()</code>可能会让程序在后续修改时更易于阅读和维护。</p>
<p>　　●
当使用<code>malloc</code>调试库来检查内存泄漏时，所有未被显式释放的内存都会被反馈为内存泄漏。这可能会使确定
(真正的) 内存泄漏的任务更加困难。</p>
<h5 id="malloc和free的实现">7.1.2.1
<code>malloc()</code>和<code>free()</code>的实现</h5>
<img src="/2024/10/29/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-7/memory_block_returned_by_malloc.svg" class="" title="memory_block_returned_by_malloc">
<p>　　<code>malloc()</code>分配内存块时，实际分配的内存块除了包含要求的内存块
(即有效载荷) 之外，还包含1个用于表示内存块大小的位于<span
style="background-color: yellow">在内存块之前</span>的整数。</p>
<p>　　<code>malloc()</code>会先扫描空闲内存块链表来寻找大小不小于要求的内存块。扫描策略因实现而异常
(例如，首次适配和最佳适配)。若内存块的大小等于要求，则将其返回给调用者；若大于要求，则先进行分割，然后将符合要求的内存块返回给调用者
(更小的块留在空闲内存块链表)。</p>
<p>　　若空闲内存块链表中没有满足要求的内存块，则<code>malloc()</code>会调用<code>sbrk()</code>来分配更多内存。为了减少<code>sbrk()</code>的调用次数，<code>malloc()</code>调用<code>sbrk()</code>分配的内存的大小会大于要求
(虚拟内存页大小的整数倍)，然后将多余的内存放入空闲内存块链表。</p>
<img src="/2024/10/29/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-7/a_block_on_the_free_list.svg" class="" title="a_block_on_the_free_list">
<p>　　为了将内存块加入到空闲内存块链表，<code>free()</code>会使用内存块的有效载荷来存储前驱块指针和后继块指针。</p>
<img src="/2024/10/29/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-7/heap_containing_allocated_blocks_and_a_free_list.svg" class="" title="heap_containing_allocated_blocks_and_a_free_list">
<p>　　随着内存块的分配和释放，已分配的内存块和空闲内存块链表中的空闲内存块会混合在一起。</p>
<p>　　C允许创建指向堆中的任何位置的指针和修改它们指向的内容
(包括块长度、前驱块指针和后继块指针)，若使用不当，则很可能导致漏洞。为了避免这一问题，应当遵守以下规则：</p>
<p>　　● 当分配内存块后，应当避免使用该内存块之外的字节。</p>
<p>　　● 避免重复释放相同的内存块。</p>
<p>　　●
避免对不是通过<code>malloc</code>包中的函数获取的指针调用<code>free()</code>。</p>
<p>　　<code>glibc</code>提供了很多用于监控和控制<code>malloc</code>包的函数的非标准函数。函数<code>mallopt()</code>提供了多个用于控制<code>malloc()</code>使用的算法的参数。函数<code>mallinfo()</code>会返回关于<code>malloc()</code>分配的内存块的各种数据的结构体。很多UNIX实现都提供了这2个函数，但这些函数的实现因UNIX实现而异。</p>
<h5 id="malloc调试工具和库">7.1.2.2 <code>malloc</code>调试工具和库</h5>
<p>　　可以通过<code>malloc</code>调试库或<code>glibc</code>提供的<code>malloc</code>调试工具来定位堆内存漏洞。</p>
<p>　　<code>glibc</code>提供了如下<code>malloc</code>调试工具：</p>
<p>　　●
函数<code>mtrace()</code>和<code>muntrace()</code>允许程序启用或关闭对堆内存分配调用的追踪。这2个函数与环境变量<code>MALLOC_TRACE</code>一起使用，环境变量<code>MALLOC_TRACE</code>的定义需要包含用于写入追踪信息的文件的名称。当调用<code>mtrace()</code>时，会检查环境变量<code>MALLOC_TRACE</code>定义的文件是否存在以及对其是否拥有写权限。若是，则所有对<code>malloc</code>包的函数的调用都会被追踪和记录。由于写入的内容不易被人类读取，所以提供了脚本
(也称为<code>mtrace</code>)
来分析文件并生成可读的摘要。出于安全，set-user-ID和set-group-ID程序会忽略对<code>mtrace()</code>的调用。</p>
<p>　　●
函数<code>mcheck()</code>和<code>mprobe()</code>允许程序对已分配的内存块进行一致性检查
(例如，捕捉试图写已分配的内存块之外的位置的错误)。这些函数提供的功能与<code>glibc</code>调试库的重叠。使用这些函数的程序必须与<code>mcheck</code>库一起链接
(使用参数<code>cc -lmcheck</code>)。</p>
<p>　　●
环境变量<code>MALLOC_CHECK_</code>提供的功能与<code>mcheck()</code>和<code>mprobe()</code>的相似，但前者无需修改和重新编译程序。通过为环境变量<code>MALLOC_CHECK_</code>设置不同的值，可以控制程序如何响应堆内存分配错误。0表示忽略错误；1表示在<code>stderr</code>中打印诊断错误；2表示调用<code>abor()</code>来终止程序。这种方法无法检查所有堆内存错误，仅适用于检测<span
style="background-color: yellow">常见堆内存错误</span>。相比<code>malloc</code>调试工具，这种方法更高效和易于使用，并且成本更低。出于安全，set-user-ID和set-group-ID程序会忽略环境变量<code>MALLOC_CHECK_</code>的设置。</p>
<p>　　<code>malloc</code>调试库提供的API与标准<code>malloc</code>包的相同，但前者会执行额外的步骤来捕捉堆内存分配漏洞。为了使用<code>malloc</code>调试库，需要链接标准C库。因为该调试库通常以更慢的运行时操作速度和/或更大的内存消耗为代价，所以应该仅在调试时使用该库。该库包括<code>Electric Fence</code>、<code>dmalloc</code>、<code>Valgrind</code>和<code>Insure++</code>，其中<code>Valgrind</code>和<code>Insure++</code>可以检测多种与堆内存分配无关的错误。</p>
<h5 id="示例程序">7.1.2.3 示例程序</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* free_and_sbrk.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ALLOCS 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr[MAX_ALLOCS];</span><br><span class="line">    <span class="type">int</span> freeStep, freeMin, freeMax, blockSize, numAllocs, j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s num-allocs block-size [step [min [max]]]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numAllocs = getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">&quot;num-allocs&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (numAllocs &gt; MAX_ALLOCS)</span><br><span class="line">    &#123;</span><br><span class="line">        cmdLineErr(<span class="string">&quot;num-allocs &gt; %d\n&quot;</span>, MAX_ALLOCS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    blockSize = getInt(argv[<span class="number">2</span>], GN_GT_0 | GN_ANY_BASE, <span class="string">&quot;block-size&quot;</span>);</span><br><span class="line"></span><br><span class="line">    freeStep = (argc &gt; <span class="number">3</span>) ? getInt(argv[<span class="number">3</span>], GN_GT_0, <span class="string">&quot;step&quot;</span>) : <span class="number">1</span>;</span><br><span class="line">    freeMin = (argc &gt; <span class="number">4</span>) ? getInt(argv[<span class="number">4</span>], GN_GT_0, <span class="string">&quot;min&quot;</span>) : <span class="number">1</span>;</span><br><span class="line">    freeMax = (argc &gt; <span class="number">5</span>) ? getInt(argv[<span class="number">5</span>], GN_GT_0, <span class="string">&quot;max&quot;</span>) : numAllocs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (freeMax &gt; numAllocs)</span><br><span class="line">    &#123;</span><br><span class="line">        cmdLineErr(<span class="string">&quot;free-max &gt; num-allocs\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Initial program break: %10p\n&quot;</span>, sbrk(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Allocating %d*%d bytes\n&quot;</span>, numAllocs, blockSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numAllocs; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr[j] = <span class="built_in">malloc</span>(blockSize);</span><br><span class="line">        <span class="keyword">if</span> (ptr[j] == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Program break is now: %10p\n&quot;</span>, sbrk(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Freeing blocks from %d to %d in steps of %d\n&quot;</span>, freeMin, freeMax, freeStep);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = freeMin - <span class="number">1</span>; j &lt; freeMax; j += freeStep)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(ptr[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After free(), program break is: %10p\n&quot;</span>, sbrk(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>free()</code>对程序分段点的影响
(先分配多个内存块，再根据可选的命令行参数释放部分或全部内存块)。</p>
<p>　　第1个和第2个命令行参数分别指定内存块的数量和大小。第3个命令行参数指定释放内存块前执行的循环步长，若省略该参数或将其指定为1，则程序会释放所有内存块；若指定为2，则每隔1个内存块释放1个内存块；依此类推。第4个和第5个参数指定待分配块的范围，若忽略这2个参数，则释放所有符合第3个参数指定的要求的内存块。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./free_and_sbrk 1000 10240 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initial program break: 0x804a6bc</span><br><span class="line">Allocating 1000*10240 bytes</span><br><span class="line">Program break is now: 0x8a13000</span><br><span class="line">Freeing blocks from 1 to 1000 in steps of 2</span><br><span class="line">After free(), program break is: 0x8a13000</span><br></pre></td></tr></table></figure>
<p>　　在这段输出中，当释放所有指定的内存块后，程序分段点依旧处于峰值
(即分配所有指定内存块时所达到的值)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./free_and_sbrk 1000 10240 1 500 1000</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initial program break: 0x804a6bc</span><br><span class="line">Allocating 1000*10240 bytes</span><br><span class="line">Program break is now: 0x8a13000</span><br><span class="line">Freeing blocks from 500 to 1000 in steps of 1</span><br><span class="line">After free(), program break is: 0x852b000</span><br></pre></td></tr></table></figure>
<p>　　在这段输出中，在释放所有指定的内存块后，程序分段点小于峰值。<code>glibc</code>的<code>free()</code>能够识别位于程序分段点的完整的空闲内存块。因此，当释放位于程序分段点的内存块后，会将其与相邻的空闲内存块合并为1个更大的内存块。这样做可以避免空闲内存块链表中有大量小到无法满足<code>malloc()</code>的请求的内存块。</p>
<p>　　当位于程序分段点的空闲内存块<span
style="background-color: yellow">足够大</span>时
(由控制<code>malloc</code>包的参数控制，其值通常是128KB)，<code>glibc</code>的<code>free()</code>才会调用<code>sbrk()</code>来减少程序分段点。</p>
<h4 id="在堆上分配内存的其他方法">7.1.3 在堆上分配内存的其他方法</h4>
<p>　　除了<code>malloc()</code>，C库还提供了大量其他用于堆内存分配的函数。</p>
<h5 id="calloc和realloc">7.1.3.1
<code>calloc()</code>和<code>realloc()</code></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> numitems, <span class="type">size_t</span> size)</span>; <span class="comment">/* 若成功则返回指向新内存块的指针，若出错则返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>; <span class="comment">/* 若成功则返回指向调整大小后的内存块的指针，若出错则返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>calloc()</code>会为数组分配堆内存，并且会将分配的内存块<span
style="background-color: yellow">初始化为0</span>。参数<code>numitems</code>指定数组的元素数。参数<code>size</code>指定元素的大小。在分配合适大小的内存块后，<code>calloc()</code>会返回指向新内存块的指针。若出错，则返回<code>NULL</code>。</p>
<p>　　函数<code>realloc()</code>会调整由<code>malloc()</code>包的函数分配的内存块的大小。参数<code>ptr</code>指向待调整大小的内存块。参数<code>size</code>指定内存块调整后的大小。在调整内存块的大小后，<code>realloc()</code>会返回指向调整大小后的内存块的指针
。若出错，则返回<code>NULL</code>，并且不会对<code>ptr</code>指向的内存块执行任何操作
(SUSv3要求如此)。当使用<code>realloc()</code>扩大内存块时，扩大的部分不会初始化。调用<code>realloc(NULL, size)</code>等同于调用<code>malloc(size)</code>。调用<code>realloc(ptr, 0)</code>等同于调用<code>malloc(0)</code>和<code>free(ptr)</code>。</p>
<p>　　
当使用<code>realloc()</code>扩大内存块时，若紧随其后的内存块是空闲内存块，并且足够大，则<code>realloc()</code>会立即合并它们；若内存块位于堆的末尾，则<code>realloc()</code>会扩展堆；若内存块位于堆的中间，并且紧随其后的内存块无法满足合并要求，则<code>realloc()</code>会分配新内存块，然后将旧内存块的数据复制到新内存块。最后1种情况很常见，并且会占用大量CPU资源。</p>
<p>　　<code>realloc()</code>可能会移动内存块，这会导致很多指向旧内存块的内容的指针无效，只有通过在内存块的指针上加上偏移量而形成的指针依旧生效。综上所述，应尽量避免使用<code>realloc()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* 成员定义 */</span></span><br><span class="line">&#125; myStruct;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span> *<span class="title">p</span>, *<span class="title">np</span>;</span></span><br><span class="line">p = <span class="built_in">calloc</span>(<span class="number">1000</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> myStruct));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;calloc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">np = <span class="built_in">realloc</span>(p, newsize);</span><br><span class="line"><span class="keyword">if</span> (nptr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 错误处理 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    p = np;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这段代码是<code>calloc()</code>和<code>realloc()</code>的用法示例。这里并不能直接将<code>realloc()</code>的返回值赋值给<code>p</code>，因为一旦<code>realloc()</code>失败，<code>p</code>会被赋值为<code>NULL</code>，导致它原本指向的内存块无法访问。</p>
<h5 id="memalign和posix_memalign">7.1.3.2
<code>memalign()</code>和<code>posix_memalign()</code></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memalign</span><span class="params">(<span class="type">size_t</span> boundary, <span class="type">size_t</span> size)</span>; <span class="comment">/* 若成功则返回指向新内存块的指针，若出错则返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>memalign()</code>会分配<code>size</code>字节的内存块，并且该内存块的起始地址是参数<code>boundary</code>的整数倍。<code>boundary</code>必须是2的幂。在分配合适大小的内存块后，<code>memalign()</code>会返回指向新内存块的指针。若出错，则返回<code>NULL</code>。</p>
<p>　　并非所有的UNIX实现都提供<code>memalign()</code>。很多提供该函数的UNIX实现将其声明在头文件<code>stdlib.h</code>中。</p>
<p>　　对于部分UNIX实现，无法对<code>memalign()</code>返回的内存块调用<code>free()</code>。因为<code>memalign()</code>在通过<code>malloc()</code>分配内存块后，返回的指针是内存块的指针<span
style="background-color: yellow">加上合适的对齐偏移量</span>。<code>glibc</code>的实现没有这个问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">posix_memalign</span><span class="params">(<span class="type">void</span> **memptr, <span class="type">size_t</span> alignment, <span class="type">size_t</span> size)</span>; <span class="comment">/* 若成功则返回0，若出错则返回正数错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>posix_memalign()</code>与<code>memalign()</code>类似，但在3个方面不同：</p>
<p>　　● 已分配的内存块地址通过参数<code>memptr</code>返回。</p>
<p>　　●
分配的内存块按照参数<code>alignment</code>对齐。<code>alignment</code>必须是<code>sizeof(void *)</code>的2的幂数倍。</p>
<p>　　● 若正常运行，则返回0；若出错，则返回正数错误号
(即通常用于<code>errno</code>的错误号)。</p>
<p>　　SUSv3没有说明<code>memalign()</code>，但详细说明了<code>posix_memalign()</code>。</p>
<h3 id="在栈上分配内存">7.2 在栈上分配内存</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;alloca.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">alloca</span><span class="params">(<span class="type">size_t</span> size)</span>; <span class="comment">/* 返回指向栈内存块的指针 */</span></span><br></pre></td></tr></table></figure>
<p>　　与<code>malloc</code>包的函数类似，函数<code>alloca()</code>会动态分配栈内存。参数<code>size</code>指定栈内存块的大小。该函数会返回指向栈内存块的指针。<code>alloca()</code>通过扩大栈帧来获取内存。因为正在执行的函数的栈帧位于栈顶，所以只需增加栈指针就能获取栈内存。</p>
<p>　　SUSv3没有说明<code>alloca()</code>，但大多数UNIX实现都提供了该函数。对于<code>glibc</code>的旧版本和部分UNIX实现
(主要衍生自BSD)，<code>alloca()</code>的声明在头文件<code>stdlib.h</code>中。</p>
<p>　　若栈因为调用<code>alloca()</code>而溢出，则程序的行为将无法预测。此时，<code>alloca()</code>不会返回<code>NULL</code>，但程序会收到信号<code>SIGSEGV</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *y;</span><br><span class="line">y = alloca(size);</span><br><span class="line">func(x, y, z);</span><br></pre></td></tr></table></figure>
<p>　　这段代码是<code>alloca()</code>的用法示例。这里并不能将<code>alloca()</code>的返回值直接作为函数的参数传递，因为一旦如此，分配的栈内存块会位于<span
style="background-color: yellow">被调函数</span>的栈帧的中间。</p>
<p>　　通过<code>alloca()</code>分配内存比通过<code>malloc()</code>分配内存更具优势。第1个优势是通过<code>alloca()</code>分配内存更快，因为<code>alloca()</code>由编译器实现为直接调整栈指针的内联代码。此外，<code>alloca()</code>无需维护空闲内存块链表。第2个优势是函数返回时，栈帧会自动释放，包括<code>alloca()</code>分配的内存块
(因为函数返回时会将栈指针寄存器设置为前1个栈帧的末尾)。</p>
<p>　　当通过<code>longjmp()</code>或<code>siglongjmp()</code>来在信号处理程序中执行非本地跳转时，<code>alloca()</code>会很有用。在这种情况下，若使用<code>malloc()</code>来分配内存，则很可能跳过释放内存的代码部分，进而导致内存泄漏。相比之下，<code>alloca()</code>完全避免这个问题。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第8章 用户和组</title>
    <url>/2024/11/08/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-8/</url>
    <content><![CDATA[<p>　　每个用户都有1个唯一的登录名 (用户名) 和1个关联的数字用户ID
(即UID)。用户可以属于1个或多个组。每个组都有1个唯一的组名和1个组ID
(即GID)。</p>
<p>　　用户ID和组ID的主要用途是确定各种系统资源的所有权和控制进程对系统资源的访问权限。</p>
<h3 id="密码文件和影子密码文件">8.1 密码文件和影子密码文件</h3>
<p>　　系统中的每个用户都在系统密码文件<code>/etc/passwd</code>中有1行记录，每行记录都包括以冒号<code>:</code>分隔的7个字段，如以下示例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mtk:x:1000:100:Michael Kerrisk:/home/mtk:/bin/bash</span><br></pre></td></tr></table></figure>
<p>　　这些字段从左到右依次是<span
style="background-color: yellow">登录名</span>、<span
style="background-color: yellow">加密后的密码</span>、<span
style="background-color: yellow">用户ID</span>、<span
style="background-color: yellow">组ID</span>、<span
style="background-color: yellow">注释</span>、<span
style="background-color: yellow">主目录</span>和<span
style="background-color: yellow">登录shell</span>。</p>
<p>　　●
登录名就是登录时输入的用户名，也可以视为与用户ID关联的符号标识符。当通过<code>ls</code>等程序获取文件的所有者时，返回的就是登录名。</p>
<p>　　●
通常，UNIX会使用DES加密密码。在这种情况下，加密后的密码包括13个字符。当加密后的密码字段不是13个字符的字符串时，对应的登录名将会被禁用。若已启用影子密码
(通常如此)，则该字段会被忽略，此时，该字段通常会包含字符<code>x</code>
(也可能出现其他未加密的字符)，真正的密码会存储在影子密码文件<code>/etc/shadow</code>中。若该字段为空，则对应的登录名无需密码就可以登录
(无论是否启用影子密码)。除了DES，还可以使用MD5等加密算法。MD5会输出128位的消息摘要
(即散列值)，该值会以34个字符的字符串形式存储在 (影子) 密码文件中。</p>
<p>　　●
若用户ID为0时，则表示对应的账户拥有超级用户特权，这样的账户通常只有1个，并且登录名是<code>root</code>。密码文件中可能会出现多行用户ID相同的记录，这允许用户使用不同的登录名来访问相同的资源，并且这些登录名可以属于不同的组。对于Linux
2.2及以下版本，用户ID存储为16位值 (即0~65536)。对于Linux
2.4及以上版本，用户ID存储为32位值。</p>
<p>　　● 组ID是用户所属的第1个组的ID。</p>
<p>　　●
注释是用户的相关信息，可以通过<code>finger</code>等程序获取。</p>
<p>　　●
主目录是用户登录后初始目录。用户登录后，主目录字段会成为环境变量<code>HOME</code>的值。</p>
<p>　　●
用户登录后，控制权会转移给登录shell，登录shell字段会成为环境变量<code>SHELL</code>的值。若该字段为空，则登录shell会默认为<code>/bin/sh</code>
(即<code>sh</code>)。登录shell通常是shell，但可以是任何程序。</p>
<span id="more"></span>
<p>　　对于单机系统，所有密码信息都存储在<code>/etc/passwd</code>中。当使用网络信息系统或轻量级目录访问协议等系统来在网络环境中分发密码时，部分密码信息会存储在远程系统。只要应用程序使用<code>getpwnam()</code>和<code>getpwuid()</code>等函数来访问密码信息，NIS和LDAP的使用就对这些应用程序是透明的。</p>
<p>　　从历史角度，UNIX系统维护着所有用户信息，包括加密后的密码
(在<code>/etc/passwd</code>中)。因为各种非特权系统工具需要读密码文件中的信息，所以密码文件需要对所有用户都是可读的，这为密码破解程序创造了可乘之机
(密码破解文件会尝试对可能的密码进行加密，然后与密码文件中的密码进行匹配)。影子密码文件的设计初衷正是为了防止这类攻击，基本思想是将所有非敏感的用户数据存放在公开可读的密码文件，加密后的密码存放在仅对特权程序可读的影子密码文件。</p>
<p>　　除了登录名字段和加密后的密码字段，影子密码文件还包含很多安全相关的字段。</p>
<p>　　SUSv3没有说明影子密码，并且并非所有UNIX实现都提供了该功能。</p>
<h3 id="组文件">8.2 组文件</h3>
<p>　　用户所属的组由密码文件中的字段和组文件中的字段共同决定。对于早期UNIX实现，用户只能属于1个组。用户登录时的初始组由密码文件中的组ID字段决定，随后可以通过命令<code>newgrp</code>修改
(若对应的组设置了密码，则用户需要提供组密码)。4.2BSD允许用户能属于多个组，随后POSIX.1-1990将其标准化。</p>
<p>　　系统中的每个组都在组文件<code>/etc/group</code>中有1行记录，每行记录都包括以冒号<code>:</code>分隔的4个字段，如以下示例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">users:x:100:</span><br><span class="line">jambit:x:106:claus,felli,frank,harti,markus,martin,mtk,paul</span><br></pre></td></tr></table></figure>
<p>　　这些字段从左到右依次是<span
style="background-color: yellow">组名</span>、 <span
style="background-color: yellow">加密后的密码</span>、<span
style="background-color: yellow">组ID</span>和<span
style="background-color: yellow">用户列表</span>。</p>
<p>　　● 组名可以视为与组ID对应的符号标识符。</p>
<p>　　●
组密码是可选的，特权用户可以通过命令<code>passwd</code>来设置组密码。设置了组密码后，当不属于该组的用户启动属于该组的shell时，命令<code>newgrp</code>会要求用户输入组密码。若已启用影子密码，则该字段会被忽略，此时，该字段通常是字符<code>x</code>
(也可能是其他字符串，甚至是空字符串)，真正的密码会存储在<strong>影子组文件</strong><code>/etc/gshadow</code>
(只有特权用户和程序能访问)。组密码的加密方式与用户密码的相似。</p>
<p>　　●
通常，只有1个组ID为0的组，并且该组的组名是<code>root</code>。对于Linux
2.2及以下版本，组ID存储为16位值 (即0~65536)。对于Linux
2.4及以上版本，组ID存储为32位值。</p>
<p>　　● 用户列表包含以逗号<code>,</code>分隔的组成员的登录名。</p>
<p>　　若用户<code>avr</code>属于组<code>users</code>、<code>staff</code>和<code>teach</code>，则密码文件中会包含如下记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">avr:x:1001:100:Anthony Robins:/home/avr:/bin/bash</span><br></pre></td></tr></table></figure>
<p>　　组文件会包含如下记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">users:x:100:</span><br><span class="line">staff:x:101:mtk,avr,martinl</span><br><span class="line">teach:x:104:avr,rlb,alc</span><br></pre></td></tr></table></figure>
<p>　　密码文件中的记录的第4个字段是100，对应组<code>users</code>。用户<code>avr</code>所属的其他组通过组文件的记录的用户列表字段来确定。</p>
<h3 id="检索用户信息和组信息">8.3 检索用户信息和组信息</h3>
<h4 id="从密码文件和组文件中检索记录">8.3.1
从密码文件和组文件中检索记录</h4>
<p>　　函数<code>getpwnam()</code>和<code>getpwuid()</code>可用于从密码文件中检索记录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功则返回指向结构体passwd指针，若出错或未找到则返回NULL */</span></span><br><span class="line"><span class="keyword">struct</span> passwd *<span class="title function_">getpwnam</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> passwd *<span class="title function_">getpwuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *pw_name;   <span class="comment">/* 登录名 (用户名) */</span></span><br><span class="line">    <span class="type">char</span> *pw_passwd; <span class="comment">/* 加密后的密码 (若未启用影子密码) */</span></span><br><span class="line">    <span class="type">uid_t</span> pw_uid;    <span class="comment">/* 用户ID */</span></span><br><span class="line">    <span class="type">gid_t</span> pw_gid;    <span class="comment">/* 组ID */</span></span><br><span class="line">    <span class="type">char</span> *pw_gecos;  <span class="comment">/* 注释 (用户的相关信息) */</span></span><br><span class="line">    <span class="type">char</span> *pw_dir;    <span class="comment">/* 初始工作 (主) 目录 */</span></span><br><span class="line">    <span class="type">char</span> *pw_shell;  <span class="comment">/* 登录shell */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　 函数<code>getpwnam()</code>会根据登录名
(即参数<code>name</code>)
检索密码文件，函数<code>getpwuid()</code>会根据用户ID
(即参数<code>uid</code>)
检索密码文件。这2个函数都返回指向结构体<code>passwd</code>的指针。</p>
<p>　　SUSv3并未说明结构体<code>passwd</code>的成员<code>pw_passwd</code>和<code>pw_gecos</code>，但所有UNIX实现都提供了这2个成员。当且仅当未启用影子密码时，成员<code>pw_passwd</code>才包含有效信息。其他部分UNIX实现提供了该结构体的额外的非标准成员。</p>
<p>　　成员<code>pw_gecos</code>的名称源自早期UNIX实现，其中该成员存储用于与运行着通用电气综合运作系统的机器通信的信息。尽管这种用法早已过时，但该名称仍然存在。如今，该成员用于保存用户的相关信息。</p>
<p>　　函数<code>getpwnam()</code>和<code>getpwuid()</code>返回的指针指向的结构体是静态分配的，所以这2个函数不是可重入的，并且指针指向的结构体会被后续的<code>getpwnam()</code>、<code>getpwuid()</code>或<code>getpwent()</code>调用覆盖。</p>
<p>　　根据SUSv3，若密码文件中没有匹配的记录，则<code>getpwnam()</code>和<code>getpwuid()</code>会返<code>NULL</code>，并且<span
style="background-color: yellow">不会</span>设置<code>errno</code>。但是，在这一点上，很多UNIX实现并没有遵循SUSv3的规定。在这种情况下，除了返回<code>NULL</code>之外，这些UNIX实现还会将<code>errno</code>设置为非0值
(例如，<code>ENOENT</code>和<code>ESRCH</code>)。对于<code>glibc</code>
2.7之前的版本，会将<code>errno</code>设置为<code>ENOENT</code>，但从<code>glibc</code>
2.7开始，<code>glibc</code>遵循SUSv3的规定
(不设置<code>errno</code>)。这种给跨UNIX实现的差异部分是因为POSIX.1-1990不要求这些函数设置<code>errno</code>，并且允许它们根据情况设置合适的值。这一切造就了移植的不便。</p>
<p>　　函数<code>getgrnam()</code>和<code>getgrgid()</code>可用于从组文件中检索记录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若成功则返回指向结构体group指针，若出错或未找到则返回NULL */</span></span><br><span class="line"><span class="keyword">struct</span> group *<span class="title function_">getgrnam</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> group *<span class="title function_">getgrgid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *gr_name;   <span class="comment">/* 组名 */</span></span><br><span class="line">    <span class="type">char</span> *gr_passwd; <span class="comment">/* 加密后的密码 (若未启用影子密码) */</span></span><br><span class="line">    <span class="type">gid_t</span> gr_gid;    <span class="comment">/* 组ID */</span></span><br><span class="line">    <span class="type">char</span> **gr_mem;   <span class="comment">/* 除了最后1个元素是NULL之外，其他元素都是组文件中的用户列表字段中的登录名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>getgrnam()</code>会根据组名 (即参数<code>name</code>)
检索组文件，函数<code>getgrgid()</code>会根据组ID
(即参数<code>gid</code>)
检索组文件。这2个函数都返回指向结构体<code>group</code>的指针。</p>
<p>　　SUSv3并未说明结构体<code>group</code>的成员<code>gr_passwd</code>，但所有UNIX实现都提供了该成员。当且仅当未启用影子密码时，成员<code>gr_passwd</code>才包含有效信息。</p>
<p>　　与<code>getpwnam()</code>和<code>getpwuid()</code>类似，<code>getgrnam()</code>和<code>getgrgid()</code>返回的指针指向的结构体也会被后续的这2个函数的调用覆盖。</p>
<p>　　当<code>getgrnam()</code>和<code>getgrgid()</code>找不到匹配的记录时，它们的行为与<code>getpwnam()</code>和<code>getpwuid()</code>的类似。</p>
<p>　　SUSv3详细说明了一组与这4个函数等效的可重入函数，即<code>getpwnam_r()</code>、<code>getpwuid_r()</code>、<code>getgrnam_r()</code>和<code>getgrgid_r()</code>，这些函数的参数都包括1个结构体<code>passwd</code>
(或<code>group</code>) 和1个用于存放结构体<code>passwd</code>
(或<code>group</code>)中的成员指针指向的其他结构体的缓冲区。该缓冲区的大小可以通过调用<code>sysconf(_SC_GETPW_R_SIZE_MAX)</code>来获取
(对于组相关函数，则是调用<code>sysconf(_SC_GETGR_R_SIZE_MAX)</code>)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ugid_functions.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ugid_functions.h&quot;</span> <span class="comment">/* 定义函数原型的头文件 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 返回uid对应的登录名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param uid</span></span><br><span class="line"><span class="comment"> * @return char* 若出错，则返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">userNameFromId</span><span class="params">(<span class="type">uid_t</span> uid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pwd</span>;</span></span><br><span class="line">    pwd = getpwuid(uid);</span><br><span class="line">    <span class="keyword">return</span> (pwd == <span class="literal">NULL</span>) ? <span class="literal">NULL</span> : pwd-&gt;pw_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 返回name对应的用户ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name</span></span><br><span class="line"><span class="comment"> * @return uid_t 若出错，则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">userIdFromName</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pwd</span>;</span></span><br><span class="line">    <span class="type">uid_t</span> u;</span><br><span class="line">    <span class="type">char</span> *endptr;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">NULL</span> || *name == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    u = strtol(name, &amp;endptr, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (*endptr == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pwd = getpwnam(name);</span><br><span class="line">    <span class="keyword">if</span> (pwd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pwd-&gt;pw_uid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 返回gid对应的组名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param gid</span></span><br><span class="line"><span class="comment"> * @return char* 若出错，则返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">groupNameFromId</span><span class="params">(<span class="type">gid_t</span> gid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">grp</span>;</span></span><br><span class="line">    grp = getgrgid(gid);</span><br><span class="line">    <span class="keyword">return</span> (grp == <span class="literal">NULL</span>) ? <span class="literal">NULL</span> : grp-&gt;gr_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 返回name对应的组ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name</span></span><br><span class="line"><span class="comment"> * @return gid_t 若出错，则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">groupIdFromName</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">grp</span>;</span></span><br><span class="line">    <span class="type">gid_t</span> g;</span><br><span class="line">    <span class="type">char</span> *endptr;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">NULL</span> || *name == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g = strtol(name, &amp;endptr, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (*endptr == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    grp = getgrnam(name);</span><br><span class="line">    <span class="keyword">if</span> (grp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grp-&gt;gr_gid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，函数<code>userNameFromId()</code>、<code>userIdFromName()</code>、<code>groupNameFromId()</code>、<code>groupIdFromName()</code>用于登录/组名与用户/组ID的相互转换。此外，<code>userNameFromId()</code>和<code>groupNameFromId()</code>允许输入只包含数字的字符串，此时，这2个函数会直接将字符串转换为数字，然后返回给调用者。</p>
<h4 id="扫描密码文件和组文件中的所有记录">8.3.2
扫描密码文件和组文件中的所有记录</h4>
<p>　　函数<code>getpwent()</code>、<code>setpwent()</code>和<code>endpwent()</code>用于对密码文件进行顺序扫描。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> passwd *<span class="title function_">getpwent</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 若成功则返回指向结构体passwd的指针，若出错或遇到流结尾则返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setpwent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">endpwent</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>　　每次调用函数<code>getpwent()</code>都会返回1条记录。若没有更多记录或出错，则返回<code>NULL</code>。第1次调用该函数时，会自动打开密码文件。当扫描完成后，需要调用函数<code>endpwent()</code>来关闭密码文件。</p>
<p>　　可以通过以下代码来打印密码文件中的所有登录名和用户ID：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pwd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((pwd = getpwent()) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-8s %5ld\n&quot;</span>, pwd-&gt;pw_name, (<span class="type">long</span>)pwd-&gt;pw_uid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">endpwent();</span><br></pre></td></tr></table></figure>
<p>　　函数<code>setpwent</code>会让<code>getpwent()</code>从密码文件的开头开始扫描。</p>
<p>　　与<code>getpwent()</code>、<code>setpwent()</code>和<code>endpwent()</code>类似，函数<code>getgrent()</code>、<code>setgrent()</code>和<code>endgrent()</code>用于对组文件进行顺序扫描。</p>
<h4 id="从影子密码文件中检索记录">8.3.3 从影子密码文件中检索记录</h4>
<p>　　函数<code>getspnam()</code>、<code>getspent()</code>、<code>setspent()</code>和<code>endspent()</code>用于从影子密码文件中检索单条记录或扫描所有记录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shadow.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> spwd *<span class="title function_">getspnam</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 若成功则返回指向结构体spwd的指针，若出错或未找到则返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> spwd *<span class="title function_">getspent</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 若成功则返回指向结构体spwd的指针，若出错或遇到流结尾则返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setspent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">endspent</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spwd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *sp_namp; <span class="comment">/* 登录名 (用户名) */</span></span><br><span class="line">    <span class="type">char</span> *sp_pwdp; <span class="comment">/* 加密后的密码 */</span></span><br><span class="line">    <span class="comment">/* 剩余成员用于提供 &quot;密码自动过期&quot; 功能，即强制用户定期修改密码 */</span></span><br><span class="line">    <span class="type">long</span> sp_lstchg;        <span class="comment">/* 上次更改密码的时间 (自1970年1月1日起的天数) */</span></span><br><span class="line">    <span class="type">long</span> sp_min;           <span class="comment">/* 密码更改之间的最小天数 */</span></span><br><span class="line">    <span class="type">long</span> sp_max;           <span class="comment">/* 需要更改密码前的最大天数 */</span></span><br><span class="line">    <span class="type">long</span> sp_warn;          <span class="comment">/* 距离警告用户密码即将过期之前的天数 */</span></span><br><span class="line">    <span class="type">long</span> sp_inact;         <span class="comment">/* 账户过期后，账户被视为非活动状态并锁定的天数 */</span></span><br><span class="line">    <span class="type">long</span> sp_expire;        <span class="comment">/* 账户过期时间 (自1970年1月1日起的天数) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sp_flag; <span class="comment">/* 保留供将来使用 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这里不会介绍这些函数的细节，因为这些函数与对应的用于从密码文件中检索记录的函数类似。SUSv3没有说明这些函数，并且并非所有UNIX实现都提供了这些函数。</p>
<h3 id="密码加密和用户认证">8.4 密码加密和用户认证</h3>
<p>　　有些应用程序会要求用户进行身份认证，通常是输入用户名 (即登录名)
和密码。为此，应用程序可能会维护自己的用户名和密码数据库。有时，允许用户输入
(影子)
密码文件中定义的标准用户名和密码是必要或便利的。例如，<code>ssh</code>和<code>ftp</code>等用于登录到远程系统的网络应用程序验证用户名和密码的方式与标准登录程序的相同。</p>
<p>　　出于安全，UNIX系统使用<strong>单向加密</strong>算法来加密密码，这表示无法通过加密后的密码来获取密码明文。因此，验证输入的密码是否正确的方法就是将其以相同的算法加密，然后将结果与影子密码文件中的加密后的密码对比。加密算法封装在函数<code>crypt()</code>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">crypt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *key, <span class="type">const</span> <span class="type">char</span> *salt)</span>; <span class="comment">/* 若成功则返回静态分配的加密后的密码字符串，若出错则返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>crypt()</code>会使用DES加密算法的变体来加密由最多8个字符组成的参数<code>key</code>
(即密码)。参数<code>salt</code>是由2个字符组成的字符串，用于置乱
(使得加密后的密码更难破解)。该函数返回静态分配的由13个字符组成的字符串
(即加密后的密码)。</p>
<p>　　MD5算法生成的以美元符号<code>$</code>开头的由34个字符组成的字符串使得<code>crypt()</code>能够区分DES加密后的密码和MD5加密后的密码。</p>
<p>　　参数<code>salt</code>和<code>crypt()</code>返回的字符串中的字符都是从由64个字符组成的集合<code>[a-zA-Z0-9/.]</code>中选择。因此，对于同一密码明文，DES加密后的密码有4096种可能。</p>
<p>　　<code>crypt()</code>会将<code>salt</code>作为返回的字符串的前2个字符，这表示可以通过影子密码文件中已存在的加密后的密码来获取合适的<code>salt</code>值
(<code>passwd</code>等程序加密密码时会生成随机的<code>salt</code>值)。实际上，<code>salt</code>包含的字符可以多于2个，但函数<code>crypt()</code>会忽略<code>salt</code>的前2个字符之外的所有字符。</p>
<p>　　为了在Linux上使用<code>crypt</code>，编译程序时必须与库<code>crypt</code>一起链接
(使用选项<code>-lcrypt</code>)。</p>
<p>　　通常，通过函数<code>getpass()</code>来读取用户在终端输入的密码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getpass</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *prompt)</span>; <span class="comment">/* 若成功则返回静态分配的输入的密码字符串，若出错则返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>getpass()</code>会先禁用终端特殊字符的回显和处理，然后打印参数<code>prompt</code>指定的字符串和读1行输入，最后将去除换行符后的以<code>NULL</code>结尾的输入作为结果返回
(该字符串是静态分配的，所以会被后续的<code>getpass()</code>调用覆盖)。在<code>getpass()</code>返回之前，会先将终端的设置恢复。</p>
<p>　　SUSv2详细说明了<code>getpass()</code>
(将其标记为LEGACY)，但SUSv3没有说明该函数。大多数UNIX实现都提供了该函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check_password.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE   <span class="comment">/* 定义了该宏后，getpass()会声明在&lt;unistd.h&gt;中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE <span class="comment">/* 定义了该宏后，crypt()会声明在&lt;unistd.h&gt;中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shadow.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *username, *password, *encrypted, *p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pwd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spwd</span> *<span class="title">spwd</span>;</span></span><br><span class="line">    Boolean authOk;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="type">long</span> lnmax;</span><br><span class="line"></span><br><span class="line">    lnmax = sysconf(_SC_LOGIN_NAME_MAX);</span><br><span class="line">    <span class="keyword">if</span> (lnmax == <span class="number">-1</span>) <span class="comment">/* 用户名长度上限获取失败 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        lnmax = <span class="number">256</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    username = <span class="built_in">malloc</span>(lnmax);</span><br><span class="line">    <span class="keyword">if</span> (username == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Username: &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span> (fgets(username, lnmax, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE); <span class="comment">/* 遇到EOF时退出 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">strlen</span>(username);</span><br><span class="line">    <span class="keyword">if</span> (username[len - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        username[len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* 移除最后的\n */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pwd = getpwnam(username);</span><br><span class="line">    <span class="keyword">if</span> (pwd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;couldn&#x27;t get password record&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    spwd = getspnam(username);</span><br><span class="line">    <span class="keyword">if</span> (spwd == <span class="literal">NULL</span> &amp;&amp; errno == EACCES)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;no permission to read shadow password file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (spwd != <span class="literal">NULL</span>) <span class="comment">/* 在影子密码文件中找到记录 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        pwd-&gt;pw_passwd = spwd-&gt;sp_pwdp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    password = getpass(<span class="string">&quot;Password: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 加密密码和清除密码明文 */</span></span><br><span class="line">    encrypted = crypt(password, pwd-&gt;pw_passwd);</span><br><span class="line">    <span class="keyword">for</span> (p = password; *p != <span class="string">&#x27;\0&#x27;</span>;)</span><br><span class="line">    &#123;</span><br><span class="line">        *p++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encrypted == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;crypt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    authOk = <span class="built_in">strcmp</span>(encrypted, pwd-&gt;pw_passwd) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!authOk)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Incorrect password\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Successfully authenticated: UID=%ld\n&quot;</span>, (<span class="type">long</span>)pwd-&gt;pw_uid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行认证 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何通过<code>crypt()</code>来认证用户。该程序会先读取用户名，然后检索对应的
(影子) 密码文件记录。若未找到记录或程序没有影子密码文件的访问权限
(需要超级用户特权或属于组<code>shadow</code>)，则打印错误信息。通过<code>getpass()</code>读密码后，程序会使用<code>crypt()</code>来对其加密，然后将结果与影子密码文件中对应的记录对比。若相同，则打印对应的用户ID。</p>
<p>　　在第19~23行，这里通过调用<code>sysconf(_SC_LOGIN_NAME_MAX)</code>
(获取主机系统中的用户名长度上限)
来决定用于存放用户名的字符串的长度。</p>
<p>　　在第63~67行，这里展示了1个重要的安全点，即<span
style="background-color: yellow">读取密码后立即加密密码和清除密码明文</span>，这最小化了程序崩溃时生成包含密码明文的内存快照的可能性。实际上，还有其他可能泄漏密码明文的方式。例如，当包含密码明文的虚拟内存页被换出后，特权程序可以从交换文件中读取密码明文。此外，拥有对应特权的进程可以通过读取<code>/dev/mem</code>
(将计算机的物理内存表示为连续的字节流的虚拟设备)
来试图寻找密码明文。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
</search>
