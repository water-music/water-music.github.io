<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><link rel="canonical" href="http://example.com/2024/10/21/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-6/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/10/21/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-6/","path":"2024/10/21/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-6/","title":"《Linux/UNIX系统编程手册》第6章 进程"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第6章 进程 |</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-text">6.1 进程的内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">6.2 虚拟内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E6%A0%88%E5%B8%A7"><span class="nav-text">6.3 栈和栈帧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-text">6.4 命令行参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%88%97%E8%A1%A8"><span class="nav-text">6.5 环境列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%AE%BF%E9%97%AE%E7%8E%AF%E5%A2%83%E5%88%97%E8%A1%A8"><span class="nav-text">6.5.1 在程序中访问环境列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%88%97%E8%A1%A8"><span class="nav-text">6.5.2 修改环境列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="nav-text">6.5.3 示例程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E6%9C%AC%E5%9C%B0%E8%B7%B3%E8%BD%AC"><span class="nav-text">6.6 非本地跳转</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F-1"><span class="nav-text">6.6.1 示例程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setjmp%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-text">6.6.2 setjmp()的限制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#longjmp%E6%BB%A5%E7%94%A8"><span class="nav-text">6.6.3 longjmp()滥用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98"><span class="nav-text">6.6.4 编译器优化问题</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2024/10/21/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux/UNIX系统编程手册》第6章 进程 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第6章 进程</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-10-21 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-21T00:00:00+08:00">2024-10-21</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-11-27 00:00:00" itemprop="dateModified" datetime="2024-11-27T00:00:00+08:00">2024-11-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/computer-system/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>15k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　<strong>程序</strong>是1个文件，其中包含一系列描述如何在运行时构建进程的信息，包括<span style="background-color:#ff0">二进制格式ID</span>、<span style="background-color:#ff0">机器语言指令</span>、<span style="background-color:#ff0">程序入口点地址</span>、<span style="background-color:#ff0">数据</span>、<span style="background-color:#ff0">符号表和重定位表</span>、<span style="background-color:#ff0">共享库和动态链接信息</span>以及<span style="background-color:#ff0">其他信息</span>。</p><p>　　● 每个程序文件都包含描述可执行文件格式的元信息 (即二进制格式ID)，这使内核能够解析文件的剩余信息。从历史角度，有2个广泛使用的UNIX可执行文件格式，即原始的<code>a.out</code> (汇编器输出) 和之后出现的更复杂的<strong>通用对象文件格式</strong>。如今，Linux等大部分UNIX实现使用的都是更具优势的<strong>可执行链接格式</strong>。</p><p>　　● 机器语言指令对程序的算法进行编码。</p><p>　　● 程序入口点地址是程序执行时的第1条指令的地址。</p><p>　　● 程序文件包含用于初始化变量和字符串的值 (即数据)。</p><p>　　● 符号表和重定位表描述程序中的函数和变量的名称和位置。这些表用途广泛，包含调试和运行时符号解析 (即动态链接)。</p><p>　　● 程序文件包含的字段列出了程序在运行时所需的共享库和加载这些库的动态链接器的路径名。</p><p>　　● 程序文件还包含描述如何构建进程的各种其他信息。</p><p>　　1个程序可能会构建多个进程，多个进程可能运行相同的程序。</p><p>　　<strong>进程</strong>是由内核定义的抽象实体，系统会分配资源给进程来执行程序。</p><p>　　从内核角度，进程由用户空间内存 (包含程序代码和代码使用的变量) 和各种内核数据结构 (维护程序状态信息) 组成。内核数据结构中记录的信息包含与进程关联的各种ID、虚拟内存表、打开的文件描述符表、与信号传递和处理相关的信息、进程资源使用情况和限制、当前工作目录和主机的其他信息。</p><p>　　每个进程都有正整数的<strong>进程ID</strong> (即PID)，用于标识系统中的进程。很多系统调用会使用或返回进程ID。除了<code>init</code> (进程ID为1) 等少数系统进程，程序和为运行程序创建的进程的进程ID之间没有固定关系。</p><p>　　每个进程都有<strong>父进程</strong>，即创建该进程的进程。每个进程的父进程ID属性表示系统中的所有进程的树状关系。进程的父进程也有父进程，依此类推，一直追溯到进程<code>init</code>，它是所有进程的祖先。这个 "族谱" 可以通过命令<code>pstree</code>查看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的进程ID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的父进程的进程ID */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>getpid()</code>会返回调用进程的进程ID。系统调用<code>getppid()</code>会返回调用进程的父进程ID。</p><p>　　若进程因为父进程终止而成为了<strong>孤儿进程</strong>，则它会被进程<code>init</code>收养 (系统调用<code>getppid()</code>会返回1)。任何进程的父进程都可以通过特定于Linux的文件<code>/proc/PID/status</code>中的字段<code>Ppid</code>查看。</p><p>　　Linux内核为进程ID设置的最大值是<span style="background-color:#ff0">32767</span>。当新进程创建时，会为其分配下1个按序可用的进程ID。当达到上限32767时，进程会将进程ID计数器重置为<span style="background-color:#ff0">300</span>，因为数值较小的进程ID会永远分配给系统进程和守护进程。</p><p>　　对于Linux 2.4及以下版本，进程ID的最大值32767由内核常量<code>PID_MAX</code>定义。这在Linux 2.6发生了变化，进程ID的默认最大值还是32767，不过该上限可通过特定于Linux的文件<code>/proc/sys/kernel/pid_max</code>修改 (32位平台的最大值是2<sup>15</sup>，64位平台的最大值是2<sup>22</sup>)。</p><span id="more"></span><p>　　每个C程序都有函数<code>main()</code> (即<span style="background-color:#ff0">主函数</span>)，该函数是程序执行的起点。</p><p>　　每个进程都有关联的称为<strong>环境列表</strong> (简称<strong>环境</strong>) 的字符串数组，其中的元素都定义为<code>name=value</code>的形式。因此，环境变量表示一组用于存放任意信息的名称-值对，其中的名称称为<strong>环境变量</strong>。</p><p>　　当进程被创建时，进程会继承父进程的环境列表 (这是一种原始但经常使用的进程间通信方式)。随后，进程可以修改自己的环境列表，这些修改对其他进程不可见。</p><p>　　环境变量的常见使用场景之一是shell。通过设置环境变量，shell可以保证对应的值会传递给它创建的用于执行用户命令行的进程。</p><p>　　有些库函数允许通过设置环境变量来修改其行为，这允许用户无需修改源码或重新链接对应的库，就能通过这些函数控制应用程序的行为。例如，库函数<code>getopt()</code>的行为会根据环境变量<code>POSIXLY_CORRECT</code>来改变。</p><p>　　有时，修改环境列表会很有用。第1个原因是对环境列表的修改对后续创建的子进程都是可见的。第2个原因是环境列表的修改对加载到该进程的内存的新程序是可见的。因此，除了用于进程间通信，环境列表还能用于程序间通信。</p><h3 id="进程的内存布局">6.1 进程的内存布局</h3><p>　　系统分配给进程的内存包含多个部分，通常称为<strong>段</strong>或<strong>节</strong>，包含<span style="background-color:#ff0">文本段</span>、<span style="background-color:#ff0">初始化数据段</span>、<span style="background-color:#ff0">未初始化数据段</span>、<span style="background-color:#ff0">栈</span>和<span style="background-color:#ff0">堆</span>。</p><p>　　● 文本段包含进程运行的程序的机器语言指令。文本段是只读的，所以进程无法通过指针来修改其中的指令。多个进程可能运行相同的程序，所以文本段是共享的 (程序代码的单个副本可以映射到多个进程的虚拟地址空间)。</p><p>　　● 初始化数据段包含显式初始化的全局变量和静态变量。当程序加载到内存时，会从可执行文件中读这些变量的值。此外，该段也称为<span style="background-color:#ff0">用户初始化数据段</span>。</p><p>　　● 未初始化数据段包含隐式初始化的全局变量和静态变量。在程序启动前，系统会将该段初始化为0。由于历史原因，该段也称为<code>bss</code>段，源自早期汇编器助记符 "block started by symbol"。当程序存储在磁盘时，没必要为未初始化的数据分配空间。相反，可执行文件只需要记录未初始化数据段的位置和大小，并且这些空间由程序加载器在运行时分配。因此，才会用未初始化数据段来单独存储未初始化的全局变量和静态变量。此外，该段也称为<span style="background-color:#ff0">0初始化数据段</span>。</p><p>　　● 栈是包含栈帧的动态伸缩的段。系统会为所有当前被调用的函数分配栈帧，包含函数局部变量、参数和返回值。在C中，函数参数和局部变量称为<strong>自动变量</strong>，因为当函数创建时会自动创建这些变量。当函数返回时，自动变量会自动释放 (因为对应的栈帧已经被释放)。</p><p>　　● 堆是运行时为变量动态分配空间的区域。堆的顶端称为<strong>程序分段点</strong>。</p><p>　　可以通过命令<code>size</code>来展示二进制可执行文件的文本段、初始化数据段和未初始化数据段的大小。</p><p>　　<strong>应用程序二进制接口</strong>是用于指定二进制可执行文件在运行时如何与某些服务 (例如，内核或库) 交换信息的一组规则。ABI还指定了哪些寄存器或栈位置用于交换信息和交换的值的含义。一旦编译器使用了特定ABI，生成的二进制可执行文件可以运行在所有提供了该ABI的系统。这与仅保证应用程序源码的可移植性的标准化API (例如，SUSv3) 形成对比。</p><p>　　在之后的内容中，有些库函数会返回指向静态分配的内存的指针，也就是初始化数据段和未初始化数据段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mem_segments.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> globBuf[<span class="number">65536</span>];         <span class="comment">/* 未初始化数据段 */</span></span><br><span class="line"><span class="type">int</span> primes[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;; <span class="comment">/* 初始化数据段 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">/* 在square()的栈帧中分配空间 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result; <span class="comment">/* 在square()的栈帧中分配空间 */</span></span><br><span class="line">    result = x * x;</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">/* 返回值通过寄存器传递 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">doCalc</span><span class="params">(<span class="type">int</span> val)</span> <span class="comment">/* doCalc()的栈帧中分配空间 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The square of %d is %d\n&quot;</span>, val, square(val));</span><br><span class="line">    <span class="keyword">if</span> (val &lt; <span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t; <span class="comment">/* doCalc()的栈帧中分配空间 */</span></span><br><span class="line">        t = val * val * val;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The cube of %d is %d\n&quot;</span>, val, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> <span class="comment">/* 在main()的栈帧中分配空间 */</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> key = <span class="number">9973</span>;      <span class="comment">/* 初始化数据段 */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> mbuf[<span class="number">10240000</span>]; <span class="comment">/* 未初始化数据段 */</span></span><br><span class="line">    <span class="type">char</span> *p;                    <span class="comment">/* 在主函数的栈帧中分配空间 */</span></span><br><span class="line">    p = <span class="built_in">malloc</span>(<span class="number">1024</span>);           <span class="comment">/* 指向堆的指针 */</span></span><br><span class="line">    doCalc(key);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了各种C变量所在的段。这里展示的情况是基于编译器不执行优化和程序仅通过栈传递参数。当使用编译器优化后，可能会将频繁使用的变量存储在寄存器中，甚至直接优化到不存在。此外，有些ABI要求函数参数和结果通过寄存器传递。</p><p>　　Linux等大多数UNIX实现都提供了全局符号<code>etext</code>、<code>edata</code>和<code>end</code> (SUSv3并未说明这些符号)。这些符号可以在程序中用于获取文本段的下1个字节的起始地址 (对应<code>etext</code>)、未初始化数据段的下1个字节的起始地址 (对应<code>edata</code>) 和初始化数据段的下1个字节的起始地址 (对应<code>end</code>)。为了使用这些符号，需要显式声明它们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> etext, edata, end;</span><br></pre></td></tr></table></figure><p>　　然后，可以通过<code>&amp;etext</code>来获取文本段的结束地址/初始化数据段的起始地址。</p><img src="/2024/10/21/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-6/typical_memory_layout_of_a_process_on_linux.svg" title="typical_memory_layout_of_a_process_on_linux"><p>　　如图所示，这是x86-32架构的各种内存段的布局。程序的命令行参数存储在<code>argv</code>和<code>environ</code> (可以通过主函数的参数<code>argv</code>访问)。图中所示的十六进制地址可能因内核配置和程序链接选项而异。灰色部分表示程序虚拟地址空间中的无效区域，即这些区域的页表还未创建。</p><h3 id="虚拟内存管理">6.2 虚拟内存管理</h3><p>　　与大多数现代内核相同，Linux使用<strong>虚拟内存管理</strong>。虚拟内存管理通过充分利用<span style="background-color:#ff0">引用局部性</span>来提升CPU和RAM (物理内存) 的效率。大多数程序都有2种局部性，即<strong>空间局部性</strong>和<strong>时间局部性</strong>。空间局部性是程序<span style="background-color:#ff0">访问最近访问过的内存地址附近的内存地址</span>的趋势 (由于指令和数据结构的顺序处理)。时间局部性是程序<span style="background-color:#ff0">访问最近访问过的内存地址</span>的趋势 (由于循环)。</p><p>　　引用局部性使得在程序运行时仅在RAM中维护其部分地址空间成为可能。</p><img src="/2024/10/21/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-6/overview_of_virtual_memory.svg" title="overview_of_virtual_memory"><p>　　程序使用的内存划分为称为<strong>页</strong>的大小固定的单元。相应地，RAM也划分为相同大小的<strong>页帧</strong>。在任何时刻，仅需要程序的部分页驻留在页帧中，这些页称为<strong>驻留集</strong>。程序未使用的页的副本维护在<strong>交换空间</strong>中 (交换空间是磁盘空间中的预留区域，用于补充RAM)，仅在有需要时才会加载到物理内存。当程序引用的页未驻留在物理内存中时，会出现<strong>缺页</strong>，缺页处理程序会将对应的页加载到内存 (在此过程中，内核会挂起程序)。</p><p>　　对于x86-32，页大小是4096字节。部分其他Linux实现使用的页更大。例如，Alpha的页大小是8192字节，IA-64的页大小是可变的 (默认是16384字节)。程序可以通过调用<code>sysconf(_SC_PAGESIZE)</code>来得到页大小。</p><p>　　为了支持虚拟内存，内核会为每个进程都维护<strong>页表</strong>。页表描述了进程的每个页在<strong>虚拟地址空间</strong> (进程可用的虚拟内存页的集合) 中的位置。页表中的每个条目都表示虚拟页在RAM中的位置，或者虚拟页当前在磁盘上。通常，虚拟地址空间中的很多虚拟页都是<span style="background-color:#ff0">未使用</span>的，所以无需为它们维护页表条目。当进程试图访问没有对应页表条目的地址时，会收到信号<code>SIGSEGV</code>。</p><p>　　在进程的生命周期内，其有效虚拟地址集不是固定的，因为内核会给进程分配和取消分配页 (和页表条目)。当<span style="background-color:#ff0">栈向下增长到临界值</span>，<span style="background-color:#ff0">在堆上分配和释放空间</span> (通过<code>brk()</code>、<code>sbrk()</code>和<code>malloc()</code>等函数)，<span style="background-color:#ff0">连接和分离System V共享内存区域</span> (通过函数<code>shmat()</code>和<code>shmdt()</code>) 以及<span style="background-color:#ff0">创建内存映射和取消内存映射</span>时，就会出现这种情况。</p><p>　　虚拟内存的实现需要<strong>分页式内存管理单元</strong>形式的硬件支持。PMMU会将虚拟内存地址引用转换为对应的物理内存地址，并且会在虚拟内存地址对应的页没有驻留在RAM中时通知内核出现了缺页。</p><p>　　虚拟内存管理将进程的虚拟地址空间与RAM的物理地址空间分开，这有如下优势：</p><p>　　● 进程彼此隔离，并且也与内核隔离，所以进程无法读或修改其他进程或内核的内存 (使每个进程的页表条目都指向RAM或交换空间中的不同物理页)。</p><p>　　● 当有需要时，多个进程可以共享内存 (使不同进程的页表条目指向RAM中的相同物理页)。通常，有2种情况会需要内存共享。第1种情况是多个运行相同程序的进程会共享相同的程序代码副本，这种共享是隐式的。第2种情况是进程通过系统调用<code>shmget()</code>和<code>mmap()</code>来显式地请求共享其他进程的内存区域 (为了进程间通信)。</p><p>　　● 有助于实现进程保护 (可以通过标记页表条目来指示对应内容的访问权限)。当多个进程共享RAM中的物理页时，可以为每个进程指定不同的访问权限。</p><p>　　● 程序员和工具 (例如，编译程序和链接程序) 无需关注程序在RAM中物理布局。</p><p>　　● 因为仅需要程序的一部分驻留在内存中，所以程序的加载速度和运行速度更快。此外，这使得进程的虚拟内存容量大于RAM容量成为可能。</p><p>　　● 因为每个进程使用了更少的RAM，所以RAM中可以驻留更多的进程。同样，因为增加了CPU在任何时刻至少执行1个进程的可能，所以提高了CPU利用率。</p><h3 id="栈和栈帧">6.3 栈和栈帧</h3><p>　　栈会随着函数调用和返回而伸缩。对于Linux/x86-32 (和大多数其他Linux和UNIX实现)，栈位于高地址处，并且向下增长 (栈的实际方向是硬件实现细节。Linux实现HP PA-RISC使用的就是向下增长的栈)。特殊寄存器<strong>栈指针</strong>总是指向栈顶。当调用函数时，会在栈中分配1个栈帧；当函数返回时，会释放对应的栈帧。</p><p>　　从虚拟内存角度，栈的大小会随着栈帧的分配而增加。在大多数实现中，其大小不会随着栈帧的释放而减少，对应的内存会直接在分配栈帧时重新使用。之前所说的栈会随着栈帧的分配和释放而伸缩是从逻辑角度。</p><p>　　<span style="background-color:#ff0">内核栈</span>是系统为每个进程在内核内存中维护对应的内存区域，用于系统调用执行期间内部函数调用的栈。</p><p>　　除了之前介绍的栈和内核栈，还有<span style="background-color:#ff0">用户栈</span>。用户栈包含自动变量和调用链信息。每个函数都会使用特定的CPU寄存器 (例如，指向下1条待执行的机器语言指令的程序计数器)。当调用函数时，这些寄存器的副本会保存在被调函数的栈帧中，以便于在函数返回时恢复调用函数的寄存器值。</p><p>　　因为函数可以调用函数，所以栈中可以有多个栈帧 (若函数递归调用自己，则栈中会出现多个该函数的栈帧)。</p><img src="/2024/10/21/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-6/example_of_a_process_stack.svg" title="example_of_a_process_stack"><p>　　如图所示，这是6.1中的<code>mem_segments.c</code>的函数<code>square</code>执行期间栈的情况。</p><h3 id="命令行参数">6.4 命令行参数</h3><p>　　当执行程序时，命令行参数 (shell解析的单个词语) 可以通过主函数的参数访问。第1个参数是<code>int argc</code>，该参数是命令行参数的数量。第2个参数是<code>char *argv[]</code>，该参数是数组，除了最后1个元素是空指针之外，其他元素都是以<code>null</code>字符结尾的字符串。<code>argv[0]</code>通常是函数名。</p><p>　　<code>argv[0]</code>可以用于到相同程序的多个链接 (即名称)，并且根据调用的链接来执行不同的操作。例如，命令<code>gzip</code>、<code>gunzip</code>和<code>zcat</code>链接的可执行文件相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* necho.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, j, argv[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/10/21/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-6/values_of_argc_and_argv_for_the_command_necho_hello_world.svg" title="values_of_argc_and_argv_for_the_command_necho_hello_world"><p>　　这个示例会以每行1个参数的形式回显命令行参数。</p><p>　　因为<code>argv</code>以<code>NULL</code>结尾，所以可以通过如下方式来迭代命令行参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> **p;</span><br><span class="line"><span class="keyword">for</span> (p = argv; *p; p++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(*p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　参数<code>argc</code>和<code>argv</code>仅限于主函数。若需要在其他函数中使用命令行参数，则需要将<code>argv</code>作为参数传递或使用指向<code>argv</code>的全局指针。</p><p>　　任何进程的命令行参数都可以通过特定于Linux的文件<code>/proc/PID/cmdline</code>来获取，其中的参数以<code>null</code>字节结尾 (进程可以通过文件<code>/proc/self/cmdline</code>来访问自己的命令行参数)。</p><p>　　GNU C标准库提供了2个全局变量来获取用于执行程序的名称 (即<code>argv[0]</code>)，即<code>program_invocation_name</code>和<code>program_invocation_short_name</code>。前者提供用于执行程序的完整路径名，而后者则去除了目录前缀。若需要使用这2个全局变量，则需要定义宏<code>_GNU_SOURCE</code>，这2个全局变量就可以通过头文件<code>error.h</code>获取。</p><p>　　如6.1中的图所示，数组<code>argv</code>和<code>environ</code>以及它们最初指向的字符串占据单独的内存区域。该区域的容量上限可以存储在该区域。对于SUSv3，该上限通过常量<code>ARG_MAX</code>或调用<code>sysconf(_SC_ARG_MAX)</code>来获取。SUSv3还要求<code>ARG_MAX</code>的最小值是<code>_POSIX_ARG_MAX</code> (即4096)。大部分UNIX实现允许更高的上限。SUSv3并未说明实现在计算<code>ARG_MAX</code>时否需要包含开销字节 (即结尾的<code>null</code>字节、对齐字节以及<code>argv</code>和<code>environ</code>数组的指针)。</p><p>　　从历史角度，Linux的<code>ARG_MAX</code>固定为32页 (即Linux/x86-32上的131072字节)，并且包括开销字节。从内核2.6.23开始，数组<code>argv</code>和<code>environ</code>所处内存区域的限制可以通过资源限制<code>RLIMIT_STACK</code>来控制，并且允许更大的限制，该限制计算为调用<code>execve()</code>时资源限制<code>RLIMIT_STACK</code>的软限制的<span class="math inline">\(\frac{1}{4}\)</span>。</p><p>　　很多程序都是通过库函数<code>getopt()</code>来解析命令行选项 (即以连字符<code>-</code>开头的参数)。</p><h3 id="环境列表">6.5 环境列表</h3><p>　　对于大多数shell，可以通过命令<code>export</code>来为添加环境变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL=/bin/bash</span><br><span class="line">export SHELL</span><br></pre></td></tr></table></figure><p>　　在这个示例中，第1行命令会创建变量<code>SHELL</code>，第2行命令会将该变量添加到shell进程的环境列表中。对于<code>bash</code>和<code>ksh</code>，这2行命令可以缩写为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export SHELL=/bin/bash</span><br></pre></td></tr></table></figure><p>　　对于<code>csh</code>，可以通过命令<code>setenv</code>来设置环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv SHELL /bin/bash</span><br></pre></td></tr></table></figure><p>　　环境变量可以通过命令<code>unset</code>移除 (<code>csh</code>中的命令<code>unsetenv</code>)。</p><p>　　对于<code>sh</code>及其继承者 (例如，<code>bash</code>和<code>ksh</code>)，以下语法可用于在执行程序时为执行程序的进程创建环境变量 (不会影响shell)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NAME=value program1 program2</span><br></pre></td></tr></table></figure><p>　　命令<code>printenv</code>可用于获取当前环境列表。</p><p>　　任何进程的环境列表都可以通过特定于Linux的文件<code>/proc/PID/environ</code>来获取 (形如<code>NAME=value</code>，并且以<code>null</code>字节结尾)。</p><h4 id="在程序中访问环境列表">6.5.1 在程序中访问环境列表</h4><p>　　在C程序中，环境列表可以通过全局变量<code>char **environ</code> (C运行时启动代码会定义该变量，并且会将环境列表的地址赋值给它)。与<code>argv</code>类似，<code>environ</code>是数组，除了最后1个元素是空指针之外，其他元素都是以<code>null</code>字符结尾的字符串。</p><img src="/2024/10/21/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-6/example_of_process_environment_list_data_structures.svg" title="example_of_process_environment_list_data_structures"><p>　　如图所示，这是命令<code>printenv</code>展示的环境列表对应的数据结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* display_env.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> **ep;</span><br><span class="line">    <span class="keyword">for</span> (ep = environ; *ep; ep++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(*ep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会通过访问<code>environ</code>来列出进程的所有环境变量，其输出与命令<code>printenv</code>的相同。</p><p>　　还可以通过声明主函数的第3个参数来访问环境列表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *envp[])</span></span><br></pre></td></tr></table></figure><p>　　参数<code>envp</code>的用法与<code>environ</code>的相同，但仅限于主函数。尽管该功能广泛实现于UNIX系统，但还是应该避免使用，因为SUSv3并未说明该功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 若环境变量存在则返回对应值；若不存在则返回NULL */</span></span><br></pre></td></tr></table></figure><p>　　对于给定名称的环境变量，<code>getenv()</code>会返回对应值 (字符串)。若环境变量不存在，则返回<code>NULL</code>。</p><p>　　● SUSv3明确指出，应用程序<span style="background-color:#ff0">不应该</span>修改<code>getenv()</code>返回的字符串，因为该字符串实际上就是环境列表的一部分 (对于大部分实现)。</p><p>　　● SUSv3允许<code>getenv()</code>实现返回的字符串使用静态分配的缓冲区，但静态缓冲区可能被后续的<code>getenv()</code>、<code>setenv()</code>、<code>putenv()</code>或<code>unsetenv()</code>调用覆盖。尽管<code>glibc</code>的<code>getenv()</code>实现不以这种方式使用静态缓冲区，为了例保证可移植性，还是应该在后续调用这些函数前将<code>getenv()</code>返回的字符串复制到其他位置。</p><h4 id="修改环境列表">6.5.2 修改环境列表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span>; <span class="comment">/* 若成功则返回0，若出错则返回非0值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> overwrite)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>putenv()</code>会创建环境变量，或者修改已有的环境变量 (若存在)。参数<code>string</code>是形如<code>name=value</code>的字符串。在调用<code>putenv()</code>后，<code>string</code>会成环境变量的一部分 (并非复制<code>string</code>，而是直接将其赋值给环境列表中的元素)，即后续对<code>string</code>的修改会直接应用到环境变量。因此，<code>string</code>不能是自动变量 (当定义该变量的函数返回后，存储自动变量的内存区域可能会被覆盖)。若<code>putenv()</code>出错，则返回<span style="background-color:#ff0">非0值</span>。</p><p>　　<code>glibc</code>的<code>putenv()</code>实现提供了非标准扩展。若<code>string</code>不包含等号<code>=</code>，则会从环境列表中移除名称为<code>string</code>的环境变量。</p><p>　　函数<code>setenv()</code>会通过为形如<code>name=value</code>的字符串分配内存缓冲区来创建环境变量，然后将参数<code>name</code>和<code>value</code>复制到该缓冲区 (不同于<code>putenv()</code>，后续对<code>name</code>和<code>value</code>的修改不会应用到环境变量，所以这2个参数可以是自动变量)。只有当参数<code>overwrite</code>非0时，才会覆盖已有的环境变量。</p><p>　　函数<code>unsetenv()</code>会移除名为参数<code>name</code>的环境变量。与<code>setenv()</code>相同，<code>name</code>不应该包含等号。</p><p>　　<code>setenv()</code>和<code>unsetenv</code>源于BSD，它们的使用率不如<code>putenv()</code>。POSIX.1和SUSv2没有说明这2个函数，但SUSv3详细说明了它们。对于<code>glibc</code> 2.2.2之前的版本，<code>unsetenv()</code>的返回值类型是<code>void</code>，这也是该函数在BSD中的返回值类型，并且部分UNIX实现依然如此。</p><p>　　有时，可能需要清空环境列表，可以直接将<code>NULL</code>赋值给<code>environ</code>，这也是库函数<code>clearenv()</code>执行的步骤。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE <span class="comment">/* 或#define _SVID_SOURCE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">clearenv</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 若成功则返回0，若出错则返回非0值 */</span></span><br></pre></td></tr></table></figure><p>　　在部分情况下，<code>setenv()</code>和<code>clearenv()</code>一起使用会导致内存泄漏。<code>setenv()</code>会分配内存缓冲区，并会将其作为环境变量的一部分。调用<code>clearenv()</code>时，不会释放缓冲区。在实际中，通常不会这样使用，因为一般仅会在开始时调用<code>clearenv()</code>，或者用于清空继承的环境列表。</p><p>　　SUSv3并未说明<code>clearenv()</code>，但很多UNIX实现都提供了该函数。SUSv3指出，若应用程序直接修改<code>environ</code> (正如<code>clearenv()</code>所作)，则<code>setenv()</code>、<code>unsetenv()</code>和<code>getenv()</code>的行为将会是未定义的 (防止符合规范的应用程序通过修改环境列表来完全控制实现环境变量的数据结构)。SUSv3要求应用程序只能通过先获取所有环境变量，再对其逐个调用<code>unsetenv()</code>的方式来清空环境列表。</p><h4 id="示例程序">6.5.3 示例程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">char</span> **ep;</span><br><span class="line"></span><br><span class="line">    clearenv();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (putenv(argv[j]) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;putenv: %s&quot;</span>, argv[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setenv(<span class="string">&quot;GREET&quot;</span>, <span class="string">&quot;Hello world&quot;</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;setenv&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsetenv(<span class="string">&quot;BYE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ep = environ; *ep; ep++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(*ep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这是之前介绍的函数的用法示例。在第1次清空环境列表后，该程序会创建命令行参数中定义的环境变量。然后，创建环境变量<code>GTEET</code> (若不存在)，并且移除环境变量<code>BYE</code>。最后，打印当前环境列表。</p><h3 id="非本地跳转">6.6 非本地跳转</h3><p>　　库函数<code>setjmp()</code>和<code>longjmp()</code>用于执行<strong>非本地跳转</strong> (非本地表示跳转目标在当前执行的函数之外)。</p><p>　　与其他编程语言相同，C提供了跳转语句。跳转语句更容易使程序难以阅读和维护，但有时也会使程序更高效和/或简洁。</p><p>　　无法从当前执行的函数跳转到其他函数是C跳转的限制之一。但是，该功能有时可能很有用。考虑如下错误处理场景：在多层嵌套的函数执行期间遇到了错误，处理方法是放弃当前执行的任务，经过多个函数返回，然后继续执行更高层的函数 (甚至高于主函数)。为了完成这些，需要让每个函数都返回合适的返回值。这是完全合理的，在很多情况下，这是理想的处理方法。但是，在有些情况下，直接从嵌套函数的中间跳转到调用它的函数 (调用函数、调用函数的调用函数，依此类推) 会让代码更简洁，这正是<code>setjmp()</code>和<code>longjmp()</code>提供的功能。</p><p>　　对于C，无法在函数之间跳转的原因是所有的C函数都在相同的作用域 (标准C中没有函数声明的嵌套，尽管<code>gcc</code>支持这种方式)。因此，对于函数X和Y，编译器无法得知在调用函数Y时函数X的栈帧是否在栈中 (即无法得知能否从函数Y跳转到函数X)。对于Pascal等编程语言，允许函数声明嵌套和从嵌套函数跳转到包含它的函数，并且函数的静态作用域允许编译器确定一些动态作用域的信息。若函数Y在词法上嵌套在函数X中，则编译器会知道当调用函数Y时函数X的栈帧必定在栈中，并且能生成从函数Y跳转函数X的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>; <span class="comment">/* 若第1次调用则返回0；若通过longjmp()则返回非0值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure><p>　　调用<code>setjmp()</code>会为后续的<code>longjmp()</code>执行的跳转设置目标 (即调用<code>setjmp()</code>的位置)。第1次调用<code>setjmp()</code>会返回0。在调用<code>longjmp()</code>后，<code>setjmp()</code>会像第2次调用它一样返回，返回值是<code>longjmp()</code>的参数<code>val</code>。通过为参数<code>val</code>指定不同的值，就可以区分不同跳转点。将参数<code>val</code>指定为0时，为了区分第1次调用<code>setjmp()</code>的返回值，<code>longjmp()</code>会将其替换为<span style="background-color:#ff0">1</span>。</p><p>　　<code>setjmp()</code>可以将当前进程的环境列表的各种信息存储在参数<code>env</code>中，<code>longjmp()</code>必须将参数<code>env</code>指定为相同的值。因为<code>setjmp()</code>的调用和<code>longjmp()</code>的调用在不同的函数，参数<code>env</code>需要声明为全局变量，或者作为函数参数。</p><p>　　参数<code>env</code>还存储着调用<code>setjmp()</code>时<span style="background-color:#ff0">程序计数器</span>和<span style="background-color:#ff0">栈指针</span>的副本。这些信息允许后续的<code>longjmp()</code>调用执完成2个关键的步骤：</p><p>　　● 去除栈上的<code>longjmp()</code>调用之间和<code>setjmp()</code>调用之前的无关函数的栈帧。该过程有时称为<span style="background-color:#ff0">展开栈</span>，通过将栈指针重置为<code>env</code>中保存的值来完成。</p><p>　　● 通过重置程序计数器来让程序从第1次调用<code>setjmp()</code>的位置执行。同样，这也是通过<code>env</code>中保存的值来完成。</p><p>　　若跳转语句会让程序变得难以阅读，则非本地跳转会严重加剧这一点，因为非本地跳转能够在任意2个函数之间进行控制转移。因此，应该尽量不使用非本地跳转。</p><h4 id="示例程序-1">6.6.1 示例程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* longjmp.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> jmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    longjmp(env, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> argc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        longjmp(env, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    f2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (setjmp(env))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Calling f1() after initial setjmp()\n&quot;</span>);</span><br><span class="line">        f1(argc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;We jumped back from f1()\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;We jumped back from f2()\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这是<code>setjmp()</code>和<code>longjmp()</code>的用法示例。该程序会在第1次调用<code>setjmp()</code>来设置跳转目标。后续的<code>switch</code>语句会根据<code>setjmp()</code>返回值来执行不同的操作。若返回值是0 (表示第1次调用<code>setjmp()</code>)，则会调用<code>f1()</code>，而<code>f1()</code>会根据<code>argc</code>来调用<code>longjmp()</code>或<code>f2()</code>。若执行到<code>f2()</code>，则会调用<code>longjmp()</code>。<code>longjmp()</code>会执行非本地跳转。</p><h4 id="setjmp的限制">6.6.2 <code>setjmp()</code>的限制</h4><p>　　SUSv3和C99指出，只能在以下上下文中调用<code>setjmp()</code>：</p><p>　　● 作为选择或迭代语句 (例如，<code>if</code>、<code>switch</code>和<code>while</code>) 的完整控制表达式。</p><p>　　● 作为一元运算符<code>!</code>的操作数，其结果表达式是选择或迭代语句的完整控制表达式。</p><p>　　● 作为比较操作 (例如，<code>==</code>、<code>!=</code>和<code>&lt;</code>) 的一部分，其他操作数是整数常量表达式，并且结果表达式是选择或迭代语句的完整控制表达式。</p><p>　　● 作为未嵌入到较大表达式中的独立函数调用。</p><p>　　显然，赋值语句并不在以上范围，<code>s = setjmp(env)</code>不符合规范。</p><p>　　若将<code>setjmp()</code>作为常规函数来实现，则无法保证有足够的信息来保存封闭表达式所使用的所有寄存器和临时栈位置的值 (用于后续调用<code>longjmp()</code>时恢复)。因此，仅允许在不需要临时存储的表达式中调用<code>setjmp()</code>。</p><h4 id="longjmp滥用">6.6.3 <code>longjmp()</code>滥用</h4><p>　　若将缓存区<code>env</code>声明为全局变量，则可能会按以下步骤执行：</p><p>　　1) 调用函数<code>x()</code>，<code>x()</code>会通过<code>setjmp()</code>来在全局变量<code>env</code>中设置跳转目标。</p><p>　　2) 从<code>x()</code>返回。</p><p>　　3) 调用函数<code>y()</code>，<code>y()</code>会通过<code>env</code>来调用<code>longjmp()</code>。</p><p>　　这是很严重的错误，因为无法将已经返回的函数作为跳转目标。在这种情况下，<code>longjmp()</code>会试图展开栈来回到已经不存在的栈帧。若足够幸运，则程序会崩溃。但是，根据栈的状态，其他可能的结果包括无限调用-返回循环和程序的行为如同其真的从已经结束的函数返回 (对于多线程程序，类似的滥用行为是<code>setjmp()</code>的调用和<code>longjmp()</code>的调用在不同的线程)。</p><p>　　SUSv3指出，若在嵌套的信号处理程序中调用<code>longjmp()</code> (即在信号处理程序中调用其他信号处理程序)，则程序的行为将会是未定义的。</p><h4 id="编译器优化问题">6.6.4 编译器优化问题</h4><p>　　若使用编译器优化，则可能会改变程序的指令执行顺序和将不使用编译器优化时存储在RAM的变量存储在寄存器中。这些优化通常依赖于反映程序词法结构的运行时控制流。因为通过<code>setjmp()</code>和<code>longjmp()</code>执行的跳转操作在运行时生成和执行，并且不会反映在程序词法结构上，执行编译器优化时不会考虑它们。此外，部分ABI实现的语义要求<code>longjmp()</code>恢复调用<code>setjmp()</code>时保存的寄存器副本。这表示<code>longjmp()</code>可能会让优化后的变量最终取得错误的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* setjmp_vars.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> jmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">doJump</span><span class="params">(<span class="type">int</span> nvar, <span class="type">int</span> rvar, <span class="type">int</span> vvar)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Inside doJump(): nvar=%d rvar=%d vvar=%d\n&quot;</span>, nvar, rvar, vvar);</span><br><span class="line">    longjmp(env, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nvar;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> rvar; <span class="comment">/* 在可能的情况下分配在寄存器中 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> vvar;</span><br><span class="line"></span><br><span class="line">    nvar = <span class="number">111</span>;</span><br><span class="line">    rvar = <span class="number">222</span>;</span><br><span class="line">    vvar = <span class="number">333</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setjmp(env) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* setjmp()后执行 */</span></span><br><span class="line">        nvar = <span class="number">777</span>;</span><br><span class="line">        rvar = <span class="number">888</span>;</span><br><span class="line">        vvar = <span class="number">999</span>;</span><br><span class="line">        doJump(nvar, rvar, vvar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* longjmp()后执行 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After longjmp(): nvar=%d rvar=%d vvar=%d\n&quot;</span>, nvar, rvar, vvar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　当正常编译这个程序时，会得到预期的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cc -o setjmp_vars setjmp_vars.c</span><br><span class="line">./setjmp_vars</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside doJump(): nvar=777 rvar=888 vvar=999</span><br><span class="line">After longjmp(): nvar=777 rvar=888 vvar=999</span><br></pre></td></tr></table></figure><p>　　但是，在使用编译器优化后，会得到意料之外的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cc -O -o setjmp_vars setjmp_vars.c</span><br><span class="line">./setjmp_vars</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside doJump(): nvar=777 rvar=888 vvar=999</span><br><span class="line">After longjmp(): nvar=111 rvar=222 vvar=999</span><br></pre></td></tr></table></figure><p>　　在<code>longjmp()</code>执行完成后，<code>nvar</code>和<code>rvar</code>的值重置为调用<code>setjmp()</code>之前的值。这是因为编译器执行的代码重组由于<code>longjmp()</code>而混乱。所有可能作为优化对象的局部变量 (通常指指针、<code>char</code>、<code>int</code>、<code>float</code>和<code>long</code>) 都可能会遇到这个问题。</p><p>　　可以通过将变量声明为<code>volatile</code> (告诉编译器不对该变量使用优化) 来解决这个问题。在示例程序中，<code>vvar</code>就声明为<code>volatile</code>，所以它的值是正确的。</p><p>　　因为不同编译器使用的优化类型不同，为了保证可移植性，应该将调用<code>setjmp()</code>的函数中的可能成为优化对象的局部变量都声明为<code>volatile</code>。</p><p>　　若对GNU C编译器使用选项<code>-Wextra</code> (额外的警告)，则会生成如下警告：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc -Wall -Wextra -O -o setjmp_vars setjmp_vars.c</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setjmp_vars.c: In function &#x27;main&#x27;:</span><br><span class="line">setjmp_vars.c:16: warning: variable &#x27;nvar&#x27; might be clobbered by &#x27;longjmp&#x27; or &#x27;vfork&#x27;</span><br><span class="line">setjmp_vars.c:17: warning: variable &#x27;rvar&#x27; might be clobbered by &#x27;longjmp&#x27; or &#x27;vfork&#x27;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2024/10/05/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-5/" rel="prev" title="《Linux/UNIX系统编程手册》第5章 文件I/O：更多细节"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第5章 文件I/O：更多细节</a></div><div class="post-nav-item"><a href="/2024/10/29/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-7/" rel="next" title="《Linux/UNIX系统编程手册》第7章 内存分配">《Linux/UNIX系统编程手册》第7章 内存分配 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script></body></html>