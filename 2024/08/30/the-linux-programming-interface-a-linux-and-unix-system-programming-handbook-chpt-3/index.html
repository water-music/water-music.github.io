<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><link rel="canonical" href="http://example.com/2024/08/30/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-3/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/08/30/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-3/","path":"2024/08/30/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-3/","title":"《Linux/UNIX系统编程手册》第3章 系统编程概念"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第3章 系统编程概念 |</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">3.1 系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gnu-c%E5%BA%93"><span class="nav-text">3.2 GNU C库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF"><span class="nav-text">3.3 处理系统调用和库函数中的错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%94%99%E8%AF%AF"><span class="nav-text">3.3.1 处理系统调用错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%BA%93%E5%87%BD%E6%95%B0%E9%94%99%E8%AF%AF"><span class="nav-text">3.3.2 处理库函数错误</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E6%9C%AC%E4%B9%A6%E4%B8%AD%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-text">3.4 关于本书中示例程序的说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-text">3.4.1 常用函数头文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E8%A7%A3%E6%9E%90%E6%95%B0%E5%80%BC%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-text">3.4.2 用于解析数值命令行参数的函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">3.5 可移植性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%AE%8F"><span class="nav-text">3.5.1 功能测试宏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.5.2 系统数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">3.5.3 其他可移植性问题</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2024/08/30/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux/UNIX系统编程手册》第3章 系统编程概念 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第3章 系统编程概念</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-08-30 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-30T00:00:00+08:00">2024-08-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-10-02 00:00:00" itemprop="dateModified" datetime="2024-10-02T00:00:00+08:00">2024-10-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/computer-system/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>20k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　<strong>系统调用</strong>是内核中的受控入口点，允许进程请求内核代表自己执行某些操作 (命令<code>strace</code>可用于追踪程序中的系统调用)。</p><p>　　● 系统调用会将处理器状态从用户模式切换到内核模式，以便CPU访问受保护的内核内存。</p><p>　　● 系统调用集是固定的，每个系统调用都有唯一的数字标识符 (这些标识符通常对程序不可见，因为程序通过名称来标识系统调用)。</p><p>　　● 每个系统调用都可能有参数，指定要从用户空间 (进程的虚拟地址空间) 传输到内核空间的信息，反之亦然。</p><p>　　在Linux中，系统调用服务例程的名称通常是<code>sys_xyz()</code>，其中<code>xyz()</code>是对应的系统调用名。</p><p>　　<strong>库函数</strong>是构成标准C库的众多函数之一。很多库函数都不会使用系统调用。相反，有些库函数就是系统调用的包装函数，这些库函数提供的接口通常比对应的系统调用提供的接口更易于使用。</p><p>　　从C程序角度，调用C库中的包装函数等同于调用对应的系统调用服务例程。在之后的内容，会用诸如 "调用系统调用<code>xyz()</code>" 的措辞表示 "调用系统调用<code>xyz()</code>的包装函数"。</p><p>　　各种UNIX实现上有很多标准C库的实现。Linux上最广泛使用的实现是GNU C库 (即<code>glibc</code>)。GNU C库的主要开发者和维护者最初是Roland McGrath。如今，这项工作由Ulrich Drepper接班。Linux上还有其他可用的C库，包括用于嵌入式设备应用程序的内存要求较小的库 (例如，<code>uClibc</code>和<code>diet libc</code>)。</p><p>　　在C语言中，术语<strong>左值</strong>指引用存储区域的表达式。最常见的示例就是变量标识符。部分运算符也会生成左值。例如，若<code>p</code>是指向存储区域的指针，则<code>*p</code>就是左值。</p><p>　　对于POSIX.1-1990说明的很多函数，POSIX.1-1990要求头文件<code>sys/types.h</code>的引入先于其他与这些函数有关联的头文件。但是，这个要求是多余的，因为当时的大部分UNIX实现都不要求应用程序为这些函数引入此头文件。因此，SUSv1移除了该要求。尽管如此，在开发可移植程序时，尽量将该头文件作为第1批引入的头文件。</p><span id="more"></span><h3 id="系统调用">3.1 系统调用</h3><p>　　从编程角度，调用系统调用与调用C函数极其相似。但是，系统调用的执行包含很多步骤。以x86-32为例，其流程如下：</p><p>　　1) 应用程序调用C库中的系统调用包装函数。</p><p>　　2) 包装函数必须保证系统调用的所有参数都可用于系统调用陷阱处理例程。这些参数通过栈传递给包装函数，但内核希望这些参数位于特定的寄存器中。包装函数会将这些参数复制到内核指定的寄存器。</p><p>　　3) 因为所有系统调用都以相同的方式进入内核，所以内核需要识别系统调用的方法。为了实现这一点，包装函数将系统调用号复制到CPU寄存器<code>%eax</code>。</p><p>　　4) 包装函数执行陷阱指令<code>int 0x80</code>，该指令会将处理器从用户模式切换到内核模式并执行系统陷阱向量的位置<code>0x80</code>指向的代码。</p><p>　　5) 内核调用例程<code>system_call()</code> (位于汇编文件<code>arch/i386/entry.S</code>) 来处理陷阱，该处理程序会执行5个步骤。第1步，<span style="background-color:#ff0">将寄存器值保存到内核栈</span>。第2步，<span style="background-color:#ff0">检查系统调用号的有效性</span>。第3步，<span style="background-color:#ff0">调用合适的系统调用服务例程</span>，通过系统调用号索引包含所有系统调用服务例程的表 (对应内核变量<code>sys_call_table</code>) 来查找例程。若系统调用服务例程有参数，则会先验证其有效性。然后，服务例程执行请求的任务 (这些任务可能会涉及根据参数指定的地址修改值或在用户内存和内核内存中传输数据)，最后，服务例程返回结果状态给例程<code>system_call()</code>。第4步，<span style="background-color:#ff0">从内核栈中恢复寄存器值并将系统调用返回值压入栈</span>。第5步，<span style="background-color:#ff0">返回到包装函数，同时处理器切换到用户模式</span>。</p><p>　　6) 若系统调用服务例程的返回值表示出错，则包装函数会根据该返回值设置全局变量<code>errno</code>。然后，包装函数返回到调用函数，提供1个整数返回值来指示系统调用是否成功。</p><p>　　在Linux中，系统调用服务例程遵循非负返回值表示成功的约定。当出错时，例程会返回负值，该值是<code>errno</code>的某个值的相反数。当返回值为负时，C库中的包装函数会取它的相反数，将结果复制到<code>errno</code>，然后返回-1作为结果，表示出错。</p><p>　　非负返回值表示成功的约定基于假设：系统调用服务例程正常运行时不会返回负值。对于少数系统调用服务例程，此假设不成立。一般情况下，这不是问题，因为<code>errno</code>的负值范围不与有效的负返回值重叠。但是，对于系统调用<code>fcntl()</code>的操作<code>F_GETOWN</code>，这个约定会导致问题。</p><p>　　较新的x86-32架构实现了指令<code>sysenter</code>，该指令提供了比传统的陷阱指令<code>int 0x80</code>更快速地切换到内核模式的方法。内核2.6和<code>glibc</code> 2.3.2及更高的版本支持该指令。</p><img src="/2024/08/30/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-3/steps_in_the_execution_of_a_system_call.svg" title="steps_in_the_execution_of_a_system_call"><p>　　上图是系统调用<code>execve()</code>的执行步骤。对于运行在x86-32上的Linux，<code>execve()</code>的系统调用号是11 (<code>__NR_execve</code>)。因此，在向量<code>sys_call_table</code>中，条目11包含系统调用服务例程<code>sys_execve()</code>的地址。</p><p>　　以系统调用<code>getppid()</code>为例，该系统调用会返回调用进程的父进程的进程ID，对于运行在x86-32上的Linux 2.6.25，1千万次调用大约耗时2.2s。在同样的系统上，1千万次调用简单地返回1个整数的C函数大约耗时0.11s。此外，大多数系统调用的耗时都远高于<code>getppid()</code>的耗时。</p><h3 id="gnu-c库">3.2 GNU C库</h3><p>　　当需要确定系统上的GNU C库的版本时，可以在shell中以运行程序的方式运行<code>glibc</code>共享库文件，这会显示大量文本 (包括版本号) ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/lib/libc.so.6</span><br></pre></td></tr></table></figure><p>　　在某些Linux分发版中，GNU C库的路径并非<code>/lib/libc.so.6</code>，可以对动态链接<code>glibc</code>的可执行文件运行程序<code>ldd</code> (列出动态依赖) 来确定库的位置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd myprog | grep libc</span><br></pre></td></tr></table></figure><p>　　应用程序可以通过2种方法来确定系统中已有的GNU C库的版本，即判断常量和调用库函数。从2.0版本开始，<code>glibc</code>定义了2个常量 (<code>__GLIBC__</code>和<code>__GLIBC_MINOR__</code>)，可以在编译时进行判断 (<code>#ifdef</code>语句)。例如，对于<code>glibc</code>版本是2.12的系统，这2个常量的值分别是2和12。但是，这种方法不适用于程序运行时的系统和编译时的系统不同的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gnu/libc-version.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">gnu_get_libc_version</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回null结尾的静态分配的字符串，其中包含GNU C库的版本号 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>gnu_get_libc_version()</code>可以在运行时确定<code>glibc</code>的版本，该函数会返回形如<code>2.12</code>的字符串。</p><p>　　此外，函数<code>confstr()</code>也可用于确定<code>glibc</code>的版本，通过该函数检索配置变量<code>_CS_GNU_LIBC_VERSION</code> (仅限<code>glibc</code>) 的值，会返回形如<code>2.12</code>的字符串。</p><h3 id="处理系统调用和库函数中的错误">3.3 处理系统调用和库函数中的错误</h3><p>　　几乎所有系统调用和库函数都会返回某种类型的状态值，表示调用是否成功。应<span style="background-color:#ff0">始终</span>检查状态值以确定调用是否成功。若失败，则采取合适的行动 (至少应该显示错误信息，警告发生了意外情况)。</p><p>　　少部分系统调用不会失败。例如，<code>getpid()</code>总是会返回进程的进程ID，<code>_exit()</code>总是会终止进程。对于这些系统调用，检查返回值并不是必需的。</p><h4 id="处理系统调用错误">3.3.1 处理系统调用错误</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cnt = read(fd, buf, numbytes);</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read was interrupted by a signal\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Some other error occurred */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　每个系统调用的说明都给出了返回值，并且指出了那些值表示出错。返回值-1通常表示出错。当系统调用失败时，会将全局整数变量<code>errno</code>设置为正值，以标识特定的错误。头文件<code>errno.h</code>提供了<code>errno</code>的声明和相关错误号的常量，这些常量名都以<code>E</code>开头。错误相关说明提供了每个系统调用可能的<code>errno</code>值。</p><p>　　成功的系统调用和库函数不会将<code>errno</code>置0。但是，SUSv3允许成功的函数调用将<code>errno</code>设置为非0值 (尽管只有少数函数如此)。因此，在检查错误时，应先检查函数返回值是否表示出错，只有返回值表示出错时，才继续检查<code>errno</code>以确定导致错误的原因。</p><p>　　<code>getpriority()</code>等少数系统调用在正常运行时也会返回-1。对于这些函数，在调用之前应该先把<code>errno</code>置0，在调用后再进行判断。若调用返回-1并且<code>errno</code>非0，则表示出错。少数相似的库函数也是同理。</p><p>　　在调用出错后通常采取的行动是根据<code>errno</code>值打印错误信息。库函数<code>perror()</code>和<code>strerror()</code>正是用于此目的。这2个函数返回的错误信息的语言是系统设置的语言。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span>;</span><br></pre></td></tr></table></figure><p>　　函数<code>perror()</code>会打印参数<code>msg</code>指向的字符串加上当前<code>errno</code>值对应的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>; <span class="comment">/* 返回errnum对应的字符串 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>strerror()</code>会返回参数<code>errnum</code>中的错误号对应的错误信息。该函数返回的字符串是静态分配的，所以它能被后续的<code>strerror()</code>调用覆盖。</p><p>　　若<code>errnum</code>指定的错误号不存在，则函数<code>strerror()</code>返回<code>Unknown error nnn</code>形式的字符串。对于某些实现，函数<code>strerror()</code>在这种情况下会返回<code>NULL</code>。</p><h4 id="处理库函数错误">3.3.2 处理库函数错误</h4><p>　　各种库函数会返回不同的数据类型和不同的值来表示出错。这里将库函数分为3类：</p><p>　　● 第1类库函数返回错误信息的方式与系统调用相同，即返回值为-1并设置<code>errno</code>来表示特定的错误。函数<code>remove()</code>便是其中之一，该函数会删除文件 (使用系统调用<code>unlink()</code>) 或目录 (使用系统调用<code>rmdir()</code>)。这类函数的错误处理与系统调用的错误处理相同。</p><p>　　● 第2类函数的错误返回值不是-1，但仍然会设置<code>errno</code>来表示特定的错误情况。函数<code>fopen()</code>便是其中之一，该函数出错时会返回空指针，并且会根据出错的底层系统调用设置<code>errno</code>。函数<code>perror()</code>和<code>strerror()</code>可用于处理此类函数出错。</p><p>　　● 第3类函数不使用<code>errno</code>。确定此类函数是否出错及其原因需要基于函数说明。</p><h3 id="关于本书中示例程序的说明">3.4 关于本书中示例程序的说明</h3><p>　　本书中的大量示例程序依赖命令行选项和参数来决定其行为。</p><p>　　传统的UNIX命令行选项由1个连字符<code>-</code>加上1个标识选项的字母和1个可选的参数组成。GNU工具提供的扩展选项语法由2个连字符<code>-</code>加上1个标识选项的字母和1个可选的参数组成。可以通过标准<code>getopt()</code>库函数来解析这些选项。</p><p>　　本书中的每个示例程序都提供了简单的帮助工具。如果使用选项<code>--help</code>调用程序，程序会给出命令行选项和参数的语法的相关信息。</p><h4 id="常用函数头文件">3.4.1 常用函数头文件</h4><p>　　大部分示例程序都引入了包含常用定义的头文件，并且这些程序也会使用1组常用函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* tlpi_hdr.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TLPI_HDR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TLPI_HDR_H           <span class="comment">/* 防止意外的多重引用 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>       <span class="comment">/* 很多程序使用的类型定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>           <span class="comment">/* 标准I/O函数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>          <span class="comment">/* 常用库函数的原型以及常量EXIT_SUCCESS和EXIT_FAILURE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>          <span class="comment">/* 很多系统调用的原型 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>           <span class="comment">/* errno声明和errno常量 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>          <span class="comment">/* 常用字符串处理函数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;get_num.h&quot;</span>         <span class="comment">/* 用于处理数字参数的自定义函数getInt()和getLong()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;error_functions.h&quot;</span> <span class="comment">/* 用于处理错误的自定义函数的声明 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FALSE,</span><br><span class="line">    TRUE</span><br><span class="line">&#125; Boolean;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(m, n) ((m) &lt; (n) ? (m) : (n))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(m, n) ((m) &gt; (n) ? (m) : (n))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>　　几乎本书中的所有示例程序都会使用头文件<code>tlpi_hdr.h</code>。该头文件引入了各种头文件，并且定义了数据类型<code>Boolean</code>和用于计算2个数字的最大值和最小值的宏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* error_functions.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ERROR_FUNCTIONS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_FUNCTIONS_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errMsg</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="comment">/* 该宏可以保证使用以下函数来终止主函数或其他一些有返回值的函数时，</span></span><br><span class="line"><span class="comment">    gcc -Wall不会提示&quot;control reaches end of non-void function&quot; */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NORETURN __attribute__((__noreturn__))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NORETURN</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span> NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span> NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExitEN</span><span class="params">(<span class="type">int</span> errnum, <span class="type">const</span> <span class="type">char</span> *format, ...)</span> NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span> NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usageErr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span> NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cmdLineErr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span> NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>　　为了简化示例程序中的错误处理，会使用这段代码所示的错误诊断函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errMsg</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExitEN</span><span class="params">(<span class="type">int</span> errnum, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p>　　这里会使用函数<code>errMsg()</code>、<code>errExit()</code>、<code>err_exit()</code>和<code>errExitEN()</code>诊断系统调用和库函数中的错误。</p><p>　　函数<code>errMsg()</code>会在标准错误中打印1条信息 (自动在末尾加上换行符)，其参数列表与函数<code>prtinf()</code>的相同。该函数打印的的字符串是<code>errno</code>当前值对应的错误信息 (其中包含错误名，例如，EPERM) 加上函数<code>strerror()</code>返回的错误描述加上参数指定格式的输出。</p><p>　　函数<code>errExit()</code>的用法与函数<code>errMsg()</code>相似，但会终止程序。若环境变量<code>EF_DUMPCORE</code>定义为非空字符串，则该函数会通过<code>abort()</code>终止程序，同时生成内存快照 (与调试程序一起使用)；否则，该函数会通过<code>exit()</code>终止程序。</p><p>　　函数<code>err_exit()</code>在功能上与函数<code>errExit()</code>相似，但在2个方面有所不同。首先，函数<code>err_exit()</code>在打印错误信息前不会刷新标准输出。其次，函数<code>err_exit()</code>通过<code>_exit()</code>终止进程，这导致进程终止时不会刷新<code>stdio</code>缓存或调用退出处理程序。</p><p>　　函数<code>errExitEN()</code>会打印参数<code>errnum</code>指定的错误号对应的信息 (所以函数以后缀<code>EN</code>结尾)。除此之外，其他方面与函数<code>errExit()</code>相同。</p><p>　　不同于传统的UNIX系统调用，POSIX线程函数会返回错误号 (正常运行时返回0)。因此，通常会在使用POSIX线程函数的程序中使用函数<code>errExitEN()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s;</span><br><span class="line">s = pthread_create(&amp;thread, <span class="literal">NULL</span>, func, &amp;arg);</span><br><span class="line"><span class="keyword">if</span> (s)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　可以通过这段代码来确定POSIX线程函数是否出错。不直接使用<code>errno</code>的原因是POSIX线程函数中的<code>errno</code>被重定义为宏，该宏会扩展为返回可修改左值的函数调用，所以每次使用<code>errno</code>都会调用1次函数。</p><p>　　对于其他类型错误的诊断，可以使用函数<code>fatal()</code>、<code>usageErr()</code>和<code>cmdLineErr()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usageErr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cmdLineErr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p>　　函数<code>fatal()</code>用于通用错误的诊断，包括那些不设置<code>errno</code>的库函数，其参数列表与函数<code>prtinf()</code>的相同。该函数会在标准错误中输出格式化的字符串 (自动在末尾加上换行符)，然后像函数<code>errExit()</code>一样终止程序。</p><p>　　函数<code>usageErr()</code>用于命令行参数错误的诊断，其参数列表与函数<code>prtinf()</code>的相同。该函数会在标准错误中输出字符串<code>Usage:</code>加上格式化的输出，然后调用<code>exit()</code>来终止程序。</p><p>　　函数<code>cmdLineErr()</code>与函数<code>usageErr()</code>相似，但主要用于程序的命令行参数错误的诊断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* error_functions.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;error_functions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ename.c.inc&quot;</span> <span class="comment">/* ename和MAX_ENAME的定义 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line">__attribute__((__noreturn__))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">terminate</span><span class="params">(Boolean useExit3)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *s;</span><br><span class="line">    <span class="comment">/* 若环境变量EF_DUMPCORE定义为非空字符串，则生成内存快照；</span></span><br><span class="line"><span class="comment">    否则，根据useExit3的值调用exit(3)或_exit(2) */</span></span><br><span class="line">    s = getenv(<span class="string">&quot;EF_DUMPCORE&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">NULL</span> &amp;&amp; *s != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (useExit3)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">outputError</span><span class="params">(Boolean useErr, <span class="type">int</span> err, Boolean flushStdout,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 500</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE], userMsg[BUF_SIZE], errText[BUF_SIZE];</span><br><span class="line">    vsnprintf(userMsg, BUF_SIZE, format, ap);</span><br><span class="line">    <span class="keyword">if</span> (useErr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(errText, BUF_SIZE, <span class="string">&quot; [%s %s]&quot;</span>,</span><br><span class="line">                 (err &gt; <span class="number">0</span> &amp;&amp; err &lt;= MAX_ENAME) ? ename[err] : <span class="string">&quot;?UNKNOWN?&quot;</span>, strerror(err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(errText, BUF_SIZE, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;ERROR%s %s\n&quot;</span>, errText, userMsg);</span><br><span class="line">    <span class="keyword">if</span> (flushStdout)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>); <span class="comment">/* 刷新所有待处理的标准输出 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fputs</span>(buf, <span class="built_in">stderr</span>);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>); <span class="comment">/* 防止标准错误是行缓存 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errMsg</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    <span class="type">int</span> savedErrno;</span><br><span class="line">    savedErrno = errno; <span class="comment">/* 防止errno被修改 */</span></span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    outputError(TRUE, errno, TRUE, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    errno = savedErrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    outputError(TRUE, errno, TRUE, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    <span class="built_in">terminate</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    outputError(TRUE, errno, FALSE, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    <span class="built_in">terminate</span>(FALSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExitEN</span><span class="params">(<span class="type">int</span> errnum, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    outputError(TRUE, errnum, TRUE, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    <span class="built_in">terminate</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    outputError(FALSE, <span class="number">0</span>, TRUE, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    <span class="built_in">terminate</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usageErr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>); <span class="comment">/* 刷新所有待处理的标准输出 */</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: &quot;</span>);</span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>); <span class="comment">/* 防止标准错误是行缓存 */</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cmdLineErr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>); <span class="comment">/* 刷新所有待处理的标准输出 */</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Command-line usage error: &quot;</span>);</span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>); <span class="comment">/* 防止标准错误是行缓存 */</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这段代码是之前介绍的错误诊断函数的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ename.c.inc */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *ename[] = &#123;</span><br><span class="line">    <span class="comment">/* 0 */</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">/* 1 */</span> <span class="string">&quot;EPERM&quot;</span>, <span class="string">&quot;ENOENT&quot;</span>, <span class="string">&quot;ESRCH&quot;</span>, <span class="string">&quot;EINTR&quot;</span>, <span class="string">&quot;EIO&quot;</span>, <span class="string">&quot;ENXIO&quot;</span>, <span class="string">&quot;E2BIG&quot;</span>,</span><br><span class="line">    <span class="comment">/* 8 */</span> <span class="string">&quot;ENOEXEC&quot;</span>, <span class="string">&quot;EBADF&quot;</span>, <span class="string">&quot;ECHILD&quot;</span>, <span class="string">&quot;EAGAIN/EWOULDBLOCK&quot;</span>, <span class="string">&quot;ENOMEM&quot;</span>,</span><br><span class="line">    <span class="comment">/* 13 */</span> <span class="string">&quot;EACCES&quot;</span>, <span class="string">&quot;EFAULT&quot;</span>, <span class="string">&quot;ENOTBLK&quot;</span>, <span class="string">&quot;EBUSY&quot;</span>, <span class="string">&quot;EEXIST&quot;</span>, <span class="string">&quot;EXDEV&quot;</span>,</span><br><span class="line">    <span class="comment">/* 19 */</span> <span class="string">&quot;ENODEV&quot;</span>, <span class="string">&quot;ENOTDIR&quot;</span>, <span class="string">&quot;EISDIR&quot;</span>, <span class="string">&quot;EINVAL&quot;</span>, <span class="string">&quot;ENFILE&quot;</span>, <span class="string">&quot;EMFILE&quot;</span>,</span><br><span class="line">    <span class="comment">/* 25 */</span> <span class="string">&quot;ENOTTY&quot;</span>, <span class="string">&quot;ETXTBSY&quot;</span>, <span class="string">&quot;EFBIG&quot;</span>, <span class="string">&quot;ENOSPC&quot;</span>, <span class="string">&quot;ESPIPE&quot;</span>, <span class="string">&quot;EROFS&quot;</span>,</span><br><span class="line">    <span class="comment">/* 31 */</span> <span class="string">&quot;EMLINK&quot;</span>, <span class="string">&quot;EPIPE&quot;</span>, <span class="string">&quot;EDOM&quot;</span>, <span class="string">&quot;ERANGE&quot;</span>, <span class="string">&quot;EDEADLK/EDEADLOCK&quot;</span>,</span><br><span class="line">    <span class="comment">/* 36 */</span> <span class="string">&quot;ENAMETOOLONG&quot;</span>, <span class="string">&quot;ENOLCK&quot;</span>, <span class="string">&quot;ENOSYS&quot;</span>, <span class="string">&quot;ENOTEMPTY&quot;</span>, <span class="string">&quot;ELOOP&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">/* 42 */</span> <span class="string">&quot;ENOMSG&quot;</span>, <span class="string">&quot;EIDRM&quot;</span>, <span class="string">&quot;ECHRNG&quot;</span>, <span class="string">&quot;EL2NSYNC&quot;</span>, <span class="string">&quot;EL3HLT&quot;</span>, <span class="string">&quot;EL3RST&quot;</span>,</span><br><span class="line">    <span class="comment">/* 48 */</span> <span class="string">&quot;ELNRNG&quot;</span>, <span class="string">&quot;EUNATCH&quot;</span>, <span class="string">&quot;ENOCSI&quot;</span>, <span class="string">&quot;EL2HLT&quot;</span>, <span class="string">&quot;EBADE&quot;</span>, <span class="string">&quot;EBADR&quot;</span>,</span><br><span class="line">    <span class="comment">/* 54 */</span> <span class="string">&quot;EXFULL&quot;</span>, <span class="string">&quot;ENOANO&quot;</span>, <span class="string">&quot;EBADRQC&quot;</span>, <span class="string">&quot;EBADSLT&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;EBFONT&quot;</span>, <span class="string">&quot;ENOSTR&quot;</span>,</span><br><span class="line">    <span class="comment">/* 61 */</span> <span class="string">&quot;ENODATA&quot;</span>, <span class="string">&quot;ETIME&quot;</span>, <span class="string">&quot;ENOSR&quot;</span>, <span class="string">&quot;ENONET&quot;</span>, <span class="string">&quot;ENOPKG&quot;</span>, <span class="string">&quot;EREMOTE&quot;</span>,</span><br><span class="line">    <span class="comment">/* 67 */</span> <span class="string">&quot;ENOLINK&quot;</span>, <span class="string">&quot;EADV&quot;</span>, <span class="string">&quot;ESRMNT&quot;</span>, <span class="string">&quot;ECOMM&quot;</span>, <span class="string">&quot;EPROTO&quot;</span>, <span class="string">&quot;EMULTIHOP&quot;</span>,</span><br><span class="line">    <span class="comment">/* 73 */</span> <span class="string">&quot;EDOTDOT&quot;</span>, <span class="string">&quot;EBADMSG&quot;</span>, <span class="string">&quot;EOVERFLOW&quot;</span>, <span class="string">&quot;ENOTUNIQ&quot;</span>, <span class="string">&quot;EBADFD&quot;</span>,</span><br><span class="line">    <span class="comment">/* 78 */</span> <span class="string">&quot;EREMCHG&quot;</span>, <span class="string">&quot;ELIBACC&quot;</span>, <span class="string">&quot;ELIBBAD&quot;</span>, <span class="string">&quot;ELIBSCN&quot;</span>, <span class="string">&quot;ELIBMAX&quot;</span>,</span><br><span class="line">    <span class="comment">/* 83 */</span> <span class="string">&quot;ELIBEXEC&quot;</span>, <span class="string">&quot;EILSEQ&quot;</span>, <span class="string">&quot;ERESTART&quot;</span>, <span class="string">&quot;ESTRPIPE&quot;</span>, <span class="string">&quot;EUSERS&quot;</span>,</span><br><span class="line">    <span class="comment">/* 88 */</span> <span class="string">&quot;ENOTSOCK&quot;</span>, <span class="string">&quot;EDESTADDRREQ&quot;</span>, <span class="string">&quot;EMSGSIZE&quot;</span>, <span class="string">&quot;EPROTOTYPE&quot;</span>,</span><br><span class="line">    <span class="comment">/* 92 */</span> <span class="string">&quot;ENOPROTOOPT&quot;</span>, <span class="string">&quot;EPROTONOSUPPORT&quot;</span>, <span class="string">&quot;ESOCKTNOSUPPORT&quot;</span>,</span><br><span class="line">    <span class="comment">/* 95 */</span> <span class="string">&quot;EOPNOTSUPP/ENOTSUP&quot;</span>, <span class="string">&quot;EPFNOSUPPORT&quot;</span>, <span class="string">&quot;EAFNOSUPPORT&quot;</span>,</span><br><span class="line">    <span class="comment">/* 98 */</span> <span class="string">&quot;EADDRINUSE&quot;</span>, <span class="string">&quot;EADDRNOTAVAIL&quot;</span>, <span class="string">&quot;ENETDOWN&quot;</span>, <span class="string">&quot;ENETUNREACH&quot;</span>,</span><br><span class="line">    <span class="comment">/* 102 */</span> <span class="string">&quot;ENETRESET&quot;</span>, <span class="string">&quot;ECONNABORTED&quot;</span>, <span class="string">&quot;ECONNRESET&quot;</span>, <span class="string">&quot;ENOBUFS&quot;</span>, <span class="string">&quot;EISCONN&quot;</span>,</span><br><span class="line">    <span class="comment">/* 107 */</span> <span class="string">&quot;ENOTCONN&quot;</span>, <span class="string">&quot;ESHUTDOWN&quot;</span>, <span class="string">&quot;ETOOMANYREFS&quot;</span>, <span class="string">&quot;ETIMEDOUT&quot;</span>,</span><br><span class="line">    <span class="comment">/* 111 */</span> <span class="string">&quot;ECONNREFUSED&quot;</span>, <span class="string">&quot;EHOSTDOWN&quot;</span>, <span class="string">&quot;EHOSTUNREACH&quot;</span>, <span class="string">&quot;EALREADY&quot;</span>,</span><br><span class="line">    <span class="comment">/* 115 */</span> <span class="string">&quot;EINPROGRESS&quot;</span>, <span class="string">&quot;ESTALE&quot;</span>, <span class="string">&quot;EUCLEAN&quot;</span>, <span class="string">&quot;ENOTNAM&quot;</span>, <span class="string">&quot;ENAVAIL&quot;</span>,</span><br><span class="line">    <span class="comment">/* 120 */</span> <span class="string">&quot;EISNAM&quot;</span>, <span class="string">&quot;EREMOTEIO&quot;</span>, <span class="string">&quot;EDQUOT&quot;</span>, <span class="string">&quot;ENOMEDIUM&quot;</span>, <span class="string">&quot;EMEDIUMTYPE&quot;</span>,</span><br><span class="line">    <span class="comment">/* 125 */</span> <span class="string">&quot;ECANCELED&quot;</span>, <span class="string">&quot;ENOKEY&quot;</span>, <span class="string">&quot;EKEYEXPIRED&quot;</span>, <span class="string">&quot;EKEYREVOKED&quot;</span>,</span><br><span class="line">    <span class="comment">/* 129 */</span> <span class="string">&quot;EKEYREJECTED&quot;</span>, <span class="string">&quot;EOWNERDEAD&quot;</span>, <span class="string">&quot;ENOTRECOVERABLE&quot;</span>, <span class="string">&quot;ERFKILL&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ENAME 132</span></span><br></pre></td></tr></table></figure><p>　　这段代码是文件<code>error_functions.c</code>中引入的文件<code>ename.c.inc</code>，其中定义了字符串数组<code>ename</code>，该数组中的字符串就是对应的<code>errno</code>值的名称。该文件中的内容仅限于运行在x86-32的Linux 2.6 ，因为不同架构的<code>errno</code>值不同。</p><p>　　函数<code>stderror()</code>返回的字符串并未给出错误信息对应的名称，但参考手册中给出的都是错误名。通过数组<code>ename</code>，错误处理函数就可以获取错误号对应的名称。</p><p>　　数组<code>ename</code>中有部分空字符串，因为这些字符串对应的错误号未被使用。此外，数组<code>ename</code>中有部分字符串是斜杠<code>/</code>分隔的2个错误名，因为这2个错误名对应的值相同。</p><p>　　在数组<code>ename</code>中，<code>EAGAIN</code>和<code>EWOULDBLOCK</code>对应同一值 (SUSv3明确允许这样做，大部分UNIX系统也都是如此)。这2个错误通常由系统调用返回，在这种情况下，系统调用通常被阻塞 (即在完成前必须等待)，但调用函数要求系统调用返回错误，而非阻塞。<code>EAGAIN</code>源自System V，它是执行I/O、信号量操作、消息队列操作和文件上锁 (<code>fcntl()</code>) 的系统调用返回的错误。<code>EWOULDBLOCK</code>源自BSD，它是文件上锁 (<code>flock()</code>) 和套接字相关的系统调用返回的错误。</p><p>　　在SUSv3中，<code>EWOULDBLOCK</code>仅在套接字相关接口中提及。对于这些接口，SUSv3允许非阻塞的系统调用返回<code>EAGAIN</code>和<code>EWOULDBLOCK</code>。对于其他所有非阻塞的系统调用，SUSv3仅指定了<code>EAGAIN</code>。</p><h4 id="用于解析数值命令行参数的函数">3.4.2 用于解析数值命令行参数的函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get_num.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GET_NUM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_NUM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GN_NONNEG 01 <span class="comment">/* 值必须大于等于0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GN_GT_0 02   <span class="comment">/* 值必须大于0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 整数默认十进制 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GN_ANY_BASE 0100 <span class="comment">/* 可用于任何情况 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GN_BASE_8 0200   <span class="comment">/* 值以八进制表示 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GN_BASE_16 0400  <span class="comment">/* 值以十六进制表示 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getInt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 将字符串转换为int类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">getLong</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 将字符串转换为long类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>　　头文件<code>get_num.h</code>给出了用于解析数值命令行参数的函数<code>getInt()</code>和<code>getLong()</code>的声明。相比函数<code>atoi()</code>、<code>atol()</code>和<code>strtol()</code>，这2个函数提供了一些基本的数值参数的有效性检查。</p><p>　　若参数<code>arg</code>不是有效的整数字符串，则这2个函数会打印错误信息并终止程序。</p><p>　　若参数<code>name</code>非空，则它应该包含参数<code>arg</code>的标识字符串，该字符串会作为这2个函数打印的错误信息的一部分。</p><p>　　参数<code>flags</code>提供了一些对这2个函数的控制。默认情况下，这2个函数会假定字符串为有符号的十进制整数。通过对任意个<code>GN_</code>开头的常量进行与操作并赋值给参数<code>flags</code>，就能选择转换模式，并且限制范围和正负。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get_num.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;get_num.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gnFail</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fname, <span class="type">const</span> <span class="type">char</span> *msg, <span class="type">const</span> <span class="type">char</span> *arg, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s error&quot;</span>, fname);</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot; (in %s)&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;: %s\n&quot;</span>, msg);</span><br><span class="line">    <span class="keyword">if</span> (arg != <span class="literal">NULL</span> &amp;&amp; *arg != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot; offending text: %s\n&quot;</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">getNum</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fname, <span class="type">const</span> <span class="type">char</span> *arg, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> res;</span><br><span class="line">    <span class="type">char</span> *endptr;</span><br><span class="line">    <span class="type">int</span> base;</span><br><span class="line">    <span class="keyword">if</span> (arg == <span class="literal">NULL</span> || *arg == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gnFail(fname, <span class="string">&quot;null or empty string&quot;</span>, arg, name);</span><br><span class="line">    &#125;</span><br><span class="line">    base = (flags &amp; GN_ANY_BASE) ? <span class="number">0</span> : (flags &amp; GN_BASE_8) ? <span class="number">8</span></span><br><span class="line">                                   : (flags &amp; GN_BASE_16)  ? <span class="number">16</span></span><br><span class="line">                                                           : <span class="number">10</span>;</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    res = strtol(arg, &amp;endptr, base);</span><br><span class="line">    <span class="keyword">if</span> (errno != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gnFail(fname, <span class="string">&quot;strtol() failed&quot;</span>, arg, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*endptr != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gnFail(fname, <span class="string">&quot;nonnumeric characters&quot;</span>, arg, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; GN_NONNEG) &amp;&amp; res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gnFail(fname, <span class="string">&quot;negative value not allowed&quot;</span>, arg, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; GN_GT_0) &amp;&amp; res &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gnFail(fname, <span class="string">&quot;value must be &gt; 0&quot;</span>, arg, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getInt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> res;</span><br><span class="line">    res = getNum(<span class="string">&quot;getInt&quot;</span>, arg, flags, name);</span><br><span class="line">    <span class="keyword">if</span> (res &gt; INT_MAX || res &lt; INT_MIN)</span><br><span class="line">    &#123;</span><br><span class="line">        gnFail(<span class="string">&quot;getInt&quot;</span>, <span class="string">&quot;integer out of range&quot;</span>, arg, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">getLong</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getNum(<span class="string">&quot;getLong&quot;</span>, arg, flags, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这段代码是函数<code>getInt()</code>和<code>getLong()</code>的实现。</p><h3 id="可移植性问题">3.5 可移植性问题</h3><p>　　各种标准控制着系统调用和库函数API的行为。部分标准由The Open Group等标准机构定义，其他标准有历史上2个重要的UNIX实现定义，即BSD和System V第4版 (和相关的System V接口定义)。</p><p>　　在开发可移植应用程序时，可能需要在头文件中仅公开符合特定标准的定义 (例如，常量、函数原型)。为此，在编译时需要定义<strong>功能测试宏</strong>。从实现角度，可以通过判断 (通过<code>#if</code>) 应用程序为这些宏定义的值来决定头文件中的哪些功能可用。</p><p>　　第1种定义功能测试宏的方法是在引入头文件前定义宏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE 1</span></span><br></pre></td></tr></table></figure><p>　　第2种定义功能测试宏的方法是对于C编译器使用命令行参数<code>-D</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc -D_BSD_SOURCE prog.c</span><br></pre></td></tr></table></figure><h4 id="功能测试宏">3.5.1 功能测试宏</h4><p>　　相关标准详细说明了功能测试宏<code>_POSIX_SOURCE</code>、<code>_POSIX_C_SOURCE</code>和<code>_XOPEN_SOURCE</code>，所以这些宏的使用可以移植到所有支持这些标准的系统。</p><p>　　● 若定义了宏<code>_POSIX_SOURCE</code> (无论什么值)，则符合POSIX.1-1990和ISO C (1990) 的定义会公开。该宏现已被宏<code>_POSIX_C_SOURCE</code>取代。</p><p>　　● 若宏<code>_POSIX_C_SOURCE</code>定义为值1，则其功能与<code>_POSIX_SOURCE</code>相同；若定义的值大于等于199309，则还会公开符合POSIX.1b (实时) 的定义；若定义的值大于等于199506，则还会公开符合POSIX.1c (线程) 的定义；若定义的值大于等于200112，则还会公开符合POSIX.1-2001基础规范 (不包含XSI扩展) 的定义 (在版本2.3.3前，<code>glibc</code>的头文件会无视这种情况)；若定义的值大于等于200809，则还会公开符合POSIX.1-2008基础规范的定义 (在版本2.10前，<code>glibc</code>的头文件会无视这种情况)。</p><p>　　● 若定义了宏<code>_XOPEN_SOURCE</code> (无论什么值)，则会公开符合POSIX.1、POSIX.2和X/Open (XPG4) 的定义；若定义的值大于等于500，则还会公开符合SUSv2 (UNIX 98和XPG5) 扩展的定义；若定义的值大于等于600，则还会公开符合SUSv3 XSI (UNIX 03) 扩展和C99扩展的定义 (在版本2.2前，<code>glibc</code>的头文件会无视这种情况)；若定义的值大于等于700，则还会公开符合SUSv4扩展的定义 (在版本2.10前，<code>glibc</code>的头文件会无视这种情况)。值500、600和700源于SUSv2、SUSv3和SUSv4分别是X/Open规范的第5~7期。</p><p>　　功能测试宏<code>_BSD_SOURCE</code>、<code>_SVID_SOURCE</code>和<code>_GNU_SOURCE</code>仅适用于<code>glibc</code>。</p><p>　　● 若定义了宏<code>_BSD_SOURCE</code> (无论什么值)，则会公开BSD定义，而且也会将宏<code>_POSIX_C_SOURCE</code>定义为值199506。</p><p>　　● 若定义了宏<code>_SVID_SOURCE</code> (无论什么值)，则会公开System V接口定义中的定义。</p><p>　　● 若定义了宏<code>_GNU_SOURCE</code> (无论什么值)，则会公开通过设置所有上述宏而提供的定义和各种GNU扩展的定义。</p><p>　　当调用GNU C编译器时，若没有使用特殊选项，则会自动设宏<code>_POSIX_SOURCE</code>、<code>_POSIX_C_SOURCE</code> (若<code>glibc</code>的版本小于2.4，则设置为值199506；若<code>glibc</code>的版本在2.5到2.9之间，则设置为值200112；否则，设置为值200809)、<code>_BSD_SOURCE</code>和<code>_SVID_SOURCE</code>。</p><p>　　若定义上述宏之一或以标准模式之一调用编译器 (例如，<code>cc -ansi</code>或<code>cc -std=c99</code>)，则只有定义的宏会生效。但是，存在1个例外，若未定义宏<code>_POSIX_C_SOURCE</code>，并且编译器未以其标准模式之一调用，则该宏会自动定义 (若<code>glibc</code>的版本小于2.4，则设置为值199506；若<code>glibc</code>的版本在2.5到2.9之间，则设置为值200112；否则，设置为值200809)。头文件<code>features.h</code>提供了上述宏的更多信息。</p><p>　　可以定义多个功能测试宏。例如，使用如下命令来显式设置默认宏：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc -D_POSIX_SOURCE -D_POSIX_C_SOURCE=199506 \ -D_BSD_SOURCE -D_SVID_SOURCE prog.c</span><br></pre></td></tr></table></figure><p>　　POSIX.1-2001详细说明了宏<code>_POSIX_C_SOURCE</code> ，并且要求定义为值200112。SUSv3详细说明了宏<code>_XOPEN_SOURCE</code>，并且要求定义为值600。POSIX.1-2008和SUSv4与之类似，要求将这2个宏分别定义为值200809和700。</p><p>　　SUSv3要求将宏<code>_XOPEN_SOURCE</code>定义为值600时，应该提供将宏<code>_POSIX_C_SOURCE</code>定义为值200112时提供的所有功能。SUSv4与之类似。</p><h4 id="系统数据类型">3.5.2 系统数据类型</h4><p>　　为了避免可移植性问题，SUSv3详细说明了各种标准系统数据类型，并且要求UNIX实现合适地定义和使用这些类型。</p><p>　　标准系统数据类型都通过功能<code>typedef</code>定义，并且其名称几乎都以<code>_t</code>结尾。大部分标准系统数据类型都声明在头<code>sys/types.h</code>中，少部分声明在其他头文件中。</p><table><colgroup><col style="width:14%"><col style="width:28%"><col style="width:56%"></colgroup><thead><tr><th>数据类型</th><th>SUSv3类型要求</th><th>描述</th></tr></thead><tbody><tr><td><code>blkcnt_t</code></td><td>有符号整数</td><td>文件块计数</td></tr><tr><td><code>blksize_t</code></td><td>有符号整数</td><td>文件块大小</td></tr><tr><td><code>cc_t</code></td><td>无符号整数</td><td>终端特殊字符</td></tr><tr><td><code>clock_t</code></td><td>整数或实浮点数</td><td>时钟节拍的系统时间</td></tr><tr><td><code>clockid_t</code></td><td>算术类型</td><td>POSIX.1b时钟和定时器函数的时钟标识符</td></tr><tr><td><code>comp_t</code></td><td>未提及</td><td>压缩时钟节拍</td></tr><tr><td><code>dev_t</code></td><td>算术类型</td><td>设备号 (包括主编号和次编号)</td></tr><tr><td><code>DIR</code></td><td>无要求</td><td>目录流</td></tr><tr><td><code>fd_set</code></td><td>结构体</td><td>函数<code>select()</code>的文件描述符集</td></tr><tr><td><code>fsblkcnt_t</code></td><td>无符号整数</td><td>文件系统块计数</td></tr><tr><td><code>fsfilcnt_t</code></td><td>无符号整数</td><td>文件计数</td></tr><tr><td><code>gid_t</code></td><td>整数</td><td>数字组标识符</td></tr><tr><td><code>id_t</code></td><td>整数</td><td>存放标识符的通用类型，足以容纳<code>pid_t</code>、<code>uid_t</code>和<code>gid_t</code></td></tr><tr><td><code>in_addr_t</code></td><td>32位无符号整数</td><td>IPv4地址</td></tr><tr><td><code>in_port_t</code></td><td>16位无符号整数</td><td>IP端口号</td></tr><tr><td><code>ino_t</code></td><td>无符号整数</td><td>文件i-node号</td></tr><tr><td><code>key_t</code></td><td>算术类型</td><td>System V IPC密钥</td></tr><tr><td><code>mode_t</code></td><td>整数</td><td>文件权限和类型</td></tr><tr><td><code>mqd_t</code></td><td>除了数组之外的类型</td><td>POSIX消息队列描述符</td></tr><tr><td><code>msglen_t</code></td><td>无符号整数</td><td>System V消息队列允许的字节数</td></tr><tr><td><code>msgqnum_t</code></td><td>无符号整数</td><td>System V消息队列中的消息数</td></tr><tr><td><code>nfds_t</code></td><td>无符号整数</td><td>函数<code>poll()</code>的文件描述符数</td></tr><tr><td><code>nlink_t</code></td><td>整数</td><td>文件的硬链接数</td></tr><tr><td><code>off_t</code></td><td>有符号整数</td><td>文件偏移或大小</td></tr><tr><td><code>pid_t</code></td><td>有符号整数</td><td>进程ID、进程组ID和会话ID</td></tr><tr><td><code>ptrdiff_t</code></td><td>有符号整数</td><td>2个指针值之间的差值</td></tr><tr><td><code>rlim_t</code></td><td>无符号整数</td><td>资源限制</td></tr><tr><td><code>sa_family_t</code></td><td>无符号整数</td><td>套接字地址族</td></tr><tr><td><code>shmatt_t</code></td><td>无符号整数</td><td>System V共享内存段的相关进程计数</td></tr><tr><td><code>sig_atomic_t</code></td><td>整数</td><td>可原子访问的数据类型</td></tr><tr><td><code>siginfo_t</code></td><td>结构体</td><td>信号源的信息</td></tr><tr><td><code>sigset_t</code></td><td>整数或结构体</td><td>信号集</td></tr><tr><td><code>size_t</code></td><td>无符号整数</td><td>对象的大小 (以字节为单位)</td></tr><tr><td><code>socklen_t</code></td><td>至少32位的整数</td><td>套接字地址结构体的大小 (以字节为单位)</td></tr><tr><td><code>speed_t</code></td><td>无符号整数</td><td>终端行速度</td></tr><tr><td><code>ssize_t</code></td><td>有符号整数</td><td>字节计数或错误指示 (负值)</td></tr><tr><td><code>stack_t</code></td><td>结构体</td><td>备用信号栈的描述</td></tr><tr><td><code>suseconds_t</code></td><td>[-1, 1000000] 内的有符号整数</td><td>微秒时间间隔</td></tr><tr><td><code>tcflag_t</code></td><td>无符号整数</td><td>终止模式标志位掩码</td></tr><tr><td><code>time_t</code></td><td>整数或实浮点数</td><td>自纪元以来的日历时间 (以秒为单位)</td></tr><tr><td><code>timer_t</code></td><td>算术类型</td><td>POSIX.1b间隔计时器函数的计时器标识符</td></tr><tr><td><code>uid_t</code></td><td>整数</td><td>数字用户标识符</td></tr></tbody></table><p>　　SUSv3要求某些系统数据类型为算术类型，即整数或浮点数。</p><p>　　当打印数值系统数据类型时，必须保证在调用函数<code>printf()</code>时不要出现<span style="background-color:#ff0">表示依赖</span> (C的参数提升规则会将<code>short</code>转换为<code>int</code> ，而<code>int</code>和<code>long</code>不变)。函数<code>printf()</code>无法在运行时确定参数的类型，所以调用时必须显式地提供<code>%d</code>或<code>%ld</code>等格式化字符串。常用的解决方法是将系统数据类型转换为<code>long</code>并在调用<code>printf()</code>时使用格式化字符串<code>%ld</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> mypid;</span><br><span class="line">mypid = getpid();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My PID is %ld\n&quot;</span>, (<span class="type">long</span>)mypid);</span><br></pre></td></tr></table></figure><p>　　这种解决方法有1个例外。数据类型<code>off_t</code>在某些编译环境中的长度与<code>long long</code>相同，所以需要将它转换为<code>long long</code>并使用格式化字符串<code>%lld</code>。</p><p>　　C99标准为函数<code>printf()</code>定义了格式化字符串<code>%zd</code>和<code>%jd</code>，前者对应类型<code>size_t</code>和<code>sszie_t</code>，后者对应足以表示任何类型的整数的类型<code>intmax_t</code> (或<code>uintmax_t</code>)。但是，并非所有UNIX实现都使用<code>glibc</code>，所以应该避免使用这些格式化字符串。</p><h4 id="其他可移植性问题">3.5.3 其他可移植性问题</h4><p>　　每个UNIX实现都给出了用于系统调用和库函数的大量标准结构体。这里以结构体<code>sembuf</code> (用于表示系统调用<code>semop()</code>执行的信号量操作) 为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> sem_num; <span class="comment">/* 信号量号 */</span></span><br><span class="line">    <span class="type">short</span> sem_op;           <span class="comment">/* 执行的操作 */</span></span><br><span class="line">    <span class="type">short</span> sem_flg;          <span class="comment">/* 操作标志 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　尽管SUSv3详细说明了<code>sembuf</code>等结构体，但通常不会指定这些结构体中的字段定义顺序。在某些情况下，这些结构体可能会包含额外的特定于某些UNIX实现的字段。</p><p>　　因此，为了保证可移植性，应使用如下方法初始化结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">s</span>;</span></span><br><span class="line">s.sem_num = <span class="number">3</span>;</span><br><span class="line">s.sem_op = <span class="number">-1</span>;</span><br><span class="line">s.sem_flg = SEM_UNDO;</span><br></pre></td></tr></table></figure><p>　　若使用了C99，则可以使用C99的新语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">s</span> =</span> &#123;.sem_num = <span class="number">3</span>, .sem_op = <span class="number">-1</span>, .sem_flg = SEM_UNDO&#125;;</span><br></pre></td></tr></table></figure><p>　　有时，并非所有UNIX实现都定义了某个宏。例如，用于检查子进程是否生成了内存快照的宏<code>WCOREDUMP</code>在大部分UNIX实现中都可用，但SUSv3并未说明该宏。因此，该宏并不适用于所有UNIX实现。为了保证可移植性，可以使用<code>#ifdef</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WCOREDUMP</span></span><br><span class="line"><span class="comment">/* 使用宏WCOREDUMP */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>　　此外，为系统调用和库文件提供原型的头文件可能因UNIX实现而异。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2024/08/12/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-2/" rel="prev" title="《Linux/UNIX系统编程手册》第2章 基本概念"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第2章 基本概念</a></div><div class="post-nav-item"><a href="/2024/09/16/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-4/" rel="next" title="《Linux/UNIX系统编程手册》第4章 文件I/O：通用I/O模型">《Linux/UNIX系统编程手册》第4章 文件I/O：通用I/O模型 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script></body></html>