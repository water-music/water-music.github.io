<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><link rel="canonical" href="http://example.com/2024/08/12/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-2/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/08/12/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-2/","path":"2024/08/12/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-2/","title":"《Linux/UNIX系统编程手册》第2章 基本概念"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第2章 基本概念 |</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8"><span class="nav-text">2.1 内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shell"><span class="nav-text">2.2 shell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84"><span class="nav-text">2.3 用户和组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%9B%AE%E5%BD%95%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E7%9B%AE%E5%BD%95%E9%93%BE%E6%8E%A5%E5%92%8C%E6%96%87%E4%BB%B6"><span class="nav-text">2.4 单目录层次结构、目录、链接和文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6io%E6%A8%A1%E5%9E%8B"><span class="nav-text">2.5 文件I&#x2F;O模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-text">2.6 进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-text">2.7 内存映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="nav-text">2.8 静态库和共享库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ipc%E5%92%8C%E5%90%8C%E6%AD%A5"><span class="nav-text">2.9 IPC和同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-text">2.10 信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%92%8Cshell%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6"><span class="nav-text">2.11 进程组和shell作业控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84"><span class="nav-text">2.12 客户端-服务器架构</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2024/08/12/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux/UNIX系统编程手册》第2章 基本概念 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第2章 基本概念</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-12T00:00:00+08:00">2024-08-12</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-09-15 00:00:00" itemprop="dateModified" datetime="2024-09-15T00:00:00+08:00">2024-09-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/computer-system/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>14k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　术语<strong>操作系统</strong>通常有2种不同的含义：</p><p>　　● 操作系统是由管理计算机资源 (即CPU、RAM和设备) 的核心软件和所有随附的标准软件工具 (例如，命令行解释器、图形用户界面、文件工具和编辑器) 组成的软件包。</p><p>　　● 从更狭义的角度，操作系统是管理和分配计算机资源的核心软件。</p><p>　　术语<strong>内核</strong>通常是第2种含义的同义词，本书关注的正是此含义。</p><p>　　尽管在没有内核的计算机上运行是程序是可能的，但是内核的存在可以大幅度简化程序的开发和使用，并且可以增加程序员可用的功能和灵活度。内核通过提供管理计算机资源的软件层来实现这一点。</p><p>　　Linux内核程序通常位于路径<code>/boot/vmlinuz</code>或相似路径下。对于早期UNIX实现，内核程序名是<code>unix</code>。对于之后实现了虚拟内存的UNIX实现，内核程序改名为<code>vmunix</code>。对于Linux，内核程序名与系统名相似，但是用z替换了末尾的x，以表示内核是压缩的可执行文件。</p><p>　　现代处理器架构通常会允许CPU在2种模式下工作，即<strong>用户模式</strong>和<strong>内核模式</strong> (有时也称为<strong>超级用户模式</strong>)。硬件指令允许从当前模式切换到其他模式。相应地，虚拟内存的区域可以被标记为<strong>用户空间</strong>或<strong>内核空间</strong>的一部分。当运行在用户模式下时，CPU只能访问标记为用户空间的内存区域，若试图访问标记为内核空间的内存区域，则会导致硬件异常。当运行在内核模式下时，CPU能访问用户空间和内核空间的内存区域。</p><p>　　只有当CPU在内核模式下时，特定操作才能执行，例如，执行<code>halt</code>指令 (停止系统)、访问内存管理硬件和初始化I/O操作。通过这种硬件设计来将操作系统置于内核空间，操作系统实现者能确保用户进程无法访问内核的指令和数据结构或者执行不利于系统运行的操作。</p><p>　　<strong>程序</strong>通常以2种形式存在。第1种形式是<span style="background-color:#ff0">源代码</span>，即由一系列C语言等编程语言编写的语句组成的人类可读的文本。源代码必须转换成计算机可以理解的<span style="background-color:#ff0">二进制机器语言指令</span>才能执行，也就是第2种形式。这2种形式通常被认为是等同的，因为编译和链接步骤能将源代码转换为语义相同的二进制机器代码。</p><p>　　<strong>过滤器</strong>指从标准输入中读输入并对其进行一些转换，然后将转换后的内容写到标准输出的程序，例如，<code>cat</code>、<code>grep</code>、<code>tr</code>、<code>sort</code>、<code>wc</code>、<code>sed</code>和<code>awk</code>。</p><span id="more"></span><p>　　C程序可以访问<strong>命令行参数</strong>，即执行程序时命令行中提供的参数。为了访问命令行参数，程序的主函数必须声明为<code>int main(int argc, char *argv[])</code>。参数<code>argc</code>表示命令行参数的数量。参数<code>argv</code>的第1个成员<code>argv[0]</code>指向的字符串是程序名，其他成员指向的字符串就是各个命令行参数。</p><p>　　<strong>shell</strong>是专用程序，用于读用户输入的命令并执行合适的程序来响应，这种程序也称为<strong>命令解释程序</strong>。<span style="background-color:#ff0">登录shell</span>是用户第1次登录时为运行shell而创建的进程。</p><p>　　shell除了用于交互，还可以用于解释<span style="background-color:#ff0">shell脚本</span> (即包含shell命令的文本文件)。出于该目的，shell会提供部分通常与编程语言相关的功能，包括变量、循环、条件语句、I/O命令和函数。</p><p>　　对于大多数Linux文件系统，文件名最长为255个字符。文件名可以包含除了斜杠<code>/</code>和空字符<code>\0</code>之外的所有字符。在实际中，文件名建议使用字母、数字、英文句号<code>.</code>、下划线<code>_</code>和连字符<code>-</code>的组合，这65个字符组成的集合<code>[-._a-zA-Z0-9]</code>在SUSv3中被称为<strong>可移植文件名字符集</strong>。</p><p>　　应该避免在文件名中使用除了可移植文件名字符集之外的字符，因为这些字符在shell、正则表达式或其他上下文中可能有特殊含义。若需要在这些上下文中的文件名使用包含特殊含义的字符，则必须对这些字符进行<strong>转义</strong>，即在每个待转义的字符前面都加上反斜杠<code>\</code>来表示它们不需要解释为特殊含义。在不支持转义的上下文中，包含特殊含义的字符的文件名将不可用。此外，应该避免文件名以连字符<code>-</code>开头，因为这种文件名可能会被shell命令解释为参数。</p><p>　　为了执行文件I/O，C程序通常会调用标准库<code>stdio</code>中的函数，包括<code>fopen()</code>、<code>fclose()</code>、<code>scanf()</code>、<code>printf()</code>、<code>fgets()</code>、<code>fputs()</code>。库<code>stdio</code>中的函数是<code>open()</code>、<code>close()</code>、<code>read()</code>、<code>write()</code>等I/O系统调用的包装函数。</p><p>　　<strong>进程</strong>是运行中的程序的1个实例。执行程序时，内核会将程序的代码加载到虚拟内存，为程序变量分配空间并设置内核记录数据结构来记录该进程的各种信息 (例如，进程ID、终止状态、用户ID和组ID)。从内核角度，进程是内核必须与之共享各种计算机资源的实体。对于内存等有限资源，内核会先分配部分资源给进程，然后在进程的生命周期中根据进程的请求和整个系统对该资源的需求来调节资源分配。当进程终止时，为该进程分配的所有有限的资源会释放。对于CPU和网络带宽等可再生资源，所有进程必须平等地共享它们。</p><p>　　运行中的Linux系统包含大量进程，其中的很多进程都独立于彼此运行。但是，有些进程需要合作才能达到目的，为此，需要保证<strong>进程间通信</strong>和同步操作。</p><p>　　从逻辑角度，进程分为4个称为<strong>段</strong>的部分。</p><p>　　● <span style="background-color:#ff0">文本</span>段包含程序的指令。</p><p>　　● <span style="background-color:#ff0">数据</span>段包含程序所用的静态变量。</p><p>　　● <span style="background-color:#ff0">栈</span>段是会随着函数调用和返回而伸缩的区域，用于为局部变量和函数调用链信息分配空间。</p><p>　　● <span style="background-color:#ff0">堆</span>段是用于程序动态分配额外空间的区域。</p><p>　　进程中有2种重要的时间，即<span style="background-color:#ff0">实际时间</span>和<span style="background-color:#ff0">进程时间</span>。</p><p>　　● 实际时间基于某个标准点 (日历时间) 或固定点 (通常是进程生命周期的起点) 测量。在UNXI系统中，日历时间以秒为单位，自1970年1月1日凌晨开始计时 (即<span style="background-color:#ff0">协调世界时</span>)，并且以英国格林威治的经线定义的时区为基准进行协调。这个日期接近UNIX系统的诞生，也称为<strong>纪元</strong>。</p><p>　　● 进程时间也称为<span style="background-color:#ff0">CPU时间</span>，是自进程启动以来所有的CPU时间总和。CPU时间可以进一步划分为<span style="background-color:#ff0">系统CPU时间</span>和<span style="background-color:#ff0">用户CPU时间</span>，前者是在内核模式下执行代码所用的时间 (系统调用和其他代表进程执行的内核服务)，后者是在用户模式下执行代码所用的时间 (常规程序代码)。</p><p>　　命令<code>time</code>会显示执行管道中的进程所用的实际时间、系统CPU时间和用户CPU时间。</p><p>　　在现代UNIX实现中，每个进程可以有多个执行<strong>线程</strong>，线程可以类比为多个共享虚拟内存和大量其他属性的进程。每个线程都会执行相同的程序代码、数据和堆。但是，每个线程都有自己的栈，用于存储局部变量和函数调用链信息。线程可以通过共享的全局变量通信。线程API提供了<strong>互斥锁</strong>和<strong>条件变量</strong>，用于同一进程的线程的通信和同步操作。线程还能通过IPC和同步机制通信。</p><p>　　线程的主要优势是易于共享数据，并且某些算法更容易用多线程实现。此外，多线程程序可以透明地利用多处理器硬件上的并行处理的可能性。</p><p>　　<strong>伪终端</strong>是1对连接的虚拟设备，即<span style="background-color:#ff0">主设备</span>和<span style="background-color:#ff0">从设备</span>。这对设备提供了IPC通道，以允许双向传输数据。</p><p>　　伪终端的关键点在于从设备提供了行为与终端相似的接口，这使得可以将从设备连接到面向终端的程序，然后用另一个连接到主设备的程序来驱动面向终端的程序。驱动程序的输出通过终端驱动程序执行的常规输入处理 (例如，在默认模式下，回车符会映射为换行符)，然后作为输入传递给连接到从设备的面向终端的程序。面向终端的程序写到从设备的所有内容都会 (在经过所有终端输出处理后) 作为输入传递给驱动程序，即驱动程序会执行用户在常规终端上通常执行的功能。</p><p>　　伪终端用于各种应用程序，其中最著名的是X Window系统登录时提供的终端窗口的实现以及<code>telnet</code>和<code>ssh</code>等提供网络登录服务的程序。</p><p>　　<span style="background-color:#ff0">实时应用程序</span>是需要及时响应输入的应用程序。通常，这些输入来自于外部传感器或专用设备，而输出则采用控制某些外部硬件的形式。尽管很多实时应用程序需要对输入做出快速响应，但决定性因素是保证触发事件后的特定时间内做出响应。</p><p>　　实时响应 (尤其是短时间内) 需要底层操作系统的支持。大多数操作系统没有实时响应的原生支持，因为实时响应的要求于与多用户分时操作系统的要求相冲突。传统UNIX实现并不是实时操作系统，尽管实时变体已经出现。Linux的实时变体也已经出现，而且Linux内核也在向完全支持实时应用程序的方向发展。</p><p>　　POSIX.1b定义了大量支持实时应用程序的POSIX.1扩展，包括异步I/O、共享内存、内存映射文件、内存上锁、实时锁、实时定时器、备选调度策略、实时信号、信息队列和信号量。尽管它们并不严格地符号实时，但是大部分UNIX实现都支持部分或全部扩展。</p><p>　　类似于其他几个UNIX实现，Linux提供了<code>/proc</code>文件系统，它由挂载在目录<code>/proc</code>的1组目录和文件组成。该文件系统是虚拟文件系统，以文件系统中的文件和目录的形式提供内核数据结构的接口。这为查看和修改各种系统属性提供了1种简单的机制。此外，有1组名称为<code>/proc/PID</code>的目录 (PID即进程ID)，允许查看系统中正在运行的所有进程的信息。</p><p>　　<code>/proc</code>文件的内容通常是人类可读的文本形式，并且能被shell脚本解析。程序可以简单地对<code>/proc</code>文件进行打开、读和写操作。在大多数情况下，进程需要拥有权限才能修改<code>/proc</code>目录下的文件的内容。</p><h3 id="内核">2.1 内核</h3><p>　　内核负责<span style="background-color:#ff0">进程调度</span>、<span style="background-color:#ff0">内存管理</span>、<span style="background-color:#ff0">提供文件系统</span>、<span style="background-color:#ff0">创建和终止进程</span>、<span style="background-color:#ff0">访问设备</span>、<span style="background-color:#ff0">网络</span>和<span style="background-color:#ff0">提供系统调用API</span>。</p><p>　　● 计算机有1个或多个用于执行程序指令的中央处理单元。与其他UNIX系统一样，Linux是<strong>抢占式多任务</strong>操作系统。多任务表示多个进程可以同时驻留于内存中，并且都可以使用CPU。抢占式表示内核进程调度程序决定哪些进程使用CPU以及使用时间。</p><p>　　● 虽然以10年前的标准，计算机内存是巨大的，但是软件的大小也相应地变大，所以物理内存仍然是内核必须以公平且有效的方式进行共享的有限资源。与大多数现代操作系统一样，Linux使用了虚拟内存。虚拟内存主要有2个优点。首先，进程间以及进程与内核间是隔离的，所以进程无法读取或修改其他进程或内核的虚拟内存。其次，只有进程的一部分需要常驻在内存中，这降低了进程的内存占用 (允许更多进程同时驻留在内存中)，进而提高了CPU利用率。</p><p>　　● 内核在磁盘上提供了文件系统，允许对文件进行创建、检索、更新和删除等操作。</p><p>　　● 内核可以将新程序加载到内存并提供该程序运行所需的资源。一旦进程运行完成，内核必须确保该进程使用的资源得到释放，以供其他程序使用。</p><p>　　● 连接到计算机的设备 (例如，鼠标、键盘、显示器、硬盘和磁带驱动器) 允许计算机与外界进行信息通信以及输入或/和输出。内核为计算机提供了1个接口，该接口标准化和简化了设备的访问，同时也会协调多个进程对同一设备的访问。</p><p>　　● 内核会代表用户进程发送和接收网络分组，该过程包括将网络分组路由到目标系统。</p><p>　　● 进程通过称为<strong>系统调用</strong>的内核入口点来请求内核执行某些任务。</p><p>　　除了以上功能，Linux等多用户操作系统通常会为用户提供<strong>虚拟私有计算机</strong>的抽象，即每个用户都能登录系统，并且使用时很大程度上独立于其他用户。例如，每个用户都用自己的磁盘存储空间 (即<span style="background-color:#ff0">主目录</span>)。此外，用户能执行多个程序，这些程序会共享CPU，每个程序会在自己的虚拟地址空间中执行操作，并且这些程序能独立访问设备和通过网络传输信息。内核会解决访问硬件资源时潜在的冲突，所以用户和进程通常不知道这些冲突。</p><p>　　运行中的系统通常会有大量进程。对于单个进程，很多事情异步发生。运行中的进程不知道它何时被挂起以及之后运行的进程，或者它运行完成后接着运行的进程。信号的传递和IPC事件的发生由内核协调，对进程而言，这可能随时发生。很多事情对进程是不可见的。进程并不知道它在RAM中的位置，或者其内存空间的特定部分是在内存中还是在交换空间 (用于补充RAM的磁盘空间保留区域) 中。同样，进程也不知道它访问的文件所处的磁盘驱动位置，进程仅通过文件名来访问文件。进程是独立运行的，进程间无法直接通信。进程无法创建新进程或终止自己。最后，进程无法直接与连接到电脑的I/O设备通信。</p><p>　　相比之下，运行中的系统仅有1个内核，内核知道并控制所有事情。内核推动着系统中所有进程的运行。内核决定进程调度以及维护包含所有运行中的进程的信息的数据结构和可以将文件名转换为磁盘上的物理位置的底层数据结构。此外，内核还维护将每个进程的虚拟内存转换为物理内存和交换空间的数据结构。进程间的所有通信通过内核提供的机制完成。为了响应进程的请求，内核会创建新进程和终止已有进程。最后，内核 (尤其是设备驱动程序) 执行所有与I/O设备的通信，根据用户进程的请求传输信息。</p><h3 id="shell">2.2 shell</h3><p>　　尽管在某些操作系统中，命令解释程序是内核的组成部分，而在UNIX系统中，shell是用户进程。存在多个不同的shell，并且同一计算机上的不同用户可以同时使用不同的shell。随着时间的推移，出现了几个重要的shell：</p><p>　　● <span style="background-color:#ff0">Bourne shell</span> (即<code>sh</code>) 是最古老的广泛使用的shell，由Steve Bourne开发。<code>sh</code>是第7版UNIX的标准shell。<code>sh</code>中包含在很多所有shell中都熟悉的功能，包括I/O重定向、管道、文件名生成 (通配符)、变量、环境变量控制、命令替换、后台命令执行和函数。所有后续的UNIX实现除了包含它们可能提供的任何其他shell，还包含<code>sh</code>。</p><p>　　● <span style="background-color:#ff0">C shell</span> (即<code>csh</code>) 由加州大学伯克利分校的Bill Joy开发。其名称源于该shell的很多流控制结构与C语言中对应的流控制结构相似。<code>csh</code>提供了几个<code>sh</code>所没有的有用的交互功能，包含命令历史、命令行编辑、作业控制和别名。<code>csh</code>与<code>sh</code>不向后兼容。尽管BSD中的标准交互式shell是<code>csh</code>，但是shell脚本通常是为<code>sh</code>编写，以保证可移植到任何UNIX实现。</p><p>　　● <span style="background-color:#ff0">Korn shell</span> (即<code>ksh</code>) 由AT&amp;T贝尔实验室的David Korn开发，作为<code>sh</code>的后继者。除了保证与<code>sh</code>的兼容，<code>ksh</code>还包含与<code>csh</code>类似的交互功能。</p><p>　　● <span style="background-color:#ff0">Bourne again shell</span> (即<code>bash</code>) 是GNU项目对<code>sh</code>的重实现。它提供了<code>ksh</code>和<code>csh</code>中类似的交互功能。<code>bash</code>的主要开发者是Brain Fox和Chet Ramey。<code>bash</code>可能是Linux中使用最广泛的shell (在Linux中，<code>sh</code>实际是通过<code>bash</code>模拟)。</p><p>　　POSIX.2-1992详细说明了shell标准，该标准基于<code>ksh</code>当时的版本。如今，<code>ksh</code>和<code>bash</code>都通过了POSIX认证，两者都提供了很多对标准的扩展，其中的很多扩展存在差异。</p><h3 id="用户和组">2.3 用户和组</h3><p>　　每个用户都有唯一的<span style="background-color:#ff0">登录名</span> (即用户名) 和对应的数字<span style="background-color:#ff0">用户ID</span> (即UID)。每个用户的用户名和UID都由系统<span style="background-color:#ff0">密码文件</span><code>/etc/passwd</code>中的某行定义，该行包括组ID (即GID) 字段、主目录字段和登录shell字段。GID字段是用户所属的第1个组的数字GID。主目录字段是用户登录后所在的初始目录。登录shell字段是为解释用户命令而执行的程序的名称。</p><p>　　密码文件可能会包含加密后的用户密码。出于安全，密码通常存储在单独的<span style="background-color:#ff0">影子密码文件</span>，只有特权用户才能读。</p><p>　　出于管理目的 (特别是控制文件和其他系统资源的访问)，将用户组织成<span style="background-color:#ff0">组</span>很有用。在早期的UNIX实现中，1个用户只能属于1个组。BSD允许1个用户同时属于多个组，这个想法之后被其他UNIX实现和POSIX.1-1990吸收。</p><p>　　每个组都由系统<span style="background-color:#ff0">组文件</span><code>/etc/group</code>中的某行定义，该行包括组名称字段、GID字段和用户列表字段。组名称字段是组的唯一名称。GID字段是组ID。用户列表字段是以逗号分隔的组成员的用户名 (组成员的判断基于该字段，而非密码文件中的GID字段)。</p><p>　　唯一拥有特权的用户是<span style="background-color:#ff0">超级用户</span>。超级用户的UID是0，用户名通常是root。对于常规UNIX系统，超级用户会绕过系统中的所有权限检测。因此，超级用户可以无视文件的访问权限而直接访问任何文件，也可以给任何用户进程发送信号。</p><h3 id="单目录层次结构目录链接和文件">2.4 单目录层次结构、目录、链接和文件</h3><p>　　内核维护了单目录层次结构来组织系统中的所有文件 (Windows等操作系统的每个磁盘设备都有自己的目录层次结构)。该层次结构的根基是<strong>根目录</strong> (即<code>\</code>)。所有文件和目录都是根目录的后代。</p><img src="/2024/08/12/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-2/subset_of_the_linux_single_directory_hierarchy.svg" title="subset_of_the_linux_single_directory_hierarchy"><p>　　在文件系统中，每个文件都有<strong>类型</strong>。表示原始数据文件的类型称为<strong>常规文件</strong>或<strong>纯文本文件</strong>，以区分其他文件类型。这些其他文件类型包括设备、管道、套接字、目录和符号链接。</p><p>　　<strong>目录</strong>是特殊文件，其内容形式是文件名表与对应文件的引用。这种 "文件名+指针" 的关联称为<strong>链接</strong>。1个文件可以有多个链接，所以也可以有多个文件名 (在不同或相同目录下)。</p><p>　　目录可以同时包含文件和其他目录。目录间的链接构成了如图所示的目录层次结构。</p><p>　　每个目录至少包括<code>.</code>和<code>..</code>这2个条目，前者表示到目录自己的链接，后者表示到父目录 (即目录层次结构中该目录的上一级目录) 的链接。除了根目录之外的所有目录都有父目录。对于根目录，条目<code>/..</code>等同于<code>/</code>。</p><p>　　类似于普通链接，<strong>符号链接</strong>提供文件的别名。普通链接是目录列表中的 "文件名+指针" 条目，而符号链接是特殊标记文件，包含另一个文件的名称 (符号链接也是目录列表中的 "文件名+指针" 条目，其中指针指向的文件包含另一个文件的名称)。符号链接中的 "另一个文件" 通常称为符号链接的<strong>目标</strong>，通常会说符号链接引用或指向目标文件。当系统调用使用路径名时，大多数情况下，内核会自动<strong>解引用</strong>路径名中的每个符号链接，用它指向的文件名来替换它。若符号链接的目标也是符号链接，则解引用会递归 (内核对解引用的次数进行了限制)。目标文件不存在的符号链接称为<strong>死链接</strong>。此外，普通链接也称为<strong>硬链接</strong>，符号链接也称为<strong>软连接</strong>。</p><p>　　<strong>路径名</strong>是以可选的斜杠<code>/</code>开头加上以斜杠分隔的一系列文件名组成的字符串。路径名中的除了最后1个文件名之外的所有文件名都会被识别为目录或指向目录的符号链接。路径名中的最后1个文件名可能会被识别为任何类型的文件 (包括目录)。最后1个斜杠前的所有文件名也称为路径名的<span style="background-color:#ff0">目录</span>部分，最后1个斜杠后的文件名也称为路径名的<span style="background-color:#ff0">文件</span>或<span style="background-color:#ff0">基础</span>部分。</p><p>　　路径名的读取顺序是从左到右，每个文件名位于路径名中的前一文件名指定的目录下。字符<code>..</code>可以在路径名中的任何位置使用，表示路径名当前指定位置的父目录。</p><p>　　每个进程都有<strong>当前工作目录</strong>，简称为<strong>工作目录</strong>或<strong>当前目录</strong>，即进程在单目录层次结构中的位置。子进程会继承其父进程的工作目录。登录shell的初始当前工作目录为密码文件中对应的主目录字段。shell的工作目录可以用命令<code>cd</code>来修改。</p><p>　　可以用<strong>绝对路径</strong>或<strong>相对路径</strong>来描述文件在单目录层次结构中的位置。</p><p>　　● 绝对路径以表示根目录的斜杠<code>/</code>开头，例如，<code>/home/mtk/.bashrc</code>、<code>/usr/include</code>和<code>/</code>。</p><p>　　● 相对路径表示文件相对进程的工作目录的路径。为了与绝对路径区分，相对路径不以斜杠<code>/</code>开头。对于目录<code>usr</code>，文件<code>types.h</code>的相对路径是<code>include/sys/types.h</code>。对于目录<code>avr</code>，文件<code>.bashrc</code>的相对路径是<code>../mtk/bashrc</code>。</p><p>　　每个文件都有1个关联的用户ID和1个关联的组ID，用户ID定义了该文件的所有者，组ID定义了该文件的所属组。文件的所有权用于决定用户对该文件的访问权限。</p><p>　　为了控制文件的访问，系统将用户分为3类。第1类用户是文件的所有者，第2类用户的组ID与文件所属组的组ID相同，第3类用户是其他用户。可以为3类用户分别设置3个权限位，读权限位允许读文件，写权限位允许写文件，执行权限位允许执行文件。目录也可以设置这些权限位，其含义略有不同，读权限位允许列出目录的内容 (例如，文件名)，写权限位允许修改目录的内容 (例如，修改文件名)，执行 (也称为搜索) 权限位允许访问目录下的文件 (受限于文件的访问权限)。</p><h3 id="文件io模型">2.5 文件I/O模型</h3><p>　　UNIX系统的I/O模型的显著特征之一就是I/O<strong>通用性</strong>的概念，即同一系统调用 (例如，<code>open()</code>、<code>read()</code>、<code>write()</code>和<code>close()</code>)可用于执行对所有类型 (包括设备) 的文件的I/O。内核会将应用程序的I/O请求转换为对目标文件或设备执行I/O的文件系统操作或事件驱动程序操作。</p><p>　　内核本质上提供了<span style="background-color:#ff0">字节流序列</span>这种文件类型。对于磁盘文件、磁盘和磁带设备，可以通过系统调用<code>lseek()</code>来进行随机访问。</p><p>　　很多应用程序和库会将换行符 (ASCII字符的十进制的10) 解释为终止当前行并开始下一行。UNIX系统没有文件结束符，文件的结束通过不返回数据的读来检测。</p><p>　　<strong>I/O系统调用</strong>指用文件描述符 (较小的非负整数) 打开文件。文件描述符一般通过调用函数<code>open()</code>获取，该函通过路径名来指定执行I/O操作的文件。</p><p>　　通常，当进程被shell启动时，会继承3个已打开的文件描述符 (即描述符0~2)。描述符0是标准输入，进程从其读输入。描述符1是标准输出，进程向其写输出。描述符2是标准错误，进程向其写异常情况的错误信息和通知。对于交互式shell或程序，这3个描述符通常会连接到终端。在库<code>stdio</code>中，这3个描述符分别对应文件流<code>stdin</code>、<code>stdout</code>和<code>stderr</code>。</p><h3 id="进程">2.6 进程</h3><p>　　每个进程都有唯一的整数<strong>进程标识符</strong> (即PID)。此外，每个进程还有<strong>父进程标识符</strong> (即PPID)，表示请求内核创建该进程的进程。</p><p>　　进程可以通过系统调用<code>fork()</code>来创建新进程，前者称为<strong>父进程</strong>，后者称为<strong>子进程</strong>。内核通过创建父进程的副本来创建子进程。子进程会继承父进程的数据段、栈段和堆段，子进程之后可以独立地修改这些段。程序在内存中的文本段会被标记为只读，由这2个进程共享。</p><p>　　子进程要么执行与父进程相同的代码中的不同函数，要么调用系统调用<code>execve()</code>来加载和执行新程序。系统调用<code>execve()</code>会用基于新程序的代码的文本段、数据段、栈段和堆段来替换已存在的这4个段。</p><p>　　C标准库中有几个系统调用<code>execve()</code>的包装函数，这些函数大同小异，并且都以字符串<code>exec</code>开头。之后的内容会将这些函数统称为函数<code>exec()</code>。</p><p>　　<strong>守护进程</strong>是特殊进程，其创建方式与普通进程相同，但具有以下特点：</p><p>　　● 守护进程的生命周期很长。守护进程通常在系统引导时就会启动，并且会持续到关机。</p><p>　　● 守护进程运行在后台，并且没有用于读输入或写输出的控制终端。</p><p>　　<code>syslogd</code>和<code>httpd</code>就是守护进程，前者记录系统日志中的信息，后者通过超文本传输协议来提供网页。</p><p>　　每个进程都有1个<strong>环境列表</strong>，即<strong>环境变量</strong>的集合。环境变量维护在进程的用户空间内存中。环境变量包含1个名称和1个关联的值。子进程会继承父进程的环境列表，所以环境列表可用于父进程传递信息给子进程。当进程通过函数<code>exec()</code>替换当前正在运行的程序时，新程序要么继承旧程序的环境列表，要么接收作为<code>exec()</code>调用的一部分的新环境列表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export MYVAR=&#x27;Hello world&#x27;</span><br></pre></td></tr></table></figure><p>　　对于大多数shell，环境变量通过命令<code>export</code>来创建。对于<code>csh</code>，环境变量通过命令<code>setenv</code>来创建。</p><p>　　C程序可以通过外部变量<code>char **environ</code>来访问环境变量，并且有大量库函数可以用于检索和修改其环境变量的值。</p><p>　　环境变量的用途很广。例如，shell定义和使用了大量可以通过脚本或由shell执行的程序访问的环境变量。其中包括环境变量<code>HOME</code>和<code>PATH</code>，前者指定了用户的登录目录的路径，后者指定了shell在查找与用户输入的命令相对应的程序时应搜索的一系列目录。</p><p>　　进程可以以2种方法终止。第1种方法是调用系统调用<code>_exit()</code>及其包装函数来请求终止自己。第2种方法是收到信号而终止。进程终止时会生成<strong>终止状态</strong> (较小的非负整数)，父进程可以调用系统调用<code>wait()</code>来查看子进程的终止状态。当调用系统调用<code>_exit()</code>及其包装函数时，进程会显式地指明自己的终止状态。当收到信号而终止时，进程的终止状态会根据该信号的类型来设置。</p><p>　　按照惯例，终止状态为0时表示进程正常终止，终止状态非0时表示出现错误。大部分shell可以通过shell变量<code>$?</code>来获取最后执行的程序的终止状态。</p><p>　　每个进程都有多个关联的用户ID和组ID，包括<span style="background-color:#ff0">实际用户ID</span>、<span style="background-color:#ff0">实际组ID</span>、<span style="background-color:#ff0">有效用户ID</span>、<span style="background-color:#ff0">有效组ID</span>和<span style="background-color:#ff0">辅助组ID</span>。</p><p>　　● 实际用户ID和实际组ID是进程所属的用户和组的ID。子进程会继承父进程的实际用户ID和实际组ID。登录shell的实际用户ID和实际组ID取自系统密码文件中对应的字段。</p><p>　　● 有效用户ID和有效组ID (与辅助组ID一起使用) 用于确定进程对文件和IPC对象等受保护资源的访问权限。进程的有效用户ID和有效组ID通常与其实际用户ID和实际组ID相同。可以通过修改有效用户ID和有效组ID来允许进程获取其他用户或组的特权。</p><p>　　● 辅助组ID可能有多个。辅助组ID是进程所属的辅助组的ID。子进程会继承父进程的辅助组ID。登录shell的辅助组ID取自系统组文件。</p><p>　　依据传统，在UNIX系统中，有效用户ID为0 (超级用户) 的进程是<strong>特权进程</strong>，此类进程可以绕过内核通常使用的权限限制。相比之下，有效用户ID非0的进程是<strong>非特权进程</strong>，此类进程必须遵守内核的权限限制。特权进程创建的子进程也是特权进程。修改非特权进程的有效用户ID可以将其变为特权进程。</p><p>　　从内核2.2开始，Linux将传统上授予超级用户的特权划分为了多个不同的称为<strong>能力</strong>的单元。每个特权操作都与特定的能力关联，进程执行特权操作需要拥有对应的能力。传统的超级用户进程 (有效用户ID为0) 拥有全部能力。</p><p>　　在引导系统时，内核会创建特殊进程<code>init</code>，该进程源自文件<code>/sbin/init</code>。系统中的所有进程都是进程<code>init</code>的后代。进程<code>init</code>的进程ID是1，并且拥有超级用户特权。进程<code>init</code>无法被杀死 (超级用户也不能)，只会在关机时终止。进程<code>init</code>的主要任务是创建和监视系统运行所需的一系列进程。</p><p>　　通过系统调用<code>strlimit()</code>，进程可以设置其对各种资源的消耗上限。每个这样的<strong>资源限制</strong>都有2个关联的值——软限制和硬限制，前者限制进程可以消耗的资源，后者是前者可以调整的值的上限。非特权进程可以调整某个特定资源的软限制，其值必须在0到对应的硬限制之间 (小于硬限制)。当通过系统调用<code>fork()</code>创建子进程时，子进程会继承父进程的资源限制设置。</p><p>　　shell的资源限制可以通过命令<code>ulimit</code> (<code>csh</code>中的命令<code>limit</code>) 来调整，shell创建的用于执行命令的子进程会继承这些资源限制设置。</p><h3 id="内存映射">2.7 内存映射</h3><p>　　系统调用<code>mmap()</code>会在调用进程的虚拟地址空间中创建1个新的<strong>内存映射</strong>。内存映射有2种类型——<strong>文件映射</strong>和<strong>匿名映射</strong>。</p><p>　　● 文件映射会将1个文件在磁盘上的区域映射到调用进程的虚拟内存。一旦映射，该文件的内容就可以通过对相应的内存区域中的字节的操作来访问。映射的页会按需自动从文件中加载。</p><p>　　● 匿名映射没有对应的文件。相反，映射的页会初始化为0。</p><p>　　某个进程的映射中的内存可能与其他进程的映射共享。当多个进程映射同一文件的同一区域或子进程继承了父进程的映射时，就会出现这种情况。</p><p>　　当多个进程共享同一页时，若映射是私有的，则进程对映射内容的修改对其他进程<span style="background-color:#ff0">不可见</span>，并且这些修改<span style="background-color:#ff0">不会</span>应用到对应的文件；若映射是共享的，则进程对映射内容的修改对其他进程<span style="background-color:#ff0">可见</span>，并且这些修改会应用到对应的文件。</p><p>　　内存映射用途广泛，包括通过可执行文件的文本段来初始化进程的文本段、分配新内存 (填充为0)、文件I/O (内存映射I/O) 和IPC (通过共享映射)。</p><h3 id="静态库和共享库">2.8 静态库和共享库</h3><p>　　<strong>对象库</strong>是包含一系列函数 (通常存在逻辑关联) 编译后的目标代码的文件。将一系列函数放在单个对象库可以简化程序的创建和维护。在现代UNIX系统中，对象库有2种类型——<strong>静态库</strong> (也称为<strong>归档文件</strong>) 和<strong>共享库</strong>。早期UNIX系统中只有静态库。</p><p>　　静态库本质上是已编译的目标模块的结构化包。当需要使用静态库中的某个函数时，会在构建程序的链接命令中指明对应的静态库。在解析完主程序对静态库模块的函数的引用后，链接器会从静态库中提取所需模块的副本，并且将这些副本复制到作为结果的可执行文件。这个过程称为<strong>静态链接</strong>。</p><p>　　静态链接有多个缺点。第1个缺点是不同的可执行文件可能都包含同一模块的副本，这会浪费磁盘空间。第2个缺点是多个包含同一模块的程序同时运行时，会产生内存浪费，因为每个程序都需要自己的模块副本驻留在内存中。第3个缺点是修改静态库中的函数后，需要重新编译并更新静态库，所有用到该函数的应用程序都需要再次进行静态链接。</p><p>　　共享库正是为了解决静态库的问题而设计。当程序链接了1个共享库后，链接器只会在可执行文件中写1条记录，以指示可执行文件在运行时所需的共享库。在可执行文件的运行过程中，当它加载到内存时，<strong>动态链接器</strong>会保证可执行文件所需的共享库会被找到并加载到内存中，然后执行运行时链接来将可执行文件中的函数调用解析为共享库中对应的声明。在运行时，只需要1份共享库的代码驻留在内存中，所有运行中的程序都能使用该副本。</p><p>　　共享库不像静态库那样需要每个程序都包含所需模块的副本，这节省了磁盘空间。此外，在修改共享库中的函数并更新共享库后，现有程序会在下次运行时会自动使用修改后的函数。</p><h3 id="ipc和同步">2.9 IPC和同步</h3><p>　　可以通过读写磁盘文件的信息来实现IPC。但是，对于很多应用程序，这种方法效率很低而且不灵活。</p><p>　　就像所有现代UNIX实现一样，Linux提供了大量IPC机制，包括<span style="background-color:#ff0">信号</span>、<span style="background-color:#ff0">管道</span>、<span style="background-color:#ff0">套接字</span>、<span style="background-color:#ff0">文件上锁</span>、<span style="background-color:#ff0">消息队列</span>、<span style="background-color:#ff0">信号量</span>和<span style="background-color:#ff0">共享内存</span>。</p><p>　　● 信号用于指示事件已经发生。</p><p>　　● 无名管道 (类似于shell中的操作符<code>|</code>) 和有名管道用于在进程之间传输数据。</p><p>　　● 套接字用于在进程之间传输数据，无论这些进程在同一计算机上，还是在通过网络连接的不同计算机上。</p><p>　　● 文件上锁允许进程给文件在磁盘上的区域上锁，以防止其他进程读或更新文件内容。</p><p>　　● 消息队列用于在进程之间交换消息 (即数据包)。</p><p>　　● 信号量用于同步进程的操作。</p><p>　　● 共享内存允许多个进程共享同一片内存区域。当进程修改了共享内存的内容后，其他的所有进程都可以立即看到变化。</p><p>　　UNIX系统中的IPC机制繁多，并且有些机制在功能上重复，部分原因是受到了各种标准和UNIX系统的不同变体的影响。例如，有名管道和套接字都可以实现同一系统上的不相关进程之间的信息交换。两者共存于现代UNIX系统是因为有名管道来自于System V，而套接字来自于BSD。</p><h3 id="信号">2.10 信号</h3><p>　　除了用于IPC，信号通常在其他情况下也会使用。信号经常被描述为 "软件中断"。信号的到达表示某些事件或异常情况已经发生。信号有多种类型，每种类型对应1种事件或情况。每种信号类型唯一的整数标识符，由形如<code>SIGxxxx</code>的符号名定义。</p><p>　　信号的来源可以是内核、其他进程 (需要合适的权限) 或进程自己。当<span style="background-color:#ff0">用户在键盘上输入中断字符</span> (通常是Control-C)、<span style="background-color:#ff0">进程的子进程终止</span>、<span style="background-color:#ff0">进程设置的定时器过期</span>或<span style="background-color:#ff0">进程试图访问非法内存地址</span>时，内核可能会发送信号给进程。</p><p>　　在shell中，命令<code>kill</code>可以用于发送信号给进程。系统调用<code>kill()</code>也提供同样的功能。</p><p>　　当进程收到信号时，可以<span style="background-color:#ff0">忽略信号</span>、<span style="background-color:#ff0">被信号终止</span>或<span style="background-color:#ff0">被挂起直到收到特殊用途的信号</span>。</p><p>　　对于大部分信号类型，程序都可以忽略信号或触发<strong>信号处理程序</strong>，而非执行接收信号的默认操作。信号处理程序是程序员定义的函数，它会在程序收到对应的信号时自动调用。</p><p>　　在信号生成到信号接收的这段时间内，该信号对程序来说是<span style="background-color:#ff0">待处理</span>的。通常情况下，若接收程序已经在运行，则会立即收到待处理信号；否则，接收程序在下次运行时会尽快收到待处理信号。但是，可以通过将信号添加到<strong>信号掩码</strong>来阻塞信号。若信号在阻塞期间生成，则该信号会保持待处理状态，直到解除阻塞 (即从信号掩码中移除该信号)。</p><h3 id="进程组和shell作业控制">2.11 进程组和shell作业控制</h3><p>　　shell执行的程序都会在新进程中启动。例如，shell会创建3个进程来执行以下管道命令 (列出当前工作目录下的文件并按文件大小排序)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l | sort -k5n | less</span><br></pre></td></tr></table></figure><p>　　除了<code>sh</code>之外的所有主要shell都提供了称为<strong>作业控制</strong>的交互功能，该功能允许用户同时执行和控制多个命令或管道。在作业控制shell中，管道中的所有进程都放置在1个新的<strong>进程组</strong>或<strong>作业</strong>。对于仅包含1个命令的shell命令行，新进程组仅包含1个新创建的进程。同一进程组中的进程都有相同的整数<strong>进程组标识符</strong>——进程组的<strong>进程组组长</strong>的进程ID。</p><p>　　内核允许进程组中的所有成员执行各种操作，尤其是传递信号。作业控制shell使用此功能来允许用户挂起或恢复管道中的所有进程。</p><p>　　<strong>会话</strong>是进程组 (或作业) 集合。同一会话中的所有进程都有相同的<strong>会话标识符</strong>。<strong>会话领导</strong>是创建会话的进程，会话ID也就是会话领导的进程ID。会话主要用于作业控制shell。作业控制shell创建的所有进程组都属于同一会话，其会话领导也就是shell。</p><p>　　会话通常有1个关联的<strong>控制终端</strong>。当会话领导第1次打开终端设备时，会创建控制终端。对于交互式shell创建的会话，控制终端就是用户登录的终端。1个终端最多只能作为1个会话的控制终端。</p><p>　　打开控制终端后，会话领导会成为控制终端的<strong>控制进程</strong>。当控制进程的终端断开连接时 (例如，终端窗口关闭)，控制终端会收到信号<code>SIGHUP</code>。</p><p>　　会话总是有1个<strong>前台进程组</strong> (或<strong>前台作业</strong>)，用于从终端读输入和写输出到终端。当用户在控制终端输入<span style="background-color:#ff0">中断</span> (通常是Control-C) 或<span style="background-color:#ff0">挂起</span> (通常是Control-Z) 字符后，终端驱动程序会发送信号来杀死或挂起前台进程组。会话可以有任意个<strong>后台进程组</strong> (或<strong>后台作业</strong>)，它们通过与号字符<code>&amp;</code>创建。</p><p>　　作业控制shell提供了列出所有作业、发送信号给作业以及将前台作业改为后台作业或将后台作业改为前台作业的命令。</p><h3 id="客户端-服务器架构">2.12 客户端-服务器架构</h3><p>　　<span style="background-color:#ff0">客户端-服务器应用程序</span>由2个进程组成，即客户端进程和服务器进程。客户端通过发送请求信息给服务器来请求服务器执行某些服务。服务器解释客户端的请求，执行合适的操作，然后发送响应信息给客户端。</p><p>　　客户端和服务器可以位于同一计算机，也可以位于通过网络连接的不同计算机。客户端和服务器通过IPC机制通信。</p><p>　　有时，客户端和服务器可能会进行请求和响应的扩展对话。</p><p>　　通常，客户端应用程序与用户交互，而服务器应用程序提供对某些共享资源的访问。此外，可能出现多个客户端进程的实例与1个或少数几个服务器进程的实例通信的情况。</p><p>　　服务器可能会实现多个服务，例如：</p><p>　　● 提供对数据库或其他共享信息资源的访问。</p><p>　　● 通过网络提供对远程文件的访问。</p><p>　　● 封装部分业务逻辑。</p><p>　　● 提供对共享硬件资源 (例如，打印机) 的访问。</p><p>　　● 提供网页。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2024/07/03/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-1/" rel="prev" title="《Linux/UNIX系统编程手册》第1章 历史和标准"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第1章 历史和标准</a></div><div class="post-nav-item"><a href="/2024/08/30/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-3/" rel="next" title="《Linux/UNIX系统编程手册》第3章 系统编程概念">《Linux/UNIX系统编程手册》第3章 系统编程概念 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script></body></html>