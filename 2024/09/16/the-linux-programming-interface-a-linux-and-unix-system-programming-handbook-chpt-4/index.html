<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><link rel="canonical" href="http://example.com/2024/09/16/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-4/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/09/16/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-4/","path":"2024/09/16/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-4/","title":"《Linux/UNIX系统编程手册》第4章 文件I/O：通用I/O模型"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第4章 文件I/O：通用I/O模型 |</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="nav-text">4.1 打开文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0flags"><span class="nav-text">4.1.1 参数flags</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A5%E8%87%AAopen%E7%9A%84%E9%94%99%E8%AF%AF"><span class="nav-text">4.1.2 来自open()的错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8creat"><span class="nav-text">4.1.3 系统调用creat()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-text">4.2 读写文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="nav-text">4.3 关闭文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="nav-text">4.4 修改文件偏移量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%A9%BA%E6%B4%9E"><span class="nav-text">4.4.1 文件空洞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="nav-text">4.4.2 示例程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8io%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%A4%96%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">4.5 通用I&#x2F;O模型之外的操作</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2024/09/16/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-4/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：water-music@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux/UNIX系统编程手册》第4章 文件I/O：通用I/O模型 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第4章 文件I/O：通用I/O模型</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-09-16 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-16T00:00:00+08:00">2024-09-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-10-20 00:00:00" itemprop="dateModified" datetime="2024-10-20T00:00:00+08:00">2024-10-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/computer-system/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>13k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　所有执行I/O的系统调用都通过<strong>文件描述符</strong> (通常是较小的非负整数) 打开文件。文件描述符用于引用所有类型的打开的文件，包括无名管道、有名管道、套接字、终端、设备和常规文件。每个进程都有自己的文件描述符集。</p><table><thead><tr><th>文件描述符</th><th>目的</th><th>POSIX名称</th><th><code>stdio</code>流</th></tr></thead><tbody><tr><td>0</td><td>标准输入</td><td><code>STDIN_FILENO</code></td><td><code>stdin</code></td></tr><tr><td>1</td><td>标准输出</td><td><code>STDOUT_FILENO</code></td><td><code>stdout</code></td></tr><tr><td>2</td><td>标准错误</td><td><code>STDERR_FILENO</code></td><td><code>stderr</code></td></tr></tbody></table><p>　　按照惯例，大多数程序都期望能够使用3个标准文件描述符 (即文件描述符0~2)。程序会继承打开它的shell的文件描述符，而shell通常在这3个文件描述符打开的情况下运行。对于交互性shell，这3个文件描述符通常指运行shell的终端。若在命令行中指定了I/O重定向，则shell会保证在启动程序前就适当地修改文件描述符。</p><p>　　当在程序中引用标准文件描述符时，可以直接使用数字0~2，更好的方法是使用头文件<code>unistd.h</code>中定义的POSIX标准名。</p><p>　　变量<code>stdin</code>、<code>stdout</code>和<code>stderr</code>初始时引用进程的标准输入、标准输出和标准错误，但可以使用库函数<code>freopen()</code>来让它们引用其他文件。作为其操作的一部分，<code>freopen()</code>可能改变重新打开的流的底层描述符。例如，对<code>stdout</code>使用<code>freopen()</code>后，无法保证其底层描述符一定是1。</p><p>　　以下是4个重要的执行文件I/O的系统调用：</p><p>　　● <code>fd = open(pathname, flags, mode)</code>会打开参数<code>pathname</code>对应的文件，然后返回打开的文件描述符。若文件不存在，则<code>open()</code>可能会创建 (根据参数<code>flags</code>的值)。参数<code>flags</code>还指定打开文件是为了读或/和写。参数<code>mode</code>指定<code>open()</code>创建的文件的访问权限，若此次调用<code>open()</code>不会创建文件，则该参数会被忽略。</p><p>　　● <code>numread = read(fd, buffer, count)</code>会从参数<code>fd</code>引用的打开的文件中读最多<code>count</code>字节，然后将这些字节存储在<code>buffer</code>中。<code>read()</code>会返回实际读取的字节数。若文件中没有可读的字节 (即遇到了文件结尾)，则<code>read()</code>会返回0。</p><p>　　● <code>numwritten = write(fd, buffer, count)</code>会从<code>buffer</code>中写最多<code>count</code>字节到参数<code>fd</code>引用的打开的文件。<code>write()</code>会返回实际写入的字节数 (不会大于<code>count</code>)。</p><p>　　● <code>status = close(fd)</code>会释放参数<code>fd</code>及其相关内核资源。</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* copy.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUF_SIZE <span class="comment">/* 允许用命令行参数cc -D覆盖定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> inputFd, outputFd, openFlags;</span><br><span class="line">    <span class="type">mode_t</span> filePerms;</span><br><span class="line">    <span class="type">ssize_t</span> numRead;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s old-file new-file\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开输入和输出文件 */</span></span><br><span class="line">    inputFd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (inputFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;opening file %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    openFlags = O_CREAT | O_WRONLY | O_TRUNC;</span><br><span class="line">    filePerms = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP |</span><br><span class="line">                S_IROTH | S_IWOTH; <span class="comment">/* rw-rw-rw- */</span></span><br><span class="line">    outputFd = open(argv[<span class="number">2</span>], openFlags, filePerms);</span><br><span class="line">    <span class="keyword">if</span> (outputFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;opening file %s&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 传输数据，直到遇到输入结束或出错 */</span></span><br><span class="line">    <span class="keyword">while</span> ((numRead = read(inputFd, buf, BUF_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (write(outputFd, buf, numRead) != numRead)</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;couldn&#x27;t write whole buffer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (close(inputFd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close input&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (close(outputFd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close output&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这是包含上述4个系统调用的用法的示例代码，其功能与命令<code>cp</code>的相同，会复制第1个命令行参数指定的文件中的内容到第2个命令行参数指定的文件。用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./copy oldfile newfile</span><br></pre></td></tr></table></figure><p>　　由于I/O通用性，上述4个系统调用可以对所有类型的文件执行I/O。因此，仅使用这些系统调用的程序也能作用于所有类型的文件。</p><p>　　为了实现I/O通用性，必须保证所有文件系统和设备驱动程序都实现了相同的I/O系统调用集。因为特定于文件系统或设备的细节都是在内核中处理，所以在开发应用程序时通常可以忽略特定于设备的因素。若需要访问特定于文件系统或设备的功能，可以使用通用系统调用<code>ioctl()</code>，该系统调用会提供I/O通用模型之外的功能的接口。</p><h3 id="打开文件">4.1 打开文件</h3><p>　　系统调用<code>open()</code>会打开已存在的文件或创建新文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, ... <span class="comment">/* mode_t mode */</span>)</span>; <span class="comment">/* 成功则返回文件描述符，出错则返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　参数<code>pathname</code>标识打开的文件 (若它是符号链接，则会解引用)。若<code>open()</code>正常运行，则返回文件描述符；若出错，则返回-1并设置<code>errno</code>。</p><table><thead><tr><th>访问模式</th><th>描述</th></tr></thead><tbody><tr><td><code>O_RDONLY</code></td><td>以只读模式打开文件</td></tr><tr><td><code>O_WRONLY</code></td><td>以只写模式打开文件</td></tr><tr><td><code>O_RDWR</code></td><td>以读写模式打开文件</td></tr></tbody></table><p>　　参数<code>flags</code>是位掩码，可用于指定文件访问模式。早期UNIX实现直接使用数字0~2表示访问模式。大多数现代UNIX实现都会将这些访问模式定义为这些值。因此，<code>O_RDWR</code>并不等价于<code>O_RDONLY | O_WRONLY</code>，后者会被认为是逻辑错误。</p><p>　　当<code>open()</code>用于创建新文件时，位掩码参数<code>mode</code>会指定新创建的文件的访问权限。若调用<code>open()</code>时不将参数<code>flags</code>指定为<code>O_CREAT</code>，则<code>mode</code>会被忽略。</p><p>　　实际上，<code>open()</code>创建的新文件的权限并非仅取决于参数<code>mode</code>，还取决于父目录的进程umask和 (可选的) 默认访问控制列表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 以只读模式打开文件 */</span></span><br><span class="line">fd = open(<span class="string">&quot;startup&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以读写模式打开已存在文件或创建新文件，截断为0字节；</span></span><br><span class="line"><span class="comment">拥有者对文件有读写权限，其他用户没有任何访问权限 */</span></span><br><span class="line">fd = open(<span class="string">&quot;myfile&quot;</span>, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以只写模式打开已存在文件或创建新文件；</span></span><br><span class="line"><span class="comment">写入的数据位于文件结尾 */</span></span><br><span class="line">fd = open(<span class="string">&quot;w.log&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC | O_APPEND,</span><br><span class="line">          S_IRUSR | S_IWUSR);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这段代码是<code>open()</code>的用法示例，这里使用了参数<code>flags</code>。</p><p>　　SUSv3要求<code>open()</code>正常运行时返回的文件描述符是进程未使用的编号最小的描述符，该功能可用于通过特定的文件描述符打开文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (close(STDIN_FILENO) == <span class="number">-1</span>) <span class="comment">/* 关闭文件描述符0 */</span></span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fd = open(pathname, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在这段代码中，因为文件描述符0未被使用，所以<code>open()</code>用该描述符打开文件。</p><h4 id="参数flags">4.1.1 参数<code>flags</code></h4><table><colgroup><col style="width:16%"><col style="width:74%"><col style="width:8%"></colgroup><thead><tr><th>标志</th><th>目的</th><th>SUS版本</th></tr></thead><tbody><tr><td><code>O_RDONLY</code></td><td>以只读模式打开</td><td>SUSv3</td></tr><tr><td><code>O_WRONLY</code></td><td>以只写模式打开</td><td>SUSv3</td></tr><tr><td><code>O_RDWR</code></td><td>以读写模式打开</td><td>SUSv3</td></tr><tr><td><code>O_CLOEXEC</code></td><td>设置close-on-exec标志 (Linux 2.6.23及以上)</td><td>SUSv4</td></tr><tr><td><code>O_CREAT</code></td><td>若文件不存在，则创建文件</td><td>SUSv3</td></tr><tr><td><code>O_DIRECT</code></td><td>文件I/O绕过缓冲区</td><td></td></tr><tr><td><code>O_DIRECTORY</code></td><td>若<code>pathname</code>不是目录，则失败</td><td>SUSv4</td></tr><tr><td><code>O_EXCL</code></td><td>与<code>O_CREAT</code>一起使用时会显式地创建文件</td><td>SUSv3</td></tr><tr><td><code>O_LARGEFILE</code></td><td>用于在32位系统中打开大文件</td><td></td></tr><tr><td><code>O_NOATIME</code></td><td>调用<code>read()</code>时不更新文件的最后访问时间 (Linux 2.6.8及以上)</td><td></td></tr><tr><td><code>O_NOCTTY</code></td><td>不会将<code>pathname</code>解释为终端</td><td>SUSv3</td></tr><tr><td><code>O_NOFOLLOW</code></td><td>不会对符号链接进行解引用</td><td>SUSv4</td></tr><tr><td><code>O_TRUNC</code></td><td>将现有文件截断为0字节</td><td>SUSv3</td></tr><tr><td><code>O_APPEND</code></td><td>总是在文件结尾写数据</td><td>SUSv3</td></tr><tr><td><code>O_ASYNC</code></td><td>当I/O可能时，生成信号</td><td></td></tr><tr><td><code>O_DSYNC</code></td><td>提供同步的I/O数据完整性</td><td>SUSv3</td></tr><tr><td><code>O_NONBLOCK</code></td><td>以非阻塞模式打开</td><td>SUSv3</td></tr><tr><td><code>O_SYNC</code></td><td>使文件写同步</td><td>SUSv3</td></tr></tbody></table><p>　　这是参数<code>flags</code>支持的所有标志常量。这些标志常量可以分为3类，即<span style="background-color:#ff0">文件访问模式标志</span>、<span style="background-color:#ff0">文件创建标志</span>和<span style="background-color:#ff0">打开文件状态标志</span> (也称为<span style="background-color:#ff0">文件状态标志</span>)。</p><p>　　● 文件访问模式标志是表中的第1~3行。这些标志可以通过系统调用<code>fcntl()</code>的操作<code>F_GETFL</code>来检索。</p><p>　　● 文件创建标志是表中的第4~13行，控制着<code>open()</code>的行为以及后续的I/O操作。这些标志无法检索或修改。</p><p>　　● 打开文件状态标志是第14~18行。这些标志可以通过<code>fcntl()</code>的操作<code>F_GETFL</code>和<code>F_SETFL</code>来检索和修改。</p><p>　　以下是这18个标志常量的详细信息：</p><p>　　● <code>O_APPEND</code>表示写入的数据总是在文件结尾。</p><p>　　● <code>O_ASYNC</code>表示可以对<code>open()</code>返回的文件描述符进行I/O时，生成信号，这个功能称为<strong>信号驱动I/O</strong>。该功能仅适用于特定的文件类型，例如，终端、有名管道和套接字。SUSv3并未说明该标志，但在大多数UNIX实现中都可以找到该标志 (或更早的类似的标志<code>FASYNC</code>)。对于Linux，在调用<code>open()</code>时指定<code>O_ASYNC</code>无效。为了启用信号驱动I/O，必须通过<code>fcntl()</code>的操作<code>F_SETFL</code>来设置该标志 (部分UNIX实现也是如此)。</p><p>　　● <code>O_CLOEXEC</code>表示启用新文件描述符的close-on-exec标志 (即<code>FD_CLOEXEC</code>)，而无需通过<code>fcntl()</code>的操作<code>F_GETFL</code>。此外，这样也避免了多线程程序中的竞争。</p><p>　　● <code>O_CREAT</code>表示若文件不存在，则创建新的空文件。若指定了该标志，则必须设置参数<code>mode</code>；否则，新文件的访问权限会被设置为随机权限。</p><p>　　● <code>O_DIRECT</code>表示允许文件I/O绕过缓冲区。若需使用此标志，则需要定义功能测试宏<code>_GNU_SOURCE</code>，该标志的定义会出现在头文件<code>fcntl.h</code>中。</p><p>　　● <code>O_DIRECTORY</code>表示参数<code>pathname</code>不是目录时，返回错误 (将<code>errno</code>设置为<code>ENOTDIR</code>)。该标志是专为实现<code>opendir()</code>而设计的扩展。若需使用此标志，则需要定义功能测试宏<code>_GNU_SOURCE</code>，该标志的定义会出现在头文件<code>fcntl.h</code>中。</p><p>　　● <code>O_DSYNC</code>表示根据同步I/O数据完整性的完成条件来写文件。</p><p>　　● <code>O_EXCL</code>与<code>O_CREAT</code>一起使用时，表示若文件已存在，则不会打开文件。同时，<code>open()</code>会失败，并将<code>errno</code>设置<code>EEXIST</code>。换句话说，该标志会保证调用进程是创建文件的进程。文件存在的检测和创建会自动执行。SUSv3要求，当<code>O_EXCL</code>与<code>O_CREAT</code>一起出现在<code>flags</code>中时，若参数<code>pathname</code>是符号链接，则<code>open()</code>会失败，并将<code>errno</code>设置<code>EEXIST</code>。这样是为了让特权应用程序可以在已知位置创建文件，而不会出现符号链接导致在不同位置 (例如，系统目录) 创建文件的可能性。</p><p>　　● <code>O_LARGEFILE</code>表示支持打开大文件，主要用于32位系统。SUSv3并未说明该标志，但在数个UNIX实现中都可以找到该标志。对于Alpha和IA-64等64位Linux实现，该标志无效。</p><p>　　● <code>O_NOATIME</code>表示读文件时不更新文件的最后访问时间 (字段<code>st_atime</code>)，该标志并非标准Linux扩展。若需要使用该标志，则调用进程必须是特权进程 (<code>CAP_FOWNER</code>) 或其有效用户ID匹配文件的所有者；否则，<code>open()</code>会失败，并会将<code>errno</code>设置为<code>EPERM</code>。在实际中，在使用该标志的情况下，对于非特权进程，需要和文件的所有者匹配的是进程的文件系统用户ID，而非有效用户ID。该标志旨在供索引和备份系统使用。该标志能显著减少磁盘活动，因为无需重复进行磁盘查找来读文件的内容和更新文件的i-node中的最后访问时间。可以使用<code>mount()</code>的标志<code>MS_NOATIME</code>和<code>FS_NOATIME_FL</code>来达到类似的功能。若需使用此标志，则需要定义功能测试宏<code>_GNU_SOURCE</code>，该标志的定义会出现在头文件<code>fcntl.h</code>中。</p><p>　　● <code>O_NOCTTY</code>表示当打开的文件是终端设备时，它不会成为控制终端。若打开的文件不是终端，则该标志无效。</p><p>　　● <code>O_NOFOLLOW</code>表示当<code>pathname</code>是符号链接时，<code>open()</code>会失败，并将<code>errno</code>设置为<code>ELOOP</code>。若需使用此标志，则需要定义功能测试宏<code>_GNU_SOURCE</code>，该标志的定义会出现在头文件<code>fcntl.h</code>中。</p><p>　　● <code>O_NONBLOCK</code>表示以非阻塞模式打开文件。</p><p>　　● <code>O_SYNC</code>表示打开同步I/O的文件。</p><p>　　● <code>O_TRUNC</code>表示当文件已存在并且是常规文件时，将其截断为长度0，以破坏文件内容。对于Linux，无论文件以只读或只写模式打开，都可以截断 (需要写权限)。SUSv3并没有说明<code>O_RDONLY</code>和<code>O_TRUNC</code>的组合，但大多数UNIX实现都有类似于Linux的行为。</p><p>　　从内核2.6.22开始，可以读目录<code>/proc/PID/fdinfo</code>下的特定于Linux的文件来获取系统中的所有进程的文件描述符的信息。对于进程的每个打开的文件描述符，该目录下都有1个对应的文件。该文件的字段<code>pos</code>表示当前文件偏移量，字段<code>flags</code> (八进制数) 表示文件访问模式标志和打开文件状态标志。</p><h4 id="来自open的错误">4.1.2 来自<code>open()</code>的错误</h4><p>　　当打开文件出错时，<code>open()</code>会返回-1并将<code>errno</code>设置为对应的值：</p><p>　　● <code>EACCES</code>表示文件权限不允许调用进程以<code>flags</code>指定的模式打开文件。此外，由于目录权限，文件可能无法访问，或文件不存在并且无法被创建。</p><p>　　● <code>EISDIR</code>表示调用进程试图以只写模式打开类型为目录的文件。</p><p>　　● <code>EMFILE</code>表示进程的打开的文件描述符数的资源限制达到上限 (<code>RLIMIT_NOFILE</code>)。</p><p>　　● <code>ENFILE</code>表示系统的打开的文件描述符数的资源限制达到上限。</p><p>　　● <code>ENOENT</code>表示出现2种情况之一。第1种情况是指定的文件不存在，但<code>flags</code>未指定<code>O_CREAT</code>。第2种情况是<code>flags</code>指定了<code>O_CREAT</code>，但<code>pathname</code>是死链接或其中的某个目录不存在。</p><p>　　● <code>EROFS</code>表示指定的文件位于只读文件系统，并且试图写该文件。</p><p>　　● <code>ETXTBSY</code>表示指定的文件是正在运行的可执行文件，对此类文件的修改是禁止的。</p><h4 id="系统调用creat">4.1.3 系统调用<code>creat()</code></h4><p>　　在早期UNIX实现中，<code>open()</code>仅有2个参数，并且不能用于创建文件。相反，系统调用<code>creat()</code>用于创建并打开新文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>; <span class="comment">/* 若成功则返回文件描述符，若失败则返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>creat()</code>会创建并打开参数<code>pathname</code>指定的文件，若文件已存在，则将其截断为长度0。该系统调用会返回文件描述符。调用<code>creat()</code>等价于以以下方式调用<code>open()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);</span><br></pre></td></tr></table></figure><p>　　因为<code>open()</code>的参数<code>flags</code>提供了对文件打开方式的更多控制，所以<code>creat()</code>现已过时。</p><h3 id="读写文件">4.2 读写文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buffer, <span class="type">size_t</span> count)</span>; <span class="comment">/* 若成功则返回读取的字节数；若遇到EOF则返回0；若出错则返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buffer, <span class="type">size_t</span> count)</span>; <span class="comment">/* 若成功则返回写入的字节数；若出错则返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>read()</code>会从参数<code>fd</code>引用的打开的文件中读数据。参数<code>count</code>表示读取的字节数。参数<code>buffer</code>表示用于存放读取的数据的内存缓冲区 (长度至少是<code>count</code>字节) 的地址，因为<span style="background-color:#ff0">系统调用不会为用于存放返回信息的缓冲区分配内存</span>。若<code>read()</code>正常运行，则返回实际读取的字节数；若遇到EOF，则返回0；若出错，则返回-1。</p><p>　　系统调用<code>write()</code>会向参数<code>fd</code>引用的打开的文件中写数据，其参数与<code>read()</code>相似。参数<code>buffer</code>表示待写入数据的地址。参数<code>count</code>表示写入的字节数。若<code>write()</code>正常运行，则返回实际写入的字节数；若出错，则返回-1。</p><p>　　对于每个打开的文件，内核都记录了<strong>文件偏移量</strong> (也称为<strong>读写偏移</strong>或<strong>读写指针</strong>)，即下次<code>read()</code>或<code>write()</code>开始的位置。它是相对文件开头的序号字节位。文件的第1个字节的偏移量是0。当打开文件时，文件偏移量会设置为0。文件偏移量会在调用<code>read()</code>或<code>write()</code>后自动调整。因此，连续调用<code>read()</code>和<code>write()</code>会按序进行。</p><p>　　<code>read()</code>实际读取的字节数可能会少于要求的字节数。对于常规文件，这可能是因为文件偏移量靠近EOF。对于无名管道、有名管道、套接字和终端等其他类型的文件，可能导致该情况的因素较多。例如，<code>read()</code>读终端时，默认遇到换行符<code>\n</code>就会结束读取。同样，<code>write()</code>实际写入的字节数也可能会少于要求的字节数。对于磁盘文件，这可能是因为磁盘已满或进程的文件大小的资源限制达到上限 (<code>RLIMIT_FSIZE</code>)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_READ 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[MAX_READ + <span class="number">1</span>];</span><br><span class="line"><span class="type">ssize_t</span> numRead;</span><br><span class="line"></span><br><span class="line">numRead = read(STDIN_FILENO, buffer, MAX_READ);</span><br><span class="line"><span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buffer[numRead] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The input data was: %s\n&quot;</span>, buffer);</span><br></pre></td></tr></table></figure><p>　　当通过<code>read()</code>读字符串时，<span style="background-color:#ff0">不会</span>将字符串结束符<code>\0</code>读取到缓冲区。若需要打印缓冲区中的字符串，则需要加上结束符。</p><p>　　当对磁盘文件执行I/O时，<code>write()</code>的非-1返回值并不保证数据已经传输到磁盘，因为内核会缓存磁盘I/O来减少磁盘活动和加快<code>write()</code>调用。</p><h3 id="关闭文件">4.3 关闭文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>; <span class="comment">/* 若成功则返回0，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>close()</code>会关闭参数<code>fd</code>引用的打开的文件。当进程终止时，它的所有打开的文件描述符都会自动关闭。</p><p>　　通常，最好显式关闭不再使用的文件描述符，因为这会使得代码在后续修改时有更好的可读性和健壮性。此外，文件描述符是有限资源，所以未关闭的文件描述符可能会导致进程耗尽描述符。对于处理多文件的生命周期长的程序，这会导致严重的问题。</p><p>　　就像其他系统调用一样，对<code>close()</code>的调用应该用错误处理代码包围起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (close(fd) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这种错误处理代码会捕捉关闭未打开的文件描述符和重复关闭同一描述符等错误，并且也能用于捕获特定文件系统在执行关闭操作时可能诊断的错误情况。NFS提供了特定于文件系统的错误的示例，若NFS提交失败 (数据无法到达远程磁盘)，则将该错误作为调用<code>close()</code>失败反馈给应用程序。</p><h3 id="修改文件偏移量">4.4 修改文件偏移量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>; <span class="comment">/* 若成功则返回新文件偏移量，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>lseek()</code>会根据参数<code>offset</code>和<code>whence</code>调整参数<code>fd</code>引用的打开的文件的文件偏移量。参数<code>offset</code>是以字节为单位的值。参数<code>whence</code>是参数<code>offset</code>的基点，其值如下：</p><p>　　● <code>SEEK_SET</code>表示文件偏移量设置为距文件开头<code>offset</code>个字节处的位置。</p><p>　　● <code>SEEK_CUR</code>表示文件偏移量设置为距当前文件偏移量<code>offset</code>个字节处的位置。</p><p>　　● <code>SEEK_END</code>表示文件偏移量设置为距文件最后1个字节的后1个字节<code>offset</code>个字节处的位置。</p><img src="/2024/09/16/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-4/interpreting_the_whence_argument_of_lseek.svg" title="interpreting_the_whence_argument_of_lseek()"><p>　　若<code>lseek()</code>正常运行，则返回新文件偏移量。</p><p>　　当参数<code>whence</code>是<code>SEEK_CUR</code>或<code>SEEK_END</code>时，参数<code>offset</code>可以是正值或负值；当参数<code>whence</code>是<code>SEEK_SET</code>时，参数<code>offset</code>只能是非负值。</p><p>　　在早期UNIX实现中，使用的是整数0~2，而非<code>SEEK_SET</code>、<code>SEEK_CUR</code>和<code>SEEK_END</code>。在旧版本的BSD中，使用的是<code>L_SET</code>、<code>L_INCR</code>和<code>L_XTND</code>。</p><p>　　某些UNIX实现 (不包括Linux) 中有非标准函数<code>tell(fd)</code>，其功能与<code>lseek()</code>相同。</p><p>　　以下是<code>lseek()</code>的用法示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd, <span class="number">0</span>, SEEK_SET);     <span class="comment">/* 文件开头处 */</span></span><br><span class="line">lseek(fd, <span class="number">0</span>, SEEK_END);     <span class="comment">/* 当前文件结尾的后1个字节处 */</span></span><br><span class="line">lseek(fd, <span class="number">-1</span>, SEEK_END);    <span class="comment">/* 当前文件结尾处 */</span></span><br><span class="line">lseek(fd, <span class="number">-10</span>, SEEK_CUR);   <span class="comment">/* 当前文件偏移量的前10个字节处 */</span></span><br><span class="line">lseek(fd, <span class="number">10000</span>, SEEK_END); <span class="comment">/* 当前文件结尾后的第10001个字节处 */</span></span><br></pre></td></tr></table></figure><p>　　<code>lseek()</code>仅会修改文件描述符关联的内核文件记录，不涉及物理设备访问。<code>lseek()</code>不适用于所有类型的文件，不能对无名管道、有名管道、套接字和终端使用。若必要时，可以对设备使用<code>lseek()</code>，例如，查询磁盘或磁带上的特定位置。</p><p>　　<code>lseek()</code>名称中的<code>l</code>源于事实：参数<code>offset</code>和返回值的类型本质上是<code>long</code>。早期UNIX实现提供了系统调用<code>seek()</code>，并将这些值定义为<code>int</code>。</p><h4 id="文件空洞">4.4.1 文件空洞</h4><p>　　前一文件结尾和新写入的字节之间的空间称为<strong>文件空洞</strong>。从编程角度，空洞里的字节是存在的，读空洞会返回只包含空字节 (即0) 的缓冲区。</p><p>　　文件空洞占用的磁盘空间很少。在大多数文件系统中，文件空间以块为单位分配。块的大小取决于文件系统，通常是1024字节的整数倍。若空洞的边界在块中，而非在块的边界，则会分配整个块来存储数据 (空洞对应的部分用0填充)。除了这种情况之外，文件系统不会为空洞分配磁盘空间，直到有数据写入空洞时。文件空洞可以节省磁盘空间，尤其是那些稀疏填充的文件。内存快照文件就是包含大量空洞的常见示例。</p><p>　　大多数UNIX原生文件系统都支持文件空洞，但很多非原生的文件系统 (例如，Microsoft的VFAT) 不支持文件空洞。</p><p>　　文件空洞的存在表示文件的常规大小可能大于实际占用的磁盘空间。<span style="background-color:#ff0">在文件空洞的中间写数据会减少可用磁盘空间</span> (尽管文件大小并没有增加)，因为内核会分配块来填充空洞。</p><p>　　SUSv3详细说明了函数<code>posix_fallocate(fd, offset, len)</code>，该函数会在磁盘上由<code>offset</code>和<code>len</code>指定的字节范围内为<code>fd</code>引用的磁盘文件分配空间。这可用于确保应用程序在随后对文件调用<code>write()</code>时不会因磁盘空间耗尽 (向文件中的空洞写数据或者其他应用程序使用了磁盘空间) 而失败。从历史角度，<code>glibc</code>通过向指定范围内的所有块写入1个字节0来实现该函数。从版本2.6.23开始，Linux提供了系统调用<code>fallocate()</code>，该系统调用提供了更高效的方式来保证必要的空间会被分配，并且<code>glibc</code>的<code>posix_fallocate()</code>实现在会在该系统调用可用时使用它。</p><p>　　系统调用<code>stat()</code>可用于获取当前文件的大小和实际分配给该文件的块的数量。</p><h4 id="示例程序">4.4.2 示例程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* seek_io.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="type">off_t</span> offset;</span><br><span class="line">    <span class="type">int</span> fd, ap, j;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">ssize_t</span> numRead, numWritten;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s file &#123;r&lt;length&gt;|R&lt;length&gt;|w&lt;string&gt;|s&lt;offset&gt;&#125;...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR | O_CREAT,</span><br><span class="line">              S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH); <span class="comment">/* rw-rw-rw- */</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ap = <span class="number">2</span>; ap &lt; argc; ap++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (argv[ap][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>: <span class="comment">/* 以文本显示当前偏移量 */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>: <span class="comment">/* 以十六进制显示当前偏移量 */</span></span><br><span class="line">            len = getLong(&amp;argv[ap][<span class="number">1</span>], GN_ANY_BASE, argv[ap]);</span><br><span class="line">            buf = <span class="built_in">malloc</span>(len);</span><br><span class="line">            <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            numRead = read(fd, buf, len);</span><br><span class="line">            <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (numRead == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: end-of-file\n&quot;</span>, argv[ap]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: &quot;</span>, argv[ap]);</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numRead; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (argv[ap][<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>((<span class="type">unsigned</span> <span class="type">char</span>)buf[j]) ? buf[j] : <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)buf[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(buf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>: <span class="comment">/* 在当前偏移量处写入字符串 */</span></span><br><span class="line">            numWritten = write(fd, &amp;argv[ap][<span class="number">1</span>], <span class="built_in">strlen</span>(&amp;argv[ap][<span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">if</span> (numWritten == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: wrote %ld bytes\n&quot;</span>, argv[ap], (<span class="type">long</span>)numWritten);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: <span class="comment">/* 修改文件偏移量 */</span></span><br><span class="line">            offset = getLong(&amp;argv[ap][<span class="number">1</span>], GN_ANY_BASE, argv[ap]);</span><br><span class="line">            <span class="keyword">if</span> (lseek(fd, offset, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: seek succeeded\n&quot;</span>, argv[ap]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cmdLineErr(<span class="string">&quot;Argument must start with [rRws]: %s\n&quot;</span>, argv[ap]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>lseek()</code>与<code>read()</code>和<code>write()</code>一起使用时的情况。该程序的第1个命令行参数是待打开文件的名称。其余参数指定对文件执行的I/O操作，这些I/O操作由1个字母和1个值组成 (没有进行分隔)：</p><p>　　● <code>soffset</code>表示将文件偏移量设置为距文件开头的<code>offset</code>个字节处的位置。</p><p>　　● <code>rlength</code>表示从当前文件偏移量处读<code>length</code>个字节，并以文本显示。</p><p>　　● <code>Rlength</code>表示从当前文件偏移量处读<code>length</code>个字节，并以十六进制显示。</p><p>　　● <code>wstr</code>表示向当文件偏移量写<code>str</code>指定的字符串。</p><p>　　以下shell命令展示了该程序的用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">touch tfile</span><br><span class="line">./seek_io tfile s100000 wabc</span><br><span class="line">ls -l tfile</span><br><span class="line">./seek_io tfile s10000 R5 </span><br></pre></td></tr></table></figure><p>　　第1条命令会创建文件<code>tfile</code>。第2条命令会将文件偏移量设置为距文件开头100000个字节处的位置，并向该位置写入字符串<code>abc</code>。第3条命令会展示文件的信息。第4条命令会将文件偏移量设置为距文件开头10000个字节处的位置 (也就是空洞)，并且从该位置读5个字节。</p><h3 id="通用io模型之外的操作">4.5 通用I/O模型之外的操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> request, ... <span class="comment">/* argp */</span>)</span>; <span class="comment">/* 若成功则返回request对应的值，若出错则返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>ioctl()</code>可用于执行通用I/O模型外的文件和驱动操作。参数<code>fd</code>是文件或设备的打开的文件描述符，参数<code>request</code>指定在该描述符上执行的控制操作。特定于设备的头文件中定义了可通过参数<code>request</code>传递的常量。</p><p>　　由C省略号<code>...</code>表示的第3个参数 (这里用<code>argp</code>表示) 可以是任何类型。参数<code>request</code>的值使得<code>ioctl()</code>能够决定<code>argp</code>预期的类型。<code>argp</code>通常是指向整数或结构体的指针，有时也不会使用。</p><p>　　SUSv3对<code>ioctl()</code>的唯一要求是用于控制STREAMS设备。STREAMS是System V的功能，但主线Linux内核并不支持该功能 (尽管已经开发了一些附加组件实现)。SUSv3并没有说明本书中描述的<code>ioctl()</code>的其他操作。但是，从UNIX系统的早期版本开始，<code>ioctl()</code>就一直作为UNIX系统的一部分，因此，很多UNIX实现都提供了本书描述的<code>ioctl()</code>的部分操作。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2024/08/30/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-3/" rel="prev" title="《Linux/UNIX系统编程手册》第3章 系统编程概念"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第3章 系统编程概念</a></div><div class="post-nav-item"><a href="/2024/10/05/the-linux-programming-interface-a-linux-and-unix-system-programming-handbook-chpt-5/" rel="next" title="《Linux/UNIX系统编程手册》第5章 文件I/O：更多细节">《Linux/UNIX系统编程手册》第5章 文件I/O：更多细节 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script></body></html>